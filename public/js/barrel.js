(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

var _math = require('soundworks/utils/math');

var _scenesConfig = require('../../shared/scenes-config');

var _scenesConfig2 = _interopRequireDefault(_scenesConfig);

var _off = require('./scenes/off');

var _off2 = _interopRequireDefault(_off);

var _co = require('./scenes/co-909');

var _co2 = _interopRequireDefault(_co);

var _collectiveLoops = require('./scenes/collective-loops');

var _collectiveLoops2 = _interopRequireDefault(_collectiveLoops);

var _coMix = require('./scenes/co-mix');

var _coMix2 = _interopRequireDefault(_coMix);

var _wwryR = require('./scenes/wwry-r');

var _wwryR2 = _interopRequireDefault(_wwryR);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioContext = soundworks.audioContext;

var sceneCtors = {
  'off': _off2.default,
  'co-909': _co2.default,
  'collective-loops': _collectiveLoops2.default,
  'co-mix': _coMix2.default,
  'wwry-r': _wwryR2.default
};

var template = '\n  <canvas class="background"></canvas>\n  <div class="foreground">\n    <div class="flex-middle">\n      <p class="big">Barrel</p>\n    </div>\n  </div>\n';

var numOutputChannels = 8; // "virtual" output channels
var maxAudioDestinationChannels = audioContext.destination.maxChannelCount;
var numAudioOutputs = maxAudioDestinationChannels ? Math.min(numOutputChannels, maxAudioDestinationChannels) : 2; // "physical" audio outputs

var BarrelExperience = function (_soundworks$Experienc) {
  (0, _inherits3.default)(BarrelExperience, _soundworks$Experienc);

  function BarrelExperience(assetsDomain) {
    (0, _classCallCheck3.default)(this, BarrelExperience);

    var _this = (0, _possibleConstructorReturn3.default)(this, (BarrelExperience.__proto__ || (0, _getPrototypeOf2.default)(BarrelExperience)).call(this));

    _this.platform = _this.require('platform', { features: ['web-audio'], showDialog: true });
    _this.sharedParams = _this.require('shared-params');
    _this.audioBufferManager = _this.require('audio-buffer-manager', { assetsDomain: assetsDomain });
    _this.metricScheduler = _this.require('metric-scheduler');

    _this.scenes = {};
    _this.currentScene = null;

    _this.clients = new _set2.default();

    _this.outputBusses = new Array(numOutputChannels); // output channels (array of gain nodes)
    _this.crossFilters = new Array(numOutputChannels); // channel cross-over filters (array of biquad filter nodes)
    _this.wooferBuss = null; // bass woofer gain node
    _this.wooferGain = 1; // bass woofer gain (linear amplitude factor)
    _this.delay = 0.02;

    _this.onSceneChange = _this.onSceneChange.bind(_this);
    _this.onConnectClient = _this.onConnectClient.bind(_this);
    _this.onDisconnectClient = _this.onDisconnectClient.bind(_this);
    _this.onClear = _this.onClear.bind(_this);
    return _this;
  }

  (0, _createClass3.default)(BarrelExperience, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(BarrelExperience.prototype.__proto__ || (0, _getPrototypeOf2.default)(BarrelExperience.prototype), 'start', this).call(this);

      this.view = new soundworks.View(template, {}, {}, { id: 'barrel' });
      this.show();

      this.initScenes();

      this.initAudio(numAudioOutputs); // init audio outputs for an interface of the given number of channels
      this.initParams();

      this.receive('connectClient', this.onConnectClient);
      this.receive('disconnectClient', this.onDisconnectClient);
      this.sharedParams.addParamListener('clear', this.onClear);
    }
  }, {
    key: 'initAudio',
    value: function initAudio() {
      var numAudioOutputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;

      var channelMerger = audioContext.createChannelMerger(numOutputChannels);
      var bassWoofer = audioContext.createGain();

      for (var i = 0; i < numOutputChannels; i++) {
        var channel = audioContext.createGain();
        var lowpass = audioContext.createBiquadFilter();
        var inverter = audioContext.createGain();

        lowpass.type = 'lowpass';
        lowpass.frequency.value = 250; // set default woofer cutoff frequency to 250 Hz
        inverter.gain.value = -1;

        // connect
        channel.connect(lowpass);

        // connect high pass to single output channel,
        // highpass = channel - lowpass(channel) = channel + inverter(lowpass(channel))
        channel.connect(channelMerger, 0, i);
        lowpass.connect(inverter);
        inverter.connect(channelMerger, 0, i);

        // connect low pass (virtual) to bass woofer
        lowpass.connect(bassWoofer);

        this.outputBusses[i] = channel;
        this.crossFilters[i] = lowpass;
      }

      // connect bass woofer to all output channels
      for (var _i = 0; _i < numOutputChannels; _i++) {
        bassWoofer.connect(channelMerger, 0, _i);
      }this.wooferBuss = bassWoofer;
      this.setWooferGain(0); // set default woofer gain to 0 dB

      audioContext.destination.channelCount = numAudioOutputs;
      var channelDestination = audioContext.destination;

      if (numAudioOutputs < numOutputChannels) {
        var splitter = audioContext.createChannelSplitter(numOutputChannels);
        var outputMerger = audioContext.createChannelMerger(numAudioOutputs);

        audioContext.destination.channelCount = numAudioOutputs;
        outputMerger.connect(audioContext.destination);
        channelMerger.connect(splitter);

        for (var _i2 = 0; _i2 < numOutputChannels; _i2++) {
          splitter.connect(outputMerger, _i2, _i2 % numAudioOutputs);
        }channelDestination = splitter;
      }

      channelMerger.connect(channelDestination);
    }
  }, {
    key: 'initParams',
    value: function initParams() {
      var _this2 = this;

      this.sharedParams.addParamListener('scene', this.onSceneChange);
      this.sharedParams.addParamListener('outputGain0', function (value) {
        return _this2.setOutputGain(0, value);
      });
      this.sharedParams.addParamListener('outputGain1', function (value) {
        return _this2.setOutputGain(1, value);
      });
      this.sharedParams.addParamListener('outputGain2', function (value) {
        return _this2.setOutputGain(2, value);
      });
      this.sharedParams.addParamListener('outputGain3', function (value) {
        return _this2.setOutputGain(3, value);
      });
      this.sharedParams.addParamListener('outputGain4', function (value) {
        return _this2.setOutputGain(4, value);
      });
      this.sharedParams.addParamListener('outputGain5', function (value) {
        return _this2.setOutputGain(5, value);
      });
      this.sharedParams.addParamListener('outputGain6', function (value) {
        return _this2.setOutputGain(6, value);
      });
      this.sharedParams.addParamListener('outputGain7', function (value) {
        return _this2.setOutputGain(7, value);
      });
      this.sharedParams.addParamListener('wooferGain', function (value) {
        return _this2.setWooferGain(value);
      });
      this.sharedParams.addParamListener('wooferCutoff', function (value) {
        return _this2.setWooferCutoff(value);
      });
      this.sharedParams.addParamListener('barrelDelay', function (value) {
        return _this2.setDelay(value);
      });
    }
  }, {
    key: 'initScenes',
    value: function initScenes() {
      for (var scene in sceneCtors) {
        var ctor = sceneCtors[scene];
        var config = _scenesConfig2.default[scene];

        if (config) this.scenes[scene] = new ctor(this, config);else throw new Error('Cannot find config for scene \'' + scene + '\'');
      }

      this.currentScene = this.scenes.off;
      this.enterCurrentScene();
    }
  }, {
    key: 'setOutputGain',
    value: function setOutputGain(index, value) {
      this.outputBusses[index].gain.value = (0, _math.decibelToLinear)(value);
    }
  }, {
    key: 'setWooferGain',
    value: function setWooferGain(value) {
      this.wooferBuss.gain.value = (0, _math.decibelToLinear)(value) / numOutputChannels;
    }
  }, {
    key: 'setWooferCutoff',
    value: function setWooferCutoff(value) {
      for (var i = 0; i < numOutputChannels; i++) {
        this.crossFilters[i].frequency.value = value;
      }
    }
  }, {
    key: 'setDelay',
    value: function setDelay(value) {
      this.delay = value;
    }
  }, {
    key: 'enterCurrentScene',
    value: function enterCurrentScene() {
      this.currentScene.enter();

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.clients), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var client = _step.value;

          this.currentScene.clientEnter(client);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'exitCurrentScene',
    value: function exitCurrentScene() {
      this.currentScene.exit();

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.clients), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var client = _step2.value;

          this.currentScene.clientExit(client);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'onSceneChange',
    value: function onSceneChange(value) {
      this.exitCurrentScene();
      this.currentScene = this.scenes[value];
      this.enterCurrentScene();
    }
  }, {
    key: 'onConnectClient',
    value: function onConnectClient(index) {
      this.clients.add(index);
      this.currentScene.clientEnter(index);
    }
  }, {
    key: 'onDisconnectClient',
    value: function onDisconnectClient(index) {
      this.clients.delete(index);
      this.currentScene.clientExit(index);
    }
  }, {
    key: 'onClear',
    value: function onClear(index) {
      if (this.currentScene.clear) this.currentScene.clear(index);
    }
  }]);
  return BarrelExperience;
}(soundworks.Experience);

exports.default = BarrelExperience;

},{"../../shared/scenes-config":12,"./scenes/co-909":4,"./scenes/co-mix":5,"./scenes/collective-loops":6,"./scenes/off":7,"./scenes/wwry-r":8,"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"soundworks/client":270,"soundworks/utils/math":310}],2:[function(require,module,exports){
'use strict';

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

var _BarrelExperience = require('./BarrelExperience');

var _BarrelExperience2 = _interopRequireDefault(_BarrelExperience);

var _serviceViews = require('../shared/serviceViews');

var _serviceViews2 = _interopRequireDefault(_serviceViews);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function bootstrap() {
  var config = (0, _assign2.default)({ appContainer: '#container' }, window.soundworksConfig);
  soundworks.client.init(config.clientType, config);

  soundworks.client.setServiceInstanciationHook(function (id, instance) {
    if (_serviceViews2.default.has(id)) instance.view = _serviceViews2.default.get(id, config);
  });

  var experience = new _BarrelExperience2.default(config.assetsDomain);
  soundworks.client.start();
} // import client side soundworks and player experience


window.addEventListener('load', bootstrap);

},{"../shared/serviceViews":11,"./BarrelExperience":1,"babel-runtime/core-js/object/assign":20,"soundworks/client":270}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Placer = function () {
  function Placer(experience) {
    (0, _classCallCheck3.default)(this, Placer);

    this.experience = experience;
    this.callbacks = [];

    this.onDone = this.onDone.bind(this);
    experience.receive('placerDone', this.onDone);
  }

  (0, _createClass3.default)(Placer, [{
    key: 'start',
    value: function start(index) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      this.callbacks[index] = callback;
    }
  }, {
    key: 'stop',
    value: function stop(index) {
      delete this.callbacks[index];
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.callbacks = [];
    }
  }, {
    key: 'onDone',
    value: function onDone(index) {
      var callback = this.callbacks[index];

      if (callback) callback(index);
    }
  }]);
  return Placer;
}();

exports.default = Placer;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"soundworks/client":270}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

var _math = require('soundworks/utils/math');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioContext = soundworks.audioContext;
var audioScheduler = soundworks.audio.getScheduler();

var SceneCo909 = function () {
  function SceneCo909(experience, config) {
    (0, _classCallCheck3.default)(this, SceneCo909);

    this.experience = experience;
    this.config = config;
    this.instruments = null;

    var numSteps = config.numSteps;
    var numInstruments = config.instruments.length;

    this.instrumentSequences = new Array(numInstruments);

    for (var i = 0; i < numInstruments; i++) {
      this.instrumentSequences[i] = new Array(numSteps);
      this.resetInstrumentSequence(i);
    }

    this.outputBusses = experience.outputBusses;

    this.onMetroBeat = this.onMetroBeat.bind(this);
    this.onSwitchNote = this.onSwitchNote.bind(this);
  }

  (0, _createClass3.default)(SceneCo909, [{
    key: 'clientEnter',
    value: function clientEnter(index) {}
  }, {
    key: 'clientExit',
    value: function clientExit(index) {
      this.resetInstrumentSequence(index);
    }
  }, {
    key: 'enterScene',
    value: function enterScene() {
      var experience = this.experience;
      var numSteps = this.config.numSteps;
      experience.metricScheduler.addMetronome(this.onMetroBeat, numSteps, numSteps, 1, 0, true);
      experience.receive('switchNote', this.onSwitchNote);
    }
  }, {
    key: 'enter',
    value: function enter() {
      var _this = this;

      var experience = this.experience;

      if (this.instruments) {
        this.enterScene();
      } else {
        var instrumentConfig = this.config.instruments;
        experience.audioBufferManager.loadFiles(instrumentConfig).then(function (instruments) {
          _this.instruments = instruments;
          _this.enterScene();
        });
      }
    }
  }, {
    key: 'exit',
    value: function exit() {
      var experience = this.experience;
      experience.metricScheduler.removeMetronome(this.onMetroBeat);
      experience.stopReceiving('switchNote', this.onSwitchNote);
    }
  }, {
    key: 'resetInstrumentSequence',
    value: function resetInstrumentSequence(instrument) {
      var sequence = this.instrumentSequences[instrument];

      for (var i = 0; i < sequence.length; i++) {
        sequence[i] = 0;
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      for (var i = 0; i < this.instrumentSequences.length; i++) {
        this.resetInstrumentSequence(i);
      }
    }
  }, {
    key: 'onMetroBeat',
    value: function onMetroBeat(measure, beat) {
      var time = audioScheduler.currentTime;

      for (var i = 0; i < this.instrumentSequences.length; i++) {
        var instrument = this.instruments[i];
        var sequence = this.instrumentSequences[i];
        var state = sequence[beat];

        if (state > 0) {
          var layer = instrument.layers[state - 1];

          var gain = audioContext.createGain();
          gain.connect(this.outputBusses[i]);
          gain.gain.value = (0, _math.decibelToLinear)(layer.gain);

          var src = audioContext.createBufferSource();
          src.connect(gain);
          src.buffer = layer.buffer;
          src.start(time);
        }
      }
    }
  }, {
    key: 'onSwitchNote',
    value: function onSwitchNote(instrument, beat, state) {
      var sequence = this.instrumentSequences[instrument];
      sequence[beat] = state;
    }
  }]);
  return SceneCo909;
}();

exports.default = SceneCo909;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"soundworks/client":270,"soundworks/utils/math":310}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

var _Placer = require('./Placer');

var _Placer2 = _interopRequireDefault(_Placer);

var _LoopPlayer = require('../../shared/LoopPlayer');

var _LoopPlayer2 = _interopRequireDefault(_LoopPlayer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioContext = soundworks.audioContext;
var audioScheduler = soundworks.audio.getScheduler();

var SceneCoMix = function () {
  function SceneCoMix(experience, config) {
    (0, _classCallCheck3.default)(this, SceneCoMix);

    this.experience = experience;
    this.config = config;
    this.notes = null;

    var numTracks = config.tracks.length;
    this.outputBusses = experience.outputBusses;

    this.placer = new _Placer2.default(experience);
    this.loopPlayer = null;

    this.onTrackCutoff = this.onTrackCutoff.bind(this);
    this.onSwitchLayer = this.onSwitchLayer.bind(this);
  }

  (0, _createClass3.default)(SceneCoMix, [{
    key: 'clientEnter',
    value: function clientEnter(index) {
      var _this = this;

      var experience = this.experience;

      this.placer.start(index, function () {
        var loopPlayer = _this.loopPlayer;

        if (loopPlayer) {
          var track = _this.tracks[index];
          loopPlayer.addLoopTrack(index, track.layers);
        }
      });
    }
  }, {
    key: 'clientExit',
    value: function clientExit(index) {
      var loopPlayer = this.loopPlayer;

      if (loopPlayer) loopPlayer.removeLoopTrack(index);
    }
  }, {
    key: 'enterScene',
    value: function enterScene() {
      var experience = this.experience;
      experience.receive('trackCutoff', this.onTrackCutoff);
      experience.receive('switchLayer', this.onSwitchLayer);

      if (!this.loopPlayer) {
        var config = this.config;
        this.loopPlayer = new _LoopPlayer2.default(experience.metricScheduler, this.outputBusses, 1, config.tempo, config.tempoUnit, 0.05);
      }
    }
  }, {
    key: 'enter',
    value: function enter() {
      var _this2 = this;

      var experience = this.experience;

      if (this.notes) {
        this.enterScene();
      } else {
        var trackConfig = this.config.tracks;
        experience.audioBufferManager.loadFiles(trackConfig).then(function (tracks) {
          _this2.tracks = tracks;
          _this2.enterScene();
        });
      }
    }
  }, {
    key: 'exit',
    value: function exit() {
      var experience = this.experience;
      experience.stopReceiving('trackCutoff', this.onTrackCutoff);
      experience.stopReceiving('switchLayer', this.onSwitchLayer);

      this.placer.clear();
      this.loopPlayer.stopAllTracks();
    }
  }, {
    key: 'onTrackCutoff',
    value: function onTrackCutoff(index, value) {
      var loopPlayer = this.loopPlayer;

      if (loopPlayer) loopPlayer.setCutoff(index, value);
    }
  }, {
    key: 'onSwitchLayer',
    value: function onSwitchLayer(index, value) {
      var loopPlayer = this.loopPlayer;

      if (loopPlayer) loopPlayer.setLayer(index, value);
    }
  }]);
  return SceneCoMix;
}();

exports.default = SceneCoMix;

},{"../../shared/LoopPlayer":9,"./Placer":3,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"soundworks/client":270}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

var _math = require('soundworks/utils/math');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioContext = soundworks.audioContext;
var audioScheduler = soundworks.audio.getScheduler();

var SceneCollectiveLoops = function () {
  function SceneCollectiveLoops(experience, config) {
    (0, _classCallCheck3.default)(this, SceneCollectiveLoops);

    this.experience = experience;
    this.config = config;
    this.notes = null;

    var numSteps = config.numSteps;
    var numNotes = config.notes.length;

    this.stepStates = new Array(numSteps);

    for (var i = 0; i < numSteps; i++) {
      this.stepStates[i] = new Array(numNotes);
      this.resetStepStates(i);
    }

    this.outputBusses = experience.outputBusses;

    this.onMetroBeat = this.onMetroBeat.bind(this);
    this.onSwitchNote = this.onSwitchNote.bind(this);
  }

  (0, _createClass3.default)(SceneCollectiveLoops, [{
    key: 'clientEnter',
    value: function clientEnter(index) {}
  }, {
    key: 'clientExit',
    value: function clientExit(index) {
      this.resetStepStates(index);
    }
  }, {
    key: 'enterScene',
    value: function enterScene() {
      var experience = this.experience;
      var numSteps = this.stepStates.length;
      experience.metricScheduler.addMetronome(this.onMetroBeat, numSteps, numSteps, 1, 0, true);
      experience.receive('switchNote', this.onSwitchNote);
    }
  }, {
    key: 'enter',
    value: function enter() {
      var _this = this;

      var experience = this.experience;

      if (this.notes) {
        this.enterScene();
      } else {
        var noteConfig = this.config.notes;
        experience.audioBufferManager.loadFiles(noteConfig).then(function (notes) {
          _this.notes = notes;
          _this.enterScene();
        });
      }
    }
  }, {
    key: 'exit',
    value: function exit() {
      var experience = this.experience;
      experience.metricScheduler.removeMetronome(this.onMetroBeat);
      experience.stopReceiving('switchNote', this.onSwitchNote);
    }
  }, {
    key: 'resetStepStates',
    value: function resetStepStates(step) {
      var states = this.stepStates[step];

      for (var i = 0; i < states.length; i++) {
        states[i] = 0;
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      for (var i = 0; i < this.stepStates.length; i++) {
        this.resetStepStates(i);
      }
    }
  }, {
    key: 'onMetroBeat',
    value: function onMetroBeat(measure, beat) {
      var time = audioScheduler.currentTime;
      var notes = this.notes;
      var states = this.stepStates[beat];
      var output = this.outputBusses[beat];

      for (var i = 0; i < states.length; i++) {
        var note = notes[i];
        var state = states[i];

        if (state > 0) {
          var gain = audioContext.createGain();
          gain.connect(output);
          gain.gain.value = (0, _math.decibelToLinear)(note.gain);

          var src = audioContext.createBufferSource();
          src.connect(gain);
          src.buffer = note.buffer;
          src.start(time);
        }
      }
    }
  }, {
    key: 'onSwitchNote',
    value: function onSwitchNote(step, note, state) {
      var states = this.stepStates[step];
      states[note] = state;
    }
  }]);
  return SceneCollectiveLoops;
}();

exports.default = SceneCollectiveLoops;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"soundworks/client":270,"soundworks/utils/math":310}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SceneOff = function () {
  function SceneOff(experience, config) {
    (0, _classCallCheck3.default)(this, SceneOff);

    this.experience = experience;
    this.config = config;
  }

  (0, _createClass3.default)(SceneOff, [{
    key: 'clientEnter',
    value: function clientEnter(client) {}
  }, {
    key: 'clientExit',
    value: function clientExit(client) {}
  }, {
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }]);
  return SceneOff;
}();

exports.default = SceneOff;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"soundworks/client":270}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

var _Placer = require('./Placer');

var _Placer2 = _interopRequireDefault(_Placer);

var _QueenPlayer = require('../../shared/QueenPlayer');

var _QueenPlayer2 = _interopRequireDefault(_QueenPlayer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioContext = soundworks.audioContext;
var audioScheduler = soundworks.audio.getScheduler();

var SceneWwryR = function () {
  function SceneWwryR(experience, config) {
    (0, _classCallCheck3.default)(this, SceneWwryR);

    this.experience = experience;
    this.config = config;
    this.notes = null;

    var numTracks = config.tracks.length;
    this.outputBusses = experience.outputBusses;

    this.placer = new _Placer2.default(experience);
    this.queenPlayer = null;
    this.tracks = [];

    this.onMotionEvent = this.onMotionEvent.bind(this);
  }

  (0, _createClass3.default)(SceneWwryR, [{
    key: 'clientEnter',
    value: function clientEnter(index) {
      var _this = this;

      var experience = this.experience;

      this.placer.start(index, function () {
        var queenPlayer = _this.queenPlayer;

        if (queenPlayer) queenPlayer.startTrack(index, _this.tracks[index]);
      });
    }
  }, {
    key: 'clientExit',
    value: function clientExit(index) {
      var queenPlayer = this.queenPlayer;

      if (queenPlayer) queenPlayer.stopTrack(index);
    }
  }, {
    key: 'enterScene',
    value: function enterScene() {
      var experience = this.experience;
      experience.receive('motionEvent', this.onMotionEvent);

      if (!this.queenPlayer) this.queenPlayer = new _QueenPlayer2.default(this.outputBusses);
    }
  }, {
    key: 'enter',
    value: function enter() {
      var _this2 = this;

      var experience = this.experience;

      if (this.notes) {
        this.enterScene();
      } else {
        var trackConfig = this.config.tracks;
        experience.audioBufferManager.loadFiles(trackConfig).then(function (tracks) {
          _this2.tracks = tracks;
          _this2.enterScene();
        });
      }
    }
  }, {
    key: 'exit',
    value: function exit() {
      var experience = this.experience;
      experience.stopReceiving('motionEvent', this.onMotionEvent);

      this.placer.clear();
    }
  }, {
    key: 'onMotionEvent',
    value: function onMotionEvent(index, data) {
      var queenPlayer = this.queenPlayer;

      if (queenPlayer) queenPlayer.onMotionEvent(index, data);
    }
  }]);
  return SceneWwryR;
}();

exports.default = SceneWwryR;

},{"../../shared/QueenPlayer":10,"./Placer":3,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"soundworks/client":270}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

var _math = require('soundworks/utils/math');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audio = soundworks.audio;
var audioContext = soundworks.audioContext;
var audioScheduler = soundworks.audio.getScheduler();

function appendSegments(segments, loopSegment, measureDuration) {
  var buffer = loopSegment.buffer;
  var bufferDuration = buffer ? buffer.duration : 0;
  var startOffset = loopSegment.startOffset || 0;
  var gain = loopSegment.gain;
  var repeat = loopSegment.repeat || 1;

  for (var n = 0; n < repeat; n++) {
    var cont = !!loopSegment.continue;

    for (var i = 0; i < loopSegment.length; i++) {
      var offset = startOffset + i * measureDuration;

      if (offset < bufferDuration) {
        var segment = new Segment(buffer, offset, Infinity, 0, gain, cont);
        segments.push(segment);
      }

      cont = true;
    }
  }
}

var Segment = function Segment(buffer) {
  var offsetInBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var durationInBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  var offsetInMeasure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var gain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var cont = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  (0, _classCallCheck3.default)(this, Segment);

  this.buffer = buffer;
  this.offsetInBuffer = offsetInBuffer;
  this.durationInBuffer = durationInBuffer; // 0: continue untill next segment starts
  this.offsetInMeasure = offsetInMeasure;
  this.gain = gain;
  this.continue = cont; // segment continues previous segment
};

var SegmentTrack = function () {
  function SegmentTrack(output, segmentLayers) {
    var transitionTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.05;
    (0, _classCallCheck3.default)(this, SegmentTrack);

    this.src = audioContext.createBufferSource();

    this.segmentLayers = segmentLayers;
    this.transitionTime = transitionTime;

    this.minCutoffFreq = 5;
    this.maxCutoffFreq = audioContext.sampleRate / 2;
    this.logCutoffRatio = Math.log(this.maxCutoffFreq / this.minCutoffFreq);

    this.layerIndex = 0;
    this.discontinue = true;

    var cutoff = audioContext.createBiquadFilter();
    cutoff.connect(output);
    cutoff.type = 'lowpass';
    cutoff.frequency.value = this.maxCutoffFreq;

    this.src = null;
    this.env = null;
    this.cutoff = cutoff;
    this.endTime = 0;
  }

  (0, _createClass3.default)(SegmentTrack, [{
    key: 'startSegment',
    value: function startSegment(audioTime, segment) {
      var buffer = segment.buffer;
      var bufferDuration = buffer.duration;
      var offsetInBuffer = segment.offsetInBuffer;
      var durationInBuffer = Math.min(segment.durationInBuffer || Infinity, bufferDuration - offsetInBuffer);
      var transitionTime = this.transitionTime;

      if (audioTime < this.endTime - transitionTime) {
        var src = this.src;
        var endTime = Math.min(audioTime + transitionTime, this.endTime);

        if (transitionTime > 0) {
          var env = this.env;
          // env.gain.cancelScheduledValues(audioTime);
          env.gain.setValueAtTime(1, audioTime);
          env.gain.linearRampToValueAtTime(0, endTime);
        }

        src.stop(endTime);
      }

      if (offsetInBuffer < bufferDuration) {
        var delay = 0;

        if (offsetInBuffer < transitionTime) {
          delay = transitionTime - offsetInBuffer;
          transitionTime = offsetInBuffer;
        }

        var gain = audioContext.createGain();
        gain.connect(this.cutoff);
        gain.gain.value = (0, _math.decibelToLinear)(segment.gain);

        var _env = audioContext.createGain();
        _env.connect(gain);

        if (transitionTime > 0) {
          _env.gain.value = 0;
          _env.gain.setValueAtTime(0, audioTime + delay);
          _env.gain.linearRampToValueAtTime(1, audioTime + delay + transitionTime);
        }

        var _src = audioContext.createBufferSource();
        _src.connect(_env);
        _src.buffer = buffer;
        _src.start(audioTime + delay, offsetInBuffer - transitionTime);

        audioTime += transitionTime;

        var endInBuffer = offsetInBuffer + durationInBuffer;
        var _endTime = audioTime + durationInBuffer;

        this.src = _src;
        this.env = _env;
        this.endTime = _endTime;
      }
    }
  }, {
    key: 'stopSegment',
    value: function stopSegment() {
      var audioTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : audioContext.currentTime;

      var src = this.src;

      if (src) {
        var transitionTime = this.transitionTime;
        var env = this.env;

        env.gain.setValueAtTime(1, audioTime);
        env.gain.linearRampToValueAtTime(0, audioTime + transitionTime);

        src.stop(audioTime + transitionTime);

        this.src = null;
        this.env = null;
        this.endTime = 0;
      }
    }
  }, {
    key: 'startMeasure',
    value: function startMeasure(audioTime, measureIndex) {
      var canContinue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var segments = this.segmentLayers[this.layerIndex];
      var measureIndexInPattern = measureIndex % segments.length;
      var segment = segments[measureIndexInPattern];

      if (segment && (this.discontinue || !(segment.continue && canContinue))) {
        var delay = segment.offsetInMeasure || 0;
        this.startSegment(audioTime + delay, segment);
        this.discontinue = false;
      }
    }
  }, {
    key: 'setCutoff',
    value: function setCutoff(value) {
      var cutoffFreq = this.minCutoffFreq * Math.exp(this.logCutoffRatio * value);
      this.cutoff.frequency.value = cutoffFreq;
    }
  }, {
    key: 'setLayer',
    value: function setLayer(value) {
      this.layerIndex = value;
      this.discontinue = true;
    }
  }]);
  return SegmentTrack;
}();

var LoopPlayer = function (_audio$TimeEngine) {
  (0, _inherits3.default)(LoopPlayer, _audio$TimeEngine);

  function LoopPlayer(metricScheduler, audioOutputs) {
    var measureLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var tempo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 120;
    var tempoUnit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1 / 4;
    var transitionTime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.05;
    var measureCallback = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (measureCount) {};
    (0, _classCallCheck3.default)(this, LoopPlayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LoopPlayer.__proto__ || (0, _getPrototypeOf2.default)(LoopPlayer)).call(this));

    _this.metricScheduler = metricScheduler;
    _this.audioOutputs = audioOutputs;
    _this.measureLength = measureLength;
    _this.tempo = tempo;
    _this.tempoUnit = tempoUnit;
    _this.transitionTime = transitionTime;
    _this.measureCallback = measureCallback;

    _this.measureDuration = 60 / (tempo * tempoUnit);
    _this.measureIndex = undefined;
    _this.segmentTracks = new _map2.default();

    _this.metricScheduler.add(_this);
    return _this;
  }

  (0, _createClass3.default)(LoopPlayer, [{
    key: 'stopAllTracks',
    value: function stopAllTracks() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.segmentTracks), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
              index = _step$value[0],
              segmentTrack = _step$value[1];

          segmentTrack.stopSegment();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(syncTime, metricPosition, metricSpeed) {
      if (metricSpeed === 0) this.stopAllTracks();
    }
  }, {
    key: 'syncPosition',
    value: function syncPosition(syncTime, metricPosition, metricSpeed) {
      var audioTime = audioScheduler.currentTime;
      var floatMeasures = metricPosition / this.measureLength;
      var numMeasures = Math.ceil(floatMeasures);
      var nextMeasurePosition = numMeasures * this.measureLength;

      this.measureIndex = numMeasures - 1;
      this.nextMeasureTime = undefined;

      return nextMeasurePosition;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(syncTime, metricPosition, metricSpeed) {
      var audioTime = audioScheduler.currentTime;

      this.measureIndex++;

      var canContinue = this.nextMeasureTime && Math.abs(audioTime - this.nextMeasureTime) < 0.01;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.segmentTracks), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = (0, _slicedToArray3.default)(_step2.value, 2),
              index = _step2$value[0],
              segmentTrack = _step2$value[1];

          segmentTrack.startMeasure(audioTime, this.measureIndex, canContinue);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.measureCallback(audioTime, this.measureIndex);

      this.nextMeasureTime = audioTime + this.measureDuration;

      return metricPosition + this.measureLength;
    }
  }, {
    key: 'getLoopTrack',
    value: function getLoopTrack(index) {
      return this.segmentTracks.get(index);
    }
  }, {
    key: 'removeLoopTrack',
    value: function removeLoopTrack(index) {
      var segmentTrack = this.segmentTracks.get(index);

      if (segmentTrack) {
        segmentTrack.stopSegment();
        this.segmentTracks.delete(index);
      }
    }
  }, {
    key: 'addLoopTrack',
    value: function addLoopTrack(index, loopLayers) {
      var _this2 = this;

      var segmentTrack = this.segmentTracks.get(index);

      if (segmentTrack) throw new Error('Cannot add segment track twice (index: ' + index + ')');

      var segmentLayers = [];

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        var _loop = function _loop() {
          var layer = _step3.value;

          var segments = [];

          if (Array.isArray(layer)) layer.forEach(function (seg) {
            return appendSegments(segments, seg, _this2.measureDuration);
          });else appendSegments(segments, layer, _this2.measureDuration);

          segmentLayers.push(segments);
        };

        for (var _iterator3 = (0, _getIterator3.default)(loopLayers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      segmentTrack = new SegmentTrack(this.audioOutputs[index], segmentLayers, this.transitionTime);
      this.segmentTracks.set(index, segmentTrack);
    }
  }, {
    key: 'setCutoff',
    value: function setCutoff(index, value) {
      var segmentTrack = this.segmentTracks.get(index);

      if (segmentTrack) segmentTrack.setCutoff(value);
    }
  }, {
    key: 'setLayer',
    value: function setLayer(index, value) {
      var segmentTrack = this.segmentTracks.get(index);

      if (segmentTrack) segmentTrack.setLayer(value);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.stopAllTracks();
      this.metricScheduler.remove(this);
    }
  }]);
  return LoopPlayer;
}(audio.TimeEngine);

exports.default = LoopPlayer;

},{"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/map":19,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"babel-runtime/helpers/slicedToArray":38,"soundworks/client":270,"soundworks/utils/math":310}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('soundworks/client');

var soundworks = _interopRequireWildcard(_client);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audio = soundworks.audio;
var audioContext = soundworks.audioContext;
var audioScheduler = soundworks.audio.getScheduler();

var HitEngine = function (_audio$SegmentEngine) {
  (0, _inherits3.default)(HitEngine, _audio$SegmentEngine);

  function HitEngine(track, output) {
    (0, _classCallCheck3.default)(this, HitEngine);

    var _this = (0, _possibleConstructorReturn3.default)(this, (HitEngine.__proto__ || (0, _getPrototypeOf2.default)(HitEngine)).call(this));

    _this.buffer = track.buffer;
    _this.positionArray = track.markers.time;
    _this.offsetArray = track.markers.offset;

    _this.releaseRel = 0.25;

    _this.connect(output);
    return _this;
  }

  (0, _createClass3.default)(HitEngine, [{
    key: 'start',
    value: function start() {}
  }, {
    key: 'stop',
    value: function stop() {}
  }, {
    key: 'onMotionEvent',
    value: function onMotionEvent(data) {
      this.segmentIndex = data;
      this.trigger();
    }
  }]);
  return HitEngine;
}(audio.SegmentEngine);

var PowerChordEngine = function (_audio$GranularEngine) {
  (0, _inherits3.default)(PowerChordEngine, _audio$GranularEngine);

  function PowerChordEngine(track, output) {
    (0, _classCallCheck3.default)(this, PowerChordEngine);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (PowerChordEngine.__proto__ || (0, _getPrototypeOf2.default)(PowerChordEngine)).call(this));

    _this2.buffer = track.buffer;
    _this2.periodAbs = 0.01;
    _this2.periodRel = 0;
    _this2.durationAbs = 0.08;
    _this2.durationRel = 0;
    _this2.gain = 2 * _this2.periodAbs / _this2.durationAbs;

    _this2.connect(output);
    return _this2;
  }

  (0, _createClass3.default)(PowerChordEngine, [{
    key: 'start',
    value: function start() {
      if (!this.master) audioScheduler.add(this);
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this.master) audioScheduler.remove(this);
    }
  }, {
    key: 'onMotionEvent',
    value: function onMotionEvent(data) {
      var margin = 0.5 * this.durationAbs + this.positionVar;
      var range = this.buffer.duration - 2 * margin;
      this.position = margin + data * range;
    }
  }]);
  return PowerChordEngine;
}(audio.GranularEngine);

var GuitarRiffEngine = function (_audio$GranularEngine2) {
  (0, _inherits3.default)(GuitarRiffEngine, _audio$GranularEngine2);

  function GuitarRiffEngine(track, output) {
    (0, _classCallCheck3.default)(this, GuitarRiffEngine);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (GuitarRiffEngine.__proto__ || (0, _getPrototypeOf2.default)(GuitarRiffEngine)).call(this));

    _this3.segments = track.markers;

    _this3.buffer = track.buffer;
    _this3.periodAbs = 0.010;
    _this3.periodRel = 0;
    _this3.durationAbs = 0.080;
    _this3.durationRel = 0;
    _this3.position = 0;
    _this3.positionVar = 0.02;
    _this3.gain = 0;

    _this3.segmentIndex = 15;
    _this3.playingPosition = 0;
    _this3.playingSpeed = 0;
    _this3.gainFactor = 2 * _this3.periodAbs / _this3.durationAbs;

    _this3.connect(output);
    return _this3;
  }

  (0, _createClass3.default)(GuitarRiffEngine, [{
    key: 'trigger',
    value: function trigger(time) {
      var segments = this.segments;

      if (this.playingSpeed > 0 && this.playingPosition < segments[this.segmentIndex].end) {
        this.position = this.playingPosition;
        this.positionVar = 0;
        this.gain = this.gainFactor * 0.707;
      } else {
        this.position = segments[this.segmentIndex].end;
        this.positionVar = 0.02;

        if (this.playingSpeed !== 0) {
          this.playingSpeed = 0;
          this.gain = this.gainFactor * 1.0;
        } else {
          this.gain *= segments[this.segmentIndex].sustain;
        }
      }

      this.playingPosition += this.periodAbs * this.playingSpeed;

      return (0, _get3.default)(GuitarRiffEngine.prototype.__proto__ || (0, _getPrototypeOf2.default)(GuitarRiffEngine.prototype), 'trigger', this).call(this, time);
    }
  }, {
    key: 'start',
    value: function start() {
      if (!this.master) {
        var segments = this.segments;

        this.segmentIndex = 15;
        this.playingPosition = segments[this.segmentIndex].start;
        this.playingSpeed = segments[this.segmentIndex].speed;
        this.gain = this.gainFactor * 0.707;

        audioScheduler.add(this);
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this.master) audioScheduler.remove(this);
    }
  }, {
    key: 'onMotionEvent',
    value: function onMotionEvent(data) {
      var segments = this.segments;

      this.playingPosition = segments[data].start;
      this.playingSpeed = segments[data].speed;

      this.segmentIndex = data;
    }
  }]);
  return GuitarRiffEngine;
}(audio.GranularEngine);

var QueenPlayer = function () {
  function QueenPlayer(outputs) {
    (0, _classCallCheck3.default)(this, QueenPlayer);

    this.outputs = outputs;

    this.engines = [];

    this.onMotionEvent = this.onMotionEvent.bind(this);
  }

  (0, _createClass3.default)(QueenPlayer, [{
    key: 'startTrack',
    value: function startTrack(index, track) {
      var engine = this.engines[index];

      if (!engine) {
        switch (track.name) {
          case 'drums':
          case 'verse':
          case 'chorus':
          case 'freddy':
            engine = new HitEngine(track, this.outputs[index]);
            break;

          case 'power chord':
            engine = new PowerChordEngine(track, this.outputs[index]);
            break;

          case 'guitar riff':
            engine = new GuitarRiffEngine(track, this.outputs[index]);
            break;
        }

        this.engines[index] = engine;
      }

      engine.start();
    }
  }, {
    key: 'stopTrack',
    value: function stopTrack(index) {
      var engine = this.engines[index];

      if (engine) engine.stop();
    }
  }, {
    key: 'onMotionEvent',
    value: function onMotionEvent(index, data) {
      var engine = this.engines[index];

      if (engine) engine.onMotionEvent(data);
    }
  }]);
  return QueenPlayer;
}();

exports.default = QueenPlayer;

},{"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"soundworks/client":270}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('soundworks/client');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// --------------------------- example
/**
 * Interface for the view of the `audio-buffer-manager` service.
 *
 * @interface AbstractAudioBufferManagerView
 * @extends module:soundworks/client.View
 */
/**
 * Method called when a new information about the currently loaded assets
 * is received.
 *
 * @function
 * @name AbstractAudioBufferManagerView.onProgress
 * @param {Number} percent - The purcentage of loaded assets.
 */
// ------------------------------------

var noop = function noop() {};

var serviceViews = {
  // ------------------------------------------------
  // AudioBufferManager
  // ------------------------------------------------
  'service:audio-buffer-manager': function (_SegmentedView) {
    (0, _inherits3.default)(AudioBufferManagerView, _SegmentedView);

    function AudioBufferManagerView() {
      (0, _classCallCheck3.default)(this, AudioBufferManagerView);

      var _this = (0, _possibleConstructorReturn3.default)(this, (AudioBufferManagerView.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferManagerView)).call(this));

      _this.template = '\n        <div class="section-top flex-middle">\n          <p><%= msg[status] %></p>\n        </div>\n        <div class="section-center flex-center">\n          <% if (showProgress) { %>\n          <div class="progress-wrap">\n            <div class="progress-bar"></div>\n          </div>\n          <% } %>\n        </div>\n        <div class="section-bottom"></div>\n      ';

      _this.model = {
        status: 'loading',
        showProgress: true,
        msg: {
          loading: 'Loading sounds...',
          decoding: 'Decoding sounds...'
        }
      };
      return _this;
    }

    (0, _createClass3.default)(AudioBufferManagerView, [{
      key: 'onRender',
      value: function onRender() {
        (0, _get3.default)(AudioBufferManagerView.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferManagerView.prototype), 'onRender', this).call(this);
        this.$progressBar = this.$el.querySelector('.progress-bar');
      }
    }, {
      key: 'onProgress',
      value: function onProgress(ratio) {
        var percent = Math.round(ratio * 100);

        if (percent === 100) {
          this.model.status = 'decoding';
          this.render('.section-top');
        }

        if (this.model.showProgress) this.$progressBar.style.width = percent + '%';
      }
    }]);
    return AudioBufferManagerView;
  }(_client.SegmentedView),

  // ------------------------------------------------
  // Auth
  // ------------------------------------------------
  'service:auth': function (_SegmentedView2) {
    (0, _inherits3.default)(AuthView, _SegmentedView2);

    function AuthView() {
      (0, _classCallCheck3.default)(this, AuthView);

      var _this2 = (0, _possibleConstructorReturn3.default)(this, (AuthView.__proto__ || (0, _getPrototypeOf2.default)(AuthView)).call(this));

      _this2.template = '\n        <% if (!rejected) { %>\n          <div class="section-top flex-middle">\n            <p><%= instructions %></p>\n          </div>\n          <div class="section-center flex-center">\n            <div>\n              <input type="password" id="password" />\n              <button class="btn" id="send"><%= send %></button>\n            </div>\n          </div>\n          <div class="section-bottom flex-middle">\n            <button id="reset" class="btn"><%= reset %></button>\n          </div>\n        <% } else { %>\n          <div class="section-top"></div>\n          <div class="section-center flex-center">\n            <p><%= rejectMessage %></p>\n          </div>\n          <div class="section-bottom flex-middle">\n            <button id="reset" class="btn"><%= reset %></button>\n          </div>\n        <% } %>\n      ';

      _this2.model = {
        instructions: 'Login',
        send: 'Send',
        reset: 'Reset',
        rejectMessage: 'Sorry, you don\'t have access to this client',
        rejected: false
      };

      _this2._sendPasswordCallback = noop;
      _this2._resetCallback = noop;
      return _this2;
    }

    (0, _createClass3.default)(AuthView, [{
      key: 'onRender',
      value: function onRender() {
        var _this3 = this;

        (0, _get3.default)(AuthView.prototype.__proto__ || (0, _getPrototypeOf2.default)(AuthView.prototype), 'onRender', this).call(this);

        this.installEvents({
          'click #send': function clickSend() {
            var password = _this3.$el.querySelector('#password').value;

            if (password !== '') _this3._sendPasswordCallback(password);
          },
          'click #reset': function clickReset() {
            return _this3._resetCallback();
          }
        });
      }
    }, {
      key: 'setSendPasswordCallback',
      value: function setSendPasswordCallback(callback) {
        this._sendPasswordCallback = callback;
      }
    }, {
      key: 'setResetCallback',
      value: function setResetCallback(callback) {
        this._resetCallback = callback;
      }
    }, {
      key: 'updateRejectedStatus',
      value: function updateRejectedStatus(value) {
        this.model.rejected = value;
        this.render();
      }
    }]);
    return AuthView;
  }(_client.SegmentedView),

  // ------------------------------------------------
  // Checkin
  // ------------------------------------------------
  'service:checkin': function (_SegmentedView3) {
    (0, _inherits3.default)(CheckinView, _SegmentedView3);

    function CheckinView() {
      (0, _classCallCheck3.default)(this, CheckinView);

      var _this4 = (0, _possibleConstructorReturn3.default)(this, (CheckinView.__proto__ || (0, _getPrototypeOf2.default)(CheckinView)).call(this));

      _this4.template = '\n        <% if (label) { %>\n          <div class="section-top flex-middle">\n            <p class="big"><%= labelPrefix %></p>\n          </div>\n          <div class="section-center flex-center">\n            <div class="checkin-label">\n              <p class="huge bold"><%= label %></p>\n            </div>\n          </div>\n          <div class="section-bottom flex-middle">\n            <p class="small"><%= labelPostfix %></p>\n          </div>\n        <% } else { %>\n          <div class="section-top"></div>\n          <div class="section-center flex-center">\n            <p><%= error ? errorMessage : wait %></p>\n          </div>\n          <div class="section-bottom"></div>\n        <% } %>\n      ';

      _this4.model = {
        labelPrefix: 'Go to',
        labelPostfix: 'Touch the screen<br class="portrait-only" />when you are ready.',
        error: false,
        errorMessage: 'Sorry,<br/>no place available',
        wait: 'Please wait...',
        label: ''
      };

      _this4._readyCallback = null;
      return _this4;
    }

    (0, _createClass3.default)(CheckinView, [{
      key: 'onRender',
      value: function onRender() {
        var _this5 = this;

        (0, _get3.default)(CheckinView.prototype.__proto__ || (0, _getPrototypeOf2.default)(CheckinView.prototype), 'onRender', this).call(this);

        var eventName = this.options.interaction === 'mouse' ? 'click' : 'touchstart';

        this.installEvents((0, _defineProperty3.default)({}, eventName, function () {
          return _this5._readyCallback();
        }));
      }
    }, {
      key: 'setReadyCallback',
      value: function setReadyCallback(callback) {
        this._readyCallback = callback;
      }
    }, {
      key: 'updateLabel',
      value: function updateLabel(value) {
        this.model.label = value;
        this.render();
      }
    }, {
      key: 'updateErrorStatus',
      value: function updateErrorStatus(value) {
        this.model.error = value;
        this.render();
      }
    }]);
    return CheckinView;
  }(_client.SegmentedView),

  'service:language': function (_SegmentedView4) {
    (0, _inherits3.default)(LanguageView, _SegmentedView4);

    function LanguageView() {
      (0, _classCallCheck3.default)(this, LanguageView);

      var _this6 = (0, _possibleConstructorReturn3.default)(this, (LanguageView.__proto__ || (0, _getPrototypeOf2.default)(LanguageView)).call(this));

      _this6.template = '\n        <div class="section-top"></div>\n        <div class="section-center">\n          <% for (let key in options) { %>\n            <button class="btn" data-id="<%= key %>"><%= options[key] %></button>\n          <% } %>\n        </div>\n        <div class="section-bottom"></div>\n      ';

      _this6.model = {};

      _this6._selectionCallback = noop;
      return _this6;
    }

    (0, _createClass3.default)(LanguageView, [{
      key: 'onRender',
      value: function onRender() {
        var _this7 = this;

        (0, _get3.default)(LanguageView.prototype.__proto__ || (0, _getPrototypeOf2.default)(LanguageView.prototype), 'onRender', this).call(this);

        var eventName = this.options.interaction === 'mouse' ? 'click' : 'touchstart';
        this.installEvents((0, _defineProperty3.default)({}, eventName + ' .btn', function undefined(e) {
          var target = e.target;
          var id = target.getAttribute('data-id');
          _this7._selectionCallback(id);
        }));
      }
    }, {
      key: 'setSelectionCallback',
      value: function setSelectionCallback(callback) {
        this._selectionCallback = callback;
      }
    }]);
    return LanguageView;
  }(_client.SegmentedView),

  // ------------------------------------------------
  // Locator
  // ------------------------------------------------
  'service:locator': function (_SquaredView) {
    (0, _inherits3.default)(LocatorView, _SquaredView);

    function LocatorView() {
      (0, _classCallCheck3.default)(this, LocatorView);

      var _this8 = (0, _possibleConstructorReturn3.default)(this, (LocatorView.__proto__ || (0, _getPrototypeOf2.default)(LocatorView)).call(this));

      _this8.template = '\n        <div class="section-square"></div>\n        <div class="section-float flex-middle">\n          <% if (!showBtn) { %>\n            <p class="small"><%= instructions %></p>\n          <% } else { %>\n            <button class="btn"><%= send %></button>\n          <% } %>\n        </div>\n      ';

      _this8.model = {
        instructions: 'Define your position in the area',
        send: 'Send',
        showBtn: false
      };

      _this8.area = null;
      _this8._selectCallback = noop;

      _this8._onAreaTouchStart = _this8._onAreaTouchStart.bind(_this8);
      _this8._onAreaTouchMove = _this8._onAreaTouchMove.bind(_this8);
      return _this8;
    }

    (0, _createClass3.default)(LocatorView, [{
      key: 'show',
      value: function show() {
        (0, _get3.default)(LocatorView.prototype.__proto__ || (0, _getPrototypeOf2.default)(LocatorView.prototype), 'show', this).call(this);
        this.selector.show();
      }
    }, {
      key: 'onRender',
      value: function onRender() {
        (0, _get3.default)(LocatorView.prototype.__proto__ || (0, _getPrototypeOf2.default)(LocatorView.prototype), 'onRender', this).call(this);
        this.$areaContainer = this.$el.querySelector('.section-square');
      }
    }, {
      key: 'setArea',
      value: function setArea(area) {
        this._area = area;
        this._renderArea();
      }
    }, {
      key: 'setSelectCallback',
      value: function setSelectCallback(callback) {
        this._selectCallback = callback;
      }
    }, {
      key: 'remove',
      value: function remove() {
        (0, _get3.default)(LocatorView.prototype.__proto__ || (0, _getPrototypeOf2.default)(LocatorView.prototype), 'remove', this).call(this);

        this.surface.removeListener('touchstart', this._onAreaTouchStart);
        this.surface.removeListener('touchmove', this._onAreaTouchMove);
      }
    }, {
      key: 'onResize',
      value: function onResize(viewportWidth, viewportHeight, orientation) {
        (0, _get3.default)(LocatorView.prototype.__proto__ || (0, _getPrototypeOf2.default)(LocatorView.prototype), 'onResize', this).call(this, viewportWidth, viewportHeight, orientation);

        if (this.selector) this.selector.onResize(viewportWidth, viewportHeight, orientation);
      }
    }, {
      key: '_renderArea',
      value: function _renderArea() {
        this.selector = new _client.SpaceView();
        this.selector.setArea(this._area);

        this.selector.render();
        this.selector.appendTo(this.$areaContainer);
        this.selector.onRender();

        this.surface = new _client.TouchSurface(this.selector.$svgContainer);
        this.surface.addListener('touchstart', this._onAreaTouchStart);
        this.surface.addListener('touchmove', this._onAreaTouchMove);
      }
    }, {
      key: '_onAreaTouchStart',
      value: function _onAreaTouchStart(id, normX, normY) {
        var _this9 = this;

        if (!this.position) {
          this._createPosition(normX, normY);

          this.model.showBtn = true;
          this.render('.section-float');
          this.installEvents({
            'click .btn': function clickBtn(e) {
              return _this9._selectCallback(_this9.position.x, _this9.position.y);
            }
          });
        } else {
          this._updatePosition(normX, normY);
        }
      }
    }, {
      key: '_onAreaTouchMove',
      value: function _onAreaTouchMove(id, normX, normY) {
        this._updatePosition(normX, normY);
      }
    }, {
      key: '_createPosition',
      value: function _createPosition(normX, normY) {
        this.position = {
          id: 'locator',
          x: normX * this._area.width,
          y: normY * this._area.height
        };

        this.selector.addPoint(this.position);
      }
    }, {
      key: '_updatePosition',
      value: function _updatePosition(normX, normY) {
        this.position.x = normX * this._area.width;
        this.position.y = normY * this._area.height;

        this.selector.updatePoint(this.position);
      }
    }]);
    return LocatorView;
  }(_client.SquaredView),

  // ------------------------------------------------
  // Placer
  // ------------------------------------------------
  'service:placer': function (_SquaredView2) {
    (0, _inherits3.default)(PlacerViewList, _SquaredView2);

    function PlacerViewList() {
      (0, _classCallCheck3.default)(this, PlacerViewList);

      var _this10 = (0, _possibleConstructorReturn3.default)(this, (PlacerViewList.__proto__ || (0, _getPrototypeOf2.default)(PlacerViewList)).call(this));

      _this10.template = '\n        <div class="section-square flex-middle">\n          <% if (rejected) { %>\n          <div class="fit-container flex-middle">\n            <p><%= reject %></p>\n          </div>\n          <% } %>\n        </div>\n        <div class="section-float flex-middle">\n          <% if (!rejected) { %>\n            <% if (showBtn) { %>\n              <button class="btn"><%= send %></button>\n            <% } %>\n          <% } %>\n        </div>\n      ';

      _this10.model = {
        instructions: 'Select your position',
        send: 'Send',
        reject: 'Sorry, no place is available',
        showBtn: false,
        rejected: false
      };

      _this10._onSelectionChange = _this10._onSelectionChange.bind(_this10);
      return _this10;
    }

    (0, _createClass3.default)(PlacerViewList, [{
      key: 'show',
      value: function show() {
        (0, _get3.default)(PlacerViewList.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlacerViewList.prototype), 'show', this).call(this);
        this.selector.show();
      }
    }, {
      key: '_onSelectionChange',
      value: function _onSelectionChange(e) {
        var _this11 = this;

        this.model.showBtn = true;
        this.render('.section-float');

        this.installEvents({
          'click .btn': function clickBtn(e) {
            var position = _this11.selector.value;

            if (position) _this11._onSelect(position.index, position.label, position.coordinates);
          }
        });
      }
    }, {
      key: 'setArea',
      value: function setArea(area) {/* no need for area */}
    }, {
      key: 'onRender',
      value: function onRender() {
        (0, _get3.default)(PlacerViewList.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlacerViewList.prototype), 'onRender', this).call(this);
        this.$selectorContainer = this.$el.querySelector('.section-square');
      }
    }, {
      key: 'onResize',
      value: function onResize(viewportWidth, viewportHeight, orientation) {
        (0, _get3.default)(PlacerViewList.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlacerViewList.prototype), 'onResize', this).call(this, viewportWidth, viewportHeight, orientation);

        if (this.selector) this.selector.onResize(viewportWidth, viewportHeight, orientation);
      }
    }, {
      key: 'displayPositions',
      value: function displayPositions(capacity) {
        var labels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var coordinates = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var maxClientsPerPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        this.positions = [];
        this.numberPositions = capacity / maxClientsPerPosition;

        for (var index = 0; index < this.numberPositions; index++) {
          var label = labels !== null ? labels[index] : (index + 1).toString();
          var position = { index: index, label: label };

          if (coordinates) position.coordinates = coordinates[index];

          this.positions.push(position);
        }

        this.selector = new _client.SelectView({
          instructions: this.model.instructions,
          entries: this.positions
        });

        this.selector.render();
        this.selector.appendTo(this.$selectorContainer);
        this.selector.onRender();

        this.selector.installEvents({
          'change': this._onSelectionChange
        });
      }
    }, {
      key: 'updateDisabledPositions',
      value: function updateDisabledPositions(indexes) {
        for (var index = 0; index < this.numberPositions; index++) {
          if (indexes.indexOf(index) === -1) this.selector.enableIndex(index);else this.selector.disableIndex(index);
        }
      }
    }, {
      key: 'setSelectCallack',
      value: function setSelectCallack(callback) {
        this._onSelect = callback;
      }
    }, {
      key: 'reject',
      value: function reject(disabledPositions) {
        this.model.rejected = true;
        this.render();
      }
    }]);
    return PlacerViewList;
  }(_client.SquaredView),

  // graphic placer flavor for predetermined coordinates
  // 'service:placer': class PlacerViewGraphic extends SquaredView {
  //   constructor() {
  //     super();

  //     this.template = `
  //       <div class="section-square flex-middle">
  //         <% if (rejected) { %>
  //         <div class="fit-container flex-middle">
  //           <p><%= reject %></p>
  //         </div>
  //         <% } %>
  //       </div>
  //       <div class="section-float flex-middle">
  //         <% if (!rejected) { %>
  //           <% if (showBtn) { %>
  //             <button class="btn"><%= send %></button>
  //           <% } %>
  //         <% } %>
  //       </div>
  //     `;

  //     this.model = {
  //       instructions: 'Select your position',
  //       send: 'Send',
  //       reject: 'Sorry, no place is available',
  //       showBtn: false,
  //       rejected: false,
  //     };

  //     this._area = null;
  //     this._disabledPositions = [];
  //     this._onSelectionChange = this._onSelectionChange.bind(this);
  //   }

  //   show() {
  //     super.show();
  //     this.selector.show();
  //   }

  //   onRender() {
  //     super.onRender();
  //     this.$selectorContainer = this.$el.querySelector('.section-square');
  //   }

  //   onResize(viewportWidth, viewportHeight, orientation) {
  //     super.onResize(viewportWidth, viewportHeight, orientation);

  //     if (this.selector)
  //       this.selector.onResize(viewportWidth, viewportHeight, orientation);
  //   }

  //   _onSelectionChange(e) {
  //     const position = this.selector.shapePointMap.get(e.target);
  //     const disabledIndex = this._disabledPositions.indexOf(position.index);

  //     if (disabledIndex === -1)
  //       this._onSelect(position.id, position.label, [position.x, position.y]);
  //   }

  //   setArea(area) {
  //     this._area = area;
  //   }

  //   displayPositions(capacity, labels = null, coordinates = null, maxClientsPerPosition = 1) {
  //     this.numberPositions = capacity / maxClientsPerPosition;
  //     this.positions = [];

  //     for (let i = 0; i < this.numberPositions; i++) {
  //       const label = labels !== null ? labels[i] : (i + 1).toString();
  //       const position = { id: i, label: label };
  //       const coords = coordinates[i];
  //       position.x = coords[0];
  //       position.y = coords[1];

  //       this.positions.push(position);
  //     }

  //     this.selector = new SpaceView();
  //     this.selector.setArea(this._area);
  //     this.selector.render();
  //     this.selector.appendTo(this.$selectorContainer);
  //     this.selector.onRender();
  //     this.selector.setPoints(this.positions);

  //     this.selector.installEvents({
  //       'click .point': this._onSelectionChange
  //     });
  //   }

  //   updateDisabledPositions(indexes) {
  //     this._disabledPositions = indexes;

  //     for (let index = 0; index < this.numberPositions; index++) {
  //       const position = this.positions[index];
  //       const isDisabled = indexes.indexOf(index) !== -1;
  //       position.selected = isDisabled ? true : false;
  //       this.selector.updatePoint(position);
  //     }
  //   }

  //   setSelectCallack(callback) {
  //     this._onSelect = callback;
  //   }

  //   reject(disabledPositions) {
  //     this.model.rejected = true;
  //     this.render();
  //   }
  // },

  // ------------------------------------------------
  // Platform
  // ------------------------------------------------
  'service:platform': function (_SegmentedView5) {
    (0, _inherits3.default)(PlatformView, _SegmentedView5);

    function PlatformView() {
      (0, _classCallCheck3.default)(this, PlatformView);

      var _this12 = (0, _possibleConstructorReturn3.default)(this, (PlatformView.__proto__ || (0, _getPrototypeOf2.default)(PlatformView)).call(this));

      _this12.template = '\n        <% if (isCompatible === false) { %>\n          <div class="section-top"></div>\n          <div class="section-center flex-center">\n            <p><%= errorCompatibleMessage %></p>\n          </div>\n          <div class="section-bottom"></div>\n        <% } else if (hasAuthorizations === false) { %>\n          <div class="section-top"></div>\n          <div class="section-center flex-center">\n            <p><%= errorHooksMessage %></p>\n          </div>\n          <div class="section-bottom"></div>\n        <% } else { %>\n          <div class="section-top flex-middle"></div>\n          <div class="section-center flex-center">\n              <p class="big">\n                <%= intro %>\n                <br />\n                <b><%= globals.appName %></b>\n              </p>\n          </div>\n          <div class="section-bottom flex-middle">\n            <% if (checking === true) { %>\n            <p class="small soft-blink"><%= checkingMessage %></p>\n            <% } else if (hasAuthorizations === true) { %>\n            <p class="small soft-blink"><%= instructions %></p>\n            <% } %>\n          </div>\n        <% } %>\n      ';

      _this12.model = {
        isCompatible: null,
        hasAuthorizations: null,
        checking: false,
        intro: 'Welcome to',
        instructions: 'Touch the screen to join!',
        checkingMessage: 'Please wait while checking compatiblity',
        errorCompatibleMessage: 'Sorry,<br />Your device is not compatible with the application.',
        errorHooksMessage: 'Sorry,<br />The application didn\'t obtain the necessary authorizations.'
      };

      _this12._touchstartCallback = noop;
      _this12._mousedownCallback = noop;
      return _this12;
    }

    (0, _createClass3.default)(PlatformView, [{
      key: 'onRender',
      value: function onRender() {
        var _this13 = this;

        (0, _get3.default)(PlatformView.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlatformView.prototype), 'onRender', this).call(this);

        this.installEvents({
          'mousedown': function mousedown(e) {
            return _this13._mousedownCallback(e);
          },
          'touchstart': function touchstart(e) {
            return _this13._touchstartCallback(e);
          }
        });
      }
    }, {
      key: 'setTouchStartCallback',
      value: function setTouchStartCallback(callback) {
        this._touchstartCallback = callback;
      }
    }, {
      key: 'setMouseDownCallback',
      value: function setMouseDownCallback(callback) {
        this._mousedownCallback = callback;
      }
    }, {
      key: 'updateCheckingStatus',
      value: function updateCheckingStatus(value) {
        this.model.checking = value;
        this.render();
      }
    }, {
      key: 'updateIsCompatibleStatus',
      value: function updateIsCompatibleStatus(value) {
        this.model.isCompatible = value;
        this.render();
      }
    }, {
      key: 'updateHasAuthorizationsStatus',
      value: function updateHasAuthorizationsStatus(value) {
        this.model.hasAuthorizations = value;
        this.render();
      }
    }]);
    return PlatformView;
  }(_client.SegmentedView),

  // ------------------------------------------------
  // Raw-Socket
  // ------------------------------------------------
  'service:raw-socket': function (_SegmentedView6) {
    (0, _inherits3.default)(RawSocketView, _SegmentedView6);

    function RawSocketView() {
      (0, _classCallCheck3.default)(this, RawSocketView);

      var _this14 = (0, _possibleConstructorReturn3.default)(this, (RawSocketView.__proto__ || (0, _getPrototypeOf2.default)(RawSocketView)).call(this));

      _this14.template = '\n        <div class="section-top"></div>\n        <div class="section-center flex-center">\n          <p class="soft-blink"><%= wait %></p>\n        </div>\n        <div class="section-bottom"></div>\n      ';

      _this14.model = {
        wait: 'Opening socket,<br />stand by&hellip;'
      };
      return _this14;
    }

    return RawSocketView;
  }(_client.SegmentedView),

  // ------------------------------------------------
  // Sync
  // ------------------------------------------------
  'service:sync': function (_SegmentedView7) {
    (0, _inherits3.default)(RawSocketView, _SegmentedView7);

    function RawSocketView() {
      (0, _classCallCheck3.default)(this, RawSocketView);

      var _this15 = (0, _possibleConstructorReturn3.default)(this, (RawSocketView.__proto__ || (0, _getPrototypeOf2.default)(RawSocketView)).call(this));

      _this15.template = '\n        <div class="section-top"></div>\n        <div class="section-center flex-center">\n          <p class="soft-blink"><%= wait %></p>\n        </div>\n        <div class="section-bottom"></div>\n      ';

      _this15.model = {
        wait: 'Clock syncing,<br />stand by&hellip;'
      };
      return _this15;
    }

    return RawSocketView;
  }(_client.SegmentedView),

  // public API
  has: function has(id) {
    return !!this[id];
  },
  get: function get(id, config) {
    var ctor = this[id];
    var view = new ctor();
    // additionnal configuration
    view.model.globals = (0, _assign2.default)({}, config);
    view.options.id = id.replace(/\:/g, '-');

    return view;
  }
};

exports.default = serviceViews;

},{"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/defineProperty":34,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"soundworks/client":270}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  'off': {},

  /******************************************************************
   *
   *  CO-909
   *
   */
  'co-909': {
    numSteps: 16,
    instruments: [{
      name: 'bass drum',
      layers: [{
        buffer: 'sounds/co-909/909-BD-low.wav',
        gain: 5
      }, {
        buffer: 'sounds/co-909/909-BD-high.wav',
        gain: 0
      }]
    }, {
      name: 'snare drum',
      layers: [{
        buffer: 'sounds/co-909/909-SD-low.wav',
        gain: 0
      }, {
        buffer: 'sounds/co-909/909-SD-high.wav',
        gain: 0
      }]
    }, {
      name: 'hi hat',
      layers: [{
        buffer: 'sounds/co-909/909-HH-closed.wav',
        gain: 0
      }, {
        buffer: 'sounds/co-909/909-HH-open.wav',
        gain: 0
      }]
    }, {
      name: 'mid tom',
      layers: [{
        buffer: 'sounds/co-909/909-MT-low.wav',
        gain: 0
      }, {
        buffer: 'sounds/co-909/909-MT-high.wav',
        gain: 0
      }]
    }, {
      name: 'rim shot / hand clap',
      layers: [{
        buffer: 'sounds/co-909/909-PC-rimshot.wav',
        gain: 3
      }, {
        buffer: 'sounds/co-909/909-PC-clap.wav',
        gain: -4
      }]
    }, {
      name: 'high tom',
      layers: [{
        buffer: 'sounds/co-909/909-HT-low.wav',
        gain: 0
      }, {
        buffer: 'sounds/co-909/909-HT-high.wav',
        gain: 0
      }]
    }, {
      name: 'low tom',
      layers: [{
        buffer: 'sounds/co-909/909-LT-low.wav',
        gain: 0
      }, {
        buffer: 'sounds/co-909/909-LT-high.wav',
        gain: 0
      }]
    }, {
      name: 'cymbal',
      layers: [{
        buffer: 'sounds/co-909/909-CY-ride.wav',
        gain: 0
      }, {
        buffer: 'sounds/co-909/909-CY-crash.wav',
        gain: 0
      }]
    }]
  },

  /******************************************************************
   *
   *  Collective Loops
   *
   */
  'collective-loops': {
    numSteps: 8,
    notes: [{
      class: 'perc',
      buffer: 'sounds/collective-loops/perc-01.mp3',
      gain: -5
    }, {
      class: 'perc',
      buffer: 'sounds/collective-loops/perc-02.mp3',
      gain: -5
    }, {
      class: 'perc',
      buffer: 'sounds/collective-loops/perc-03.mp3',
      gain: -5
    }, {
      class: 'bass',
      buffer: 'sounds/collective-loops/bass-01.mp3',
      gain: 0
    }, {
      class: 'bass',
      buffer: 'sounds/collective-loops/bass-02.mp3',
      gain: 0
    }, {
      class: 'bass',
      buffer: 'sounds/collective-loops/bass-03.mp3',
      gain: -2
    }, {
      class: 'bass',
      buffer: 'sounds/collective-loops/bass-04.mp3',
      gain: -2
    }, {
      class: 'bass',
      buffer: 'sounds/collective-loops/bass-05.mp3',
      gain: -2
    }, {
      class: 'bass',
      buffer: 'sounds/collective-loops/bass-06.mp3',
      gain: -2
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-01.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-02.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-03.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-04.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-05.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-06.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-07.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-08.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-09.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-10.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-11.mp3',
      gain: -10
    }, {
      class: 'melody',
      buffer: 'sounds/collective-loops/marimba-12.mp3',
      gain: -10
    }]
  },

  /******************************************************************
   *
   *  Co-Mix
   *
   */
  'co-mix': {
    tempo: 122,
    tempoUnit: 1 / 4,
    tracks: [{
      name: 'shaker',
      layers: [{
        buffer: 'sounds/co-mix/guitperc_shakers_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 5,
        intensity: [-86.2238, -87.2964, -86.6231, -50.0227, -23.2275, -33.6563, -40.0632, -43.9436, -47.3482, -49.0431, -50.3298, -50.5785, -51.4341, -51.1312, -51.8434, -52.1517, -56.4795, -55.5522, -56.1323, -53.3651, -37.5976, -48.2543, -53.5457, -57.4785, -58.8241, -59.6460, -60.9979, -61.9955, -61.8797, -66.0868, -65.1289, -61.9954, -63.4401, -64.9324, -67.2832, -42.4458, -25.0882, -34.1612, -42.3827, -45.1786, -49.9462, -34.4362, -34.1592, -46.1838, -50.3337, -50.8272, -40.8872, -41.4080, -51.5691, -54.6439, -55.1437, -55.2293, -39.5364, -45.7542, -55.9990, -59.9176, -50.7076, -29.3177, -39.6631, -45.0248, -51.0381, -53.3976, -44.5741, -40.3501, -51.6904, -57.2505, -59.4560, -49.8847, -45.2397, -55.9307, -61.4636, -63.3942, -62.6039, -39.3958, -43.4064, -56.8639, -60.9049, -59.5997, -21.4049, -29.9538, -38.9817, -41.9041, -45.3900, -44.8024, -38.5337, -45.2699, -48.4920, -50.4580, -49.5885, -42.7882, -51.6827, -54.1580, -53.5547, -55.4567, -40.8436, -41.7515, -54.2414, -56.9389, -57.2206, -31.2919, -32.9113, -44.5312, -49.1064, -52.5984, -52.5539, -39.1615, -46.5205, -57.0270, -58.1169, -58.1791, -43.4612, -52.7410, -59.0380, -62.6190, -64.1331, -43.8698, -40.6983, -53.1256, -59.6478, -61.3933, -34.7897, -27.6958, -38.0187, -45.0180, -46.9496, -49.7330, -38.6116, -43.2930, -50.7147, -52.7741, -53.5330, -43.6258, -49.6113, -55.6910, -55.9453, -58.0148, -43.4510, -44.1040, -54.6593, -58.4940, -60.6939, -59.0044, -45.3466, -51.5988, -60.0717, -62.9296, -63.5690, -41.3956, -46.7646, -57.2677, -60.8152, -63.1028, -58.6314, -61.3379, -65.7114, -67.2598, -68.8863, -64.1028, -49.9863, -57.6492, -68.0576, -70.4992, -39.4147, -23.9870, -35.2112, -41.1856, -44.5803, -47.9125, -40.3444, -38.6761, -48.1753, -51.5298, -50.5300, -34.1354, -32.4095, -44.2636, -48.6271, -51.8466, -52.9184, -53.8784, -56.3661, -58.0101, -59.1399, -60.7830, -60.7844, -62.2625, -61.7865, -63.0219, -65.7033, -64.5377, -62.6891, -63.8071, -64.8768, -67.4312, -66.1961, -68.4777, -67.1396, -68.6664, -68.7066, -70.4525, -72.8558, -69.0867, -70.8717, -73.4244, -72.5243, -32.0706, -31.0550, -40.4775, -46.3891, -48.8090, -52.1410, -50.2408, -53.4419, -52.0918, -54.9813, -55.2416, -55.2319, -57.1566, -56.9944, -56.9864, -60.0515, -34.9511, -34.0989, -46.5422, -52.0558, -54.4199, -54.1553, -58.9808, -60.7401, -60.5066, -61.2997, -31.1834, -24.7415, -35.8956, -41.4736, -43.5521, -45.6148, -29.0571, -36.4486, -44.2226, -47.0522, -49.7626, -48.9415, -50.5712, -53.9706, -53.1675, -55.1120, -55.7566, -54.7661, -55.3820, -60.0679, -59.7240, -56.6246, -32.4871, -35.7075, -49.2530, -52.4983, -53.5862, -38.2991, -46.2813, -52.5299, -55.9026, -60.4093, -61.4698, -63.1290, -62.5869, -63.9491, -65.3991, -50.3706, -27.2472, -35.9905, -43.9966, -46.9504, -51.1841, -34.0480, -34.2545, -46.4160, -50.1045, -50.6692, -52.3547, -52.8940, -56.5524, -56.4737, -56.5692, -58.1698, -59.6027, -57.6406, -60.1555, -62.3640, -41.0799, -21.6809, -32.8564, -39.8381, -42.5262, -45.2428, -46.1996, -47.5064, -47.9590, -48.9029, -51.2215, -43.4266, -39.4199, -50.1750, -52.6382, -53.2653, -54.6237, -39.8526, -43.8058, -55.9756, -57.0407, -57.0840, -29.4054, -37.7529, -44.1250, -49.8361, -53.7855, -48.0687, -39.4468, -49.1473, -55.6301, -58.6129, -47.5131, -27.1363, -36.3828, -44.2582, -47.0521, -51.4688, -40.2181, -41.4923, -50.5530, -52.1228, -53.1750, -32.9788, -35.3529, -47.2268, -50.4385, -52.6059, -52.2612, -38.8539, -46.0995, -55.2216, -58.4798, -41.4676, -24.1453, -34.9764, -40.7903, -44.3337, -47.4936, -48.9538, -50.3837, -50.7440, -51.7446, -51.1038, -33.8670, -31.2189, -43.1436, -47.7964, -51.0903, -51.9965, -53.3448, -55.7608, -56.9105, -58.4745, -60.3125, -60.4931, -61.5140, -61.5345, -62.7035, -65.1809, -40.6635, -32.5463, -42.6013, -51.9391, -53.8019, -45.8597, -27.3429, -36.9597, -44.1896, -46.8695, -50.9014, -50.4147, -52.3953, -52.1105, -52.7163, -54.2706, -30.5022, -33.7233, -44.8401, -49.0034, -52.0331, -40.3893, -35.7913, -48.2225, -51.7017, -55.2802, -55.9394, -34.0818, -38.0029, -50.9678, -55.2935, -56.9153, -36.9080, -45.6980, -52.1549, -56.5087, -60.3526, -29.4558, -29.8518, -40.0823, -44.8424, -48.9917, -46.0404, -36.5068, -46.9114, -50.6750, -52.4659, -47.7725, -22.6312, -32.4762, -40.3491, -42.0177, -45.7280, -40.0471, -44.2170, -46.6813, -48.2823, -50.8484],
        gain: 1
      }, {
        buffer: 'sounds/co-mix/guitperc_shakers_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-26.7686, -40.7180, -48.0289, -54.6909, -30.3665, -19.3695, -35.6002, -43.7537, -43.3233, -47.0108, -27.3686, -31.6296, -41.9944, -45.5334, -52.2155, -29.6135, -32.7086, -46.1698, -50.8722, -55.3990, -37.4588, -25.7993, -39.2561, -47.0533, -54.2618, -32.6488, -17.6939, -33.4920, -42.4215, -42.0950, -48.0394, -29.3269, -28.6661, -40.6672, -42.8450, -50.7224, -33.0287, -29.3234, -44.6265, -51.3156, -53.0503, -43.1599, -25.9769, -36.4737, -45.8260, -53.4457, -40.6208, -19.2405, -30.7799, -41.0571, -42.4975, -49.4282, -32.1612, -26.8171, -40.2373, -42.5307, -51.7244, -37.7599, -27.2880, -43.3552, -51.0765, -51.1509, -49.1089, -26.9600, -32.6505, -44.1705, -51.7865, -44.3258, -19.2542, -25.9437, -39.2110, -42.8037, -47.8307, -35.9319, -25.8675, -39.1168, -41.5105, -46.8066, -42.5569, -26.4152, -41.7176, -49.7034, -50.0362, -53.4592, -28.7348, -29.4171, -42.4886, -49.9119, -51.8423, -23.7234, -22.6973, -37.8478, -44.0632, -46.3804, -40.8407, -25.8417, -37.2813, -42.3355, -48.8329, -47.0761, -26.7570, -39.2545, -48.5073, -49.8681, -55.8691, -31.3185, -27.2483, -41.1320, -48.4996, -54.1500, -25.2544, -19.4781, -36.1079, -43.9889, -43.8426, -44.8972, -26.5656, -33.4976, -41.3626, -44.7527, -49.8747, -28.2173, -35.0036, -46.9652, -50.3935, -56.2246, -34.9306, -26.0610, -40.0424, -47.5436, -54.4766, -32.6355, -18.9519, -34.8936, -43.2876, -42.8370, -47.9391, -28.1609, -30.1826, -41.6401, -44.5907, -52.9371, -31.0215, -31.0418, -45.5114, -51.2046, -54.3902, -39.8659, -25.7761, -38.2488, -46.5641, -53.9959, -35.0597, -17.6696, -32.3270, -41.7596, -41.9827, -48.3566, -30.4489, -27.6628, -40.1336, -42.2056, -49.7549, -34.9645, -28.2513, -44.1425, -51.2593, -52.1240, -45.9387, -26.3235, -34.7565, -45.1159, -52.7750, -43.0230, -19.8330, -28.8401, -40.3131, -42.7471, -49.2754, -33.7432, -26.2871, -39.8736, -42.3085, -51.0249, -40.0344, -26.7614, -42.6989, -50.6066, -50.5453, -51.3045, -27.6585, -31.0743, -43.3907, -50.9006, -47.5045, -20.2097, -24.0890, -38.4696, -43.2417, -47.0362, -37.9162, -25.7141, -38.3003, -41.3256, -46.3517, -44.4208, -26.4202, -40.8643, -49.1915, -49.8725, -54.8048, -29.7921, -28.3092, -41.8346, -49.1997, -53.4562, -25.1987, -21.3723, -37.1724, -44.2367, -45.3139, -43.0493, -26.0877, -35.7290, -42.3150, -47.7366, -48.7321, -27.2816, -37.4651, -47.7963, -50.0420, -56.3542, -32.7931, -26.5995, -40.6419, -48.0251, -54.4135, -27.2332, -18.6709, -35.3843, -43.7275, -43.1041, -46.3176, -27.2009, -31.9069, -41.3792, -44.2290, -50.9465, -29.3396, -33.0877, -46.0734, -50.7324, -55.5919, -36.9758, -25.8271, -39.4215, -47.1511, -54.3166, -34.6881, -18.6740, -34.0626, -42.6950, -42.4917, -48.5830, -29.1140, -28.9445, -41.1934, -43.7279, -52.8515, -32.6957, -29.6333, -44.8739, -51.4110, -53.3386, -42.5255, -25.9211, -36.8427, -45.9756, -53.5823, -37.5664, -17.8684, -30.7099, -41.0198, -42.0493, -48.5492, -31.8251, -26.9238, -39.9836, -41.9671, -48.7177, -37.2007, -27.4345, -43.4311, -50.8213, -51.2821, -48.5771, -26.8286, -33.0153, -44.3416, -51.9655, -45.4254, -20.5273, -26.8123, -39.5559, -43.0766, -48.6955, -35.5517, -25.9430, -39.4458, -42.1653, -50.0470, -42.2476, -26.4749, -41.9783, -50.0168, -50.1330, -53.0922, -28.5161, -29.7012, -42.6529, -50.0902, -50.5142, -21.4196, -22.4255, -37.7203, -43.6802, -46.0792, -40.2339, -25.7890, -37.4170, -41.5374],
        gain: 1
      }]
    }, {
      name: 'bass',
      layers: [{
        buffer: 'sounds/co-mix/percs_bass_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 16,
        intensity: [-86.3055, -86.1327, -86.5097, -86.8673, -39.8717, -41.1279, -58.5508, -61.4910, -63.5728, -65.2200, -66.6549, -68.2730, -69.6344, -70.7225, -71.4813, -72.0349, -73.1585, -73.9444, -74.9801, -56.1197, -34.6543, -42.8681, -49.8883, -54.5037, -56.2186, -58.0532, -58.0438, -58.1446, -60.2989, -59.5993, -60.0576, -29.3929, -25.5895, -37.3841, -37.0632, -36.9804, -40.9177, -43.5301, -44.4451, -48.1340, -48.3078, -49.8806, -54.8364, -56.3357, -56.8706, -59.1627, -48.7989, -42.2354, -48.7954, -52.0499, -54.8884, -30.8823, -13.4219, -17.2948, -25.6311, -30.2662, -32.9971, -35.9327, -36.4959, -38.9820, -38.5261, -39.6187, -40.1770, -41.2096, -42.8325, -43.2143, -43.1150, -44.7548, -43.9133, -43.7466, -46.5858, -45.9947, -44.7993, -45.2389, -45.7966, -45.3040, -44.3464, -42.4154, -41.2494, -42.9914, -44.6485, -47.6332, -50.1923, -51.4374, -51.1532, -52.2998, -54.5450, -55.1254, -56.9204, -56.8770, -56.7765, -57.8986, -59.2956, -58.7179, -57.5262, -57.5468, -59.2081, -62.5600, -62.7513, -63.6326, -64.8954, -63.9724, -62.4707, -65.4870, -42.3177, -38.0896, -50.3224, -55.3330, -57.0770, -57.5325, -60.2261, -59.8039, -61.8052, -61.2760, -61.4371, -61.7089, -63.9499, -64.3414, -63.7070, -64.8103, -30.9798, -33.5983, -44.5284, -50.5441, -50.4200, -49.4057, -49.4839, -52.3163, -52.4215, -54.5206, -58.5414, -59.0939, -58.3554, -59.9615, -56.0407, -55.5191, -21.2698, -13.4522, -18.3458, -21.2716, -26.3757, -29.1201, -30.1735, -34.3374, -37.2976, -36.3476, -37.6582, -25.8067, -25.0247, -28.0933, -30.9125, -32.4987, -35.6157, -36.3348, -36.6702, -36.1177, -38.3933, -39.2299, -38.5981, -40.3430, -40.0449, -40.5338, -41.1239, -40.7258, -41.8493, -42.5198, -44.6926, -46.1406, -47.8680, -48.6844, -48.3388, -49.1653, -46.3952, -45.3613, -37.0843, -47.7153, -52.1319, -56.1427, -56.4086, -56.7583, -55.7297, -58.8648, -61.0384, -59.9465, -62.8563, -63.3327, -62.8673, -62.9646, -64.6365, -36.9033, -34.2102, -46.6951, -51.9684, -54.8546, -56.2718, -57.5163, -56.6554, -57.5644, -57.9916, -58.9748, -52.8240, -23.4606, -32.8447, -37.2567, -37.3468, -37.7905, -41.5570, -44.1408, -45.8669, -48.1917, -50.6181, -51.9749, -55.5205, -56.6402, -57.2591, -57.9868, -41.2832, -46.3170, -50.1116, -53.5823, -55.8720, -16.7116, -15.4214, -21.9497, -30.8881, -32.2064, -32.5688, -37.0290, -38.6796, -37.8654, -38.7887, -40.5967, -38.2725, -43.6800, -45.2626, -41.7202, -41.7163, -41.1805, -40.7762, -39.1332, -40.7055, -42.2191, -43.0429, -43.6396, -45.6101, -45.8410, -45.3006, -48.0820, -47.2789, -48.6120, -49.3048, -50.0345, -51.5050, -50.6895, -51.4784, -49.7110, -48.9799, -52.7072, -54.6416, -57.2615, -57.7304, -56.6560, -56.7783, -57.6573, -55.2317, -59.6517, -62.7568, -64.0384, -65.3089, -65.4704, -63.2880, -62.9676, -63.3134, -63.3880, -34.1100, -34.8898, -46.5193, -51.4285, -52.5654, -53.3964, -55.2735, -55.4324, -56.8027, -57.0671, -57.5935, -58.8900, -60.5713, -60.7200, -60.3408, -42.3322, -28.8163, -41.0452, -48.9798, -52.5226, -50.7143, -51.7237, -52.3585, -51.3281, -51.6616, -51.8222, -56.8264, -55.6445, -58.9142, -58.5098, -58.3922, -41.1544, -13.7295, -10.4613, -18.2073, -23.7901, -26.8757, -27.2156, -30.9134, -36.6173, -34.7583, -35.1036, -28.3486, -25.2913, -25.9314, -30.5339, -31.3475, -32.0211, -33.2957, -32.3021, -30.8965, -30.8063, -33.0911, -36.3797, -38.5857, -39.6164, -39.4119, -38.7971, -38.2432, -39.8386, -41.2960, -43.7441, -44.5814, -46.2041, -45.4688, -44.9712, -43.7802, -42.6728, -41.7026, -37.2512, -44.9884, -50.1796, -50.9378, -49.7431, -49.8761, -48.8494, -51.1637, -55.1065, -58.8642, -59.9679, -61.9068, -58.9910, -57.1658, -56.6988, -48.2702, -34.7892, -45.0269, -50.0835, -54.0448, -55.8834, -55.1161, -54.9382, -56.1533, -57.8465, -58.6980, -52.8154, -23.4614, -32.8441, -37.2228, -37.3228, -37.7905, -41.5413, -44.1744, -45.8947, -48.1868, -50.5912, -51.9642, -55.6055, -56.5540, -56.9888, -58.0867, -41.3011, -46.2796, -50.2334, -53.6250, -55.9276, -25.7085, -13.0455, -18.4735, -26.1814, -30.2930, -33.1931, -35.2695, -36.4341, -39.5418, -38.6538, -39.4573, -40.2860, -41.2012, -43.5866, -42.8751, -43.2695, -44.7948, -43.7750, -43.8356, -46.9509, -45.6327, -45.1472, -47.0377, -44.9307, -43.9621, -44.7082, -43.2643, -41.8655, -43.5265, -45.6200, -47.0175, -50.9450, -52.3010, -52.6696, -53.7940, -53.4697, -54.9656, -58.0783, -57.5970, -56.3611, -57.5575, -58.9696, -58.9664, -58.8657, -56.4034, -60.4527, -62.9003, -63.1454, -63.4145, -64.8271, -63.2252, -63.0614, -66.4191, -39.5118, -39.8629, -50.7019, -55.3710, -57.6574, -57.7191, -59.8000, -58.9995, -61.4070, -61.0522, -61.8623, -62.5038, -63.4532, -64.8449, -64.3867, -64.0360, -29.0690, -34.9551, -44.8876, -49.6623, -49.8165, -51.5705, -52.9871, -54.1910, -54.5889, -54.1713, -58.1728, -54.5361, -54.0928, -55.6205, -55.7502, -58.3490, -19.0781, -13.4731, -19.1482, -21.6093, -27.2234, -29.6138, -30.3995, -34.9704, -37.6565, -36.3489, -36.6703, -25.4518, -25.3369, -28.8906, -30.9197, -32.6741, -35.8779, -35.9860, -37.2117, -36.0335, -38.5616, -39.5196, -38.9150, -39.4492, -39.7401, -40.6467, -39.8997, -40.6722, -41.7777, -42.5818, -44.2209, -47.0804, -48.3571, -49.7514, -48.3534, -48.8273, -46.0782, -38.8617, -39.3195, -49.5029, -52.8384, -56.7238, -56.3069, -57.0270, -55.5617, -59.3806, -61.7031, -60.2194, -63.0221, -63.8127, -61.9196, -62.5735, -64.7371, -35.7345, -34.6684, -47.4207, -52.5160, -55.2392, -56.3436, -57.5218, -56.6870, -57.6933, -58.1056, -58.7453, -29.3805, -25.5780, -37.3599, -37.0625, -36.9802, -40.9095, -43.4958, -44.3912, -48.0464, -48.2806, -49.8709, -54.7201, -56.0326, -56.7832, -59.0218, -48.7801, -42.2175, -48.8539, -52.1161, -54.8306, -56.7541, -15.7243, -15.7878, -22.8802, -31.4787, -32.4002, -32.8649, -37.8164, -38.7411, -37.7421, -38.9051, -40.6515, -38.5227, -44.1260, -45.3794, -41.6692, -41.6109, -41.1571, -40.5754, -39.0520, -40.6010, -42.3375, -43.6279, -42.9009, -44.7865, -44.7898, -45.3581, -46.2563, -46.8536, -46.7722, -48.7046, -50.7447, -52.5898, -51.8573, -51.5988, -49.9273, -49.3098, -52.8382, -55.2557, -57.8953, -58.0217, -57.1303, -56.8366, -57.5630, -55.5303, -59.1951, -63.1544, -63.6961, -65.7342, -65.7314, -63.1155, -62.4953, -63.2024, -59.7327, -33.2648, -37.0430, -46.6141, -51.7878, -53.1320, -53.5456, -55.4291, -55.6118, -57.1611, -57.3052, -57.5461, -58.9970, -60.6036, -61.0177, -60.2529, -38.3213, -30.0511, -41.9838, -48.8883, -51.4868, -49.0062, -49.5278, -50.9994, -51.1119, -54.2600, -55.1762, -59.9251, -58.3417, -59.1768, -56.6220, -55.3825, -34.3093, -12.8762, -10.8080, -18.8242, -23.6699, -27.1276, -26.9508, -31.8098, -36.5671, -34.3348, -35.3471, -28.0127, -25.1513, -26.6153, -30.0479, -31.2144, -32.0543, -32.5916, -31.7633, -30.8856, -31.0264, -33.4530, -36.8607, -38.4226, -39.6031, -39.0902, -39.2577, -38.3200, -39.8672, -41.6009, -44.4209, -44.8983, -46.5912, -45.2990, -44.7414, -43.4730, -42.5362, -41.8265, -37.0850, -44.6348, -50.3991, -50.7399, -49.6119, -49.6909, -48.9242, -51.4957, -55.6202, -58.6535, -60.5012, -61.7269, -59.0881, -56.9953, -56.5625, -53.0744, -34.5284, -42.7612, -49.7322, -54.2122, -54.5570, -55.5133, -55.2509, -55.8134, -57.0701, -58.4324, -52.8629, -23.4577, -32.8539, -37.2380, -37.3275, -37.7839, -41.5617, -44.1742, -45.9075, -48.1950, -50.5809, -51.9352, -55.4837, -56.5049, -57.0212, -58.0530, -41.3050, -46.3336, -50.1939, -53.6889, -56.0007, -30.8891, -13.4206, -17.2422, -25.5059, -30.1450, -32.8856, -35.5168, -36.3565, -39.0246, -38.6932, -39.5120, -40.1483, -41.2500, -43.0274, -43.0261, -42.9404, -44.7278, -43.8663, -43.7360, -46.4012, -45.9624, -44.7811, -45.1246, -45.7506, -45.2727, -44.2616, -42.2810, -41.1544, -43.0457, -44.6391, -47.5593, -50.3159, -51.6831, -51.1782, -52.2406, -54.3804, -55.2449, -56.9439, -56.8583, -56.7027, -57.7033, -59.3274, -58.7837, -57.5012, -57.4918, -59.2944, -62.4090, -62.6743, -63.4813, -64.8952, -64.0738, -62.6162, -65.4142, -42.3160, -38.0895, -50.3486, -55.3402, -57.0539, -57.5453, -60.2142, -59.7849, -61.7339, -61.2223, -61.3900, -61.7583, -63.9343, -64.3162, -63.6575, -64.0335, -28.4276, -36.7790, -46.3855, -52.3863, -50.6413, -51.9551, -51.6276, -53.1301, -51.5338, -50.8105, -56.1944, -55.0385, -57.0722, -59.7475, -58.4309, -59.9283, -21.2735, -13.4383, -18.2499, -21.2189, -26.3159, -28.9140, -30.2585, -34.2153, -37.2729, -36.1723, -34.1478, -25.2806, -25.4800, -29.4343, -31.1378, -32.3877, -36.0957, -35.8680, -37.1607, -36.0314, -38.5692, -39.7589, -39.0086, -39.9280, -39.9961, -40.6450, -40.3388, -41.2142, -41.5647, -43.0380, -44.1823, -46.8169, -47.8127, -48.6876, -48.5286, -48.9827, -45.8322, -39.1243, -39.9303, -48.7484, -54.0649, -56.0652, -56.3616, -56.5852, -55.6823, -58.8292, -61.1452, -59.9405, -62.6468, -63.5309, -62.7960, -63.0445, -64.5123, -36.9060, -34.2078, -46.7334, -51.9077, -54.8373, -56.2652, -57.4323, -56.6413, -57.6664, -57.8774, -59.0031, -29.3867, -25.5831, -37.2850, -37.0893, -36.9669, -40.9017, -43.4998, -44.3868, -48.0322, -48.2561, -49.8640, -54.7104, -56.0000, -56.7677, -59.0021, -48.7692, -42.2224, -48.7719, -52.0829, -54.8048, -57.4108, -16.6999, -15.4219, -21.9611, -30.9290, -32.3596, -32.6367, -37.1466, -38.6810, -37.8511, -38.8254, -40.6520, -38.2627, -43.8163, -45.2593, -41.8067, -41.6990, -41.1418, -40.7251, -39.0389, -40.5693, -42.1164, -43.0260, -43.6926, -45.5645, -45.9447, -45.3455, -47.9779, -47.2555, -49.1188, -48.9610, -49.7198, -50.7806, -50.5673, -51.4463, -49.3757, -49.2594, -52.3865, -54.2515, -56.8152, -57.7882, -56.6048, -56.8327, -57.6183, -55.2004, -59.5106, -62.5322, -63.4787, -64.6580, -64.9818, -63.0774, -62.9036, -63.2167, -63.0534, -34.1121, -34.8913, -46.4966, -51.5573, -52.7301, -53.5342, -55.3123, -55.4748, -56.8636, -57.1248, -57.6181, -58.8365, -60.4514, -60.6143, -60.2636, -34.2127, -30.7114, -42.3820, -48.2338, -49.8505, -50.5373, -51.4541, -54.7089, -52.8508, -55.3601, -56.6193, -56.0504, -53.9159, -55.7653, -55.1369, -56.7464, -41.1208, -13.7166, -10.4114, -18.1890, -23.7460, -26.8111, -27.1519, -30.8716, -36.5595, -34.5922, -35.1030, -26.4318, -25.1910, -27.0185, -30.6648, -31.6397, -32.3895, -33.4691, -32.3160, -30.7789, -31.0455, -32.9448, -36.3068, -38.7545, -39.8207, -39.4688, -38.8302, -38.4599, -40.0112, -41.6244, -44.0114, -45.2418, -46.3723, -45.6770, -44.6604, -43.7292, -42.4037, -41.6915, -37.6494, -44.4523, -49.8507, -51.6007, -49.7152, -49.9025, -48.9231, -51.0914, -55.1052, -58.9320, -60.1060, -61.8003, -58.9459, -57.1766, -56.6286, -48.2532, -34.7771, -45.0455, -50.0532, -54.0208, -55.8152, -55.0760, -55.0850, -56.0530, -57.7627, -58.5847, -52.8009, -23.4608, -32.8453, -37.2229, -37.3233, -37.7905, -41.5400, -44.1730, -45.8941, -48.1872, -50.5904, -51.9649, -55.5963, -56.5484, -56.9742, -58.0793, -41.3009, -46.2783, -50.2301, -53.6213, -55.9305, -25.7008, -13.0663, -18.6339, -26.5084, -30.6382, -33.4920, -36.0038, -36.6007, -39.3380, -38.3616, -39.8910, -40.2180, -41.2305, -43.1730, -42.8765, -43.3878, -44.6626, -43.7545, -43.8130, -47.0991, -45.5748, -45.0732, -47.0563, -44.9273, -44.0465, -44.7438, -43.0634, -41.6550, -43.6401, -45.2850, -47.0206, -51.2544, -52.1631, -51.7244, -53.1570, -53.6430, -55.1649, -57.8382, -57.4357, -56.4807, -57.5874, -58.9828, -59.1512, -58.8194, -56.4676, -60.4572, -62.8445, -63.2022, -63.8502, -64.8717, -63.3494, -63.0289, -66.7627, -39.5125, -39.8608, -50.6830, -55.3732, -57.6324, -57.8171, -59.8410, -59.1126, -61.3690, -61.0887, -61.8827, -62.5790, -63.3941, -65.0123, -64.4044, -56.4250, -28.6530, -38.0238, -46.6953, -51.6424, -49.4585, -50.1038, -50.2495, -51.7755, -53.4102, -53.5926, -59.7170, -58.0861, -58.6068, -58.6968, -56.1093, -56.0755, -19.0790, -13.4676, -19.0347, -21.5253, -27.1608, -29.4674, -30.4021, -34.9058, -37.5989, -36.2396, -32.4896, -25.1986, -25.7643, -29.8582, -31.2802, -32.4784, -36.3620, -35.4561, -37.7056, -36.5597, -38.7665, -40.0015, -39.4536, -39.1850, -39.6889, -40.9423, -39.2562, -41.0327, -41.4597, -43.0535, -44.0247, -47.6424, -48.3379, -49.5316, -48.7540, -48.5678, -45.8190, -39.3534, -40.8909, -49.2863, -53.9329, -56.7126, -56.0771, -56.8275, -55.3853, -59.2936, -61.5963, -60.1345, -62.7550, -63.6524, -61.8896, -62.5084, -64.5425, -35.7344, -34.6635, -47.4241, -52.4564, -55.2402, -56.3979, -57.5131, -56.6610, -57.6774, -58.0140, -58.7681, -29.3798, -25.5777, -37.3613, -37.0626, -36.9792, -40.9095, -43.4963, -44.3926, -48.0477, -48.2806, -49.8722, -54.7201, -56.0388, -56.7861, -59.0275, -48.7899, -42.2194, -48.8557, -52.1193, -54.8338, -56.7596, -15.7264, -15.7901, -22.8617, -31.4368, -32.2330, -32.7679, -37.6988, -38.7238, -37.8009, -38.8478, -40.6056, -38.4601, -44.0326, -45.4361, -41.5644, -41.6329, -41.1879, -40.6555, -39.1794, -40.8012, -42.4710, -43.6821, -42.9100, -44.7157, -44.7178, -45.3439, -46.2079, -46.8979, -46.8402, -48.6658, -50.8103, -52.5789, -52.0955, -51.6201, -49.9044, -49.4859, -53.0275, -55.3934, -57.9267, -57.9773, -57.1754, -56.9548, -57.5976, -55.5373, -59.2119, -63.1259, -63.4721, -65.5159, -65.7228, -63.0597, -62.5304, -63.3419, -59.7403, -33.2651, -37.0354, -46.6233, -51.7290, -53.0574, -53.4755, -55.4113, -55.5568, -57.1321, -57.2843, -57.5908, -59.0350, -60.6623, -61.0116, -60.2447, -31.7462, -32.2703, -43.8158, -50.7122, -51.3668, -51.3463, -51.1545, -53.0814, -50.9074, -51.3693, -54.7425, -55.4891, -55.7862, -59.9211, -57.8953, -58.5088, -34.3338, -12.8897, -10.8784, -19.0439, -23.8509, -27.2622, -27.1065, -31.8813, -36.6171, -34.4587, -35.3891, -25.5988, -25.1403, -27.6112, -30.5353, -31.8987, -33.2445, -32.9183, -32.4131, -30.5120, -31.1218, -33.3895, -36.5254, -38.3663, -39.8678, -39.2605, -39.2881, -38.6539, -39.9733, -42.2083, -44.2515, -45.6191, -46.7915, -45.5940, -44.7255, -43.4848, -42.2383],
        gain: 0
      }, {
        buffer: 'sounds/co-mix/percs_bass_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 8,
        intensity: [-86.7987, -86.5294, -87.0894, -42.0940, -18.6202, -18.0059, -19.0751, -16.9197, -15.8691, -14.0201, -15.3785, -20.5028, -18.2615, -16.9914, -17.7362, -22.1606, -22.7815, -22.1664, -24.4330, -25.8838, -23.4600, -23.9362, -20.9873, -19.6802, -21.3228, -23.4347, -24.9499, -23.1086, -23.2861, -22.7966, -23.5732, -22.9736, -24.4246, -25.1465, -25.8472, -26.0463, -26.6172, -24.2445, -23.8622, -20.2828, -22.9417, -22.6118, -26.4941, -27.4091, -23.6340, -22.2479, -24.1242, -25.5719, -26.8697, -29.6403, -30.6441, -32.1310, -30.2648, -29.9000, -20.2871, -20.1360, -23.3232, -26.0337, -29.8029, -29.0891, -28.8199, -28.1261, -27.7806, -31.5967, -28.2265, -30.4939, -30.5947, -28.2601, -28.2321, -31.3028, -29.1582, -31.0560, -29.0917, -24.4770, -27.6876, -33.1540, -32.7105, -37.9996, -36.2042, -35.1520, -34.6535, -38.2624, -38.2496, -41.9053, -37.4932, -35.5311, -27.5048, -33.9796, -37.8762, -35.9769, -41.7795, -41.9161, -36.3511, -33.6605, -20.3483, -32.7241, -42.8237, -46.2883, -43.5846, -44.0414, -46.2586, -49.0029, -42.4760, -46.3470, -47.7812, -37.4575, -44.6618, -53.9253, -55.0524, -58.3875, -37.8018, -42.7682, -54.8729, -61.6559, -60.1609, -21.2660, -25.4662, -52.3470, -55.1400, -58.7658, -34.5844, -26.7089, -55.1623, -58.6948, -57.2742, -57.6829, -33.4506, -42.2684, -56.9086, -59.4355, -59.0857, -38.4670, -45.2448, -57.1867, -52.5044, -57.6731, -29.1582, -25.6916, -54.1999, -59.6017, -61.6189, -54.9369, -38.5433, -50.6073, -64.0806, -63.4781, -65.9521, -35.3625, -43.3244, -55.1620, -57.5738, -59.7213, -45.0696, -46.8826, -65.9439, -67.3558, -65.2678, -59.0849, -46.4118, -57.3640, -73.5012, -73.1539, -73.9444, -50.7920, -61.3593, -75.8033, -75.8019, -77.3987, -42.1472, -46.7446, -68.9213, -78.1700, -79.6315, -56.4290, -51.8584, -67.7271, -77.7038, -77.7180, -72.0183, -47.7959, -58.4434, -73.3052, -77.4587, -80.4316, -54.7548, -64.1034, -82.3347, -83.8928, -84.7618, -63.3963, -58.7928, -70.9145, -84.4845, -83.6392, -76.7783, -61.8943, -75.1551, -82.3776, -83.4165, -84.9455, -53.0834, -63.8309, -80.9983, -84.0127, -84.8390, -61.9235, -65.6749, -80.6199, -84.7494, -85.1397, -70.6537, -60.2526, -72.2141, -82.8203, -85.1317, -86.1467, -65.4104, -79.4288, -86.2349, -86.2096, -86.9198, -69.6615, -71.1891, -82.8350, -86.0070, -86.1688, -78.6744, -73.7601, -85.0974, -86.2083, -86.0355, -84.9467, -64.2468, -79.0972, -86.1502, -86.2920, -86.1504, -69.9066, -78.8108, -86.2465, -86.4085, -86.5542, -74.7758, -72.9238, -83.1766, -86.2726, -86.5869, -85.8459, -76.7540, -86.2269, -86.3295, -86.6552, -86.8991, -77.6097, -81.9317, -85.9239, -86.7974, -86.3307, -82.8254, -83.8602, -86.8536, -86.6871, -86.7418, -34.0310, -24.5276, -54.8520, -66.4253, -68.8671, -69.8451, -72.8380, -76.1384, -77.3687, -78.8657, -82.6503, -34.8592, -38.1425, -39.6196, -40.1615, -41.6624, -41.7444, -42.6399, -46.5834, -48.2179, -52.0174, -43.0760, -20.8575, -46.8589, -60.9600, -61.1110, -65.2803, -29.0603, -38.6588, -41.3842, -42.1468, -42.8305, -39.2953, -39.7633, -46.3549, -48.3904, -50.3120, -49.7841, -41.4287, -53.0539, -57.8361, -59.7925, -46.4301, -26.5043, -41.1320, -43.3845, -43.9918, -44.5915, -38.6802, -44.4361, -48.0410, -49.2839, -50.8219, -44.8475, -38.7925, -53.0929, -58.2083, -58.6930, -60.5742, -43.5173, -62.4705, -66.8295, -68.6894, -70.8718, -28.2666, -41.5496, -65.3949, -64.7959, -68.2192, -31.5677, -30.9551, -49.4886, -54.7676, -59.1385, -58.7123, -42.7272, -63.0253, -66.4287, -67.8820, -69.4739, -53.1098, -65.4690, -73.1068, -72.7323, -76.1268, -52.6114, -55.3086, -71.9011, -75.8824, -77.6670, -69.8885, -55.8469, -80.2685, -83.2058, -83.7572, -80.2504, -43.0177, -62.7660, -76.8985, -79.3757, -80.8592, -44.1618, -51.7774, -77.4703, -77.7529, -81.4570, -63.5211, -56.8797, -80.0577, -84.7204, -85.1164, -80.8811, -64.1566, -80.4401, -84.5430, -83.9326, -86.2422, -61.3150, -71.0241, -82.3765, -84.5446, -85.1215, -72.7356, -69.3830, -85.3869, -85.7100, -86.4850, -72.2202, -55.9137, -79.4596, -84.5448, -85.3084, -85.3616, -54.5259, -68.9610, -84.7919, -84.5829, -86.2734, -69.5441, -71.9750, -86.1869, -86.5989, -86.6297, -80.8457, -76.3908, -85.9698, -86.1629, -86.8343, -85.9650, -71.5122, -83.7848, -85.9817, -86.2732, -86.3955, -78.4212, -82.7298, -86.1025, -86.1860, -86.9085, -74.9094, -69.4076, -85.8593, -86.6653, -86.7457, -84.3351, -66.0233, -82.8626, -86.2686, -86.6346, -32.5855, -21.4196, -48.4679, -65.2272, -68.2001, -72.0864, -73.5830, -76.5368, -77.3726, -80.8910, -82.3307, -38.8628, -41.0246, -52.6093, -64.7731, -66.6690, -44.5260, -38.7364, -48.6988, -62.4539, -65.1496, -40.7447, -17.7258, -39.8474, -63.5380, -67.3981, -70.2004, -23.9898, -38.1924, -64.6620, -70.2732, -68.6682, -39.1856, -36.5597, -48.8733, -63.5103, -60.6199, -50.3046, -37.7739, -54.0817, -62.0539, -64.1215, -65.6442, -21.4654, -40.9676, -64.5880, -63.4563, -69.2841, -42.4418, -44.6766, -57.8997, -62.9799, -63.9176, -44.4688, -35.8372, -49.7074, -64.8606, -66.3774, -65.6016, -39.6930, -58.2298, -74.8330, -78.3424, -78.6018, -23.8779, -34.9876, -61.3288, -67.0527, -67.9154, -27.3430, -25.6684, -55.3580, -63.3620, -66.1331, -53.4410, -35.0467, -45.9308, -61.4144, -66.2176, -68.8526, -40.3903, -43.5944, -57.1465, -66.7092, -67.1931, -25.1811, -29.2584, -59.1334, -65.5706, -69.7029, -64.9855, -52.9013, -70.6722, -78.2422, -81.5030, -77.2079, -33.6301, -39.0203, -40.0093, -40.6220, -41.3253, -38.6996, -42.8788, -47.1976, -49.3987, -51.7437, -51.7776, -48.6725, -56.8855, -60.6071, -62.9778, -64.0810, -36.2506, -39.7415, -41.4497, -42.1099, -42.9401, -37.9786, -44.1052, -46.8940, -48.6640, -50.5560, -52.3210, -54.1649, -56.2382, -58.1511, -60.1195, -61.2795, -36.4900, -40.2876, -42.8413, -43.5541, -44.3259, -44.3660, -45.9142, -47.1191, -48.6872, -50.3747, -46.0092, -37.3977, -44.0549, -44.5614, -45.6477, -46.6063, -47.3145, -48.3827, -49.4542, -50.9289, -52.5625, -37.3693, -42.7373, -46.8527, -48.1794, -49.9426, -51.4787, -52.9050, -54.3181, -55.5071, -56.8788, -48.5331, -38.6986, -45.5179, -52.6759, -58.0072, -60.9530, -23.5072, -37.9258, -62.5635, -63.2114, -59.9858, -57.1013, -51.4184, -47.6878, -49.2307, -44.7693, -43.0890, -40.0500, -45.1681, -43.9268, -44.8464, -43.3281, -36.9092, -37.6618, -38.6023, -39.3046, -38.8488, -23.9237, -28.6964, -34.0118, -34.0492, -36.4248, -34.4585, -30.1823, -38.8011, -38.5066, -34.2518, -30.5698, -29.9974, -28.7524, -30.1269, -29.3103, -27.9077, -28.3642, -28.9954, -29.7613, -29.0743, -27.7875, -28.3687, -27.1046, -31.0501, -34.0440, -35.6508, -32.6657, -31.7953, -29.9988, -24.8189, -25.2160, -24.7587, -24.1628, -26.9012, -25.4156, -26.7927, -22.1773, -24.1338, -25.7253, -26.1091, -23.8348, -16.4403, -18.4687, -21.3814, -24.9508, -19.9540, -23.8056, -27.4914, -22.0985, -24.0292, -25.9927, -24.8108, -23.3473, -24.6422, -28.4908, -23.2048, -23.9677, -22.4557, -19.5076, -16.7627, -16.4242, -21.7421, -20.8414],
        gain: 0
      }]
    }, {
      name: 'bass drum',
      layers: [{
        buffer: 'sounds/co-mix/kick_tom_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-85.9162, -86.3524, -85.9727, -39.0189, -22.8205, -32.2486, -32.5072, -33.7830, -37.7065, -48.0141, -47.0989, -42.2004, -41.9919, -44.3923, -48.5619, -50.9864, -50.2686, -50.4122, -52.0094, -54.2128, -55.7668, -56.6672, -57.7974, -59.4052, -61.2474, -62.8914, -64.9304, -66.8331, -68.5224, -70.3207, -72.5675, -85.0187, -86.4059, -86.0835, -86.6153, -30.3904, -23.9984, -33.9869, -32.6954, -34.3653, -39.2752, -51.2350, -45.2089, -41.8893, -42.3684, -45.2763, -49.5131, -50.9177, -50.1627, -50.6671, -52.5050, -23.7080, -22.3741, -25.3418, -30.0949, -33.9130, -36.2067, -36.6200, -40.5036, -43.5904, -46.1583, -47.7042, -50.0402, -52.0620, -53.5128, -55.4133, -57.2175, -60.0541, -61.6635, -63.7132, -66.6359, -68.3915, -70.3666, -72.3083, -74.7626, -75.3393, -77.9318, -47.5208, -22.6840, -30.6253, -32.5474, -33.5485, -36.9608, -46.1067, -48.4833, -42.4687, -41.8340, -43.9271, -47.9630, -50.9317, -50.3624, -50.3030, -51.7351, -53.9302, -55.6184, -56.5589, -57.6231, -59.1851, -60.9916, -23.5840, -27.9378, -32.9468, -33.2680, -35.9293, -43.3177, -50.9814, -43.0757, -41.6902, -43.2677, -46.9839, -50.6531, -50.5414, -50.1702, -51.3074, -53.4327, -55.3311, -56.3616, -57.3465, -58.8098, -60.5551, -62.3780, -64.1998, -66.1986, -67.9001, -69.6599, -71.5547, -79.2012, -86.7151, -86.7614, -86.6678, -86.8673, -86.7983, -86.0827, -86.4953, -86.7415, -86.5526, -86.4961, -86.4493, -86.9994, -86.5247, -86.3206, -86.8086, -87.4411, -86.8785, -86.6833, -85.8397, -86.1152, -86.3527, -86.4903, -86.0861, -86.3078, -86.4872, -86.7297, -86.5235, -86.3903, -86.5288, -86.3236, -86.4545, -86.3779, -86.5591, -86.3596, -86.7319, -86.1075, -86.5885, -86.5322, -86.6309, -86.1744, -86.3886, -86.1029, -86.1333, -86.5448, -86.6410, -86.7606, -24.3916, -26.9881, -33.2278, -33.1586, -35.5578, -42.3309, -51.8573, -43.4083, -41.6856, -43.0471, -46.6127, -50.4796, -50.6241, -50.1436, -51.1526, -53.2325, -55.2049, -56.2896, -57.2428, -58.6601, -60.3786, -62.2437, -64.0160, -66.0269, -67.7636, -69.5065, -37.0859, -22.9417, -32.7032, -32.5228, -33.8520, -37.8994, -22.9108, -29.1441, -32.7830, -33.3469, -36.3473, -44.4953, -49.8629, -42.7695, -41.7315, -43.5406, -47.4131, -50.8042, -50.4561, -50.2176, -51.4906, -43.1644, -19.2187, -24.5054, -27.4179, -32.5991, -34.5773, -37.0045, -38.8007, -41.3122, -44.1973, -46.7759, -48.6422, -50.9270, -51.4985, -53.6972, -56.3022, -58.1213, -60.6060, -62.8584, -65.2340, -67.1950, -68.8377, -71.0709, -73.2554, -75.4227, -77.2652, -79.0409, -80.5948, -82.0767, -83.4588, -84.3148, -84.6251, -85.4691, -85.9806, -86.0323, -85.7705, -86.2019, -86.1723, -85.9542, -86.8379, -86.5431, -86.4413, -86.3565, -86.1718, -86.8257, -85.9658, -85.8776, -86.5643, -86.0196, -86.7839, -86.7521, -86.1777, -86.4766, -86.7200, -86.5205, -86.2236, -86.7232, -86.9918, -85.7602, -23.5051, -28.0584, -32.9169, -33.2807, -35.9758, -43.4428, -50.8614, -43.0390, -41.6927, -43.2952, -47.0310, -50.6717, -50.5328, -50.1743, -51.3261, -53.4559, -55.3469, -56.3751, -57.3562, -58.8277, -60.5691, -62.3952, -64.2379, -66.2239, -67.9167, -69.6758, -71.5988, -79.3664, -86.2369, -86.8645, -86.7371, -86.2865, -86.6090, -86.7218, -86.1347, -86.1527, -86.3741, -86.6650, -86.4327, -86.9939, -86.6067, -86.1653, -86.2633, -86.3094, -86.3707, -86.3397, -86.2727, -86.3253, -86.1372, -86.0924, -86.0450, -86.2455, -86.8506, -86.2048, -86.3737, -86.3418, -86.6051, -86.1308, -86.2561, -86.8599, -86.0770, -86.2906, -86.4572],
        gain: -3
      }, {
        buffer: 'sounds/co-mix/kick_tom_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-86.5744, -86.6427, -86.8267, -40.6386, -24.4404, -33.8685, -34.1272, -35.4031, -39.3266, -49.6333, -48.7184, -43.8202, -43.6118, -46.0119, -29.8844, -27.8210, -36.5768, -35.5950, -37.5440, -43.1826, -55.1826, -47.0463, -44.4913, -45.3588, -48.1612, -24.4895, -31.0850, -34.2697, -35.0620, -38.1632, -46.5947, -51.0280, -44.2755, -43.3656, -45.2623, -49.1902, -52.4636, -52.0377, -51.8514, -53.1738, -55.3494, -57.1238, -58.0898, -59.1202, -60.6434, -62.4310, -25.6278, -29.0153, -34.7064, -34.8352, -37.3594, -44.4251, -53.0326, -44.8436, -43.2940, -44.7636, -48.4069, -52.1837, -52.1963, -51.7668, -52.8375, -54.9401, -56.8781, -57.9361, -58.9047, -60.3390, -62.0597, -27.9455, -27.2036, -35.3604, -34.5850, -36.6352, -42.5403, -54.1160, -45.6612, -43.3472, -44.3542, -47.6577, -51.7527, -52.3743, -51.7450, -52.5458, -54.5380, -56.6055, -57.7802, -58.6991, -60.0488, -61.7327, -31.8211, -25.6631, -35.6361, -34.3231, -35.9909, -40.9121, -52.8740, -46.8294, -43.5188, -44.0022, -46.9125, -51.1438, -52.5413, -51.7881, -52.3004, -54.1360, -56.2931, -57.6221, -58.5092, -59.7642, -61.4138, -37.9569, -24.6245, -34.4975, -34.1511, -35.5083, -39.6409, -50.3640, -48.2681, -43.7533, -43.7007, -46.2138, -50.4132, -52.6124, -51.8665, -52.0942, -53.7484, -55.9462, -57.4448, -58.3392, -59.4992, -61.1060, -48.4290, -24.2989, -32.3319, -34.1616, -35.1793, -38.6152, -47.8191, -50.0307, -44.0746, -43.4616, -45.5700, -49.6150, -52.5543, -51.9778, -51.9268, -53.3720, -55.5852, -43.8741, -39.6067, -39.8006, -41.1338, -42.9463, -24.8304, -30.1252, -34.4377, -34.9473, -37.7669, -45.5245, -52.0455, -44.5331, -43.3261, -45.0213, -48.8192, -52.3546, -52.1163, -51.8126, -53.0160, -55.1649, -57.0154, -58.0250, -59.0267, -60.5010, -62.2585, -26.5096, -28.1652, -35.0054, -34.7214, -37.0020, -43.4913, -53.8069, -45.2138, -43.3147, -44.5672, -48.0512, -52.0024, -52.2869, -51.7579, -52.7007, -54.7539, -56.7557, -57.8682, -58.8154, -60.2058, -61.9107, -29.4619, -26.4645, -35.6129, -34.4606, -36.3212, -41.7462, -53.8543, -46.1687, -43.4210, -44.1891, -47.3137, -51.4945, -52.4595, -51.7634, -52.4298, -54.3560, -56.4666, -57.7131, -58.6148, -59.9204, -61.5786, -34.2343, -25.1196, -35.3150, -34.2295, -35.7534, -40.3039, -51.7886, -47.4401, -43.6158, -43.8603, -46.5920, -50.8258, -52.5878, -51.8197, -52.2012, -53.9583, -56.1388, -57.5455, -58.4346, -59.6375, -61.2816, -41.9611, -24.3757, -33.5693, -34.1271, -35.3417, -39.1478, -49.1853, -49.0278, -43.8864, -43.5819, -45.9119, -50.0530, -52.6039, -51.9112, -52.0109, -53.5734, -55.7758, -57.3627, -58.2666, -59.3840, -60.9805, -55.6629, -24.4352, -31.3104, -34.2501, -35.0681, -38.2174, -46.7500, -50.9178, -44.2590, -43.3864, -45.3101, -49.2534, -52.4814, -52.0353, -51.8682, -53.2067, -55.3857, -57.1476, -58.1073, -59.1502, -60.6789, -62.4557, -25.4672, -29.2024, -34.6624, -34.8489, -37.4112, -44.5680, -52.9445, -44.8105, -43.3052, -44.8039, -48.4668, -52.2138, -52.1905, -51.7794, -52.8687, -54.9772, -56.9036, -57.9557, -58.9281, -60.3681, -62.1018, -27.6579, -27.3656, -35.3138, -34.6062, -36.6832, -42.6674, -54.1319, -45.6080, -43.3499, -44.3889, -47.7167, -51.7922, -52.3689, -51.7517, -52.5720, -54.5754, -53.8684, -40.2722, -39.7912, -40.6675, -42.2900, -31.1085, -25.7970, -35.6624, -34.3459, -36.0463, -41.0521, -53.0833, -46.7061, -43.5002, -44.0344, -46.9828, -51.2078, -52.5270, -51.7835, -52.3209, -54.1751, -56.3212, -57.6400, -58.5375, -59.7886, -61.4443],
        gain: -3
      }]
    }, {
      name: 'clap',
      layers: [{
        buffer: 'sounds/co-mix/claps_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-86.7117, -86.6296, -86.7966, -86.4751, -86.6367, -86.4515, -86.3527, -86.1292, -86.4780, -86.4362, -86.2572, -86.3878, -86.1944, -86.5611, -86.7589, -86.5403, -86.3255, -86.8620, -86.5331, -86.8531, -86.6757, -86.6406, -87.0172, -86.0174, -87.0361, -86.3934, -86.5372, -86.7124, -86.1056, -86.8691, -19.9564, -16.0211, -23.4318, -44.5763, -86.1041, -86.8198, -86.5131, -86.6756, -86.5913, -85.9343, -86.5368, -86.7247, -86.3532, -86.3268, -86.4583, -73.0457, -7.83180, -3.71578, -7.86790, -17.4960, -26.6026, -33.8386, -38.2885, -36.7628, -35.6485, -33.5364, -31.5518, -14.5465, -20.0735, -30.2018, -44.0565, -46.6614, -49.1322, -50.2912, -52.7300, -56.2021, -58.7465, -18.2943, -13.4773, -18.5778, -36.6836, -49.9712, -23.2810, -9.71799, -14.2854, -25.3721, -44.8666, -48.5095, -47.0116, -45.7875, -49.7393, -52.8716, -53.8813, -55.1191, -56.9030, -57.2005, -59.0281, -60.6677, -61.3812, -62.7854, -64.5762, -66.0179, -68.1519, -68.9161, -69.8142, -71.0879, -72.9443, -73.6609, -74.2792, -75.4412, -75.7700, -77.3162, -78.2854, -78.8699, -79.6232, -80.5115, -81.2887, -81.0852, -81.9592, -85.6928, -86.2050, -86.3684, -86.2133, -86.4828, -87.1799, -86.4589, -86.4013, -86.6999, -86.6064, -86.0551, -86.4101, -86.6049, -86.9769, -87.0129, -86.2539, -87.1337, -86.4272, -86.9084, -86.5278, -86.5780, -29.0368, -5.25153, -4.05848, -8.99821, -18.7385, -27.5313, -33.1466, -34.3688, -33.5900, -31.4047, -30.7460, -30.6458, -32.8840, -33.4066, -35.5446, -36.0616, -37.6643, -35.8834, -37.5383, -38.5742, -36.7253, -39.4659, -38.0267, -41.5809, -39.4116, -41.3329, -39.4915, -42.3194, -41.8597, -44.5506, -44.2740, -44.4229, -45.3097, -46.0853, -46.5765, -46.0870, -47.3311, -46.6057, -48.0799, -47.5160, -47.9759, -47.7489, -48.7245, -51.3993, -50.9718, -52.0524, -51.8474, -52.5842, -51.2146, -51.9496, -55.1279, -54.6393, -53.3460, -54.8230, -56.7233, -54.5463, -55.3001, -54.7763, -55.9909, -56.7011, -58.1413, -58.9360, -59.0788, -58.7061, -23.2382, -15.0842, -22.2107, -38.8461, -61.6867, -62.9353, -63.4224, -62.1408, -60.7408, -59.9127, -60.8097, -59.1619, -58.8293, -58.4249, -58.9964, -57.5181, -57.0429, -55.3881, -54.8355, -55.1430, -55.1856, -16.3855, -4.33599, -5.21611, -13.0823, -22.6033, -31.2226, -36.9457, -38.0025, -35.7798, -34.3207, -33.9863, -35.3132, -37.2128, -39.8722, -43.2131, -45.8139, -26.0227, -15.8194, -22.7694, -37.7839, -56.9354, -33.1566, -12.9310, -16.6565, -25.0996, -46.5638, -51.3437, -11.5671, -11.8099, -17.5731, -39.8000, -47.6298, -49.0579, -45.2676, -47.7944, -52.4740, -53.4378, -54.4738, -56.4546, -55.9040, -57.6392, -60.1831, -61.2974, -62.6212, -63.6056, -64.8772, -67.1072, -68.1356, -69.3473, -69.9385, -71.3990, -73.5700, -73.3331, -74.9066, -75.7902, -76.5222, -77.0130, -78.6490, -79.4498, -80.6488, -80.2655, -81.4502, -81.2194, -84.2361, -86.3893, -86.7967, -86.4096, -86.7945, -86.3694, -86.1212, -86.6927, -86.5260, -86.7363, -86.6571, -86.1438, -86.5803, -86.4869, -86.7112, -86.0831, -86.4870, -86.8946, -86.4338, -86.0997, -86.1261, -87.1041, -10.0398, -3.32862, -6.34050, -13.9151, -23.7885, -30.6866, -34.8157, -34.0968, -32.0303, -30.6722, -31.2855, -32.0064, -33.5389, -33.9095, -36.6658, -37.2943, -37.6850, -36.3813, -38.6595, -37.1253, -38.5339, -40.2856, -39.0188, -40.5702, -40.4551, -40.2152, -42.3481, -40.9154, -43.2087, -45.5948, -44.2301, -44.1142, -45.5910, -46.7008, -45.4520, -47.4572, -47.1536, -46.9597, -48.1321, -47.8157, -47.8434, -49.0372],
        gain: -8
      }, {
        buffer: 'sounds/co-mix/claps_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-86.4750, -85.9864, -85.7777, -86.9640, -86.4084, -86.5822, -86.5043, -87.0963, -86.5532, -86.7099, -86.9069, -86.5064, -86.7645, -86.3498, -86.1724, -86.4363, -86.1265, -86.1709, -86.2230, -86.2147, -86.3183, -86.8943, -86.4000, -86.5688, -41.7653, -10.4811, -8.23912, -15.0129, -24.9167, -33.9327, -38.7356, -41.7859, -41.0317, -39.6819, -38.2554, -39.3813, -41.4911, -43.5899, -46.9333, -49.0982, -51.3827, -53.9772, -55.4404, -57.9953, -61.0001, -63.6103, -64.7098, -66.4737, -68.4032, -70.4586, -72.3592, -73.8147, -75.9967, -77.6400, -79.0561, -79.9651, -80.7152, -81.7846, -82.2799, -82.9234, -82.6816, -85.4037, -27.2069, -21.6649, -19.9913, -26.2687, -36.5719, -14.3786, -7.75862, -12.0284, -21.2610, -29.8148, -33.1073, -35.5112, -36.9906, -36.2887, -35.9326, -36.7164, -37.3829, -38.6131, -41.2644, -39.1780, -41.7111, -41.8404, -43.8713, -42.6451, -44.5108, -42.4789, -45.8959, -44.4028, -47.0453, -47.8514, -47.6355, -48.0820, -49.2026, -50.1385, -48.9827, -50.6989, -50.0391, -50.8854, -50.8753, -51.1423, -50.8691, -52.1018, -53.8688, -54.3113, -55.0181, -55.1857, -55.5548, -23.8637, -8.96994, -9.47291, -18.2185, -26.9778, -35.3318, -38.7389, -42.1173, -40.3451, -38.9010, -38.4497, -39.9025, -41.9095, -44.1272, -47.5923, -49.9929, -51.7090, -54.1436, -55.5425, -57.8221, -60.1380, -61.3216, -63.4128, -62.5959, -62.6307, -62.1464, -64.0745, -62.1964, -61.8768, -62.0049, -62.2775, -61.0933, -60.0261, -59.0196, -58.0287, -58.5042, -57.8853, -73.0955, -86.1926, -86.3797, -86.3641, -86.0630, -53.4350, -11.0628, -7.82302, -14.4974, -23.6043, -32.9483, -38.7163, -41.2414, -41.1816, -40.0423, -38.0793, -39.2580, -41.2415, -43.2677, -46.6692, -48.7120, -51.4794, -54.1465, -55.4053, -57.6183, -60.7852, -62.8540, -64.4629, -66.1650, -67.8975, -70.1727, -71.7313, -73.8727, -76.3040, -77.1920, -78.6594, -79.5886, -80.3585, -81.5114, -82.4169, -82.9293, -83.2961, -84.9307, -86.1553, -86.0596, -86.3263, -86.4878, -85.9848, -15.8596, -7.94923, -11.4213, -20.6764, -29.8503, -37.1381, -39.3484, -42.0414, -40.2840, -38.1950, -38.8016, -40.5197, -42.3938, -45.1352, -47.9736, -50.8950, -53.1987, -54.5775, -56.9648, -59.7467, -61.7559, -63.7275, -65.9513, -66.9694, -69.4767, -71.7631, -72.7284, -75.4532, -76.2736, -78.7536, -79.5012, -80.2551, -81.1380, -82.4063, -82.6366, -82.7670, -83.6086, -68.5301, -18.4600, -23.5302, -20.4883, -32.4299, -27.2790, -9.34141, -8.97984, -17.3387, -26.0129, -32.7624, -34.4547, -36.9199, -35.8482, -37.0391, -36.3857, -37.6588, -38.0598, -40.0615, -40.0078, -40.3431, -42.7428, -41.2217, -44.1340, -43.0997, -44.0150, -44.7621, -44.3935, -46.2260, -49.1286, -47.4304, -47.2616, -48.6947, -49.6742, -48.7970, -50.3932, -50.5117, -49.9072, -51.6189, -50.9953, -51.2143, -52.0070, -52.4630, -55.3361, -54.4820, -55.6588, -55.2568, -55.8246, -11.8104, -7.68554, -13.7164, -22.9191, -32.3536, -38.4654, -40.6652, -41.2445, -40.0330, -37.9232, -39.1431, -41.0489, -43.0117, -46.2645, -48.5915, -51.0789, -53.5496, -54.6998, -56.3060, -59.5386, -60.6275, -62.3320, -62.3100, -62.7595, -62.2101, -63.6340, -62.6991, -61.7550, -62.1693, -61.1607, -61.6027, -59.9720, -60.2500, -58.0765, -58.2117, -57.8779, -62.2069, -86.1486, -86.2368, -86.6331, -87.0211, -86.7973, -17.6741, -8.19673, -10.8199, -20.0033, -29.0073, -36.6178, -39.0920, -42.1836, -40.3207, -38.3724, -38.6863, -40.3669, -42.2910, -45.0881, -47.7898, -50.6302, -52.8644, -54.6963, -56.9384, -59.5078, -61.5457],
        gain: -8
      }]
    }, {
      name: 'hats',
      layers: [{
        buffer: 'sounds/co-mix/hats_percs_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-87.3882, -86.7905, -86.5785, -22.6979, -8.78208, -14.8833, -23.2617, -30.4747, -39.2975, -20.9038, -31.7903, -41.5655, -48.5031, -58.5376, -11.8830, -10.8417, -18.0415, -25.7428, -32.9741, -23.9387, -16.9209, -30.1248, -38.9321, -45.2912, -39.1852, -8.66584, -13.2449, -21.7262, -28.8407, -36.5679, -21.4022, -30.2454, -40.5370, -47.8049, -56.4176, -15.2951, -9.58169, -16.2701, -24.3994, -31.8218, -28.4953, -15.7623, -28.9982, -38.0558, -44.4371, -54.5939, -23.8609, -35.5685, -45.1493, -51.9100, -62.8707, -22.4344, -28.4730, -39.4678, -47.1424, -54.7990, -25.0619, -20.7218, -33.7218, -42.3770, -48.8130, -35.6219, -15.0470, -27.7931, -37.0890, -43.6125, -56.8195, -24.0942, -34.1097, -44.1092, -51.1972, -60.4878, -24.0847, -26.5138, -38.3879, -46.4836, -53.4404, -28.9881, -19.3406, -32.6215, -41.5551, -47.9021, -46.9129, -14.8035, -26.4888, -36.0723, -42.8536, -53.7818, -13.5911, -10.4341, -17.2373, -25.1841, -32.5004, -25.8895, -8.61894, -14.3248, -22.8519, -29.9454, -38.4419, -8.85036, -12.4132, -20.6510, -27.7663, -35.2271, -17.4219, -21.1335, -32.7099, -40.6608, -47.8317, -20.5070, -9.15469, -15.2330, -23.6510, -30.8991, -38.2724, -21.0316, -33.6807, -43.0176, -49.5505, -62.4594, -10.0874, -11.4279, -18.9522, -26.3801, -33.8797, -19.5406, -19.1921, -31.6329, -39.9910, -46.6578, -35.5817, -25.2440, -38.5255, -47.4830, -53.8276, -54.8016, -20.8443, -32.3641, -41.9909, -48.8106, -59.5162, -19.6095, -25.1817, -36.2951, -44.0262, -51.5594, -22.4983, -17.4939, -30.5581, -39.2522, -45.6744, -41.4713, -24.3397, -37.3517, -46.5462, -53.0035, -67.2615, -21.1444, -30.8817, -40.9425, -48.0780, -57.1765, -21.3377, -23.2325, -35.2257, -43.3705, -50.2767, -26.6061, -16.1679, -29.4517, -38.4159, -44.7649, -62.8218, -9.51898, -12.1601, -19.8668, -27.2069, -34.5950, -25.8756, -25.0143, -37.5443, -45.9318, -52.5891, -26.5767, -8.45569, -14.1530, -22.7136, -29.7701, -38.2193, -14.9504, -25.3580, -35.2591, -42.2743, -51.8563, -12.7437, -10.7716, -17.7639, -25.5810, -32.9438, -28.8740, -23.3536, -36.4662, -45.2082, -51.6125, -39.5315, -8.20111, -12.9950, -21.3997, -28.4966, -36.2309, -15.5942, -23.7413, -34.1990, -41.5905, -49.9005, -27.6251, -29.0430, -41.1385, -49.3213, -56.1897, -33.2688, -22.0687, -35.3460, -44.3451, -50.6967, -54.2422, -17.8372, -29.1451, -38.8273, -45.6834, -56.1337, -16.7846, -21.9040, -33.1294, -40.9201, -48.3582, -30.2220, -27.2112, -40.0566, -48.6101, -55.1245, -39.4410, -21.2355, -34.1710, -43.4026, -49.8727, -63.8431, -18.2042, -27.6496, -37.7799, -44.9651, -53.9020, -18.6041, -19.9539, -32.0626, -40.2602, -47.1105, -33.2452, -8.41738, -13.7666, -22.1428, -29.2891, -37.2055, -10.2082, -11.6965, -19.3597, -26.7431, -34.0531, -15.3384, -9.79331, -16.4807, -24.6044, -31.7710, -30.7867, -15.4268, -28.5390, -37.6876, -44.1043, -57.6051, -9.09070, -12.3505, -20.3897, -27.5910, -35.0639, -23.0001, -27.7134, -39.0475, -46.8690, -54.2180, -21.2827, -8.94635, -14.8760, -23.3917, -30.6427, -36.5011, -14.8944, -27.2929, -36.6966, -43.3137, -55.5195, -24.3242, -33.4856, -43.6890, -50.9112, -59.7045, -24.9225, -25.7505, -37.9687, -46.2079, -53.0002, -30.9486, -18.9119, -32.1739, -41.1973, -47.5708, -53.7337, -14.8386, -25.9352, -35.6674, -42.5602, -52.7782, -25.2809, -31.7441, -42.6245, -50.2468, -57.9877, -27.6180, -23.9695, -36.8949, -45.5019, -51.9716, -37.4624, -18.1387, -30.9896, -40.2482, -46.7491, -60.3519, -15.2731, -24.4153, -34.6212, -41.8564, -50.6281],
        gain: 3
      }, {
        buffer: 'sounds/co-mix/hats_percs_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-86.3534, -86.1134, -87.3273, -28.9215, -15.9851, -25.8019, -32.9732, -42.2863, -51.3928, -15.9669, -24.1903, -34.1962, -43.3230, -49.9376, -11.4481, -10.9644, -16.5294, -21.6228, -28.3159, -21.2020, -12.9675, -23.9658, -32.3941, -39.9541, -43.5508, -24.1055, -36.8676, -46.1641, -52.6822, -65.8977, -16.6665, -22.3445, -32.1421, -42.1124, -48.4365, -14.3137, -10.1142, -16.7918, -23.8853, -30.4423, -26.9977, -13.3782, -24.9705, -34.7258, -42.0414, -50.2586, -23.8384, -35.5643, -45.1440, -51.9244, -62.8820, -16.6287, -16.7495, -26.3416, -36.2163, -43.1221, -19.8504, -8.92355, -14.5011, -18.4104, -22.5152, -28.3285, -13.1417, -23.0396, -33.5913, -40.7704, -49.6312, -15.9725, -19.0112, -27.6657, -38.7998, -45.6796, -22.0743, -16.5804, -21.9041, -24.6101, -28.0567, -24.8795, -9.01075, -14.5547, -19.9718, -20.5080, -28.3284, -11.5085, -18.7506, -26.0534, -31.0786, -32.0816, -23.2719, -20.2488, -26.5651, -25.4523, -25.7937, -27.5093, -15.6776, -26.5570, -36.3605, -43.3279, -46.8993, -8.44550, -12.0123, -17.7721, -23.5057, -29.4900, -16.0921, -18.1372, -29.3526, -37.9775, -44.1454, -31.4314, -26.5557, -39.4185, -46.5229, -50.1593, -39.4860, -12.7273, -19.4536, -22.9195, -27.3953, -28.1921, -9.95792, -12.6385, -18.9707, -24.1950, -29.9094, -17.9606, -16.2194, -26.6384, -31.0860, -32.0877, -28.9462, -15.4050, -23.3523, -25.0468, -25.1133, -26.6940, -15.6947, -23.1742, -30.7616, -32.4704, -32.5203, -12.4833, -10.4414, -15.9947, -20.3000, -24.2996, -19.7327, -12.0701, -18.8132, -15.3634, -30.2907, -40.8460, -24.3370, -37.3335, -46.5466, -52.9965, -67.2066, -17.4605, -21.0504, -31.5806, -41.3688, -48.6948, -16.5112, -10.3850, -16.7166, -23.3492, -30.0626, -26.2256, -16.1921, -29.4777, -38.4248, -44.7623, -62.8001, -16.5889, -21.4061, -29.1027, -40.5175, -47.3590, -21.7230, -18.5379, -29.7072, -39.6923, -46.4416, -24.5402, -8.69655, -14.1135, -19.2549, -25.6534, -30.6900, -11.7762, -19.8004, -28.0722, -37.8758, -45.2379, -25.8059, -30.9803, -42.2129, -49.9878, -57.4346, -25.2931, -16.8509, -27.9458, -38.1829, -45.4582, -36.7087, -8.22774, -13.5943, -20.6793, -27.5654, -34.0599, -13.8590, -20.2772, -30.1898, -39.3537, -46.2225, -27.5955, -29.0374, -41.1328, -49.3337, -56.1868, -31.2360, -13.0108, -22.9189, -30.6305, -39.9173, -47.9301, -9.13941, -11.9415, -17.4739, -18.8395, -26.6085, -15.9177, -17.7374, -28.4244, -37.9804, -44.9481, -26.7585, -14.4968, -24.6450, -32.6454, -41.5608, -39.1815, -15.4621, -20.4201, -23.4506, -27.2407, -28.1663, -11.1244, -12.1638, -18.4326, -23.7576, -29.6281, -17.4465, -13.6704, -23.8622, -29.6729, -32.2840, -31.1640, -22.6661, -27.6660, -26.2858, -25.3269, -26.7802, -17.0888, -22.2258, -32.2670, -41.0765, -45.7236, -14.1694, -9.57914, -15.3353, -18.0114, -23.9944, -27.2047, -13.0049, -24.5332, -34.5233, -41.0885, -48.6443, -19.0868, -26.1757, -35.8076, -44.0391, -49.0705, -16.6409, -15.8827, -21.4491, -25.2359, -27.8033, -19.0343, -9.49854, -15.9734, -21.8350, -27.7266, -31.0791, -12.8389, -23.1544, -29.5255, -32.0520, -31.4514, -17.2548, -19.8306, -24.5626, -25.1417, -25.7022, -21.4768, -17.4626, -28.0546, -32.6842, -32.3339, -26.2925, -8.50244, -13.4503, -18.2980, -22.8889, -24.8030, -11.3243, -17.6846, -17.4107, -18.4031, -44.9777, -25.2722, -31.7365, -42.6195, -50.2570, -57.9668, -26.4652, -16.3702, -27.2626, -37.7622, -45.3728, -37.2133, -9.15577, -13.6882, -20.6501, -26.9578, -33.6590, -15.2973, -24.4548, -34.6057, -41.8515, -50.6287],
        gain: 1
      }]
    }, {
      name: 'soundscape',
      layers: [{
        buffer: 'sounds/co-mix/soundscape_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 9,
        intensity: [-86.9206, -86.9562, -86.4132, -82.8630, -51.9733, -46.1896, -47.6447, -46.1246, -41.7747, -41.6696, -40.0180, -38.8532, -37.6418, -39.9130, -40.9953, -39.6106, -39.5825, -37.3826, -36.3089, -36.4675, -38.0595, -36.0192, -32.2284, -29.8516, -34.8366, -34.4769, -31.8931, -30.4644, -28.6395, -30.5444, -30.8806, -27.4959, -28.7294, -35.1219, -37.5526, -38.0947, -36.1202, -28.1396, -27.3470, -29.7419, -29.1639, -30.9524, -34.9499, -38.2069, -35.6820, -31.5821, -29.2003, -29.8184, -29.0301, -30.4466, -34.4090, -38.8722, -39.1144, -30.3981, -30.7608, -29.0044, -28.6398, -30.7150, -31.5852, -30.8845, -29.5933, -30.0557, -30.6201, -32.3853, -34.3352, -36.2025, -41.6646, -45.0103, -41.9626, -34.7094, -35.8080, -34.6844, -33.8584, -35.3958, -36.4667, -35.2478, -35.2248, -37.4478, -39.1484, -39.7507, -43.2407, -44.5130, -47.4918, -50.0033, -46.3480, -44.0157, -43.3126, -42.8593, -42.9918, -42.4639, -43.4974, -43.3661, -45.7147, -47.5772, -47.3133, -47.6976, -49.5795, -49.6697, -51.3524, -54.3747, -53.1228, -51.6765, -50.5964, -52.0794, -51.2863, -51.7460, -50.8026, -51.5610, -50.9434, -51.2097, -51.5938, -52.1371, -54.3961, -56.9163, -58.3112, -57.4483, -54.6822, -54.8891, -53.7135, -53.2414, -54.0846, -53.0193, -54.7314, -55.7868, -53.3514, -52.7081, -52.9018, -55.8950, -60.2227, -60.5629, -62.8619, -61.2650, -57.4778, -57.9093, -57.0840, -56.1262, -58.1303, -58.4478, -58.0041, -59.7650, -57.9653, -58.0663, -59.3729, -62.1087, -61.1357, -63.7594, -68.8109, -66.8225, -64.7255, -63.4361, -63.7540, -60.1551, -62.1977, -61.4997, -61.8803, -62.8632, -62.6507, -64.4642, -65.4172, -67.8877, -66.9920, -67.1846, -68.2683, -68.1336, -67.2179, -69.7033, -67.5823, -67.7518, -67.9741, -66.1238, -69.2663, -70.4179, -70.5379, -71.7252, -74.1830, -71.4631, -70.5578, -70.3988, -71.8276, -74.1107, -74.1581, -74.1383, -73.1361, -73.4903, -73.6285, -74.5902, -75.0495, -74.9669, -73.5878, -75.2557, -77.4770, -77.1695, -77.0392, -78.2359, -77.1843, -77.9869, -78.4640, -77.7808, -76.0756, -77.4267, -78.5382, -77.8257, -79.6904, -79.2474, -79.0339, -80.8271, -82.1756, -81.2372, -80.3680, -81.3782, -80.5859, -82.1827, -83.3545, -82.7196, -82.3807, -82.9132, -82.8841, -83.2870, -84.8747, -83.7421, -83.5547, -84.2455, -84.9816, -84.9174, -84.6134, -84.9609, -85.3250, -85.1908, -85.1222, -84.8961, -85.2920, -84.6963, -85.9716, -85.6658, -86.0113, -86.1709, -85.6985, -86.0698, -86.2141, -86.6256, -85.9255, -86.2158, -86.1326, -86.5340, -85.6124, -86.2315, -86.0300, -84.3389, -64.5105, -57.6067, -56.0955, -52.3947, -52.7795, -48.1865, -37.5887, -37.2363, -36.1421, -34.6529, -30.6537, -29.3705, -31.9561, -36.6534, -33.9529, -30.1202, -31.3167, -29.7904, -28.1074, -29.1746, -31.1748, -33.7411, -37.6415, -40.4024, -41.5114, -30.2848, -29.5655, -33.2726, -31.9023, -32.1542, -30.8396, -31.8749, -32.0100, -31.5782, -31.7254, -33.3744, -36.9241, -42.9687, -43.3742, -38.6443, -37.0938, -35.7511, -36.0746, -37.4070, -36.4860, -34.3163, -36.0377, -39.6962, -44.0527, -43.5424, -42.5837, -44.8764, -45.7807, -50.3799, -49.7862, -48.2988, -49.6839, -47.3865, -46.1583, -47.2155, -46.6388, -46.4331, -48.4505, -49.5956, -50.1017, -49.6352, -50.1613, -50.3753, -52.0410, -54.8765, -54.6701, -53.1589, -53.1844, -52.5777, -53.2188, -51.8332, -50.2312, -51.6274, -53.8981, -51.8980, -53.2085, -52.5608, -55.5990, -56.8359, -59.2821, -60.6240, -58.0796, -57.2604, -56.7022, -53.5061, -54.7433, -54.7561, -54.3806, -55.8494, -57.9348, -54.6991, -54.6416, -55.9707, -60.0473, -64.0714, -65.9224, -65.7035, -60.1547, -57.9675, -57.8205, -56.2905, -57.5495, -59.1941, -58.3066, -60.6195, -59.1059, -57.7060, -57.8802, -60.6239, -63.7492, -64.5504, -70.6506, -69.6067, -61.7313, -57.8345, -59.6575, -60.7599, -61.4223, -59.9058, -59.7707, -63.2129, -62.5150, -56.0882, -48.7252, -46.0656, -43.9412, -45.3146, -47.7139, -53.1935, -55.9729, -51.2779, -49.2350, -49.2348, -49.9131, -51.8426, -52.1245, -52.6536, -40.1780, -41.3287, -40.3014, -37.5352, -35.9410, -38.1272, -40.1576, -43.0497, -40.3686, -38.7119, -35.4679, -32.1433, -32.3498, -31.7752, -30.1259, -28.1390, -29.4683, -28.4459, -27.2902, -31.6964, -33.9455, -34.6589, -31.2893, -30.5662, -35.8892, -28.2668, -33.2902, -31.2394, -31.9110, -32.9627, -27.5490, -27.8714, -31.5131, -31.2722, -31.9488, -33.9461, -33.2511, -35.9648, -37.9812, -39.6202, -44.2126, -42.0540, -33.9291, -34.7273, -36.3936, -36.5773, -31.6208, -28.5203, -30.8227, -32.4189, -33.8428, -32.3425, -31.6888, -31.4539, -32.5519, -34.1336, -32.7373, -37.0048, -39.1991, -41.5463, -43.9290, -43.5950, -38.2093, -35.5916, -35.3948, -39.7469, -41.5237, -37.3975, -37.0192, -37.9327, -40.3916, -40.8562, -40.3458, -45.2153, -47.1937, -48.7525, -50.7268, -50.3668, -46.9055, -45.3749, -46.6919, -48.3365, -49.6277, -47.6634, -49.6587, -50.2450, -50.1640, -48.9061, -44.6269, -49.0086, -50.3513, -54.1118, -56.2864, -55.0942, -53.3162, -52.0312, -53.0456, -55.6782, -55.6246, -54.3433, -55.2754, -56.5606, -55.6240, -54.9416, -53.6429, -57.6414, -57.8229, -61.3753, -61.7590, -60.0987, -57.8121, -59.4582, -60.6805, -59.7175, -61.4473, -60.5764, -61.7230, -61.1386, -60.4157, -60.3519, -57.9632, -61.8911, -60.7837, -49.2333, -51.5430, -51.9315, -54.7283, -59.1140, -59.9034, -58.7949, -58.1849, -56.9147, -56.2154, -53.9731, -52.1617, -55.4946, -53.0160, -55.8225, -57.2740, -51.2720, -50.3017, -51.6033, -53.8578, -60.1336, -63.7107, -61.9459, -58.0624, -57.6416, -56.0512, -54.5478, -55.0900, -55.9873, -57.0275, -57.3870, -59.3457, -56.1421, -52.4242, -50.9911, -48.1206, -50.7219, -54.7399, -55.9061, -56.4956, -54.3733, -57.2045, -57.5685, -56.3572, -55.6258, -53.3447, -50.2747, -48.8776, -48.7576, -46.1666, -47.1427, -48.1514, -47.5642, -49.5844, -51.0237, -54.0460, -53.6811, -55.9543, -55.4654, -54.5091, -55.7659, -54.3589, -53.4588, -51.6314, -52.8729, -52.2302, -50.3186, -46.3135, -45.4759, -42.6746, -41.1302, -32.0945, -29.7052, -32.1690, -37.9051, -38.3878, -38.6109, -41.8797, -42.4563, -33.7374, -27.9232, -30.3489, -32.2439, -28.4369, -27.1557, -27.3201, -30.5415, -33.7137, -35.0401, -34.6064, -32.6192, -31.2136, -30.8434, -30.3950, -33.0238, -33.1022, -34.6259, -31.7317, -28.4228, -30.1060, -30.6070, -29.2294, -26.0591, -26.2044, -30.9122, -30.4163, -28.7644, -28.0132, -28.7849, -30.9009, -31.1532, -32.9380, -32.8450, -32.2315, -31.4286, -33.9412, -35.8669, -36.5317, -35.3277, -36.7994, -37.0624, -37.8940, -38.6553, -39.1770, -40.7709, -41.2741, -42.1062, -43.5320, -45.3232, -43.5159, -42.6572, -44.5492, -45.5934, -43.2409, -43.7775, -44.7241, -47.6487, -46.6878, -47.0805, -43.9867, -42.5247, -41.9602, -39.1174, -39.2224, -44.1390, -46.0028, -47.0989, -47.3130, -46.5176, -44.1961, -43.4522, -44.2188, -48.8161, -50.1333, -49.9521, -48.5987, -47.3369, -43.5642, -42.5155, -45.0879, -47.9068, -48.2364, -47.2730, -48.3093, -48.9708, -47.2316, -47.9964, -49.8298, -55.5401, -55.7842, -52.9756, -52.5989, -51.4198, -50.7216, -51.7057, -51.3314, -51.7553, -51.1741, -50.9406, -54.2830, -54.1179, -53.9590, -53.7311, -54.5275, -59.5050, -61.1685, -57.9668, -57.0075, -56.0623, -55.6894, -55.5731, -56.0115, -56.2536, -56.2513, -58.7677, -61.6557, -60.1909, -59.5783, -62.3204, -62.0802, -68.0743, -67.0054, -63.8764, -64.3267, -63.2550, -61.9811, -63.3938, -62.7635, -62.5269, -63.4026, -61.9622, -61.9022, -63.8049, -64.4432, -66.3412, -69.5709, -73.7277, -72.4714, -69.3608, -67.8137, -66.9409, -64.4410, -65.7047, -65.9207, -70.1319, -70.2859, -66.6352, -65.0125, -66.8573, -70.6091, -73.4351, -76.0286, -79.6642, -76.3111, -74.8490, -73.4005, -73.2546, -71.2791, -71.3142, -73.4088, -73.3251, -77.7067, -75.8505, -74.4743, -75.7149, -78.4682, -78.5369, -80.5561, -82.7503, -80.5612, -80.9319, -78.9297, -78.9104],
        gain: -3
      }, {
        buffer: 'sounds/co-mix/soundscape_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 5,
        intensity: [-134.424, -134.721, -134.628, -134.802, -134.080, -134.816, -135.043, -134.332, -134.269, -134.227, -135.558, -135.341, -134.956, -134.799, -135.510, -134.958, -47.1388, -38.7786, -37.0434, -35.2597, -33.5433, -31.7800, -29.2378, -27.3676, -27.3483, -25.3739, -24.0089, -22.5675, -21.3316, -20.5113, -29.7062, -28.5372, -27.7408, -25.4373, -23.5978, -22.7876, -21.1769, -18.7337, -18.4247, -17.2847, -16.8813, -15.8505, -14.8888, -13.5132, -12.1508, -11.5213, -11.3719, -9.91284, -8.26478, -7.53782, -7.27574, -5.97496, -5.76845, -15.5413, -15.4212, -13.9870, -12.5092, -12.1221, -9.20449, -9.55219, -8.79339, -7.90568, -7.38204, -6.34308, -6.46124, -5.07017, -4.76887, -5.18489, -4.36084, -4.08792, -4.04938, -2.94966, -3.08898, -2.79700, -1.59724, -2.36335, -11.0288, -12.4400, -11.5954, -10.7139, -10.4046, -10.1569, -9.17481, -8.65543, -7.28011, -6.71718, -6.34829, -5.32406, -5.46358, -4.80172, -4.85180, -3.65912, -3.48228, -2.72215, -3.00277, -2.77643, -1.38558, -1.37385, -1.49263, -9.85042, -11.4954, -10.7158, -10.1691, -10.1056, -8.17024, -7.16194, -8.24157, -6.13870, -6.75359, -6.35561, -4.96126, -5.37478, -4.42471, -4.39235, -4.87412, -3.65639, -3.71980, -3.95647, -2.83096, -3.35349, -3.40083, -1.96105, -10.2589, -12.8995, -11.7320, -10.7068, -10.7762, -9.29634, -8.75817, -8.56397, -8.55838, -7.16002, -7.37567, -6.81824, -6.24024, -5.13475, -6.19371, -5.13440, -5.58490, -5.11520, -4.80579, -4.53131, -4.29137, -3.80607, -3.65590, -10.3411, -13.8929, -13.0429, -13.1218, -11.9299, -10.5712, -10.1857, -9.67277, -9.48256, -9.03354, -8.00061, -8.76150, -7.15911, -7.60472, -7.39437, -5.97349, -6.52723, -6.34802, -6.33500, -5.39231, -5.50097, -5.02792, -5.18890, -11.9818, -14.4596, -14.2043, -13.1121, -12.8393, -12.1283, -11.6757, -10.9269, -10.1175, -10.0611, -9.87268, -8.68834, -9.85308, -9.25524, -8.33618, -8.16159, -8.50329, -7.71186, -7.16951, -7.04302, -6.99151, -6.14804, -6.04210, -11.6215, -16.7075, -16.0610, -14.3478, -14.6079, -14.3748, -13.0137, -12.6418, -12.0454, -11.2836, -11.7047, -11.0946, -10.4025, -10.4745, -10.1934, -9.10684, -10.2800, -8.75703, -8.91663, -8.62452, -8.85978, -7.24532, -7.51082, -12.6262, -18.2552, -17.3978, -16.3396, -15.7185, -15.4172, -14.9790, -14.3056, -13.8009, -13.8094, -13.1168, -12.6017, -12.6888, -11.1627, -11.4074, -11.4975, -10.9499, -11.3171, -10.3522, -10.1853, -9.60546, -9.59638, -9.21894, -13.0924, -19.3727, -18.7534, -18.6021, -17.5119, -16.7059, -16.3950, -16.1118, -15.3703, -14.9886, -14.4812, -15.3305, -13.3977, -13.2470, -13.1346, -13.6198, -11.8746, -11.9496, -11.7487, -12.1834, -11.4981, -11.0792, -11.2288, -14.3103, -21.4521, -21.0416, -20.2811, -19.8555, -19.5436, -19.4834, -18.6214, -17.8891, -16.5754, -16.6524, -15.5803, -15.7436, -16.2990, -14.8952, -15.4608, -14.6768, -14.4557, -14.9832, -14.6448, -13.5850, -13.5855, -13.3180, -15.7234, -24.4858, -23.2711, -22.8708, -22.4938, -21.7579, -20.8111, -20.0660, -19.7828, -19.7461, -18.3869, -18.3821, -18.1824, -18.4627, -18.5739, -17.1739, -18.0779, -17.1683, -16.6892, -16.3730, -16.5951, -16.2212, -17.2801, -18.0772, -26.6918, -25.5857, -25.4695, -25.1000, -24.5020, -23.3619, -23.0578, -22.0471, -22.6709, -21.7709, -22.2265, -21.9445, -21.4331, -21.4922, -20.8294, -20.6488, -20.6554, -20.5689, -20.1175, -20.3265, -19.7568, -20.1259, -21.9454, -30.7115, -29.9865, -28.7640, -28.8563, -28.2467, -27.8501, -27.8462, -26.4897, -26.7498, -26.9606, -27.4004, -25.9008, -26.3953, -26.1551, -25.6055, -26.2661, -25.4715, -26.1475, -25.9799, -25.9802, -25.9446, -25.7608, -27.9237, -37.2513, -36.0401, -35.6998, -35.4539, -35.4647, -35.1581, -35.4588, -35.5204, -34.8928, -35.9115, -35.2384, -36.8670, -35.9399, -37.0171, -37.6042, -37.6092, -37.7770, -40.5074, -41.4768, -42.3403, -44.5980, -46.3892, -47.3005, -51.6308, -50.8691, -50.3505, -49.8692, -49.9239, -50.0907, -49.5175, -49.7440, -49.5275, -49.6664, -49.4726, -52.7406, -54.3073, -53.4957, -53.3051, -53.1737, -52.7820, -52.5471, -52.5550, -52.0829, -52.0315, -51.6111, -52.2870, -56.9871, -56.6909, -56.3134, -56.0176, -56.8224, -56.1376, -55.8006, -55.6901, -55.9258, -55.8530, -55.5106, -57.0985, -59.3509, -58.3446, -58.4291, -57.8666, -57.6882, -57.9571, -57.6658, -57.0724, -57.7599, -56.9402, -57.8287, -62.1302, -61.6555, -61.5612, -61.3872, -60.5391, -60.6173, -60.1812, -60.5420, -59.8786, -59.8918, -59.1388, -62.8182, -64.2928, -64.6950, -63.7485, -64.7708, -64.4136, -63.6551, -63.6679, -63.7014, -63.3539, -63.9689, -63.0574, -67.1811, -66.8425, -66.0813, -65.8625, -65.8558, -65.8351, -65.4393, -65.7259, -65.1310, -69.4404, -134.911, -134.827, -134.869, -134.368, -135.079, -135.172, -134.760, -134.467, -134.539, -135.152],
        gain: -3
      }]
    }, {
      name: 'flute',
      layers: [{
        buffer: 'sounds/co-mix/flutes_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 4,
        intensity: [-86.7140, -86.0111, -86.7968, -85.7716, -47.1951, -42.5284, -41.8006, -37.3438, -33.6755, -32.9206, -35.5551, -44.0069, -40.3344, -37.9089, -36.4979, -36.6922, -36.8896, -43.2903, -29.2137, -24.8089, -22.8030, -22.2097, -22.4048, -27.0546, -27.5930, -28.0897, -30.5758, -29.1310, -28.1637, -26.3948, -26.3250, -26.5674, -25.9352, -25.3465, -26.2770, -26.9965, -26.5641, -27.5430, -29.0106, -29.7814, -30.2792, -29.8440, -30.6087, -32.1818, -32.5930, -31.8257, -32.5594, -34.9273, -31.4167, -28.3739, -28.1624, -28.9715, -36.7276, -42.0948, -38.9587, -35.6363, -34.3320, -34.1619, -35.6902, -41.6024, -43.0343, -42.3222, -43.1620, -47.3579, -48.5909, -46.4086, -45.6286, -39.0292, -36.9529, -39.7826, -41.2647, -38.5089, -37.0834, -38.3598, -27.3655, -24.0796, -24.0995, -25.3276, -27.3760, -26.0117, -23.8491, -23.6150, -26.7443, -34.7930, -31.2671, -27.4338, -27.9448, -28.7593, -29.8993, -33.8872, -34.8916, -34.8928, -31.4916, -29.7060, -31.0869, -34.3296, -35.5048, -35.0726, -34.2386, -35.0323, -34.7008, -36.9763, -38.0601, -37.4757, -32.5133, -30.6935, -28.8376, -29.3883, -28.9184, -28.8041, -28.9209, -33.9845, -28.6343, -28.1067, -26.8014, -26.9459, -26.7128, -25.8054, -25.4703, -26.5972, -27.2267, -26.9902, -28.3271, -29.6434, -30.0894, -30.2384, -30.5324, -31.8441, -33.7496, -36.4180, -36.4912, -32.4687, -29.1781, -29.5506, -34.1932, -40.9052, -41.3511, -41.7162, -39.2200, -36.8351, -37.6179, -37.3796, -36.3690, -36.6445, -35.5217, -36.8956, -46.7421, -45.7489, -43.6025, -45.6623, -45.4378, -45.2543, -46.5899, -45.4591, -40.8641, -39.1847, -37.9495, -39.1887, -46.9954, -29.5803, -24.4605, -23.9199, -24.7811, -30.8185, -26.0839, -23.8546, -22.9637, -25.8123, -33.2844, -30.4739, -27.4401, -26.3855, -27.3925, -33.7730, -34.4760, -33.5860, -31.9337, -30.8843, -30.1730, -31.3118, -31.8775, -33.6092, -34.2577, -32.4879, -33.3928, -36.5417, -39.1893, -36.9801, -33.0859, -30.1091, -29.4081, -29.4174, -28.9144, -29.0192, -34.8370, -38.5655, -29.2506, -28.5224, -27.2352, -27.1479, -27.0227, -26.0981, -25.2883, -26.0983, -27.1453, -26.7033, -27.7994, -29.4573, -30.0557, -30.3691, -30.6274, -31.3405, -32.8795, -34.2120, -36.9676, -32.0523, -32.9236, -32.5338, -28.8785, -34.8785, -40.2015, -39.1713, -37.0526, -35.4888, -36.9559, -36.8034, -37.9987, -44.1287, -43.8313, -44.7842, -47.6096, -48.5331, -49.0080, -48.4516, -47.8857, -48.2990, -50.4068, -48.6256, -45.6224, -40.9344, -39.0153, -37.9178, -38.6056, -43.5710, -27.2579, -24.0377, -24.0733, -25.8913, -27.9755, -25.3302, -23.4298, -24.1985, -31.6647, -36.0491, -32.5500, -27.4967, -28.0931, -28.7901, -31.5990, -34.3069, -34.5961, -35.4436, -31.4079, -29.7474, -32.0331, -34.2835, -34.9595, -34.8909, -34.9786, -34.9788, -35.6443, -37.3985, -37.4717, -32.8629, -30.4832, -29.0277, -29.5706, -28.7959, -28.9936, -33.3512, -29.5721, -28.6488, -27.0169, -26.4093, -26.7769, -26.0283, -25.4792, -26.0984, -27.1063, -26.9490, -27.8857, -29.2005, -29.9488, -30.2094, -30.3076, -31.1387, -32.8516, -33.2812, -31.7240, -32.2067, -35.1892, -38.4521, -37.8144, -34.7559, -33.0477, -31.9620, -33.8677, -38.8005, -36.5951, -36.0461, -36.7556, -35.4106, -38.2804, -45.9382, -45.3901, -43.8136, -39.9280, -38.0653, -37.9255, -36.8701, -36.3245, -40.8172, -38.9326, -37.3889, -28.8920, -27.3222, -27.5252, -28.0434, -23.8656, -23.5386, -24.3248, -25.8755, -25.0277, -27.1335, -24.9241, -23.4546, -24.9126, -28.1152, -36.0781, -30.9368, -27.8939, -27.4556],
        gain: 5
      }, {
        buffer: 'sounds/co-mix/flutes_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 16,
        intensity: [-86.9238, -86.5842, -86.2927, -86.3965, -86.1308, -86.7846, -86.2188, -86.5125, -86.2812, -86.2972, -86.4709, -86.3296, -86.1534, -86.5740, -54.9849, -34.9818, -33.6189, -24.7755, -23.3260, -23.7708, -26.3447, -31.9350, -33.8717, -29.3506, -29.7845, -33.6296, -28.1540, -23.7374, -23.8995, -25.9221, -25.2763, -28.9962, -33.1863, -31.2881, -28.9150, -31.9780, -31.1357, -25.7411, -23.6219, -23.7382, -24.7396, -25.7451, -30.9552, -33.6197, -30.0604, -29.5992, -33.2233, -31.3507, -25.8855, -23.3893, -23.3129, -25.4281, -25.8466, -25.5889, -25.9452, -26.9036, -28.0363, -28.5160, -26.2800, -27.0664, -25.8237, -25.8152, -28.8200, -28.7313, -28.2339, -24.5729, -25.0657, -24.1682, -24.3600, -24.9532, -25.0670, -25.0237, -27.8349, -27.6103, -26.9156, -29.8916, -25.4956, -28.4011, -27.6361, -29.2890, -27.4033, -25.9746, -25.9984, -25.1109, -25.1185, -35.0676, -37.9724, -35.9668, -37.4409, -38.5904, -40.5139, -41.4743, -40.3785, -41.3182, -40.0791, -40.3641, -40.4980, -40.0565, -39.9617, -40.4928, -41.4668, -43.2550, -43.5079, -46.4685, -46.6858, -47.6016, -48.5283, -48.2842, -47.6965, -47.9401, -48.7768, -48.8708, -49.8307, -51.4237, -52.4964, -55.9710, -56.9028, -57.7683, -59.0448, -56.5072, -56.1937, -56.1902, -57.2433, -60.1781, -59.7477, -58.9563, -58.5567, -57.8001, -59.0417, -61.2665, -62.0170, -60.5208, -60.7542, -62.5763, -63.7807, -65.6299, -66.0621, -66.6928, -68.3706, -68.4252, -66.4404, -67.0473, -66.8440, -67.1496, -67.0076, -68.7265, -69.6731, -69.2355, -67.9619, -69.1365, -71.7735, -74.3249, -77.6081, -76.7778, -74.5617, -73.0601, -73.5113, -73.4914, -74.3712, -74.6148, -76.0716, -79.7539, -80.4190, -79.9344, -79.4570, -81.0663, -81.7864, -79.5364, -80.1896, -79.1082, -79.6308, -82.9219, -83.1875, -81.7653, -82.3729, -83.1051, -83.0949, -83.3280, -85.3378, -85.5584, -84.6300, -85.4904, -85.7871, -85.7327, -38.5104, -35.1946, -27.2905, -24.0464, -23.4529, -24.5301, -29.9434, -35.0577, -30.3850, -28.7497, -30.9922, -33.1170, -30.7702, -25.5327, -23.4464, -24.3669, -26.6401, -31.6301, -33.6585, -29.7091, -31.6981, -29.7659, -25.0842, -24.2601, -24.9211, -25.3474, -26.8196, -27.4374, -32.6654, -31.1843, -29.5792, -34.2022, -29.5878, -24.0532, -23.6809, -26.3582, -24.7734, -25.8539, -24.9997, -27.0760, -28.3032, -28.8945, -28.2617, -26.4695, -25.5384, -26.3482, -26.8113, -27.1374, -28.1512, -30.4289, -25.6777, -25.1308, -24.4001, -24.4890, -24.2295, -25.3889, -24.1146, -27.1388, -27.0038, -25.7255, -29.8679, -26.2422, -27.0743, -27.8344, -28.7268, -30.8162, -29.2925, -28.3157, -27.6576, -27.8175, -33.0263, -36.3402, -36.4988, -37.6057, -38.0226, -39.3049, -39.9099, -40.5523, -41.4358, -43.7269, -42.5649, -43.7230, -44.1411, -42.6833, -42.6223, -41.8653, -44.8544, -44.5972, -46.1979, -50.2391, -48.7003, -49.9346, -50.8836, -48.4186, -50.3128, -51.2191, -50.6160, -51.7579, -52.1330, -52.6545, -56.2644, -58.5331, -59.0438, -57.8833, -54.8912, -55.4574, -55.3791, -57.3004, -59.4114, -58.5147, -55.5893, -56.7067, -60.2078, -64.4257, -65.9958, -65.4048, -65.5753, -67.8208, -68.4160, -67.1590, -69.0343, -67.7023, -64.4997, -65.5599, -64.0483, -65.5479, -65.5024, -66.5782, -65.3806, -64.8526, -66.8463, -71.2248, -71.2682, -69.6397, -70.2318, -72.1781, -72.0124, -74.5982, -72.2565, -70.6956, -70.2352, -70.1804, -72.0360, -74.3891, -76.5540, -79.2818, -81.1326, -78.5482, -75.9727, -77.8102, -77.6450, -76.2824, -77.8789, -79.9755, -80.0350, -81.2354, -80.4513, -81.7262, -83.2156, -83.4499, -83.4548, -84.3729, -86.0524, -85.7159, -85.3785, -84.1978, -84.3198, -84.8526, -86.0603, -49.5944, -34.8153, -32.3990, -24.5523, -23.2643, -23.8869, -27.0960, -32.5004, -32.9659, -29.9732, -32.4885, -26.7746, -23.4647, -24.1682, -25.1400, -25.4388, -25.8173, -28.0556, -35.7022, -30.2172, -29.0851, -32.0668, -30.8545, -25.2483, -22.9434, -24.5223, -26.0117, -27.3600, -31.0952, -33.9635, -29.9301, -32.1294, -28.9473, -23.6881, -23.4201, -24.3650, -24.7175, -25.5568, -25.3837, -26.4656, -26.9642, -28.0630, -29.3845, -26.4816, -27.0230, -26.4814, -25.5972, -27.8145, -26.8244, -29.7896, -27.8411, -24.5998, -24.9176, -24.1291, -24.1911, -25.1451, -24.7378, -25.5466, -27.7118, -27.2477, -27.4858, -28.9995, -25.6309, -34.4605, -33.2667, -25.5156, -26.2686, -24.6612, -25.4696, -25.8721, -24.8522, -22.6930, -23.5010, -26.2835, -35.3115, -37.8994, -37.5873, -38.1891, -38.4737, -39.4723, -40.1209, -37.2338, -37.7519, -38.4744, -39.2989, -40.5706, -40.1677, -40.7714, -42.0579, -43.8998, -44.2524, -46.6767, -46.6928, -46.1717, -47.8937, -48.3720, -46.6274, -45.8114, -46.9626, -49.9067, -53.1502, -54.6631, -54.9445, -55.2725, -55.9767, -55.2400, -56.2680, -54.4077, -57.2555, -57.8310, -58.0430, -59.7625, -59.3658, -57.6660, -54.5320, -55.8399, -59.4032, -61.4534, -59.2022, -58.8181, -60.1778, -62.8326, -63.8510, -65.7754, -68.5962, -67.4955, -67.5306, -64.5232, -65.0400, -65.8970, -65.7285, -65.5507, -65.6037, -67.3314, -69.1822, -68.5167, -68.5688, -69.6710, -72.2881, -74.5206, -74.1499, -72.1732, -70.8629, -70.7525, -73.7437, -75.6089, -74.7415, -75.9490, -78.4416, -79.4102, -78.8850, -77.1379, -78.5170, -81.3507, -78.0183, -78.4154, -79.1321, -77.9511, -80.0285, -83.1201, -81.8774, -80.5256, -82.4227, -83.6830, -82.3185, -84.3747, -86.0121, -84.3541, -84.9146, -81.7642, -37.0169, -35.1739, -26.3228, -23.8318, -23.5235, -24.8460, -30.5260, -35.3384, -30.0209, -29.7647, -33.0290, -26.4207, -23.9061, -24.6507, -25.5065, -25.6216, -26.6015, -31.1084, -32.6718, -29.2535, -32.6342, -27.8222, -24.1270, -23.7713, -24.9704, -25.0160, -26.1195, -28.2111, -33.2760, -30.6681, -28.9791, -30.8808, -32.5973, -33.4150, -25.5311, -23.5092, -23.8367, -25.6999, -26.0152, -25.8407, -25.7444, -27.5455, -27.7490, -28.2850, -27.3995, -27.3717, -25.5822, -26.0895, -30.0736, -29.0404, -25.1087, -25.1025, -24.2517, -24.4544, -24.4066, -25.5470, -24.1162, -27.5985, -26.9876, -25.8459, -30.4159, -25.7278, -27.5754, -27.6799, -29.5841, -33.2329, -33.3917, -32.4868, -32.9191, -32.2102, -32.7671, -32.7594, -31.6701, -32.7578, -33.5237, -40.0755, -41.5070, -40.3146, -41.0316, -42.9026, -43.1896, -45.3407, -45.4685, -43.9486, -43.8421, -43.0814, -45.3037, -44.5013, -45.4261, -48.1904, -47.8286, -48.7212, -49.7142, -47.3592, -49.1915, -51.3337, -51.5750, -51.0545, -52.3436, -52.2517, -56.0398, -56.4306, -58.2582, -57.8688, -57.0869, -57.1154, -55.5251, -58.6231, -58.9417, -58.6962, -58.4987, -58.7767, -61.6082, -64.0211, -64.3276, -65.1227, -66.6978, -67.4569, -67.2723, -67.1318, -67.9586, -66.0175, -64.7169, -66.6337, -69.2896, -70.7594, -71.1768, -70.3466, -70.4322, -70.4316, -70.6477, -71.9709, -74.0591, -73.3471, -72.9942, -75.2216, -74.7083, -76.1371, -76.9400, -78.1101, -78.0700, -78.0528, -77.0763, -77.4708, -79.4457, -79.5133, -79.9092, -80.2883, -80.1741, -80.4855, -81.1992, -82.3960, -81.9263, -81.4951, -82.8357, -83.9135, -84.1624, -84.7635, -83.2654, -84.2376, -84.5197, -84.5390, -85.1785, -85.5702, -85.8404, -85.5644, -85.7086, -85.9161, -86.1015, -45.5690, -34.8370, -30.9821, -24.4233, -23.2715, -24.0150, -27.8917, -33.1435, -32.1117, -28.9976, -32.0512, -30.7696, -25.0145, -24.3481, -25.6248, -24.8053, -26.8121, -28.7368, -32.8778, -30.2896, -30.6982, -31.1605, -26.6088, -23.6261, -24.4505, -26.5964, -26.4028, -26.3842, -31.0565, -33.5031, -29.5253, -30.1046, -31.8154, -33.1885, -26.8898, -23.0989, -23.8900, -25.0255, -25.3663, -25.5176, -25.0832, -26.6586, -28.0501, -28.9896, -27.6031, -26.7166, -25.6486, -26.3180, -28.1830, -29.7311, -27.2095, -24.6740, -24.7078, -24.1515, -24.0485, -25.2711, -24.5460, -26.0915, -27.2524, -26.6646, -28.2005, -27.9263, -26.5998, -38.4670, -37.6615, -37.7849, -35.9173, -34.0460, -32.8585, -32.9663, -33.5132, -39.5500, -40.1088, -39.0172, -41.6325, -42.8478, -43.5574, -42.7423, -41.4056, -44.8245, -46.4737, -47.0991, -48.1897, -45.3661, -46.1061, -46.7762, -47.1141, -47.9857, -47.6735, -51.5171, -50.6878, -54.2596, -52.6206, -52.8645, -52.7678, -52.2647, -54.9157, -53.3332, -53.1578, -55.9342, -58.6976, -59.6630, -58.8519, -59.3298, -60.1898, -59.8929, -60.5015, -61.3236, -63.0154, -64.2693, -61.3574, -61.9819, -65.5081, -68.4585, -67.2961, -69.3103, -69.3043, -69.8988, -70.8417, -70.6408, -70.1581, -68.4418, -67.4931, -71.4258, -72.9785, -74.1121, -76.2393, -75.4837, -74.1812, -73.8809, -74.8473, -75.9106, -77.0587, -75.9656, -77.1657, -78.1460, -78.0516, -77.9660, -80.1480, -78.5857, -80.2019, -82.8588, -81.0687, -78.4526, -81.6131, -81.5465, -81.4326, -84.2981, -82.6539, -83.1058, -83.7840, -84.2922, -84.0962, -83.9676, -84.1374, -84.6757, -85.1660, -85.5080, -84.4826, -84.4935, -84.9419, -85.6067, -86.1808, -86.6883, -86.7223, -86.2169, -86.2626, -86.1989, -86.2872, -69.8718, -35.9683, -34.9193, -25.5842, -23.6129, -23.5995, -25.2710, -31.0410, -35.1443, -29.9198, -32.0296, -28.5420, -23.7353, -23.8955, -24.7740, -25.1410, -26.2626, -26.2054, -34.4656, -31.6261, -29.1048, -31.0253, -32.9156, -26.7525, -23.1571, -23.6303, -26.4451, -26.1308, -29.3384, -34.2946, -30.6258, -30.4407, -31.8366, -24.6406, -23.2061, -23.5991, -24.9909, -25.6461, -25.6168, -25.7363, -26.7773, -27.6279, -29.0224, -27.4556, -27.1597, -25.8639, -26.0601, -27.8942, -26.4805, -28.8343, -29.5199, -24.8568, -25.0659, -24.1382, -24.3845, -24.6470, -25.4374, -24.3154, -27.9097, -27.5193, -25.9801, -30.6020, -25.5370, -28.0529, -27.7132, -29.4164, -31.4477, -28.6508, -28.1437, -27.6065, -30.1830, -35.8019, -37.4101, -36.6712, -37.4522, -38.9216, -39.8759, -40.9511, -40.5188, -42.8592, -42.8911, -42.3361, -44.5928, -43.8729, -42.5422, -42.0438, -42.9798, -45.4119, -44.8163, -47.2322, -49.6066, -49.4761, -50.4774, -50.5670, -48.5249, -49.7935, -51.4115, -51.1531, -52.0177, -52.8122, -52.8513, -57.4113, -58.1696, -58.3381, -57.0948, -55.3174, -56.1031, -55.3910, -57.7935, -60.1289, -57.4222, -55.7341, -58.0015, -61.1401, -66.5029, -65.1551, -65.2903, -66.9081, -69.0893, -66.7540, -68.3160, -68.6574, -65.6833, -64.9500, -64.6991, -64.5848, -65.8258, -66.7151, -66.7713, -65.4243, -65.8004, -69.5089, -71.3676, -71.5890, -69.7951, -71.4860, -71.9835, -73.4795, -74.5591, -72.0886, -70.9333, -70.2108, -71.0750, -73.4679, -75.6196, -77.8604, -79.5839, -80.5189, -76.6487, -77.2521, -78.3942, -76.3083, -77.5289, -78.9099, -80.7753, -80.9113, -80.9010, -80.6723, -82.9096, -83.0540, -82.9065, -83.9868, -85.0309, -86.0763, -84.2131, -37.3580, -35.1967, -26.5516, -23.8895, -23.5053, -24.5121, -25.5962, -25.7967, -25.4472, -25.6406, -26.9634, -30.5164, -35.3457, -32.2705, -33.2454, -27.4104, -22.9428, -23.5251, -24.8424, -24.9206, -25.9621, -25.4736, -32.6639, -34.4631, -30.1109, -31.8386, -30.3256, -23.8853, -23.4473, -24.8015, -24.5644, -26.2385, -26.2445, -32.5381, -32.6300, -29.1315, -30.3867, -33.6255, -29.3678, -24.6050, -22.8620, -25.4637, -24.9360, -26.2059, -25.5075, -26.4256, -27.3122, -28.6865, -28.7835, -25.6684, -25.9809, -25.4794, -25.6370, -29.0320, -29.5217, -26.5308, -24.7634, -24.3981, -24.2975, -24.0722, -25.5080, -24.2759, -26.2574, -27.1142, -26.2041, -28.8358, -27.2509, -26.2737, -33.1143, -30.7878, -25.7735, -26.3207, -24.7891, -25.2237, -25.6256, -24.4541, -23.0531, -31.4603, -36.3769, -38.0636, -38.1749, -38.4406, -38.9984, -39.4669, -40.6676, -39.5167, -38.7559, -39.5104, -38.7476, -39.5786, -40.2245, -40.4082, -41.6300, -42.6243, -44.9123, -44.9436, -48.5731, -47.7143, -48.0447, -48.1810, -49.1583, -48.2156, -47.1141, -48.6987, -50.7674, -53.7162, -55.0202, -55.9455, -55.4697, -56.7880, -56.7715, -55.0452, -56.2201, -57.8966, -58.4654, -59.4701, -59.4367, -60.4153, -57.2917, -55.7051, -57.3215, -60.0725, -60.7030, -59.4129, -59.5261, -61.7301, -62.7557, -64.0214, -67.2171, -68.3043, -67.9413, -66.5344, -65.2767, -66.4098, -65.0732, -65.7489, -65.5734, -67.4994, -67.9888, -68.4502, -68.1200, -69.7490, -70.5531, -73.4296, -74.7916, -74.2631, -72.6884, -71.5952, -72.1297, -73.9858, -74.7409, -73.9042, -76.8581, -80.1769, -80.9623, -79.1623, -78.1692, -80.1504, -80.1642, -79.1110, -79.1475, -78.2525, -79.6260, -81.9174, -81.9697, -81.0612, -81.5566, -82.8955, -82.6137, -83.1907, -84.7482, -85.2269, -84.5864, -86.1013, -60.5496, -35.2916, -34.3377, -25.0580, -23.4279, -23.6891, -25.8236, -31.5334, -34.5300, -29.8606, -32.4638, -27.9321, -23.5624, -24.0048, -24.9206, -25.1777, -26.1288, -26.7280, -35.3683, -31.0263, -29.0111, -31.4445, -32.1660, -26.1528, -23.0409, -23.8560, -26.3035, -26.5555, -29.8774, -34.3114, -30.3014, -30.9877, -30.8984, -24.1616, -23.2776, -23.7757, -24.8874, -25.6893, -25.5885, -25.9548, -26.7735, -27.7234, -29.1162, -27.0019, -27.2177, -25.9756, -25.7539, -28.0461, -26.5152, -29.2060, -29.0080, -24.6760, -25.0641, -24.1056, -24.3078, -24.8308, -25.2934, -24.7113, -27.9993, -27.6510, -26.4249, -30.2846, -25.4423, -28.8461, -35.9316, -33.7887, -36.3594, -33.5767, -29.6541, -28.8006, -30.9795, -31.6648, -30.7252, -30.3135, -29.3885, -30.1348, -40.7137, -41.9536, -40.2267, -41.6937, -43.3126, -43.5901, -45.5049, -44.1152, -44.3856, -45.0520, -43.9290, -45.5596, -44.1935, -46.4259, -46.9606, -48.9860, -49.8737, -49.3219, -48.7015, -48.1405, -51.0023, -51.1434, -50.6061, -50.8303, -53.1361, -54.5988, -54.9800, -56.6519, -56.8414, -56.7408, -56.3180, -57.3170, -57.5270, -60.7219, -59.7031, -58.9170, -60.9927, -63.3639, -62.1833, -63.1643, -65.4738, -65.5279, -66.3047, -65.6084, -66.3506, -66.2087, -66.2599, -65.7398, -66.8033, -66.4419, -69.2275, -72.1977, -72.3257, -72.4158, -70.1155, -70.8313, -71.6096, -73.6007, -73.5506, -73.4826, -74.8958, -73.2583, -76.6630, -75.9893, -76.4617, -77.6175, -77.6448, -75.5475, -76.0161, -76.7305, -77.8254, -79.8230, -80.6065, -80.4773, -81.5338, -82.1039, -81.0047, -80.4960, -82.0394, -82.2449, -82.3237, -82.8066, -82.8994],
        gain: 5
      }]
    }, {
      name: 'guitar pad',
      layers: [{
        buffer: 'sounds/co-mix/guit_nappe_mode_1.wav',
        startOffset: 0.5 * 60 / 122,
        length: 8,
        intensity: [-86.3100, -86.5054, -85.9662, -71.9954, -41.4730, -30.7122, -28.1618, -22.0642, -20.2429, -19.6751, -18.6227, -16.7663, -15.4421, -16.0285, -17.3975, -20.1366, -23.5070, -26.3953, -26.6551, -28.2487, -27.6987, -25.4373, -24.5539, -25.3918, -26.6226, -26.7370, -25.9867, -25.2152, -25.5953, -24.7157, -25.3511, -26.1412, -26.4933, -26.7616, -25.8260, -24.0020, -22.3816, -21.6340, -19.5437, -17.3875, -15.6789, -15.8196, -16.6505, -20.0640, -24.3234, -23.4337, -26.8572, -22.6248, -23.9289, -23.8964, -23.5381, -23.4458, -23.4578, -23.7552, -21.9056, -25.3315, -22.3922, -22.0770, -24.0507, -23.6207, -24.6610, -26.9089, -28.2211, -25.1835, -29.0024, -28.8220, -26.4526, -25.3084, -26.9463, -26.1510, -27.1748, -29.2037, -28.5414, -27.9974, -29.6074, -27.1876, -26.9048, -26.4429, -26.8628, -25.8846, -25.3074, -24.8655, -26.6065, -28.5887, -31.9216, -31.1706, -32.5383, -34.4715, -33.8031, -32.9105, -33.1313, -32.7000, -33.3048, -34.8456, -34.4764, -33.2596, -31.9633, -31.5116, -33.5261, -34.6843, -36.5345, -37.3564, -37.7455, -36.8383, -36.2068, -37.4415, -40.5188, -38.1282, -37.9097, -40.1213, -37.3228, -35.2331, -33.5086, -32.6161, -34.9315, -36.8337, -41.6268, -43.4971, -41.2164, -39.4764, -38.2954, -37.5611, -34.9697, -36.6855, -39.1919, -42.5667, -42.8970, -40.6911, -36.8499, -38.9414, -37.5675, -38.0747, -37.4604, -36.3376, -35.7594, -35.6275, -35.4300, -35.2846, -34.7157, -34.4441, -33.9019, -33.5672, -32.8252, -32.2329, -32.2491, -31.6972, -31.7072, -31.4560, -31.1312, -30.4118, -29.9041, -29.9916, -29.9311, -29.1540, -30.0832, -29.0650, -32.3968, -31.3099, -30.7037, -27.5401, -26.7533, -30.4114, -28.1486, -30.2885, -26.7077, -28.7483, -27.6250, -31.2529, -28.2021, -32.2947, -30.0779, -31.3673, -31.1928, -28.5749, -33.2657, -27.7394, -29.6594, -32.5363, -28.3715, -29.9765, -29.4344, -30.8596, -31.0674, -31.1660, -31.0030, -32.2174, -31.7384, -33.2634, -32.9252, -33.2769, -34.4624, -33.2934, -34.2697, -34.0338, -31.6283, -32.7789, -31.8318, -31.6901, -32.3290, -32.2894, -33.4699, -31.9176, -32.7859, -32.7003, -30.2807, -31.8665, -30.7320, -33.8152, -34.6167, -35.5465, -33.3693, -35.3126, -31.7915, -35.5083, -36.8409, -32.3864, -32.1878, -32.3345, -33.4417, -31.6366, -29.1154, -29.9697, -32.2300, -34.3516, -33.6956, -33.7143, -34.5487, -35.3942, -34.4150, -31.8536, -31.1163, -31.2854, -33.9445, -33.5705, -33.7458, -31.6534, -29.5382, -29.9130, -30.3283, -31.9225, -34.5037, -35.5478, -35.6639, -34.7118, -35.6774, -30.5477, -28.3140, -28.5561, -30.8953, -34.3144, -34.5743, -37.4698, -35.6448, -32.8831, -31.8539, -34.1601, -35.0781, -34.6315, -34.2035, -34.2770, -34.0280, -32.4494, -34.3016, -36.7606, -39.6122, -40.2673, -39.5285, -39.9407, -35.7798, -36.6228, -39.4265, -40.5909, -38.5545, -40.8274, -39.0501, -41.1494, -39.4100, -40.3651, -45.9907, -43.2258, -42.9319, -45.5030, -43.0205, -42.0542, -41.8331, -40.4811, -39.5851, -39.7005, -39.8401, -38.7660, -38.0332, -41.9910, -43.6298, -43.1053, -39.4210, -37.0293, -33.3533, -30.4157, -29.0888, -23.6841, -21.5056, -21.6193, -22.3673, -23.4328, -24.4737, -25.2774, -24.4728, -22.8182, -21.6488, -22.9350, -26.1782, -28.5770, -30.3917, -29.3446, -28.1257, -27.5333, -27.7460, -27.5975, -26.4202, -25.4260, -26.1044, -25.4996, -26.2906, -25.7314, -25.2675, -25.0220, -25.3886, -22.1065, -21.2282, -20.4226, -19.3643, -17.5152, -16.3812, -17.7863, -19.8214, -21.0822, -22.7023, -22.8134, -23.9958, -23.7415, -23.8544, -22.8723, -24.9320, -26.3345, -25.3443, -25.1462, -23.9391, -22.7378, -23.6253, -24.8595, -24.2440, -26.1278, -27.0940, -28.3699, -27.3378, -27.9924, -27.4285, -28.7328, -28.5549, -29.9502, -30.0781, -27.7900, -27.7359, -27.4337, -31.3198, -29.1076, -26.9507, -30.7575, -30.7311, -29.1920, -29.0844, -31.2044, -29.5593, -30.9966, -29.3475, -28.8208, -29.6126, -28.6014, -26.1478, -26.1521, -30.0562, -30.7426, -30.3053, -31.3226, -31.4957, -29.3591, -30.6704, -30.7040, -26.4992, -25.9680, -27.8248, -29.3210, -30.6250, -31.2381, -33.8524, -31.8878, -31.1206, -33.7801, -35.4038, -35.9796, -32.7427, -31.6869, -32.7729, -31.5353, -28.6146, -28.3802, -30.3326, -32.0203, -32.4033, -31.9887, -31.1401, -30.7209, -30.4844, -30.4408, -33.8739, -36.0751, -37.6298, -34.9898, -36.0656, -34.9948, -33.4570, -36.4260, -34.2155, -32.2757, -30.1842, -29.5784, -27.8501, -29.0494, -31.0642, -31.9369, -32.4015, -39.6682, -38.9185, -35.3011, -33.7473, -34.7251, -34.5147, -35.4275, -31.6904, -31.2342, -31.2436, -31.1630, -31.3055, -33.8716, -36.0534, -37.8721, -40.1626, -38.0942, -41.4982, -39.4150, -37.8480, -40.6134, -36.8533, -38.1071, -35.3343, -34.5503, -37.6870, -37.7016, -39.6208, -41.1582, -41.5219, -43.9550, -41.8439, -42.5352, -41.8225, -43.1207, -42.4939, -42.5615, -40.0015, -40.5449, -40.3789, -40.1779, -39.1797, -38.4419, -38.2238, -38.2083, -38.0576, -37.5698, -36.9531, -36.0310, -35.8109, -35.4435, -35.2929, -35.2157, -35.1916, -35.4619, -35.5232, -35.5384, -34.9847, -35.0078, -34.8291, -34.4497, -35.0109, -35.2647, -34.2866, -36.6463, -36.1205, -35.1227, -33.0049, -32.6952, -35.8504, -32.1922, -35.2133, -33.6113, -34.8369, -32.7020, -33.8026, -33.6914, -35.8642, -34.4235, -35.4393, -33.8705, -35.6303, -35.8585, -32.4555, -33.9059, -33.5661, -32.5461, -31.1740, -29.6994, -30.9655, -30.0617, -30.7696, -31.1287, -32.2886, -31.8539, -33.6521, -32.7666, -31.4519, -30.1426, -30.1347, -31.0690, -30.7484, -29.9753, -30.0391, -30.1913, -30.0512, -31.6732, -31.5427, -31.3226, -30.6928, -30.0260, -32.5859, -30.8169, -32.0063, -29.0961, -31.2888, -31.7041, -32.6085, -31.5560, -33.6767, -28.5687, -32.3605, -33.8083, -29.7519, -28.8864, -29.5670, -31.5064, -29.9149, -30.4614, -28.7389, -30.1742, -30.5836, -32.2421, -33.1360, -33.1979, -32.2761, -31.6737, -32.5720, -32.9012, -32.1509, -32.5140, -33.0132, -31.2388, -30.3156, -28.9637, -28.9197, -30.9941, -32.5681, -34.3600, -36.2164, -34.7883, -32.9760, -32.4266, -31.8244, -31.9274, -31.8721, -33.9407, -32.9216, -34.7668, -34.9486, -35.2512, -36.9725, -36.1554, -33.4126, -33.9109, -36.7773, -36.4172, -35.4166, -33.6072, -31.9633, -31.7202, -32.8101, -37.1496, -39.7008, -38.2865, -38.1385, -38.0613, -38.4777, -37.8186, -36.1937, -39.0609, -40.4372, -39.5042, -39.0637, -37.3853, -36.8779, -38.6636, -39.8999, -42.9301, -43.5220, -45.3666, -42.9116, -41.4333, -42.9435, -45.5152, -43.2922, -44.2268, -43.5093, -42.1429, -43.4672, -42.5271, -43.0580, -42.8506, -44.8385, -47.3084, -47.7617, -49.2078, -46.7763, -46.7125, -47.3158, -47.8326, -46.5309, -45.5933, -45.1035, -44.7461, -44.7336, -44.3223, -42.8953, -42.1278, -42.5389, -43.1773, -43.5991, -42.7587, -42.9883, -43.7350, -43.2843, -43.5176, -42.3570, -41.5371, -40.8733, -41.4116, -41.2203, -40.0892, -38.7320, -40.5347, -40.8415, -40.3218, -40.1599, -37.3568, -40.1111, -42.9792, -47.5420, -43.1076, -38.1253, -39.7751, -40.4863, -38.9864, -37.1674, -37.6088, -36.1020],
        gain: 0
      }, {
        buffer: 'sounds/co-mix/guit_nappe_mode_2.wav',
        startOffset: 0.5 * 60 / 122,
        length: 8,
        intensity: [-86.6351, -86.0999, -86.6415, -82.2716, -37.5831, -31.5893, -28.7423, -24.2879, -22.1019, -25.0533, -29.9641, -30.4814, -32.7056, -35.4380, -32.5059, -25.3595, -23.5388, -26.2102, -25.6996, -25.6996, -29.1204, -35.7400, -32.7767, -27.7980, -26.0283, -33.6928, -30.1218, -26.8220, -30.6796, -34.6279, -32.5443, -32.2834, -29.0520, -32.7425, -33.6438, -32.8248, -33.6287, -27.4119, -23.7380, -19.9406, -24.8663, -24.7673, -22.9113, -29.9475, -32.6749, -34.0348, -30.2070, -28.4722, -31.4920, -32.0241, -30.2720, -32.4649, -34.4236, -30.2334, -28.3246, -25.5512, -31.6011, -32.4799, -34.5156, -39.2383, -36.1194, -37.4751, -35.3064, -34.8410, -38.0735, -35.9896, -35.2430, -37.9277, -37.7380, -35.9882, -35.7533, -34.8239, -41.8569, -41.9043, -40.4729, -44.5911, -41.7207, -43.5916, -44.2737, -44.9368, -49.1786, -46.4669, -46.0239, -49.0229, -45.3480, -44.8532, -42.8220, -43.6498, -50.0564, -48.4537, -49.4747, -52.1180, -50.8502, -53.2311, -53.0505, -55.7659, -60.5261, -55.2444, -55.9449, -58.3534, -54.2288, -54.5780, -51.5819, -53.9332, -58.8220, -56.3566, -58.5887, -59.9110, -59.4728, -61.4281, -61.5187, -65.7437, -69.1071, -63.8708, -66.1983, -66.8085, -62.7557, -63.7503, -60.9162, -64.7812, -67.4552, -64.7557, -68.5867, -68.4218, -68.7875, -70.2958, -70.8335, -75.5566, -76.7896, -72.5000, -75.4974, -48.2093, -39.5004, -33.6442, -28.9100, -28.1962, -28.2963, -29.4518, -30.5497, -31.4145, -31.0656, -29.4081, -27.2994, -25.0715, -24.2468, -24.2599, -24.8877, -26.1371, -27.5710, -28.0631, -28.4187, -30.5238, -32.2677, -26.9159, -24.4741, -24.6765, -25.2264, -26.6690, -26.2388, -26.2291, -27.0232, -27.3708, -28.0145, -28.0303, -28.8454, -30.0944, -28.3013, -29.2436, -33.3947, -31.5617, -30.0831, -30.2742, -31.2668, -31.5967, -28.5213, -24.9828, -21.6257, -20.7092, -20.3636, -22.2664, -25.9978, -29.5032, -30.4844, -28.6061, -24.8116, -21.8763, -20.7780, -20.9752, -22.8901, -26.2153, -28.3543, -30.2273, -29.7363, -27.5798, -24.4432, -24.5201, -30.5300, -33.9459, -30.3495, -29.3931, -30.5533, -29.0352, -27.2824, -27.4320, -29.4612, -32.9215, -34.3955, -30.7250, -27.5767, -25.4939, -28.6335, -31.8028, -33.8603, -32.8685, -35.3660, -32.7943, -27.6463, -27.9461, -26.2719, -29.3868, -30.2948, -31.3232, -32.2768, -32.9887, -33.0151, -30.3384, -31.4135, -34.5640, -34.9863, -38.4390, -38.1082, -37.8499, -34.0144, -33.8329, -33.5344, -33.4967, -36.9171, -38.0791, -39.8285, -40.6337, -38.2652, -38.6497, -40.5012, -41.8902, -43.1352, -44.5939, -44.1399, -43.6541, -40.8410, -41.1755, -41.9205, -42.6623, -45.4799, -47.8624, -48.6578, -47.7261, -45.4091, -47.5810, -49.2984, -50.2226, -51.3382, -51.7902, -51.3716, -51.6074, -49.9033, -50.5380, -51.7504, -52.5240, -54.6763, -55.5574, -55.5162, -55.4370, -53.6615, -56.9792, -58.5413, -59.5006, -60.1033, -60.0400, -59.5586, -43.8834, -34.9572, -34.2351, -31.6997, -32.7081, -33.9467, -33.6297, -33.1165, -33.6604, -34.5364, -36.3966, -39.3847, -42.4524, -45.3910, -47.3154, -46.5874, -43.9251, -41.1579, -36.7421, -36.0741, -36.2938, -38.5228, -34.2325, -29.6283, -26.9368, -25.7094, -25.5158, -28.6941, -33.1305, -36.6771, -37.4852, -33.1364, -31.1305, -29.4086, -24.8505, -26.8571, -30.9820, -31.3986, -32.8431, -33.3570, -31.0178, -27.8305, -28.3444, -27.8991, -28.6435, -25.2292, -24.7529, -25.6648, -24.4586, -28.0912, -28.9330, -29.2164, -33.4328, -28.3363, -29.5563, -29.5566, -25.7324, -28.3564, -27.1462, -30.5380, -32.8491, -31.4382, -31.1576, -30.8255, -31.6723, -26.8580, -19.6357, -18.5090, -18.3491, -17.1693, -20.8584, -24.3388, -25.5393, -26.2041, -22.8203, -18.9193, -17.9479, -17.9333, -18.0076, -20.8348, -24.5249, -25.6066, -23.9770, -24.7148, -24.2030, -30.0839, -25.6105, -23.3374, -24.4268, -27.4796, -25.8745, -23.4962, -22.9258, -21.6959, -22.5668, -26.4707, -32.3017, -32.4722, -29.7519, -32.7480, -31.6382, -30.2924, -30.4353, -28.0192, -30.9346, -30.5190, -30.5628, -27.8021, -29.8071, -31.6166, -32.0028, -29.5336, -30.3814, -30.4635, -32.2606, -35.6849, -32.8288, -30.9443, -29.4265, -29.5665, -27.6249, -29.5485, -31.8989, -32.9597, -34.0255, -35.8068, -37.4571, -37.6856, -38.3267, -36.6732, -32.3313, -31.5641, -32.9790, -31.5137, -34.7006, -35.0539, -34.2036, -35.0138, -34.9569, -35.0582, -31.1416, -30.7976, -30.9311, -30.4147, -32.1049, -38.1585, -39.9367, -35.9346, -35.0952, -37.0366, -32.1621, -29.3508, -34.6977, -33.3313, -33.0574, -37.0653, -37.1036, -36.9839, -36.0352, -37.6351, -37.3545, -31.2099, -27.3284, -26.5484, -28.6029, -32.3685, -33.1317, -33.5176, -39.7311, -36.6309, -37.0207, -37.1589, -36.3945, -37.0063, -38.6667, -39.7451, -37.5326, -32.9500, -30.4925, -29.2775, -30.9608, -34.0802, -35.9954, -39.6212, -44.0653, -42.2061, -39.6141, -35.1183, -35.1768, -36.1201, -38.8437, -36.6645, -31.6436, -27.7676, -25.1865, -26.3474, -25.6492, -26.6640, -28.9270, -31.7167, -31.2198, -30.2631, -26.2080, -23.7520, -24.8638, -24.5879, -26.2283, -28.7872, -30.0389, -30.3964, -31.3167, -35.7948, -34.1045, -35.3569, -32.2009, -31.6551, -28.8859, -31.0356, -27.9772, -27.7400, -30.7552, -28.7351, -31.6516, -30.4176, -30.2818, -28.4068, -29.6312, -30.0489, -29.3663, -33.5098, -32.6008, -31.5488, -35.2741, -33.6431, -27.6064, -27.9142, -30.8732, -27.3944, -27.7932, -32.0158, -31.5392, -34.3520, -34.4722, -32.2916, -32.0074, -28.9683, -30.6146, -30.6870, -30.5782, -32.1854, -32.0714, -33.6622, -34.4224, -31.0025, -31.9847, -35.2892, -33.3299, -32.3536, -33.7181, -34.4319, -33.5137, -33.6390, -35.2841, -36.2782, -35.6969, -35.4678, -40.3046, -39.4203, -39.0268, -37.6672, -36.8451, -39.0700, -38.4699, -38.4921, -39.3766, -38.8438, -38.5108, -39.4335, -41.8917, -41.7201, -42.6875, -43.4998, -45.7818, -43.8151, -45.1977, -46.8722, -46.2927, -49.3314, -48.0160, -48.6240, -47.7922, -46.8255, -46.3885, -47.0196, -48.9061, -51.2683, -52.7782, -48.1606, -43.0961, -38.3697, -36.9949, -37.2183, -37.7011, -40.2827, -43.3039, -44.7941, -44.2163, -43.5549, -42.6730, -41.0837, -42.0694, -44.1044, -45.6931, -45.9049, -44.5555, -41.7569, -41.1057, -41.2667, -41.7883, -44.0724, -46.1788, -47.7223, -48.0368, -47.4508, -46.2902, -45.4186, -47.0808, -49.2591, -50.8819, -51.0414, -50.3837, -48.3572, -48.2623, -48.7988, -49.6392, -51.5036, -53.2066, -54.4700, -54.6358, -54.8349, -54.3702, -53.8708, -55.8377, -58.1406, -59.6732, -58.9960, -57.9116, -56.0254, -56.6761, -57.2393, -58.6599, -61.0155, -62.6425, -63.5725, -63.3202, -63.3903, -62.5899, -62.6937, -65.2319, -67.4094, -64.2350, -49.1280, -44.6388, -42.8795, -42.4236, -44.5175, -45.2869, -48.4642, -48.5655, -48.1915, -44.5615, -42.6218, -42.3123, -42.4096, -43.2480, -44.2305, -46.4171, -49.1825, -49.0527, -49.1334, -48.8039, -49.7944, -48.0060, -45.8797, -43.2181, -42.4759, -41.9532, -42.4310, -44.0308, -45.5502, -45.4308, -45.5152, -44.0848, -41.9846, -40.9158, -41.3693, -42.6224, -45.0846, -45.9731, -46.0012, -44.7961, -44.7948],
        gain: 3
      }]
    }]
  },

  /******************************************************************
   *
   *  WWRY:R
   *
   */
  'wwry-r': {
    tempo: 81.5,
    tempoUnit: 1 / 4,
    tracks: [{
      name: 'drums',
      buffer: 'sounds/wwry-r/drums.mp3',
      markers: 'sounds/wwry-r/drums-markers.json'
    }, {
      name: 'verse',
      buffer: 'sounds/wwry-r/voice-solo.mp3',
      markers: 'sounds/wwry-r/voice-solo-markers.json'
    }, {
      name: 'chorus',
      buffer: 'sounds/wwry-r/choirs.mp3',
      markers: 'sounds/wwry-r/choirs-markers.json'
    }, {
      name: 'freddy',
      buffer: 'sounds/wwry-r/sing-it.mp3',
      markers: 'sounds/wwry-r/sing-it-markers.json'
    }, {
      name: 'power chord',
      buffer: 'sounds/wwry-r/guitar-chord.mp3'
    }, {
      name: 'guitar riff',
      buffer: 'sounds/wwry-r/guitar-riff.mp3',
      markers: 'sounds/wwry-r/guitar-riff-markers.json'
    }, {
      name: 'chorus',
      buffer: 'sounds/wwry-r/choirs.mp3',
      markers: 'sounds/wwry-r/choirs-markers.json'
    }, {
      name: 'drums',
      buffer: 'sounds/wwry-r/drums.mp3',
      markers: 'sounds/wwry-r/drums-markers.json'
    }]
  }
};

},{}],13:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],14:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],15:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":70}],16:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":71}],17:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":72}],18:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":73}],19:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":74}],20:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":75}],21:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":76}],22:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":77}],23:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":78}],24:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":79}],25:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":80}],26:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":81}],27:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":82}],28:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":83}],29:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":84}],30:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":85}],31:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/weak-map"), __esModule: true };
},{"core-js/library/fn/weak-map":86}],32:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],33:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":22}],34:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};
},{"../core-js/object/define-property":22}],35:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getPrototypeOf = require("../core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};
},{"../core-js/object/get-own-property-descriptor":23,"../core-js/object/get-prototype-of":24}],36:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":21,"../core-js/object/set-prototype-of":26,"../helpers/typeof":41}],37:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":41}],38:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _isIterable2 = require("../core-js/is-iterable");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = require("../core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
},{"../core-js/get-iterator":16,"../core-js/is-iterable":17}],39:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _from = require("../core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  return Array.isArray(arr) ? arr : (0, _from2.default)(arr);
};
},{"../core-js/array/from":15}],40:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _from = require("../core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};
},{"../core-js/array/from":15}],41:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":29,"../core-js/symbol/iterator":30}],42:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],43:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],44:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @module basic-controller */

var typeCounters = {};

/**
 * Base class to create new controllers.
 *
 * @param {String} type - String describing the type of the controller.
 * @param {Object} defaults - Default parameters of the controller.
 * @param {Object} config - User defined configuration options.
 */

var BaseComponent = function () {
  function BaseComponent(type, defaults) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, BaseComponent);

    this.type = type;
    this.params = Object.assign({}, defaults, config);

    // handle id
    if (!typeCounters[type]) typeCounters[type] = 0;

    if (!this.params.id) {
      this.id = type + "-" + typeCounters[type];
      typeCounters[type] += 1;
    } else {
      this.id = this.params.id;
    }

    this._listeners = new Set();
    this._groupListeners = new Set();

    // register callback if given
    if (this.params.callback) this.addListener(this.params.callback);
  }

  /**
   * Add a listener to the controller.
   *
   * @param {Function} callback - Function to be applied when the controller
   *  state change.
   */


  _createClass(BaseComponent, [{
    key: "addListener",
    value: function addListener(callback) {
      this._listeners.add(callback);
    }

    /**
     * Called when a listener is added from a containing group.
     * @private
     */

  }, {
    key: "_addGroupListener",
    value: function _addGroupListener(id, callId, callback) {
      if (!callId) this.addListener(callback);else {
        this._groupListeners.add({ callId: callId, callback: callback });
      }
    }

    /**
     * Remove a listener from the controller.
     *
     * @param {Function} callback - Function to remove from the listeners.
     * @private
     * @todo - reexpose when `container` can override this method...
     */
    // removeListener(callback) {
    //   this._listeners.remove(callback);
    // }

    /** @private */

  }, {
    key: "executeListeners",
    value: function executeListeners() {
      for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      this._listeners.forEach(function (callback) {
        return callback.apply(undefined, values);
      });

      this._groupListeners.forEach(function (payload) {
        var callback = payload.callback,
            callId = payload.callId;

        callback.apply(undefined, [callId].concat(values));
      });
    }
  }]);

  return BaseComponent;
}();

exports.default = BaseComponent;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AudioContext = window.AudioContext || window.webkitAudioContext;

/** @module basic-controllers */

var defaults = {
  label: 'Drag and drop audio files',
  labelProcess: 'process...',
  audioContext: null,
  container: null,
  callback: null
};

/**
 * Drag and drop zone for audio files returning `AudioBuffer`s
 *
 * @param {Object} config - Override default parameters.
 * @param {String} [config.label='Drag and drop audio files'] - Label of the
 *  controller.
 * @param {String} [config.labelProcess='process...'] - Label of the controller
 *  while audio files are decoded.
 * @param {AudioContext} [config.audioContext=null] - Optionnal audio context
 *  to use in order to decode audio files.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const dragAndDrop = new controllers.DragAndDrop({
 *   container: '#container',
 *   callback: (audioFiles) => console.log(audioFiles),
 * });
 */

var DragAndDrop = function (_display) {
  _inherits(DragAndDrop, _display);

  function DragAndDrop(options) {
    _classCallCheck(this, DragAndDrop);

    var _this = _possibleConstructorReturn(this, (DragAndDrop.__proto__ || Object.getPrototypeOf(DragAndDrop)).call(this, 'drag-and-drop', defaults, options));

    _this._value = null;

    if (!_this.params.audioContext) _this.params.audioContext = new AudioContext();

    _get(DragAndDrop.prototype.__proto__ || Object.getPrototypeOf(DragAndDrop.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Get the last decoded `AudioBuffer`s
   * @type {Array<AudioBuffer>}
   * @readonly
   */


  _createClass(DragAndDrop, [{
    key: 'render',
    value: function render() {
      var label = this.params.label;

      var content = '\n      <div class="drop-zone">\n        <p class="label">' + label + '</p>\n      </div>\n    ';

      this.$el = _get(DragAndDrop.prototype.__proto__ || Object.getPrototypeOf(DragAndDrop.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;
      this.$dropZone = this.$el.querySelector('.drop-zone');
      this.$label = this.$el.querySelector('.label');

      this._bindEvents();

      return this.$el;
    }
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$dropZone.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this2.$dropZone.classList.add('drag');
        e.dataTransfer.dropEffect = 'copy';
      }, false);

      this.$dropZone.addEventListener('dragleave', function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this2.$dropZone.classList.remove('drag');
      }, false);

      this.$dropZone.addEventListener('drop', function (e) {
        e.preventDefault();
        e.stopPropagation();

        var files = Array.from(e.dataTransfer.files);
        var audioFiles = files.filter(function (file) {
          return file.type.match(/^audio/);
        });
        var buffers = new Array(audioFiles.length);
        var counter = 0;

        _this2.$label.textContent = _this2.params.labelProcess;

        files.forEach(function (file, index) {
          var reader = new FileReader();

          reader.onload = function (e) {
            _this2.params.audioContext.decodeAudioData(e.target.result).then(function (audioBuffer) {
              buffers[index] = audioBuffer;
              counter += 1;

              if (counter === audioFiles.length) {
                _this2.executeListeners(buffers);
                _this2.$dropZone.classList.remove('drag');
                _this2.$label.textContent = _this2.params.label;
              }
            }).catch(function (err) {
              buffers[index] = undefined;
              counter += 1;

              if (counter === audioFiles.length) {
                _this2.executeListeners(buffers);
                _this2.$dropZone.classList.remove('drag');
                _this2.$label.textContent = _this2.params.label;
              }
            });
          };

          reader.readAsArrayBuffer(file);
        });
      }, false);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    }
  }]);

  return DragAndDrop;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = DragAndDrop;

},{"../mixins/display":59,"./BaseComponent":45}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display = require('../mixins/display');

var _display2 = _interopRequireDefault(_display);

var _container2 = require('../mixins/container');

var _container3 = _interopRequireDefault(_container2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  legend: '&nbsp;',
  default: 'opened',
  container: null
};

/**
 * Group of controllers.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the group.
 * @param {'opened'|'closed'} [config.default='opened'] - Default state of the
 *  group.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * // create a group
 * const group = new controllers.Group({
 *   label: 'Group',
 *   default: 'opened',
 *   container: '#container'
 * });
 *
 * // insert controllers in the group
 * const groupSlider = new controllers.Slider({
 *   label: 'Group Slider',
 *   min: 20,
 *   max: 1000,
 *   step: 1,
 *   default: 200,
 *   unit: 'Hz',
 *   size: 'large',
 *   container: group,
 *   callback: (value) => console.log(value),
 * });
 *
 * const groupText = new controllers.Text({
 *   label: 'Group Text',
 *   default: 'text input',
 *   readonly: false,
 *   container: group,
 *   callback: (value) => console.log(value),
 * });
 */

var Group = function (_container) {
  _inherits(Group, _container);

  function Group(config) {
    _classCallCheck(this, Group);

    var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, 'group', defaults, config));

    _this._states = ['opened', 'closed'];

    if (_this._states.indexOf(_this.params.default) === -1) throw new Error('Invalid state "' + value + '"');

    _this._state = _this.params.default;

    _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * State of the group (`'opened'` or `'closed'`).
   * @type {String}
   */


  _createClass(Group, [{
    key: 'render',


    /** @private */
    value: function render() {
      var content = '\n      <div class="group-header">\n        ' + elements.smallArrowRight + '\n        ' + elements.smallArrowBottom + '\n        <span class="label">' + this.params.label + '</span>\n      </div>\n      <div class="group-content"></div>\n    ';

      this.$el = _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;
      this.$el.classList.add(this._state);

      this.$header = this.$el.querySelector('.group-header');
      this.$container = this.$el.querySelector('.group-content');

      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$header.addEventListener('click', function () {
        var state = _this2._state === 'closed' ? 'opened' : 'closed';
        _this2.state = state;
      });
    }
  }, {
    key: 'value',
    get: function get() {
      return this.state;
    },
    set: function set(state) {
      this.state = state;
    }

    /**
     * Alias for `value`.
     * @type {String}
     */

  }, {
    key: 'state',
    get: function get() {
      return this._state;
    },
    set: function set(value) {
      if (this._states.indexOf(value) === -1) throw new Error('Invalid state "' + value + '"');

      this.$el.classList.remove(this._state);
      this.$el.classList.add(value);

      this._state = value;
    }
  }]);

  return Group;
}((0, _container3.default)((0, _display2.default)(_BaseComponent2.default)));

exports.default = Group;

},{"../mixins/container":58,"../mixins/display":59,"../utils/elements":60,"./BaseComponent":45}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  min: 0,
  max: 1,
  step: 0.01,
  default: 0,
  container: null,
  callback: null
};

/**
 * Number Box controller
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Number} [config.min=0] - Minimum value.
 * @param {Number} [config.max=1] - Maximum value.
 * @param {Number} [config.step=0.01] - Step between consecutive values.
 * @param {Number} [config.default=0] - Default value.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const numberBox = new controllers.NumberBox({
 *   label: 'My Number Box',
 *   min: 0,
 *   max: 10,
 *   step: 0.1,
 *   default: 5,
 *   container: '#container',
 *   callback: (value) => console.log(value),
 * });
 */

var NumberBox = function (_display) {
  _inherits(NumberBox, _display);

  // legend, min = 0, max = 1, step = 0.01, defaultValue = 0, $container = null, callback = null
  function NumberBox(config) {
    _classCallCheck(this, NumberBox);

    var _this = _possibleConstructorReturn(this, (NumberBox.__proto__ || Object.getPrototypeOf(NumberBox)).call(this, 'number-box', defaults, config));

    _this._value = _this.params.default;
    _this._isIntStep = _this.params.step % 1 === 0;

    _get(NumberBox.prototype.__proto__ || Object.getPrototypeOf(NumberBox.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value of the controller.
   *
   * @type {Number}
   */


  _createClass(NumberBox, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          min = _params.min,
          max = _params.max,
          step = _params.step;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.arrowLeft + '\n        <input class="number" type="number" min="' + min + '" max="' + max + '" step="' + step + '" value="' + this._value + '" />\n        ' + elements.arrowRight + '\n      </div>\n    ';

      this.$el = _get(NumberBox.prototype.__proto__ || Object.getPrototypeOf(NumberBox.prototype), 'render', this).call(this);
      this.$el.classList.add('align-small');
      this.$el.innerHTML = content;

      this.$prev = this.$el.querySelector('.arrow-left');
      this.$next = this.$el.querySelector('.arrow-right');
      this.$number = this.$el.querySelector('input[type="number"]');

      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$prev.addEventListener('click', function (e) {
        var step = _this2.params.step;
        var decimals = step.toString().split('.')[1];
        var exp = decimals ? decimals.length : 0;
        var mult = Math.pow(10, exp);

        var intValue = Math.floor(_this2._value * mult + 0.5);
        var intStep = Math.floor(step * mult + 0.5);
        var value = (intValue - intStep) / mult;

        _this2._propagate(value);
      }, false);

      this.$next.addEventListener('click', function (e) {
        var step = _this2.params.step;
        var decimals = step.toString().split('.')[1];
        var exp = decimals ? decimals.length : 0;
        var mult = Math.pow(10, exp);

        var intValue = Math.floor(_this2._value * mult + 0.5);
        var intStep = Math.floor(step * mult + 0.5);
        var value = (intValue + intStep) / mult;

        _this2._propagate(value);
      }, false);

      this.$number.addEventListener('change', function (e) {
        var value = _this2.$number.value;
        value = _this2._isIntStep ? parseInt(value, 10) : parseFloat(value);
        value = Math.min(_this2.params.max, Math.max(_this2.params.min, value));

        _this2._propagate(value);
      }, false);
    }

    /** @private */

  }, {
    key: '_propagate',
    value: function _propagate(value) {
      if (value === this._value) {
        return;
      }

      this._value = value;
      this.$number.value = value;

      this.executeListeners(this._value);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      // use $number element min, max and step system
      this.$number.value = value;
      value = this.$number.value;
      value = this._isIntStep ? parseInt(value, 10) : parseFloat(value);
      this._value = value;
    }
  }]);

  return NumberBox;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = NumberBox;

},{"../mixins/display":59,"../utils/elements":60,"./BaseComponent":45}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  options: null,
  default: null,
  container: null,
  callback: null
};

/**
 * List of buttons with state.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.options=null] - Values of the drop down list.
 * @param {Number} [config.default=null] - Default value.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const selectButtons = new controllers.SelectButtons({
 *   label: 'SelectButtons',
 *   options: ['standby', 'run', 'end'],
 *   default: 'run',
 *   container: '#container',
 *   callback: (value, index) => console.log(value, index),
 * });
 */

var SelectButtons = function (_display) {
  _inherits(SelectButtons, _display);

  function SelectButtons(config) {
    _classCallCheck(this, SelectButtons);

    var _this = _possibleConstructorReturn(this, (SelectButtons.__proto__ || Object.getPrototypeOf(SelectButtons)).call(this, 'select-buttons', defaults, config));

    if (!Array.isArray(_this.params.options)) throw new Error('TriggerButton: Invalid option "options"');

    _this._value = _this.params.default;

    var options = _this.params.options;
    var index = options.indexOf(_this._value);
    _this._index = index === -1 ? 0 : index;
    _this._maxIndex = options.length - 1;

    _get(SelectButtons.prototype.__proto__ || Object.getPrototypeOf(SelectButtons.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value.
   * @type {String}
   */


  _createClass(SelectButtons, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          options = _params.options,
          label = _params.label;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.arrowLeft + '\n        ' + options.map(function (option, index) {
        return '\n            <button class="btn" data-index="' + index + '" data-value="' + option + '">\n              ' + option + '\n            </button>';
      }).join('') + '\n        ' + elements.arrowRight + '\n      </div>\n    ';

      this.$el = _get(SelectButtons.prototype.__proto__ || Object.getPrototypeOf(SelectButtons.prototype), 'render', this).call(this, this.type);
      this.$el.innerHTML = content;

      this.$prev = this.$el.querySelector('.arrow-left');
      this.$next = this.$el.querySelector('.arrow-right');
      this.$btns = Array.from(this.$el.querySelectorAll('.btn'));

      this._highlightBtn(this._index);
      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$prev.addEventListener('click', function () {
        var index = _this2._index - 1;
        _this2._propagate(index);
      });

      this.$next.addEventListener('click', function () {
        var index = _this2._index + 1;
        _this2._propagate(index);
      });

      this.$btns.forEach(function ($btn, index) {
        $btn.addEventListener('click', function (e) {
          e.preventDefault();
          _this2._propagate(index);
        });
      });
    }

    /** @private */

  }, {
    key: '_propagate',
    value: function _propagate(index) {
      if (index < 0 || index > this._maxIndex) return;

      this._index = index;
      this._value = this.params.options[index];
      this._highlightBtn(this._index);

      this.executeListeners(this._value, this._index);
    }

    /** @private */

  }, {
    key: '_highlightBtn',
    value: function _highlightBtn(activeIndex) {
      this.$btns.forEach(function ($btn, index) {
        $btn.classList.remove('active');

        if (activeIndex === index) {
          $btn.classList.add('active');
        }
      });
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      var index = this.params.options.indexOf(value);

      if (index !== -1) this.index = index;
    }

    /**
     * Current option index.
     * @type {Number}
     */

  }, {
    key: 'index',
    get: function get() {
      this._index;
    },
    set: function set(index) {
      if (index < 0 || index > this._maxIndex) return;

      this._value = this.params.options[index];
      this._index = index;
      this._highlightBtn(this._index);
    }
  }]);

  return SelectButtons;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = SelectButtons;

},{"../mixins/display":59,"../utils/elements":60,"./BaseComponent":45}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  options: null,
  default: null,
  container: null,
  callback: null
};

/**
 * Drop-down list controller.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.options=null] - Values of the drop down list.
 * @param {Number} [config.default=null] - Default value.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const selectList = new controllers.SelectList({
 *   label: 'SelectList',
 *   options: ['standby', 'run', 'end'],
 *   default: 'run',
 *   container: '#container',
 *   callback: (value, index) => console.log(value, index),
 * });
 */

var SelectList = function (_display) {
  _inherits(SelectList, _display);

  function SelectList(config) {
    _classCallCheck(this, SelectList);

    var _this = _possibleConstructorReturn(this, (SelectList.__proto__ || Object.getPrototypeOf(SelectList)).call(this, 'select-list', defaults, config));

    if (!Array.isArray(_this.params.options)) throw new Error('TriggerButton: Invalid option "options"');

    _this._value = _this.params.default;

    var options = _this.params.options;
    var index = options.indexOf(_this._value);
    _this._index = index === -1 ? 0 : index;
    _this._maxIndex = options.length - 1;

    _get(SelectList.prototype.__proto__ || Object.getPrototypeOf(SelectList.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value.
   * @type {String}
   */


  _createClass(SelectList, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          options = _params.options;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.arrowLeft + '\n        <select>\n        ' + options.map(function (option, index) {
        return '<option value="' + option + '">' + option + '</option>';
      }).join('') + '\n        <select>\n        ' + elements.arrowRight + '\n      </div>\n    ';

      this.$el = _get(SelectList.prototype.__proto__ || Object.getPrototypeOf(SelectList.prototype), 'render', this).call(this, this.type);
      this.$el.classList.add('align-small');
      this.$el.innerHTML = content;

      this.$prev = this.$el.querySelector('.arrow-left');
      this.$next = this.$el.querySelector('.arrow-right');
      this.$select = this.$el.querySelector('select');
      // set to default value
      this.$select.value = options[this._index];
      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$prev.addEventListener('click', function () {
        var index = _this2._index - 1;
        _this2._propagate(index);
      }, false);

      this.$next.addEventListener('click', function () {
        var index = _this2._index + 1;
        _this2._propagate(index);
      }, false);

      this.$select.addEventListener('change', function () {
        var value = _this2.$select.value;
        var index = _this2.params.options.indexOf(value);
        _this2._propagate(index);
      });
    }

    /** @private */

  }, {
    key: '_propagate',
    value: function _propagate(index) {
      if (index < 0 || index > this._maxIndex) return;

      var value = this.params.options[index];
      this._index = index;
      this._value = value;
      this.$select.value = value;

      this.executeListeners(this._value, this._index);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      this.$select.value = value;
      this._value = value;
      this._index = this.params.options.indexOf(value);
    }

    /**
     * Current option index.
     * @type {Number}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      if (index < 0 || index > this._maxIndex) return;
      this.value = this.params.options[index];
    }
  }]);

  return SelectList;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = SelectList;

},{"../mixins/display":59,"../utils/elements":60,"./BaseComponent":45}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _guiComponents = require('gui-components');

var guiComponents = _interopRequireWildcard(_guiComponents);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  min: 0,
  max: 1,
  step: 0.01,
  default: 0,
  unit: '',
  size: 'medium',
  container: null,
  callback: null
};

/**
 * Slider controller.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Number} [config.min=0] - Minimum value.
 * @param {Number} [config.max=1] - Maximum value.
 * @param {Number} [config.step=0.01] - Step between consecutive values.
 * @param {Number} [config.default=0] - Default value.
 * @param {String} [config.unit=''] - Unit of the value.
 * @param {'small'|'medium'|'large'} [config.size='medium'] - Size of the
 *  slider.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const slider = new controllers.Slider({
 *   label: 'My Slider',
 *   min: 20,
 *   max: 1000,
 *   step: 1,
 *   default: 537,
 *   unit: 'Hz',
 *   size: 'large',
 *   container: '#container',
 *   callback: (value) => console.log(value),
 * });
 */

var Slider = function (_display) {
  _inherits(Slider, _display);

  function Slider(config) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, 'slider', defaults, config));

    _this._value = _this.params.default;
    _this._onSliderChange = _this._onSliderChange.bind(_this);

    _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value.
   * @type {Number}
   */


  _createClass(Slider, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          min = _params.min,
          max = _params.max,
          step = _params.step,
          unit = _params.unit,
          size = _params.size;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        <div class="range"></div>\n        <div class="number-wrapper">\n          <input type="number" class="number" min="' + min + '" max="' + max + '" step="' + step + '" value="' + this._value + '" />\n          <span class="unit">' + unit + '</span>\n        </div>\n      </div>';

      this.$el = _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), 'render', this).call(this, this.type);
      this.$el.innerHTML = content;
      this.$el.classList.add('slider-' + size);

      this.$range = this.$el.querySelector('.range');
      this.$number = this.$el.querySelector('input[type="number"]');

      this.slider = new guiComponents.Slider({
        container: this.$range,
        callback: this._onSliderChange,
        min: min,
        max: max,
        step: step,
        default: this._value,
        foregroundColor: '#ababab'
      });

      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: 'resize',
    value: function resize() {
      _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), 'resize', this).call(this);

      var _$range$getBoundingCl = this.$range.getBoundingClientRect(),
          width = _$range$getBoundingCl.width,
          height = _$range$getBoundingCl.height;

      this.slider.resize(width, height);
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$number.addEventListener('change', function () {
        var value = parseFloat(_this2.$number.value);
        // the slider propagates the value
        _this2.slider.value = value;
        _this2._value = value;
      }, false);
    }

    /** @private */

  }, {
    key: '_onSliderChange',
    value: function _onSliderChange(value) {
      this.$number.value = value;
      this._value = value;

      this.executeListeners(this._value);
    }
  }, {
    key: 'value',
    set: function set(value) {
      this._value = value;

      if (this.$number && this.$range) {
        this.$number.value = this.value;
        this.slider.value = this.value;
      }
    },
    get: function get() {
      return this._value;
    }
  }]);

  return Slider;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Slider;

},{"../mixins/display":59,"./BaseComponent":45,"gui-components":224}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  default: '',
  readonly: false,
  container: null,
  callback: null
};

/**
 * Text controller.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.default=''] - Default value of the controller.
 * @param {Array} [config.readonly=false] - Define if the controller is readonly.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-contollers';
 *
 * const text = new controllers.Text({
 *   label: 'My Text',
 *   default: 'default value',
 *   readonly: false,
 *   container: '#container',
 *   callback: (value) => console.log(value),
 * });
 */

var Text = function (_display) {
  _inherits(Text, _display);

  function Text(config) {
    _classCallCheck(this, Text);

    var _this = _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, 'text', defaults, config));

    _this._value = _this.params.default;
    _this.initialize();
    return _this;
  }

  /**
   * Current value.
   * @type {String}
   */


  _createClass(Text, [{
    key: 'render',


    /** @private */
    value: function render() {
      var readonly = this.params.readonly ? 'readonly' : '';
      var content = '\n      <span class="label">' + this.params.label + '</span>\n      <div class="inner-wrapper">\n        <input class="text" type="text" value="' + this._value + '" ' + readonly + ' />\n      </div>\n    ';

      this.$el = _get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;
      this.$input = this.$el.querySelector('.text');

      this.bindEvents();
      return this.$el;
    }

    /** @private */

  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      var _this2 = this;

      this.$input.addEventListener('keyup', function () {
        _this2._value = _this2.$input.value;
        _this2.executeListeners(_this2._value);
      }, false);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      this.$input.value = value;
      this._value = value;
    }
  }]);

  return Text;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Text;

},{"../mixins/display":59,"./BaseComponent":45}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  container: null
};

/**
 * Title.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 *
 * @example
 * import * as controller from 'basic-controllers';
 *
 * const title = new controllers.Title({
 *   label: 'My Title',
 *   container: '#container'
 * });
 */

var Title = function (_display) {
  _inherits(Title, _display);

  function Title(config) {
    _classCallCheck(this, Title);

    var _this = _possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).call(this, 'title', defaults, config));

    _get(Title.prototype.__proto__ || Object.getPrototypeOf(Title.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /** @private */


  _createClass(Title, [{
    key: 'render',
    value: function render() {
      var content = '<span class="label">' + this.params.label + '</span>';

      this.$el = _get(Title.prototype.__proto__ || Object.getPrototypeOf(Title.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;

      return this.$el;
    }
  }]);

  return Title;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Title;

},{"../mixins/display":59,"./BaseComponent":45}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&bnsp;',
  active: false,
  container: null,
  callback: null
};

/**
 * On/Off controller.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.active=false] - Default state of the toggle.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const toggle = new controllers.Toggle({
 *   label: 'My Toggle',
 *   active: false,
 *   container: '#container',
 *   callback: (active) => console.log(active),
 * });
 */

var Toggle = function (_display) {
  _inherits(Toggle, _display);

  function Toggle(config) {
    _classCallCheck(this, Toggle);

    var _this = _possibleConstructorReturn(this, (Toggle.__proto__ || Object.getPrototypeOf(Toggle)).call(this, 'toggle', defaults, config));

    _this._active = _this.params.active;

    _get(Toggle.prototype.__proto__ || Object.getPrototypeOf(Toggle.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Value of the toggle
   * @type {Boolean}
   */


  _createClass(Toggle, [{
    key: '_updateBtn',


    /** @private */
    value: function _updateBtn() {
      var method = this.active ? 'add' : 'remove';
      this.$toggle.classList[method]('active');
    }

    /** @private */

  }, {
    key: 'render',
    value: function render() {
      var content = '\n      <span class="label">' + this.params.label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.toggle + '\n      </div>';

      this.$el = _get(Toggle.prototype.__proto__ || Object.getPrototypeOf(Toggle.prototype), 'render', this).call(this);
      this.$el.classList.add('align-small');
      this.$el.innerHTML = content;

      this.$toggle = this.$el.querySelector('.toggle-element');
      // initialize state
      this.active = this._active;
      this.bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      var _this2 = this;

      this.$toggle.addEventListener('click', function (e) {
        e.preventDefault();

        _this2.active = !_this2.active;
        _this2.executeListeners(_this2._active);
      });
    }
  }, {
    key: 'value',
    set: function set(bool) {
      this.active = bool;
    },
    get: function get() {
      return this._active;
    }

    /**
     * Alias for `value`.
     * @type {Boolean}
     */

  }, {
    key: 'active',
    set: function set(bool) {
      this._active = bool;
      this._updateBtn();
    },
    get: function get() {
      return this._active;
    }
  }]);

  return Toggle;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Toggle;

},{"../mixins/display":59,"../utils/elements":60,"./BaseComponent":45}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  options: null,
  container: null,
  callback: null
};

/**
 * List of buttons without state.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.options=null] - Options for each button.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const triggerButtons = new controllers.TriggerButtons({
 *   label: 'My Trigger Buttons',
 *   options: ['value 1', 'value 2', 'value 3'],
 *   container: '#container',
 *   callback: (value, index) => console.log(value, index),
 * });
 */

var TriggerButtons = function (_display) {
  _inherits(TriggerButtons, _display);

  function TriggerButtons(config) {
    _classCallCheck(this, TriggerButtons);

    var _this = _possibleConstructorReturn(this, (TriggerButtons.__proto__ || Object.getPrototypeOf(TriggerButtons)).call(this, 'trigger-buttons', defaults, config));

    if (!Array.isArray(_this.params.options)) throw new Error('TriggerButton: Invalid option "options"');

    _this._index = null;
    _this._value = null;

    _get(TriggerButtons.prototype.__proto__ || Object.getPrototypeOf(TriggerButtons.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Last triggered button value.
   *
   * @readonly
   * @type {String}
   */


  _createClass(TriggerButtons, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          options = _params.options;


      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + options.map(function (option, index) {
        return '<a href="#" class="btn">' + option + '</a>';
      }).join('') + '\n      </div>';

      this.$el = _get(TriggerButtons.prototype.__proto__ || Object.getPrototypeOf(TriggerButtons.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;

      this.$buttons = Array.from(this.$el.querySelectorAll('.btn'));
      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$buttons.forEach(function ($btn, index) {
        var value = _this2.params.options[index];

        $btn.addEventListener('click', function (e) {
          e.preventDefault();

          _this2._value = value;
          _this2._index = index;

          _this2.executeListeners(value, index);
        });
      });
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    }

    /**
     * Last triggered button index.
     *
     * @readonly
     * @type {String}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    }
  }]);

  return TriggerButtons;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = TriggerButtons;

},{"../mixins/display":59,"./BaseComponent":45}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _BaseComponent = require('./components/BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _Group = require('./components/Group');

var _Group2 = _interopRequireDefault(_Group);

var _NumberBox = require('./components/NumberBox');

var _NumberBox2 = _interopRequireDefault(_NumberBox);

var _SelectButtons = require('./components/SelectButtons');

var _SelectButtons2 = _interopRequireDefault(_SelectButtons);

var _SelectList = require('./components/SelectList');

var _SelectList2 = _interopRequireDefault(_SelectList);

var _Slider = require('./components/Slider');

var _Slider2 = _interopRequireDefault(_Slider);

var _Text = require('./components/Text');

var _Text2 = _interopRequireDefault(_Text);

var _Title = require('./components/Title');

var _Title2 = _interopRequireDefault(_Title);

var _Toggle = require('./components/Toggle');

var _Toggle2 = _interopRequireDefault(_Toggle);

var _TriggerButtons = require('./components/TriggerButtons');

var _TriggerButtons2 = _interopRequireDefault(_TriggerButtons);

var _container2 = require('./mixins/container');

var _container3 = _interopRequireDefault(_container2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// map type names to constructors
var typeCtorMap = {
  'group': _Group2.default,
  'number-box': _NumberBox2.default,
  'select-buttons': _SelectButtons2.default,
  'select-list': _SelectList2.default,
  'slider': _Slider2.default,
  'text': _Text2.default,
  'title': _Title2.default,
  'toggle': _Toggle2.default,
  'trigger-buttons': _TriggerButtons2.default
};

var defaults = {
  container: 'body'
};

var Control = function (_container) {
  _inherits(Control, _container);

  function Control(config) {
    _classCallCheck(this, Control);

    var _this = _possibleConstructorReturn(this, (Control.__proto__ || Object.getPrototypeOf(Control)).call(this, 'control', defaults, config));

    var $container = _this.params.container;

    if (typeof $container === 'string') $container = document.querySelector($container);

    _this.$container = $container;
    return _this;
  }

  return Control;
}((0, _container3.default)(_BaseComponent2.default));

/** @module basic-controllers */

/**
 * Create a whole control surface from a json definition.
 *
 * @param {String|Element} container - Container of the controls.
 * @param {Object} - Definitions for the controls.
 * @return {Object} - A `Control` instance that behaves like a group without graphic.
 * @static
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const definitions = [
 *   {
 *     id: 'my-slider',
 *     type: 'slider',
 *     label: 'My Slider',
 *     size: 'large',
 *     min: 0,
 *     max: 1000,
 *     step: 1,
 *     default: 253,
 *   }, {
 *     id: 'my-group',
 *     type: 'group',
 *     label: 'Group',
 *     default: 'opened',
 *     elements: [
 *       {
 *         id: 'my-number',
 *         type: 'number-box',
 *         default: 0.4,
 *         min: -1,
 *         max: 1,
 *         step: 0.01,
 *       }
 *     ],
 *   }
 * ];
 *
 * const controls = controllers.create('#container', definitions);
 *
 * // add a listener on all the component inside `my-group`
 * controls.addListener('my-group', (id, value) => console.log(id, value));
 *
 * // retrieve the instance of `my-number`
 * const myNumber = controls.getComponent('my-group/my-number');
 */


function create(container, definitions) {

  function _parse(container, definitions) {
    definitions.forEach(function (def, index) {
      var type = def.type;
      var ctor = typeCtorMap[type];
      var config = Object.assign({}, def);

      //
      config.container = container;
      delete config.type;

      var component = new ctor(config);

      if (type === 'group') _parse(component, config.elements);
    });
  };

  var _root = new Control({ container: container });
  _parse(_root, definitions);

  return _root;
}

exports.default = create;

},{"./components/BaseComponent":45,"./components/Group":47,"./components/NumberBox":48,"./components/SelectButtons":49,"./components/SelectList":50,"./components/Slider":51,"./components/Text":52,"./components/Title":53,"./components/Toggle":54,"./components/TriggerButtons":55,"./mixins/container":58}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTheme = exports.create = exports.TriggerButtons = exports.Toggle = exports.Title = exports.Text = exports.Slider = exports.SelectList = exports.SelectButtons = exports.NumberBox = exports.DragAndDrop = exports.Group = exports.BaseComponent = exports.styles = undefined;

var _Group = require('./components/Group');

Object.defineProperty(exports, 'Group', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Group).default;
  }
});

var _DragAndDrop = require('./components/DragAndDrop');

Object.defineProperty(exports, 'DragAndDrop', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragAndDrop).default;
  }
});

var _NumberBox = require('./components/NumberBox');

Object.defineProperty(exports, 'NumberBox', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_NumberBox).default;
  }
});

var _SelectButtons = require('./components/SelectButtons');

Object.defineProperty(exports, 'SelectButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SelectButtons).default;
  }
});

var _SelectList = require('./components/SelectList');

Object.defineProperty(exports, 'SelectList', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SelectList).default;
  }
});

var _Slider = require('./components/Slider');

Object.defineProperty(exports, 'Slider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Slider).default;
  }
});

var _Text = require('./components/Text');

Object.defineProperty(exports, 'Text', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Text).default;
  }
});

var _Title = require('./components/Title');

Object.defineProperty(exports, 'Title', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Title).default;
  }
});

var _Toggle = require('./components/Toggle');

Object.defineProperty(exports, 'Toggle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Toggle).default;
  }
});

var _TriggerButtons = require('./components/TriggerButtons');

Object.defineProperty(exports, 'TriggerButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TriggerButtons).default;
  }
});

var _factory = require('./factory');

Object.defineProperty(exports, 'create', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_factory).default;
  }
});

var _display = require('./mixins/display');

Object.defineProperty(exports, 'setTheme', {
  enumerable: true,
  get: function get() {
    return _display.setTheme;
  }
});
exports.disableStyles = disableStyles;

var _styles2 = require('./utils/styles');

var _styles = _interopRequireWildcard(_styles2);

var _BaseComponent2 = require('./components/BaseComponent');

var _BaseComponent3 = _interopRequireDefault(_BaseComponent2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var styles = exports.styles = _styles;

/** @module basic-controllers */

// expose for plugins
var BaseComponent = exports.BaseComponent = _BaseComponent3.default;

// components


/**
 * Disable default styling (expect a broken ui)
 */
function disableStyles() {
  _styles.disable();
};

},{"./components/BaseComponent":45,"./components/DragAndDrop":46,"./components/Group":47,"./components/NumberBox":48,"./components/SelectButtons":49,"./components/SelectList":50,"./components/Slider":51,"./components/Text":52,"./components/Title":53,"./components/Toggle":54,"./components/TriggerButtons":55,"./factory":56,"./mixins/display":59,"./utils/styles":62}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var separator = '/';

function getHead(path) {
  return path.split(separator)[0];
}

function getTail(path) {
  var parts = path.split(separator);
  parts.shift();
  return parts.join(separator);
}

var container = function container(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      var _ref;

      _classCallCheck(this, _class);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = _possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [this].concat(args)));

      _this.elements = new Set();

      // sure of that ?
      delete _this._listeners;
      delete _this._groupListeners;
      return _this;
    }

    /**
     * Return one of the group children according to its `id`, `null` otherwise.
     * @private
     */


    _createClass(_class, [{
      key: '_getHead',
      value: function _getHead(id) {}
    }, {
      key: '_getTail',
      value: function _getTail(id) {}

      /**
       * Return a child of the group recursively according to the given `id`,
       * `null` otherwise.
       * @private
       */

    }, {
      key: 'getComponent',
      value: function getComponent(id) {
        var head = getHead(id);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var component = _step.value;

            if (head === component.id) {
              if (head === id) return component;else if (component.type = 'group') return component.getComponent(getTail(id));else throw new Error('Undefined component ' + id);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        throw new Error('Undefined component ' + id);
      }

      /**
       * Add Listener on each components of the group.
       *
       * @param {String} id - Path to component id.
       * @param {Function} callback - Function to execute.
       */

    }, {
      key: 'addListener',
      value: function addListener(id, callback) {
        if (arguments.length === 1) {
          callback = id;
          this._addGroupListener('', '', callback);
        } else {
          this._addGroupListener(id, '', callback);
        }
      }

      /** @private */

    }, {
      key: '_addGroupListener',
      value: function _addGroupListener(id, callId, callback) {
        if (id) {
          var componentId = getHead(id);
          var component = this.getComponent(componentId);

          if (component) {
            id = getTail(id);
            component._addGroupListener(id, callId, callback);
          } else {
            throw new Error('Undefined component ' + this.rootId + '/' + componentId);
          }
        } else {
          this.elements.forEach(function (component) {
            var _callId = callId; // create a new branche
            _callId += callId === '' ? component.id : separator + component.id;
            component._addGroupListener(id, _callId, callback);
          });
        }
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = container;

},{}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.setTheme = setTheme;

var _styles = require('../utils/styles');

var styles = _interopRequireWildcard(_styles);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

// default theme
var theme = 'light';
// set of the instanciated controllers
var controllers = new Set();

/**
 * Change the theme of the controllers, currently 3 themes are available:
 *  - `'light'` (default)
 *  - `'grey'`
 *  - `'dark'`
 *
 * @param {String} theme - Name of the theme.
 */
function setTheme(value) {
  controllers.forEach(function (controller) {
    return controller.$el.classList.remove(theme);
  });
  theme = value;
  controllers.forEach(function (controller) {
    return controller.$el.classList.add(theme);
  });
}

/**
 * display mixin - components with DOM
 * @private
 */
var display = function display(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      var _ref;

      _classCallCheck(this, _class);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // insert styles and listen window resize when the first controller is created
      var _this = _possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [this].concat(args)));

      if (controllers.size === 0) {
        styles.insertStyleSheet();

        window.addEventListener('resize', function () {
          controllers.forEach(function (controller) {
            return controller.resize();
          });
        });
      }

      controllers.add(_this);
      return _this;
    }

    _createClass(_class, [{
      key: 'initialize',
      value: function initialize() {
        var _this2 = this;

        var $container = this.params.container;

        if ($container) {
          // css selector
          if (typeof $container === 'string') {
            $container = document.querySelector($container);
            // group
          } else if ($container.$container) {
            // this.group = $container;
            $container.elements.add(this);
            $container = $container.$container;
          }

          $container.appendChild(this.render());
          setTimeout(function () {
            return _this2.resize();
          }, 0);
        }
      }

      /** @private */

    }, {
      key: 'render',
      value: function render() {
        this.$el = document.createElement('div');
        this.$el.classList.add(styles.ns, theme, this.type);

        return this.$el;
      }

      /** @private */

    }, {
      key: 'resize',
      value: function resize() {
        var boundingRect = this.$el.getBoundingClientRect();
        var width = boundingRect.width;
        var method = width > 600 ? 'remove' : 'add';

        this.$el.classList[method]('small');
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = display;

},{"../utils/styles":62}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var toggle = exports.toggle = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"toggle-element\" version=\"1.1\" viewBox=\"0 0 50 50\" preserveAspectRatio=\"none\">\n      <g class=\"x\">\n        <line x1=\"8\" y1=\"8\" x2=\"42\" y2=\"42\" stroke=\"white\" />\n        <line x1=\"8\" y1=\"42\" x2=\"42\" y2=\"8\" stroke=\"white\" />\n      </g>\n  </svg>\n";

var arrowRight = exports.arrowRight = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"arrow-right\" version=\"1.1\" viewBox=\"0 0 50 50\" preserveAspectRatio=\"none\">\n    <line x1=\"10\" y1=\"10\" x2=\"40\" y2=\"25\" />\n    <line x1=\"10\" y1=\"40\" x2=\"40\" y2=\"25\" />\n  </svg>\n";

var arrowLeft = exports.arrowLeft = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"arrow-left\" version=\"1.1\" viewBox=\"0 0 50 50\" preserveAspectRatio=\"none\">\n    <line x1=\"40\" y1=\"10\" x2=\"10\" y2=\"25\" />\n    <line x1=\"40\" y1=\"40\" x2=\"10\" y2=\"25\" />\n  </svg>\n";

var smallArrowRight = exports.smallArrowRight = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"small-arrow-right\" viewBox=\"0 0 50 50\">\n    <path d=\"M 20 15 L 35 25 L 20 35 Z\" />\n  </svg>\n";

var smallArrowBottom = exports.smallArrowBottom = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"small-arrow-bottom\" viewBox=\"0 0 50 50\">\n    <path d=\"M 15 17 L 35 17 L 25 32 Z\" />\n  </svg>\n";

},{}],61:[function(require,module,exports){
module.exports = " .basic-controllers { } .basic-controllers { width: 100%; max-width: 800px; height: 34px; padding: 3px; margin: 4px 0; background-color: #efefef; border: 1px solid #aaaaaa; box-sizing: border-box; border-radius: 2px; display: block; color: #464646; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .basic-controllers .label { font: italic normal 1.2em Quicksand, arial, sans-serif; line-height: 26px; overflow: hidden; text-align: right; padding: 0 8px 0 0; display: block; box-sizing: border-box; width: 24%; float: left; white-space: nowrap; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none; } .basic-controllers .inner-wrapper { display: -webkit-inline-flex; display: inline-flex; -webkit-flex-wrap: no-wrap; flex-wrap: no-wrap; width: 76%; float: left; } .basic-controllers.small { height: 48px; } .basic-controllers.small:not(.align-small) { height: auto; } .basic-controllers.small:not(.align-small) .label { width: 100%; float: none; text-align: left; line-height: 40px; } .basic-controllers.small:not(.align-small) .inner-wrapper { width: 100%; float: none; } .basic-controllers.small.align-small .label { display: block; margin-right: 20px; text-align: left; line-height: 40px; } .basic-controllers.small.align-small .inner-wrapper { display: inline-block; width: auto; } .basic-controllers .arrow-right, .basic-controllers .arrow-left { border-radius: 2px; width: 14px; height: 26px; cursor: pointer; background-color: #464646; } .basic-controllers .arrow-right line, .basic-controllers .arrow-left line { stroke-width: 3px; stroke: #ffffff; } .basic-controllers .arrow-right:hover, .basic-controllers .arrow-left:hover { background-color: #686868; } .basic-controllers .arrow-right:active, .basic-controllers .arrow-left:active { background-color: #909090; } .basic-controllers .small-arrow-right, .basic-controllers .small-arrow-bottom { width: 26px; height: 26px; cursor: pointer; } .basic-controllers .small-arrow-right path, .basic-controllers .small-arrow-bottom path { fill: #909090; } .basic-controllers .small-arrow-right:hover path, .basic-controllers .small-arrow-bottom:hover path { fill: #686868; } .basic-controllers .toggle-element { width: 26px; height: 26px; border-radius: 2px; background-color: #464646; cursor: pointer; } .basic-controllers .toggle-element:hover { background-color: #686868; } .basic-controllers .toggle-element line { stroke-width: 3px; } .basic-controllers .toggle-element .x { display: none; } .basic-controllers .toggle-element.active .x { display: block; } .basic-controllers .btn { display: block; text-align: center; font: normal normal 12px arial; text-decoration: none; height: 26px; line-height: 26px; background-color: #464646; border: none; color: #ffffff; margin: 0 4px 0 0; padding: 0; box-sizing: border-box; border-radius: 2px; cursor: pointer; -webkit-flex-grow: 1; flex-grow: 1; } .basic-controllers .btn:last-child { margin: 0; } .basic-controllers .btn:hover { background-color: #686868; } .basic-controllers .btn:active, .basic-controllers .btn.active { background-color: #909090; } .basic-controllers .btn:focus { outline: none; } .basic-controllers .number { height: 26px; display: inline-block; position: relative; font: normal normal 1.2em Quicksand, arial, sans-serif; vertical-align: top; border: none; background: none; color: #464646; padding: 0 4px; margin: 0; background-color: #f9f9f9; border-radius: 2px; box-sizing: border-box; } .basic-controllers .number:focus { outline: none; } .basic-controllers select { height: 26px; line-height: 26px; background-color: #f9f9f9; border-radius: 2px; border: none; vertical-align: top; padding: 0; margin: 0; } .basic-controllers select:focus { outline: none; } .basic-controllers input[type=text] { width: 100%; height: 26px; line-height: 26px; border: 0; padding: 0 4px; background-color: #f9f9f9; border-radius: 2px; color: #565656; } .basic-controllers.small .arrow-right, .basic-controllers.small .arrow-left { width: 24px; height: 40px; } .basic-controllers.small .toggle-element { width: 40px; height: 40px; } .basic-controllers.small .btn { height: 40px; line-height: 40px; } .basic-controllers.small .number { height: 40px; } .basic-controllers.small select { height: 40px; line-height: 40px; } .basic-controllers.small input[type=text] { height: 40px; line-height: 40px; } .basic-controllers.title { border: none !important; margin-bottom: 0; margin-top: 8px; padding-top: 8px; padding-bottom: 0; background-color: transparent !important; height: 25px; } .basic-controllers.title .label { font: normal bold 1.3em Quicksand, arial, sans-serif; height: 100%; overflow: hidden; text-align: left; padding: 0; width: 100%; box-sizing: border-box; -webkit-flex-grow: 1; flex-grow: 1; } .basic-controllers.group { height: auto; background-color: white; } .basic-controllers.group .group-header .label { font: normal bold 1.3em Quicksand, arial, sans-serif; height: 26px; line-height: 26px; overflow: hidden; text-align: left; padding: 0 0 0 36px; width: 100%; box-sizing: border-box; -webkit-flex-grow: 1; flex-grow: 1; float: none; cursor: pointer; } .basic-controllers.group .group-header .small-arrow-right { width: 26px; height: 26px; position: absolute; } .basic-controllers.group .group-header .small-arrow-bottom { width: 26px; height: 26px; position: absolute; } .basic-controllers.group .group-content { overflow: hidden; } .basic-controllers.group .group-content > div { margin: 4px auto; } .basic-controllers.group .group-content > div:last-child { margin-bottom: 0; } .basic-controllers.group.opened .group-header .small-arrow-right { display: none; } .basic-controllers.group.opened .group-header .small-arrow-bottom { display: block; } .basic-controllers.group.opened .group-content { display: block; } .basic-controllers.group.closed .group-header .small-arrow-right { display: block; } .basic-controllers.group.closed .group-header .small-arrow-bottom { display: none; } .basic-controllers.group.closed .group-content { display: none; } .basic-controllers.slider .range { height: 26px; display: inline-block; margin: 0; -webkit-flex-grow: 4; flex-grow: 4; position: relative; } .basic-controllers.slider .range canvas { position: absolute; top: 0; left: 0; } .basic-controllers.slider .number-wrapper { display: inline; height: 26px; text-align: right; -webkit-flex-grow: 3; flex-grow: 3; } .basic-controllers.slider .number-wrapper .number { left: 5px; width: 54px; text-align: right; } .basic-controllers.slider .number-wrapper .unit { font: italic normal 1em Quicksand, arial, sans-serif; line-height: 26px; height: 26px; width: 30px; display: inline-block; position: relative; padding-left: 5px; padding-right: 5px; color: #565656; } .basic-controllers.slider .number-wrapper .unit sup { line-height: 7px; } .basic-controllers.slider.slider-large .range { -webkit-flex-grow: 50; flex-grow: 50; } .basic-controllers.slider.slider-large .number-wrapper { -webkit-flex-grow: 1; flex-grow: 1; } .basic-controllers.slider.slider-small .range { -webkit-flex-grow: 2; flex-grow: 2; } .basic-controllers.slider.slider-small .number-wrapper { -webkit-flex-grow: 4; flex-grow: 4; } .basic-controllers.small.slider .range { height: 40px; } .basic-controllers.small.slider .number-wrapper { height: 40px; } .basic-controllers.small.slider .number-wrapper .unit { line-height: 40px; height: 40px; } .basic-controllers.number-box .number { width: 120px; margin: 0 10px; vertical-align: top; } .basic-controllers.select-list select { margin: 0 10px; width: 120px; font: normal normal 1.2em Quicksand, arial, sans-serif; color: #464646; } .basic-controllers.select-buttons .btn:first-of-type { margin-left: 4px; } .basic-controllers.text input[type=text] { font: normal normal 1.2em Quicksand, arial, sans-serif; color: #464646; } .basic-controllers.drag-and-drop { width: 100%; text-align: center; font-weight: bold; height: 100px; } .basic-controllers.drag-and-drop .drop-zone { border: 1px dotted #c4c4c4; border-radius: 2px; transition: background 200ms; height: 90px; } .basic-controllers.drag-and-drop .drop-zone.drag { background-color: #c4c4c4; } .basic-controllers.drag-and-drop .label { display: block; width: 100%; height: 90px; line-height: 90px; margin: 0; padding: 0; text-align: center; } .basic-controllers.drag-and-drop.process .label { display: none; } .basic-controllers.small.drag-and-drop { height: 120px; } .basic-controllers.small.drag-and-drop .drop-zone { height: 110px; } .basic-controllers.small.drag-and-drop .label { display: block; width: 100%; height: 110px; line-height: 110px; margin: 0; padding: 0; text-align: center; } .basic-controllers.grey { background-color: #363636; border: 1px solid #585858; color: rgba(255, 255, 255, 0.95); } .basic-controllers.grey .toggle-element { background-color: #efefef; } .basic-controllers.grey .toggle-element line { stroke: #363636; } .basic-controllers.grey .toggle-element:hover { background-color: #cdcdcd; } .basic-controllers.grey .arrow-right, .basic-controllers.grey .arrow-left { background-color: #efefef; } .basic-controllers.grey .arrow-right line, .basic-controllers.grey .arrow-left line { stroke: #363636; } .basic-controllers.grey .arrow-right:hover, .basic-controllers.grey .arrow-left:hover { background-color: #cdcdcd; } .basic-controllers.grey .arrow-right:active, .basic-controllers.grey .arrow-left:active { background-color: #ababab; } .basic-controllers.grey .small-arrow-right path, .basic-controllers.grey .small-arrow-bottom path { fill: #ababab; } .basic-controllers.grey .small-arrow-right:hover path, .basic-controllers.grey .small-arrow-bottom:hover path { fill: #cdcdcd; } .basic-controllers.grey .number, .basic-controllers.grey select, .basic-controllers.grey input[type=text] { color: rgba(255, 255, 255, 0.95); background-color: #454545; } .basic-controllers.grey .btn { background-color: #efefef; color: #363636; } .basic-controllers.grey .btn:hover { background-color: #cdcdcd; } .basic-controllers.grey .btn:active, .basic-controllers.grey .btn.active { background-color: #ababab; } .basic-controllers.grey.slider .inner-wrapper .number-wrapper .unit { color: #bcbcbc; } .basic-controllers.grey.group { background-color: #505050; } .basic-controllers.grey.drag-and-drop .drop-zone { border: 1px dotted #727272; } .basic-controllers.grey.drag-and-drop .drop-zone.drag { background-color: #727272; } .basic-controllers.dark { background-color: #242424; border: 1px solid #282828; color: #ffffff; } .basic-controllers.dark .toggle-element { background-color: #464646; } .basic-controllers.dark .toggle-element line { stroke: #ffffff; } .basic-controllers.dark .toggle-element:hover { background-color: #686868; } .basic-controllers.dark .arrow-right, .basic-controllers.dark .arrow-left { background-color: #464646; } .basic-controllers.dark .arrow-right line, .basic-controllers.dark .arrow-left line { stroke: #ffffff; } .basic-controllers.dark .arrow-right:hover, .basic-controllers.dark .arrow-left:hover { background-color: #686868; } .basic-controllers.dark .arrow-right:active, .basic-controllers.dark .arrow-left:active { background-color: #909090; } .basic-controllers.dark .small-arrow-right path, .basic-controllers.dark .small-arrow-bottom path { fill: #909090; } .basic-controllers.dark .small-arrow-right:hover path, .basic-controllers.dark .small-arrow-bottom:hover path { fill: #686868; } .basic-controllers.dark .number, .basic-controllers.dark select, .basic-controllers.dark input[type=text] { color: #ffffff; background-color: #333333; } .basic-controllers.dark .btn { background-color: #464646; color: #ffffff; } .basic-controllers.dark .btn:hover { background-color: #686868; } .basic-controllers.dark .btn:active, .basic-controllers.dark .btn.active { background-color: #909090; } .basic-controllers.dark.slider .inner-wrapper .number-wrapper .unit { color: #cdcdcd; } .basic-controllers.dark.group { background-color: #3e3e3e; } .basic-controllers.dark.drag-and-drop .drop-zone { border: 1px dotted #424242; } .basic-controllers.dark.drag-and-drop .drop-zone.drag { background-color: #424242; } ";
},{}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ns = undefined;
exports.disable = disable;
exports.insertStyleSheet = insertStyleSheet;

var _package = require('../../package.json');

var _stylesDeclarations = require('./styles-declarations.js');

var _stylesDeclarations2 = _interopRequireDefault(_stylesDeclarations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ns = exports.ns = _package.name;

var nsClass = '.' + ns;
var _disabled = false;

function disable() {
  _disabled = true;
}

function insertStyleSheet() {
  if (_disabled) return;

  var $css = document.createElement('style');
  $css.setAttribute('data-namespace', ns);
  $css.type = 'text/css';

  if ($css.styleSheet) $css.styleSheet.cssText = _stylesDeclarations2.default;else $css.appendChild(document.createTextNode(_stylesDeclarations2.default));

  // insert before link or styles if exists
  var $link = document.head.querySelector('link');
  var $style = document.head.querySelector('style');

  if ($link) document.head.insertBefore($css, $link);else if ($style) document.head.insertBefore($css, $style);else document.head.appendChild($css);
}

},{"../../package.json":63,"./styles-declarations.js":61}],63:[function(require,module,exports){
module.exports={
  "_from": "github:ircam-jstools/basic-controllers#v1.0.1",
  "_id": "basic-controllers@1.0.1",
  "_inBundle": false,
  "_location": "/basic-controllers",
  "_phantomChildren": {},
  "_requested": {
    "type": "git",
    "raw": "basic-controllers@github:ircam-jstools/basic-controllers#v1.0.1",
    "name": "basic-controllers",
    "escapedName": "basic-controllers",
    "rawSpec": "github:ircam-jstools/basic-controllers#v1.0.1",
    "saveSpec": "github:ircam-jstools/basic-controllers#v1.0.1",
    "fetchSpec": null,
    "gitCommittish": "v1.0.1"
  },
  "_requiredBy": [
    "/soundworks"
  ],
  "_resolved": "github:ircam-jstools/basic-controllers#9625a513183c1a38931c663354debe94dafb841c",
  "_spec": "basic-controllers@github:ircam-jstools/basic-controllers#v1.0.1",
  "_where": "/Users/scurto/coloop/node_modules/soundworks",
  "bugs": {
    "url": "https://github.com/ircam-jstools/basic-controllers/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "babel-runtime": "^6.18.0",
    "gui-components": "github:ircam-jstools/gui-components#v1.0.1"
  },
  "deprecated": false,
  "description": "Set of simple controllers for rapid prototyping",
  "devDependencies": {
    "babel-core": "^6.18.2",
    "babel-plugin-transform-es2015-modules-commonjs": "^6.18.0",
    "babel-plugin-transform-runtime": "^6.15.0",
    "babel-preset-es2015": "^6.18.0",
    "colors": "^1.1.2",
    "fs-extra": "^1.0.0",
    "jsdoc-to-markdown": "^2.0.1",
    "node-sass": "^3.13.0",
    "watch": "^1.0.1"
  },
  "homepage": "https://github.com/ircam-jstools/basic-controllers#readme",
  "license": "BSD-3-Clause",
  "main": "dist/index.js",
  "name": "basic-controllers",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ircam-jstools/basic-controllers.git"
  },
  "scripts": {
    "doc": "jsdoc2md -t tmpl/README.hbs --separators src/**/*.js src/*.js > README.md",
    "prewatch": "node ./bin/runner --transpile",
    "transpile": "node ./bin/runner --transpile",
    "watch": "node ./bin/runner --watch"
  },
  "version": "1.0.1"
}

},{}],64:[function(require,module,exports){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

},{}],65:[function(require,module,exports){

},{}],66:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":44,"ieee754":228}],67:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],68:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],69:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],70:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":102,"../../modules/es6.array.from":176,"../../modules/es6.string.iterator":189}],71:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":174,"../modules/es6.string.iterator":189,"../modules/web.dom.iterable":204}],72:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.is-iterable');

},{"../modules/core.is-iterable":175,"../modules/es6.string.iterator":189,"../modules/web.dom.iterable":204}],73:[function(require,module,exports){
var core = require('../../modules/_core');
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

},{"../../modules/_core":102}],74:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
require('../modules/es7.map.of');
require('../modules/es7.map.from');
module.exports = require('../modules/_core').Map;

},{"../modules/_core":102,"../modules/es6.map":178,"../modules/es6.object.to-string":186,"../modules/es6.string.iterator":189,"../modules/es7.map.from":192,"../modules/es7.map.of":193,"../modules/es7.map.to-json":194,"../modules/web.dom.iterable":204}],75:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":102,"../../modules/es6.object.assign":179}],76:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":102,"../../modules/es6.object.create":180}],77:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":102,"../../modules/es6.object.define-property":181}],78:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":102,"../../modules/es6.object.get-own-property-descriptor":182}],79:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;

},{"../../modules/_core":102,"../../modules/es6.object.get-prototype-of":183}],80:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;

},{"../../modules/_core":102,"../../modules/es6.object.keys":184}],81:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":102,"../../modules/es6.object.set-prototype-of":185}],82:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
require('../modules/es7.promise.finally');
require('../modules/es7.promise.try');
module.exports = require('../modules/_core').Promise;

},{"../modules/_core":102,"../modules/es6.object.to-string":186,"../modules/es6.promise":187,"../modules/es6.string.iterator":189,"../modules/es7.promise.finally":195,"../modules/es7.promise.try":196,"../modules/web.dom.iterable":204}],83:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":102,"../modules/es6.object.to-string":186,"../modules/es6.set":188,"../modules/es6.string.iterator":189,"../modules/es7.set.from":197,"../modules/es7.set.of":198,"../modules/es7.set.to-json":199,"../modules/web.dom.iterable":204}],84:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":102,"../../modules/es6.object.to-string":186,"../../modules/es6.symbol":190,"../../modules/es7.symbol.async-iterator":200,"../../modules/es7.symbol.observable":201}],85:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":171,"../../modules/es6.string.iterator":189,"../../modules/web.dom.iterable":204}],86:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/web.dom.iterable');
require('../modules/es6.weak-map');
require('../modules/es7.weak-map.of');
require('../modules/es7.weak-map.from');
module.exports = require('../modules/_core').WeakMap;

},{"../modules/_core":102,"../modules/es6.object.to-string":186,"../modules/es6.weak-map":191,"../modules/es7.weak-map.from":202,"../modules/es7.weak-map.of":203,"../modules/web.dom.iterable":204}],87:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],88:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],89:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],90:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":122}],91:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":112}],92:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":161,"./_to-iobject":163,"./_to-length":164}],93:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":95,"./_ctx":104,"./_iobject":119,"./_to-length":164,"./_to-object":165}],94:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":121,"./_is-object":122,"./_wks":172}],95:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":94}],96:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":97,"./_wks":172}],97:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],98:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":89,"./_ctx":104,"./_descriptors":106,"./_for-of":112,"./_iter-define":125,"./_iter-step":127,"./_meta":130,"./_object-create":134,"./_object-dp":135,"./_redefine-all":149,"./_set-species":154,"./_validate-collection":169}],99:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":91,"./_classof":96}],100:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":89,"./_an-object":90,"./_array-methods":93,"./_for-of":112,"./_has":114,"./_is-object":122,"./_meta":130,"./_redefine-all":149,"./_validate-collection":169}],101:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":89,"./_array-methods":93,"./_descriptors":106,"./_export":110,"./_fails":111,"./_for-of":112,"./_global":113,"./_hide":115,"./_is-object":122,"./_meta":130,"./_object-dp":135,"./_redefine-all":149,"./_set-to-string-tag":155}],102:[function(require,module,exports){
var core = module.exports = { version: '2.6.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],103:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":135,"./_property-desc":148}],104:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":87}],105:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],106:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":111}],107:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":113,"./_is-object":122}],108:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],109:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":140,"./_object-keys":143,"./_object-pie":144}],110:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":102,"./_ctx":104,"./_global":113,"./_has":114,"./_hide":115}],111:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],112:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":90,"./_ctx":104,"./_is-array-iter":120,"./_iter-call":123,"./_to-length":164,"./core.get-iterator-method":173}],113:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],114:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],115:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":106,"./_object-dp":135,"./_property-desc":148}],116:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":113}],117:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":106,"./_dom-create":107,"./_fails":111}],118:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],119:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":97}],120:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":128,"./_wks":172}],121:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":97}],122:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],123:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":90}],124:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":115,"./_object-create":134,"./_property-desc":148,"./_set-to-string-tag":155,"./_wks":172}],125:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":110,"./_hide":115,"./_iter-create":124,"./_iterators":128,"./_library":129,"./_object-gpo":141,"./_redefine":150,"./_set-to-string-tag":155,"./_wks":172}],126:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":172}],127:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],128:[function(require,module,exports){
module.exports = {};

},{}],129:[function(require,module,exports){
module.exports = true;

},{}],130:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":111,"./_has":114,"./_is-object":122,"./_object-dp":135,"./_uid":167}],131:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":97,"./_global":113,"./_task":160}],132:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":87}],133:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":111,"./_iobject":119,"./_object-gops":140,"./_object-keys":143,"./_object-pie":144,"./_to-object":165}],134:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":90,"./_dom-create":107,"./_enum-bug-keys":108,"./_html":116,"./_object-dps":136,"./_shared-key":156}],135:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":90,"./_descriptors":106,"./_ie8-dom-define":117,"./_to-primitive":166}],136:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":90,"./_descriptors":106,"./_object-dp":135,"./_object-keys":143}],137:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":106,"./_has":114,"./_ie8-dom-define":117,"./_object-pie":144,"./_property-desc":148,"./_to-iobject":163,"./_to-primitive":166}],138:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":139,"./_to-iobject":163}],139:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":108,"./_object-keys-internal":142}],140:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],141:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":114,"./_shared-key":156,"./_to-object":165}],142:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":92,"./_has":114,"./_shared-key":156,"./_to-iobject":163}],143:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":108,"./_object-keys-internal":142}],144:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],145:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":102,"./_export":110,"./_fails":111}],146:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],147:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":90,"./_is-object":122,"./_new-promise-capability":132}],148:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],149:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":115}],150:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":115}],151:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":87,"./_ctx":104,"./_export":110,"./_for-of":112}],152:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":110}],153:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":90,"./_ctx":104,"./_is-object":122,"./_object-gopd":137}],154:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":102,"./_descriptors":106,"./_global":113,"./_object-dp":135,"./_wks":172}],155:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":114,"./_object-dp":135,"./_wks":172}],156:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":157,"./_uid":167}],157:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":102,"./_global":113,"./_library":129}],158:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":87,"./_an-object":90,"./_wks":172}],159:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":105,"./_to-integer":162}],160:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":97,"./_ctx":104,"./_dom-create":107,"./_global":113,"./_html":116,"./_invoke":118}],161:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":162}],162:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],163:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":105,"./_iobject":119}],164:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":162}],165:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":105}],166:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":122}],167:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],168:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":113}],169:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":122}],170:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":102,"./_global":113,"./_library":129,"./_object-dp":135,"./_wks-ext":171}],171:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":172}],172:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":113,"./_shared":157,"./_uid":167}],173:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":96,"./_core":102,"./_iterators":128,"./_wks":172}],174:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":90,"./_core":102,"./core.get-iterator-method":173}],175:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};

},{"./_classof":96,"./_core":102,"./_iterators":128,"./_wks":172}],176:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":103,"./_ctx":104,"./_export":110,"./_is-array-iter":120,"./_iter-call":123,"./_iter-detect":126,"./_to-length":164,"./_to-object":165,"./core.get-iterator-method":173}],177:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":88,"./_iter-define":125,"./_iter-step":127,"./_iterators":128,"./_to-iobject":163}],178:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":101,"./_collection-strong":98,"./_validate-collection":169}],179:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":110,"./_object-assign":133}],180:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":110,"./_object-create":134}],181:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":106,"./_export":110,"./_object-dp":135}],182:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":137,"./_object-sap":145,"./_to-iobject":163}],183:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":141,"./_object-sap":145,"./_to-object":165}],184:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":143,"./_object-sap":145,"./_to-object":165}],185:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":110,"./_set-proto":153}],186:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"dup":65}],187:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":87,"./_an-instance":89,"./_classof":96,"./_core":102,"./_ctx":104,"./_export":110,"./_for-of":112,"./_global":113,"./_is-object":122,"./_iter-detect":126,"./_library":129,"./_microtask":131,"./_new-promise-capability":132,"./_perform":146,"./_promise-resolve":147,"./_redefine-all":149,"./_set-species":154,"./_set-to-string-tag":155,"./_species-constructor":158,"./_task":160,"./_user-agent":168,"./_wks":172}],188:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":101,"./_collection-strong":98,"./_validate-collection":169}],189:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":125,"./_string-at":159}],190:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":90,"./_descriptors":106,"./_enum-keys":109,"./_export":110,"./_fails":111,"./_global":113,"./_has":114,"./_hide":115,"./_is-array":121,"./_is-object":122,"./_library":129,"./_meta":130,"./_object-create":134,"./_object-dp":135,"./_object-gopd":137,"./_object-gopn":139,"./_object-gopn-ext":138,"./_object-gops":140,"./_object-keys":143,"./_object-pie":144,"./_property-desc":148,"./_redefine":150,"./_set-to-string-tag":155,"./_shared":157,"./_to-iobject":163,"./_to-primitive":166,"./_uid":167,"./_wks":172,"./_wks-define":170,"./_wks-ext":171}],191:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":93,"./_collection":101,"./_collection-weak":100,"./_fails":111,"./_is-object":122,"./_meta":130,"./_object-assign":133,"./_redefine":150,"./_validate-collection":169}],192:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":151}],193:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":152}],194:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":99,"./_export":110}],195:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":102,"./_export":110,"./_global":113,"./_promise-resolve":147,"./_species-constructor":158}],196:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":110,"./_new-promise-capability":132,"./_perform":146}],197:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":151}],198:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":152}],199:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":99,"./_export":110}],200:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":170}],201:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":170}],202:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":151}],203:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":152}],204:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":113,"./_hide":115,"./_iterators":128,"./_wks":172,"./es6.array.iterator":177}],205:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":206,"_process":247}],206:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":241}],207:[function(require,module,exports){
/*jshint browser:true, node:true*/

'use strict';

module.exports = Delegate;

/**
 * DOM event delegator
 *
 * The delegator will listen
 * for events that bubble up
 * to the root node.
 *
 * @constructor
 * @param {Node|string} [root] The root node or a selector string matching the root node
 */
function Delegate(root) {

  /**
   * Maintain a map of listener
   * lists, keyed by event name.
   *
   * @type Object
   */
  this.listenerMap = [{}, {}];
  if (root) {
    this.root(root);
  }

  /** @type function() */
  this.handle = Delegate.prototype.handle.bind(this);
}

/**
 * Start listening for events
 * on the provided DOM element
 *
 * @param  {Node|string} [root] The root node or a selector string matching the root node
 * @returns {Delegate} This method is chainable
 */
Delegate.prototype.root = function(root) {
  var listenerMap = this.listenerMap;
  var eventType;

  // Remove master event listeners
  if (this.rootElement) {
    for (eventType in listenerMap[1]) {
      if (listenerMap[1].hasOwnProperty(eventType)) {
        this.rootElement.removeEventListener(eventType, this.handle, true);
      }
    }
    for (eventType in listenerMap[0]) {
      if (listenerMap[0].hasOwnProperty(eventType)) {
        this.rootElement.removeEventListener(eventType, this.handle, false);
      }
    }
  }

  // If no root or root is not
  // a dom node, then remove internal
  // root reference and exit here
  if (!root || !root.addEventListener) {
    if (this.rootElement) {
      delete this.rootElement;
    }
    return this;
  }

  /**
   * The root node at which
   * listeners are attached.
   *
   * @type Node
   */
  this.rootElement = root;

  // Set up master event listeners
  for (eventType in listenerMap[1]) {
    if (listenerMap[1].hasOwnProperty(eventType)) {
      this.rootElement.addEventListener(eventType, this.handle, true);
    }
  }
  for (eventType in listenerMap[0]) {
    if (listenerMap[0].hasOwnProperty(eventType)) {
      this.rootElement.addEventListener(eventType, this.handle, false);
    }
  }

  return this;
};

/**
 * @param {string} eventType
 * @returns boolean
 */
Delegate.prototype.captureForType = function(eventType) {
  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;
};

/**
 * Attach a handler to one
 * event for all elements
 * that match the selector,
 * now or in the future
 *
 * The handler function receives
 * three arguments: the DOM event
 * object, the node that matched
 * the selector while the event
 * was bubbling and a reference
 * to itself. Within the handler,
 * 'this' is equal to the second
 * argument.
 *
 * The node that actually received
 * the event can be accessed via
 * 'event.target'.
 *
 * @param {string} eventType Listen for these events
 * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element
 * @param {function()} handler Handler function - event data passed here will be in event.data
 * @param {boolean} [useCapture] see 'useCapture' in <https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener>
 * @returns {Delegate} This method is chainable
 */
Delegate.prototype.on = function(eventType, selector, handler, useCapture) {
  var root, listenerMap, matcher, matcherParam;

  if (!eventType) {
    throw new TypeError('Invalid event type: ' + eventType);
  }

  // handler can be passed as
  // the second or third argument
  if (typeof selector === 'function') {
    useCapture = handler;
    handler = selector;
    selector = null;
  }

  // Fallback to sensible defaults
  // if useCapture not set
  if (useCapture === undefined) {
    useCapture = this.captureForType(eventType);
  }

  if (typeof handler !== 'function') {
    throw new TypeError('Handler must be a type of Function');
  }

  root = this.rootElement;
  listenerMap = this.listenerMap[useCapture ? 1 : 0];

  // Add master handler for type if not created yet
  if (!listenerMap[eventType]) {
    if (root) {
      root.addEventListener(eventType, this.handle, useCapture);
    }
    listenerMap[eventType] = [];
  }

  if (!selector) {
    matcherParam = null;

    // COMPLEX - matchesRoot needs to have access to
    // this.rootElement, so bind the function to this.
    matcher = matchesRoot.bind(this);

  // Compile a matcher for the given selector
  } else if (/^[a-z]+$/i.test(selector)) {
    matcherParam = selector;
    matcher = matchesTag;
  } else if (/^#[a-z0-9\-_]+$/i.test(selector)) {
    matcherParam = selector.slice(1);
    matcher = matchesId;
  } else {
    matcherParam = selector;
    matcher = matches;
  }

  // Add to the list of listeners
  listenerMap[eventType].push({
    selector: selector,
    handler: handler,
    matcher: matcher,
    matcherParam: matcherParam
  });

  return this;
};

/**
 * Remove an event handler
 * for elements that match
 * the selector, forever
 *
 * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters
 * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed
 * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed
 * @returns {Delegate} This method is chainable
 */
Delegate.prototype.off = function(eventType, selector, handler, useCapture) {
  var i, listener, listenerMap, listenerList, singleEventType;

  // Handler can be passed as
  // the second or third argument
  if (typeof selector === 'function') {
    useCapture = handler;
    handler = selector;
    selector = null;
  }

  // If useCapture not set, remove
  // all event listeners
  if (useCapture === undefined) {
    this.off(eventType, selector, handler, true);
    this.off(eventType, selector, handler, false);
    return this;
  }

  listenerMap = this.listenerMap[useCapture ? 1 : 0];
  if (!eventType) {
    for (singleEventType in listenerMap) {
      if (listenerMap.hasOwnProperty(singleEventType)) {
        this.off(singleEventType, selector, handler);
      }
    }

    return this;
  }

  listenerList = listenerMap[eventType];
  if (!listenerList || !listenerList.length) {
    return this;
  }

  // Remove only parameter matches
  // if specified
  for (i = listenerList.length - 1; i >= 0; i--) {
    listener = listenerList[i];

    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {
      listenerList.splice(i, 1);
    }
  }

  // All listeners removed
  if (!listenerList.length) {
    delete listenerMap[eventType];

    // Remove the main handler
    if (this.rootElement) {
      this.rootElement.removeEventListener(eventType, this.handle, useCapture);
    }
  }

  return this;
};


/**
 * Handle an arbitrary event.
 *
 * @param {Event} event
 */
Delegate.prototype.handle = function(event) {
  var i, l, type = event.type, root, phase, listener, returned, listenerList = [], target, /** @const */ EVENTIGNORE = 'ftLabsDelegateIgnore';

  if (event[EVENTIGNORE] === true) {
    return;
  }

  target = event.target;

  // Hardcode value of Node.TEXT_NODE
  // as not defined in IE8
  if (target.nodeType === 3) {
    target = target.parentNode;
  }

  root = this.rootElement;

  phase = event.eventPhase || ( event.target !== event.currentTarget ? 3 : 2 );
  
  switch (phase) {
    case 1: //Event.CAPTURING_PHASE:
      listenerList = this.listenerMap[1][type];
    break;
    case 2: //Event.AT_TARGET:
      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);
      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);
    break;
    case 3: //Event.BUBBLING_PHASE:
      listenerList = this.listenerMap[0][type];
    break;
  }

  // Need to continuously check
  // that the specific list is
  // still populated in case one
  // of the callbacks actually
  // causes the list to be destroyed.
  l = listenerList.length;
  while (target && l) {
    for (i = 0; i < l; i++) {
      listener = listenerList[i];

      // Bail from this loop if
      // the length changed and
      // no more listeners are
      // defined between i and l.
      if (!listener) {
        break;
      }

      // Check for match and fire
      // the event if there's one
      //
      // TODO:MCG:20120117: Need a way
      // to check if event#stopImmediatePropagation
      // was called. If so, break both loops.
      if (listener.matcher.call(target, listener.matcherParam, target)) {
        returned = this.fire(event, target, listener);
      }

      // Stop propagation to subsequent
      // callbacks if the callback returned
      // false
      if (returned === false) {
        event[EVENTIGNORE] = true;
        event.preventDefault();
        return;
      }
    }

    // TODO:MCG:20120117: Need a way to
    // check if event#stopPropagation
    // was called. If so, break looping
    // through the DOM. Stop if the
    // delegation root has been reached
    if (target === root) {
      break;
    }

    l = listenerList.length;
    target = target.parentElement;
  }
};

/**
 * Fire a listener on a target.
 *
 * @param {Event} event
 * @param {Node} target
 * @param {Object} listener
 * @returns {boolean}
 */
Delegate.prototype.fire = function(event, target, listener) {
  return listener.handler.call(target, event, target);
};

/**
 * Check whether an element
 * matches a generic selector.
 *
 * @type function()
 * @param {string} selector A CSS selector
 */
var matches = (function(el) {
  if (!el) return;
  var p = el.prototype;
  return (p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector);
}(Element));

/**
 * Check whether an element
 * matches a tag selector.
 *
 * Tags are NOT case-sensitive,
 * except in XML (and XML-based
 * languages such as XHTML).
 *
 * @param {string} tagName The tag name to test against
 * @param {Element} element The element to test with
 * @returns boolean
 */
function matchesTag(tagName, element) {
  return tagName.toLowerCase() === element.tagName.toLowerCase();
}

/**
 * Check whether an element
 * matches the root.
 *
 * @param {?String} selector In this case this is always passed through as null and not used
 * @param {Element} element The element to test with
 * @returns boolean
 */
function matchesRoot(selector, element) {
  /*jshint validthis:true*/
  if (this.rootElement === window) return element === document;
  return this.rootElement === element;
}

/**
 * Check whether the ID of
 * the element in 'this'
 * matches the given ID.
 *
 * IDs are case-sensitive.
 *
 * @param {string} id The ID to test against
 * @param {Element} element The element to test with
 * @returns boolean
 */
function matchesId(id, element) {
  return id === element.id;
}

/**
 * Short hand for off()
 * and root(), ie both
 * with no parameters
 *
 * @return void
 */
Delegate.prototype.destroy = function() {
  this.off();
  this.root();
};

},{}],208:[function(require,module,exports){
/*jshint browser:true, node:true*/

'use strict';

/**
 * @preserve Create and manage a DOM event delegator.
 *
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */
var Delegate = require('./delegate');

module.exports = function(root) {
  return new Delegate(root);
};

module.exports.Delegate = Delegate;

},{"./delegate":207}],209:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":210,"engine.io-parser":220}],210:[function(require,module,exports){
/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

},{"./transport":211,"./transports/index":212,"component-emitter":68,"debug":218,"engine.io-parser":220,"indexof":229,"parseqs":243,"parseuri":244}],211:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":68,"engine.io-parser":220}],212:[function(require,module,exports){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

},{"./polling-jsonp":213,"./polling-xhr":214,"./websocket":216,"xmlhttprequest-ssl":217}],213:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */
function glob () {
  return typeof self !== 'undefined' ? self
      : typeof window !== 'undefined' ? window
      : typeof global !== 'undefined' ? global : {};
}

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = (global.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":215,"component-inherit":69}],214:[function(require,module,exports){
/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

},{"./polling":215,"component-emitter":68,"component-inherit":69,"debug":218,"xmlhttprequest-ssl":217}],215:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":211,"component-inherit":69,"debug":218,"engine.io-parser":220,"parseqs":243,"xmlhttprequest-ssl":217,"yeast":332}],216:[function(require,module,exports){
(function (Buffer){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
} else {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

}).call(this,require("buffer").Buffer)

},{"../transport":211,"buffer":66,"component-inherit":69,"debug":218,"engine.io-parser":220,"parseqs":243,"ws":65,"yeast":332}],217:[function(require,module,exports){
// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

},{"has-cors":227}],218:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":219,"_process":247}],219:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":241}],220:[function(require,module,exports){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary2');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('./utf8');

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

},{"./keys":221,"./utf8":222,"after":13,"arraybuffer.slice":14,"base64-arraybuffer":43,"blob":64,"has-binary2":225}],221:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],222:[function(require,module,exports){
/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, it’s not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};

},{}],223:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getScale(domain, range) {
  var slope = (range[1] - range[0]) / (domain[1] - domain[0]);
  var intercept = range[0] - slope * domain[0];

  function scale(val) {
    return slope * val + intercept;
  }

  scale.invert = function (val) {
    return (val - intercept) / slope;
  };

  return scale;
}

function getClipper(min, max, step) {
  return function (val) {
    var clippedValue = Math.round(val / step) * step;
    var fixed = Math.max(Math.log10(1 / step), 0);
    var fixedValue = clippedValue.toFixed(fixed); // fix floating point errors
    return Math.min(max, Math.max(min, parseFloat(fixedValue)));
  };
}

/**
 * @module gui-components
 */

/**
 * Versatile canvas based slider.
 *
 * @param {Object} options - Override default parameters.
 * @param {'jump'|'proportionnal'|'handle'} [options.mode='jump'] - Mode of the slider:
 *  - in 'jump' mode, the value is changed on 'touchstart' or 'mousedown', and
 *    on move.
 *  - in 'proportionnal' mode, the value is updated relatively to move.
 *  - in 'handle' mode, the slider can be grabbed only around its value.
 * @param {Function} [options.callback] - Callback to be executed when the value
 *  of the slider changes.
 * @param {Number} [options.width=200] - Width of the slider.
 * @param {Number} [options.height=30] - Height of the slider.
 * @param {Number} [options.min=0] - Minimum value.
 * @param {Number} [options.max=1] - Maximum value.
 * @param {Number} [options.step=0.01] - Step between each consecutive values.
 * @param {Number} [options.default=0] - Default value.
 * @param {String|Element} [options.container='body'] - CSS Selector or DOM
 *  element in which inserting the slider.
 * @param {String} [options.backgroundColor='#464646'] - Background color of the
 *  slider.
 * @param {String} [options.foregroundColor='steelblue'] - Foreground color of
 *  the slider.
 * @param {'horizontal'|'vertical'} [options.orientation='horizontal'] -
 *  Orientation of the slider.
 * @param {Array} [options.markers=[]] - List of values where markers should
 *  be displayed on the slider.
 * @param {Boolean} [options.showHandle=true] - In 'handle' mode, define if the
 *  draggable should be show or not.
 * @param {Number} [options.handleSize=20] - Size of the draggable zone.
 * @param {String} [options.handleColor='rgba(255, 255, 255, 0.7)'] - Color of the
 *  draggable zone (when `showHandle` is `true`).
 *
 * @example
 * import { Slider} from 'gui-components';
 *
 * const slider = new Slider({
 *   mode: 'jump',
 *   container: '#container',
 *   default: 0.6,
 *   markers: [0.5],
 *   callback: (value) => console.log(value),
 * });
 */

var Slider = function () {
  function Slider(options) {
    _classCallCheck(this, Slider);

    var defaults = {
      mode: 'jump',
      callback: function callback(value) {},
      width: 200,
      height: 30,
      min: 0,
      max: 1,
      step: 0.01,
      default: 0,
      container: 'body',
      backgroundColor: '#464646',
      foregroundColor: 'steelblue',
      orientation: 'horizontal',
      markers: [],

      // handle specific options
      showHandle: true,
      handleSize: 20,
      handleColor: 'rgba(255, 255, 255, 0.7)'
    };

    this.params = Object.assign({}, defaults, options);
    this._listeners = [];
    this._boundingClientRect = null;
    this._touchId = null;
    this._value = null;
    this._canvasWidth = null;
    this._canvasHeight = null;
    // for proportionnal mode
    this._currentMousePosition = { x: null, y: null };
    this._currentSliderPosition = null;

    this._onMouseDown = this._onMouseDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    this._onMouseUp = this._onMouseUp.bind(this);

    this._onTouchStart = this._onTouchStart.bind(this);
    this._onTouchMove = this._onTouchMove.bind(this);
    this._onTouchEnd = this._onTouchEnd.bind(this);

    this._onResize = this._onResize.bind(this);

    this._createElement();

    // initialize
    this._resizeElement();
    this._setScales();
    this._bindEvents();
    this._onResize();
    this._updateValue(this.params.default, true, true);

    window.addEventListener('resize', this._onResize);
  }

  /**
   * Current value of the slider.
   *
   * @type {Number}
   */


  _createClass(Slider, [{
    key: 'reset',


    /**
     * Reset the slider to its default value.
     */
    value: function reset() {
      this._updateValue(this.params.default);
    }

    /**
     * Resize the slider.
     *
     * @param {Number} width - New width of the slider.
     * @param {Number} height - New height of the slider.
     */

  }, {
    key: 'resize',
    value: function resize(width, height) {
      this.params.width = width;
      this.params.height = height;

      this._resizeElement();
      this._setScales();
      this._onResize();
      this._updateValue(this._value, true, true);
    }
  }, {
    key: '_updateValue',
    value: function _updateValue(value) {
      var _this = this;

      var silent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var forceRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var callback = this.params.callback;

      var clippedValue = this.clipper(value);

      // resize render but don't trigger callback
      if (clippedValue === this._value && forceRender === true) requestAnimationFrame(function () {
        return _this._render(clippedValue);
      });

      // trigger callback
      if (clippedValue !== this._value) {
        this._value = clippedValue;

        if (!silent) callback(clippedValue);

        requestAnimationFrame(function () {
          return _this._render(clippedValue);
        });
      }
    }
  }, {
    key: '_createElement',
    value: function _createElement() {
      var container = this.params.container;

      this.$canvas = document.createElement('canvas');
      this.ctx = this.$canvas.getContext('2d');

      if (container instanceof Element) this.$container = container;else this.$container = document.querySelector(container);

      this.$container.appendChild(this.$canvas);
    }
  }, {
    key: '_resizeElement',
    value: function _resizeElement() {
      var _params = this.params,
          width = _params.width,
          height = _params.height;

      // logical and pixel size of the canvas

      this._pixelRatio = function (ctx) {
        var dPR = window.devicePixelRatio || 1;
        var bPR = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

        return dPR / bPR;
      }(this.ctx);

      this._canvasWidth = width * this._pixelRatio;
      this._canvasHeight = height * this._pixelRatio;

      this.ctx.canvas.width = this._canvasWidth;
      this.ctx.canvas.height = this._canvasHeight;
      this.ctx.canvas.style.width = width + 'px';
      this.ctx.canvas.style.height = height + 'px';
    }
  }, {
    key: '_onResize',
    value: function _onResize() {
      this._boundingClientRect = this.$canvas.getBoundingClientRect();
    }
  }, {
    key: '_setScales',
    value: function _setScales() {
      var _params2 = this.params,
          orientation = _params2.orientation,
          width = _params2.width,
          height = _params2.height,
          min = _params2.min,
          max = _params2.max,
          step = _params2.step;
      // define transfert functions

      var screenSize = orientation === 'horizontal' ? width : height;

      var canvasSize = orientation === 'horizontal' ? this._canvasWidth : this._canvasHeight;

      var domain = orientation === 'horizontal' ? [min, max] : [max, min];
      var screenRange = [0, screenSize];
      var canvasRange = [0, canvasSize];

      this.screenScale = getScale(domain, screenRange);
      this.canvasScale = getScale(domain, canvasRange);
      this.clipper = getClipper(min, max, step);
    }
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      this.$canvas.addEventListener('mousedown', this._onMouseDown);
      this.$canvas.addEventListener('touchstart', this._onTouchStart);
    }
  }, {
    key: '_onStart',
    value: function _onStart(x, y) {
      var started = null;

      switch (this.params.mode) {
        case 'jump':
          this._updatePosition(x, y);
          started = true;
          break;
        case 'proportionnal':
          this._currentMousePosition.x = x;
          this._currentMousePosition.y = y;
          started = true;
          break;
        case 'handle':
          var orientation = this.params.orientation;
          var position = this.screenScale(this._value);
          var compare = orientation === 'horizontal' ? x : y;
          var delta = this.params.handleSize / 2;

          if (compare < position + delta && compare > position - delta) {
            this._currentMousePosition.x = x;
            this._currentMousePosition.y = y;
            started = true;
          } else {
            started = false;
          }
          break;
      }

      return started;
    }
  }, {
    key: '_onMove',
    value: function _onMove(x, y) {
      switch (this.params.mode) {
        case 'jump':
          break;
        case 'proportionnal':
        case 'handle':
          var deltaX = x - this._currentMousePosition.x;
          var deltaY = y - this._currentMousePosition.y;
          this._currentMousePosition.x = x;
          this._currentMousePosition.y = y;

          x = this.screenScale(this._value) + deltaX;
          y = this.screenScale(this._value) + deltaY;
          break;
      }

      this._updatePosition(x, y);
    }
  }, {
    key: '_onEnd',
    value: function _onEnd() {
      switch (this.params.mode) {
        case 'jump':
          break;
        case 'proportionnal':
        case 'handle':
          this._currentMousePosition.x = null;
          this._currentMousePosition.y = null;
          break;
      }
    }

    // mouse events

  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(e) {
      var pageX = e.pageX;
      var pageY = e.pageY;
      var x = pageX - this._boundingClientRect.left;
      var y = pageY - this._boundingClientRect.top;

      if (this._onStart(x, y) === true) {
        window.addEventListener('mousemove', this._onMouseMove);
        window.addEventListener('mouseup', this._onMouseUp);
      }
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(e) {
      e.preventDefault(); // prevent text selection

      var pageX = e.pageX;
      var pageY = e.pageY;
      var x = pageX - this._boundingClientRect.left;;
      var y = pageY - this._boundingClientRect.top;;

      this._onMove(x, y);
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(e) {
      this._onEnd();

      window.removeEventListener('mousemove', this._onMouseMove);
      window.removeEventListener('mouseup', this._onMouseUp);
    }

    // touch events

  }, {
    key: '_onTouchStart',
    value: function _onTouchStart(e) {
      if (this._touchId !== null) return;

      var touch = e.touches[0];
      this._touchId = touch.identifier;

      var pageX = touch.pageX;
      var pageY = touch.pageY;
      var x = pageX - this._boundingClientRect.left;
      var y = pageY - this._boundingClientRect.top;

      if (this._onStart(x, y) === true) {
        window.addEventListener('touchmove', this._onTouchMove);
        window.addEventListener('touchend', this._onTouchEnd);
        window.addEventListener('touchcancel', this._onTouchEnd);
      }
    }
  }, {
    key: '_onTouchMove',
    value: function _onTouchMove(e) {
      var _this2 = this;

      e.preventDefault(); // prevent text selection

      var touches = Array.from(e.touches);
      var touch = touches.filter(function (t) {
        return t.identifier === _this2._touchId;
      })[0];

      if (touch) {
        var pageX = touch.pageX;
        var pageY = touch.pageY;
        var x = pageX - this._boundingClientRect.left;
        var y = pageY - this._boundingClientRect.top;

        this._onMove(x, y);
      }
    }
  }, {
    key: '_onTouchEnd',
    value: function _onTouchEnd(e) {
      var _this3 = this;

      var touches = Array.from(e.touches);
      var touch = touches.filter(function (t) {
        return t.identifier === _this3._touchId;
      })[0];

      if (touch === undefined) {
        this._onEnd();
        this._touchId = null;

        window.removeEventListener('touchmove', this._onTouchMove);
        window.removeEventListener('touchend', this._onTouchEnd);
        window.removeEventListener('touchcancel', this._onTouchEnd);
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(x, y) {
      var _params3 = this.params,
          orientation = _params3.orientation,
          height = _params3.height;

      var position = orientation === 'horizontal' ? x : y;
      var value = this.screenScale.invert(position);

      this._updateValue(value, false, true);
    }
  }, {
    key: '_render',
    value: function _render(clippedValue) {
      var _params4 = this.params,
          backgroundColor = _params4.backgroundColor,
          foregroundColor = _params4.foregroundColor,
          orientation = _params4.orientation;

      var canvasPosition = Math.round(this.canvasScale(clippedValue));
      var width = this._canvasWidth;
      var height = this._canvasHeight;
      var ctx = this.ctx;

      ctx.save();
      ctx.clearRect(0, 0, width, height);

      // background
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, width, height);

      // foreground
      ctx.fillStyle = foregroundColor;

      if (orientation === 'horizontal') ctx.fillRect(0, 0, canvasPosition, height);else ctx.fillRect(0, canvasPosition, width, height);

      // markers
      var markers = this.params.markers;

      for (var i = 0; i < markers.length; i++) {
        var marker = markers[i];
        var position = this.canvasScale(marker);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();

        if (orientation === 'horizontal') {
          ctx.moveTo(position - 0.5, 1);
          ctx.lineTo(position - 0.5, height - 1);
        } else {
          ctx.moveTo(1, height - position + 0.5);
          ctx.lineTo(width - 1, height - position + 0.5);
        }

        ctx.closePath();
        ctx.stroke();
      }

      // handle mode
      if (this.params.mode === 'handle' && this.params.showHandle) {
        var delta = this.params.handleSize * this._pixelRatio / 2;
        var start = canvasPosition - delta;
        var end = canvasPosition + delta;

        ctx.globalAlpha = 1;
        ctx.fillStyle = this.params.handleColor;

        if (orientation === 'horizontal') {
          ctx.fillRect(start, 0, end - start, height);
        } else {
          ctx.fillRect(0, start, width, end - start);
        }
      }

      ctx.restore();
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(val) {
      // don't trigger the callback when value is set from outside
      this._updateValue(val, true, false);
    }
  }]);

  return Slider;
}();

exports.default = Slider;

},{}],224:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Slider = require('./Slider');

Object.defineProperty(exports, 'Slider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Slider).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./Slider":223}],225:[function(require,module,exports){
(function (Buffer){
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

}).call(this,require("buffer").Buffer)

},{"buffer":66,"isarray":226}],226:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],227:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],228:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],229:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],230:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;

},{}],231:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = require('lodash._reinterpolate'),
    templateSettings = require('lodash.templatesettings');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Used by `_.defaults` to customize its `_.assignIn` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function assignInDefaults(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  return (objectToString.call(value) == errorTag) ||
    (typeof value.message == 'string' && typeof value.name == 'string');
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, assignInDefaults);

  var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = template;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash._reinterpolate":230,"lodash.templatesettings":232}],232:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = require('lodash._reinterpolate');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g,
    reEvaluate = /<%([\s\S]+?)%>/g;

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB). Change the following template settings to use
 * alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the
 * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = templateSettings;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash._reinterpolate":230}],233:[function(require,module,exports){
// THIS FILE IS GENERATED - DO NOT EDIT!
/*!mobile-detect v1.4.3 2018-09-08*/
/*global module:false, define:false*/
/*jshint latedef:false*/
/*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
(function (define, undefined) {
define(function () {
    'use strict';

    var impl = {};

    impl.mobileDetectRules = {
    "phones": {
        "iPhone": "\\biPhone\\b|\\biPod\\b",
        "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+",
        "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
        "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
        "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
        "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
        "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F",
        "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)",
        "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
        "Asus": "Asus.*Galaxy|PadFone.*Mobile",
        "NokiaLumia": "Lumia [0-9]{3,4}",
        "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
        "Palm": "PalmSource|Palm",
        "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
        "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
        "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
        "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
        "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
        "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
        "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
        "Alcatel": "Alcatel",
        "Nintendo": "Nintendo (3DS|Switch)",
        "Amoi": "Amoi",
        "INQ": "INQ",
        "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
    },
    "tablets": {
        "iPad": "iPad|iPad.*Mobile",
        "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
        "GoogleTablet": "Android.*Pixel C",
        "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835",
        "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk\/[0-9.]+ like Chrome\/[0-9.]+ (?!Mobile)",
        "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
        "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
        "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
        "BlackBerryTablet": "PlayBook|RIM Tablet",
        "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
        "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
        "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
        "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30",
        "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
        "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
        "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
        "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
        "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304F|TB-X304L|TB-8703F|Tab2A7-10F|TB2-X30L",
        "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
        "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
        "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
        "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
        "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
        "IRUTablet": "M702pro",
        "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
        "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
        "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
        "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
        "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
        "NokiaLumiaTablet": "Lumia 2520",
        "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
        "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
        "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
        "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
        "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
        "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
        "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
        "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
        "FlyTablet": "IQ310|Fly Vision",
        "bqTablet": "Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))|Maxwell.*Lite|Maxwell.*Plus",
        "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09",
        "NecTablet": "\\bN-06D|\\bN-08D",
        "PantechTablet": "Pantech.*P4100",
        "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
        "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
        "ZyncTablet": "z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900",
        "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
        "NabiTablet": "Android.*\\bNabi",
        "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
        "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
        "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
        "PlaystationTablet": "Playstation.*(Portable|Vita)",
        "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
        "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
        "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
        "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
        "GalapadTablet": "Android.*\\bG1\\b(?!\\))",
        "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
        "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
        "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
        "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
        "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
        "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
        "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
        "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
        "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
        "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
        "DPSTablet": "DPS Dream 9|DPS Dual 7",
        "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
        "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
        "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
        "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
        "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
        "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
        "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
        "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
        "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
        "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497",
        "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
        "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
        "iMobileTablet": "i-mobile i-note",
        "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
        "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
        "AMPETablet": "Android.* A78 ",
        "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
        "TecnoTablet": "TECNO P9|TECNO DP8D",
        "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
        "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
        "FX2Tablet": "FX2 PAD7|FX2 PAD10",
        "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
        "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
        "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
        "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
        "CaptivaTablet": "CAPTIVA PAD",
        "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
        "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
        "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
        "JaytechTablet": "TPC-PA762",
        "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
        "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
        "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
        "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
        "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
        "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
        "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
        "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
        "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
        "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
        "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
        "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
        "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
        "UbislateTablet": "UbiSlate[\\s]?7C",
        "PocketBookTablet": "Pocketbook",
        "KocasoTablet": "\\b(TB-1207)\\b",
        "HisenseTablet": "\\b(F5281|E2371)\\b",
        "Hudl": "Hudl HT7S3|Hudl 2",
        "TelstraTablet": "T-Hub2",
        "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
    },
    "oss": {
        "AndroidOS": "Android",
        "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
        "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
        "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
        "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;",
        "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
        "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
        "MeeGoOS": "MeeGo",
        "MaemoOS": "Maemo",
        "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
        "webOS": "webOS|hpwOS",
        "badaOS": "\\bBada\\b",
        "BREWOS": "BREW"
    },
    "uas": {
        "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
        "Dolfin": "\\bDolfin\\b",
        "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+$|Coast\/[0-9.]+",
        "Skyfire": "Skyfire",
        "Edge": "Mobile Safari\/[.0-9]* Edge",
        "IE": "IEMobile|MSIEMobile",
        "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
        "Bolt": "bolt",
        "TeaShark": "teashark",
        "Blazer": "Blazer",
        "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
        "WeChat": "\\bMicroMessenger\\b",
        "UCBrowser": "UC.*Browser|UCWEB",
        "baiduboxapp": "baiduboxapp",
        "baidubrowser": "baidubrowser",
        "DiigoBrowser": "DiigoBrowser",
        "Puffin": "Puffin",
        "Mercury": "\\bMercury\\b",
        "ObigoBrowser": "Obigo",
        "NetFront": "NF-Browser",
        "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
        "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
    },
    "props": {
        "Mobile": "Mobile\/[VER]",
        "Build": "Build\/[VER]",
        "Version": "Version\/[VER]",
        "VendorID": "VendorID\/[VER]",
        "iPad": "iPad.*CPU[a-z ]+[VER]",
        "iPhone": "iPhone.*CPU[a-z ]+[VER]",
        "iPod": "iPod.*CPU[a-z ]+[VER]",
        "Kindle": "Kindle\/[VER]",
        "Chrome": [
            "Chrome\/[VER]",
            "CriOS\/[VER]",
            "CrMo\/[VER]"
        ],
        "Coast": [
            "Coast\/[VER]"
        ],
        "Dolfin": "Dolfin\/[VER]",
        "Firefox": [
            "Firefox\/[VER]",
            "FxiOS\/[VER]"
        ],
        "Fennec": "Fennec\/[VER]",
        "Edge": "Edge\/[VER]",
        "IE": [
            "IEMobile\/[VER];",
            "IEMobile [VER]",
            "MSIE [VER];",
            "Trident\/[0-9.]+;.*rv:[VER]"
        ],
        "NetFront": "NetFront\/[VER]",
        "NokiaBrowser": "NokiaBrowser\/[VER]",
        "Opera": [
            " OPR\/[VER]",
            "Opera Mini\/[VER]",
            "Version\/[VER]"
        ],
        "Opera Mini": "Opera Mini\/[VER]",
        "Opera Mobi": "Version\/[VER]",
        "UCBrowser": [
            "UCWEB[VER]",
            "UC.*Browser\/[VER]"
        ],
        "MQQBrowser": "MQQBrowser\/[VER]",
        "MicroMessenger": "MicroMessenger\/[VER]",
        "baiduboxapp": "baiduboxapp\/[VER]",
        "baidubrowser": "baidubrowser\/[VER]",
        "SamsungBrowser": "SamsungBrowser\/[VER]",
        "Iron": "Iron\/[VER]",
        "Safari": [
            "Version\/[VER]",
            "Safari\/[VER]"
        ],
        "Skyfire": "Skyfire\/[VER]",
        "Tizen": "Tizen\/[VER]",
        "Webkit": "webkit[ \/][VER]",
        "PaleMoon": "PaleMoon\/[VER]",
        "Gecko": "Gecko\/[VER]",
        "Trident": "Trident\/[VER]",
        "Presto": "Presto\/[VER]",
        "Goanna": "Goanna\/[VER]",
        "iOS": " \\bi?OS\\b [VER][ ;]{1}",
        "Android": "Android [VER]",
        "BlackBerry": [
            "BlackBerry[\\w]+\/[VER]",
            "BlackBerry.*Version\/[VER]",
            "Version\/[VER]"
        ],
        "BREW": "BREW [VER]",
        "Java": "Java\/[VER]",
        "Windows Phone OS": [
            "Windows Phone OS [VER]",
            "Windows Phone [VER]"
        ],
        "Windows Phone": "Windows Phone [VER]",
        "Windows CE": "Windows CE\/[VER]",
        "Windows NT": "Windows NT [VER]",
        "Symbian": [
            "SymbianOS\/[VER]",
            "Symbian\/[VER]"
        ],
        "webOS": [
            "webOS\/[VER]",
            "hpwOS\/[VER];"
        ]
    },
    "utils": {
        "Bot": "Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom",
        "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
        "DesktopMode": "WPDesktop",
        "TV": "SonyDTV|HbbTV",
        "WebKit": "(webkit)[ \/]([\\w.]+)",
        "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
        "Watch": "SM-V700"
    }
};

    // following patterns come from http://detectmobilebrowsers.com/
    impl.detectMobileBrowsers = {
        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
        tabletPattern: /android|ipad|playbook|silk/i
    };

    var hasOwnProp = Object.prototype.hasOwnProperty,
        isArray;

    impl.FALLBACK_PHONE = 'UnknownPhone';
    impl.FALLBACK_TABLET = 'UnknownTablet';
    impl.FALLBACK_MOBILE = 'UnknownMobile';

    isArray = ('isArray' in Array) ?
        Array.isArray : function (value) { return Object.prototype.toString.call(value) === '[object Array]'; };

    function equalIC(a, b) {
        return a != null && b != null && a.toLowerCase() === b.toLowerCase();
    }

    function containsIC(array, value) {
        var valueLC, i, len = array.length;
        if (!len || !value) {
            return false;
        }
        valueLC = value.toLowerCase();
        for (i = 0; i < len; ++i) {
            if (valueLC === array[i].toLowerCase()) {
                return true;
            }
        }
        return false;
    }

    function convertPropsToRegExp(object) {
        for (var key in object) {
            if (hasOwnProp.call(object, key)) {
                object[key] = new RegExp(object[key], 'i');
            }
        }
    }

    function prepareUserAgent(userAgent) {
        return (userAgent || '').substr(0, 500); // mitigate vulnerable to ReDoS
    }

    (function init() {
        var key, values, value, i, len, verPos, mobileDetectRules = impl.mobileDetectRules;
        for (key in mobileDetectRules.props) {
            if (hasOwnProp.call(mobileDetectRules.props, key)) {
                values = mobileDetectRules.props[key];
                if (!isArray(values)) {
                    values = [values];
                }
                len = values.length;
                for (i = 0; i < len; ++i) {
                    value = values[i];
                    verPos = value.indexOf('[VER]');
                    if (verPos >= 0) {
                        value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
                    }
                    values[i] = new RegExp(value, 'i');
                }
                mobileDetectRules.props[key] = values;
            }
        }
        convertPropsToRegExp(mobileDetectRules.oss);
        convertPropsToRegExp(mobileDetectRules.phones);
        convertPropsToRegExp(mobileDetectRules.tablets);
        convertPropsToRegExp(mobileDetectRules.uas);
        convertPropsToRegExp(mobileDetectRules.utils);

        // copy some patterns to oss0 which are tested first (see issue#15)
        mobileDetectRules.oss0 = {
            WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
            WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
        };
    }());

    /**
     * Test userAgent string against a set of rules and find the first matched key.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
     * @private
     */
    impl.findMatch = function(rules, userAgent) {
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    return key;
                }
            }
        }
        return null;
    };

    /**
     * Test userAgent string against a set of rules and return an array of matched keys.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
     * @private
     */
    impl.findMatches = function(rules, userAgent) {
        var result = [];
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    result.push(key);
                }
            }
        }
        return result;
    };

    /**
     * Check the version of the given property in the User-Agent.
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {String} version or <tt>null</tt> if version not found
     * @private
     */
    impl.getVersionStr = function (propertyName, userAgent) {
        var props = impl.mobileDetectRules.props, patterns, i, len, match;
        if (hasOwnProp.call(props, propertyName)) {
            patterns = props[propertyName];
            len = patterns.length;
            for (i = 0; i < len; ++i) {
                match = patterns[i].exec(userAgent);
                if (match !== null) {
                    return match[1];
                }
            }
        }
        return null;
    };

    /**
     * Check the version of the given property in the User-Agent.
     * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {Number} version or <tt>NaN</tt> if version not found
     * @private
     */
    impl.getVersion = function (propertyName, userAgent) {
        var version = impl.getVersionStr(propertyName, userAgent);
        return version ? impl.prepareVersionNo(version) : NaN;
    };

    /**
     * Prepare the version number.
     *
     * @param {String} version
     * @return {Number} the version number as a floating number
     * @private
     */
    impl.prepareVersionNo = function (version) {
        var numbers;

        numbers = version.split(/[a-z._ \/\-]/i);
        if (numbers.length === 1) {
            version = numbers[0];
        }
        if (numbers.length > 1) {
            version = numbers[0] + '.';
            numbers.shift();
            version += numbers.join('');
        }
        return Number(version);
    };

    impl.isMobileFallback = function (userAgent) {
        return impl.detectMobileBrowsers.fullPattern.test(userAgent) ||
            impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0,4));
    };

    impl.isTabletFallback = function (userAgent) {
        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
    };

    impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
        if (cache.mobile !== undefined) {
            return;
        }
        var phone, tablet, phoneSized;

        // first check for stronger tablet rules, then phone (see issue#5)
        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
        if (tablet) {
            cache.mobile = cache.tablet = tablet;
            cache.phone = null;
            return; // unambiguously identified as tablet
        }

        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
        if (phone) {
            cache.mobile = cache.phone = phone;
            cache.tablet = null;
            return; // unambiguously identified as phone
        }

        // our rules haven't found a match -> try more general fallback rules
        if (impl.isMobileFallback(userAgent)) {
            phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
            if (phoneSized === undefined) {
                cache.mobile = impl.FALLBACK_MOBILE;
                cache.tablet = cache.phone = null;
            } else if (phoneSized) {
                cache.mobile = cache.phone = impl.FALLBACK_PHONE;
                cache.tablet = null;
            } else {
                cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                cache.phone = null;
            }
        } else if (impl.isTabletFallback(userAgent)) {
            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
            cache.phone = null;
        } else {
            // not mobile at all!
            cache.mobile = cache.tablet = cache.phone = null;
        }
    };

    // t is a reference to a MobileDetect instance
    impl.mobileGrade = function (t) {
        // impl note:
        // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
        // When changes are made in Mobile_Detect.php, copy this method and replace:
        //     $this-> / t.
        //     self::MOBILE_GRADE_(.) / '$1'
        //     , self::VERSION_TYPE_FLOAT / (nothing)
        //     isIOS() / os('iOS')
        //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
        var $isMobile = t.mobile() !== null;

        if (
            // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
            t.os('iOS') && t.version('iPad')>=4.3 ||
            t.os('iOS') && t.version('iPhone')>=3.1 ||
            t.os('iOS') && t.version('iPod')>=3.1 ||

            // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
            // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
            // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
            // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
            ( t.version('Android')>2.1 && t.is('Webkit') ) ||

            // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
            t.version('Windows Phone OS')>=7.0 ||

            // Blackberry 7 - Tested on BlackBerry Torch 9810
            // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
            t.is('BlackBerry') && t.version('BlackBerry')>=6.0 ||
            // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
            t.match('Playbook.*Tablet') ||

            // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
            ( t.version('webOS')>=1.4 && t.match('Palm|Pre|Pixi') ) ||
            // Palm WebOS 3.0  - Tested on HP TouchPad
            t.match('hp.*TouchPad') ||

            // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
            ( t.is('Firefox') && t.version('Firefox')>=12 ) ||

            // Chrome for Android - Tested on Android 4.0, 4.1 device
            ( t.is('Chrome') && t.is('AndroidOS') && t.version('Android')>=4.0 ) ||

            // Skyfire 4.1 - Tested on Android 2.3 device
            ( t.is('Skyfire') && t.version('Skyfire')>=4.1 && t.is('AndroidOS') && t.version('Android')>=2.3 ) ||

            // Opera Mobile 11.5-12: Tested on Android 2.3
            ( t.is('Opera') && t.version('Opera Mobi')>11 && t.is('AndroidOS') ) ||

            // Meego 1.2 - Tested on Nokia 950 and N9
            t.is('MeeGoOS') ||

            // Tizen (pre-release) - Tested on early hardware
            t.is('Tizen') ||

            // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
            // @todo: more tests here!
            t.is('Dolfin') && t.version('Bada')>=2.0 ||

            // UC Browser - Tested on Android 2.3 device
            ( (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android')>=2.3 ) ||

            // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
            ( t.match('Kindle Fire') ||
                t.is('Kindle') && t.version('Kindle')>=3.0 ) ||

            // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
            t.is('AndroidOS') && t.is('NookTablet') ||

            // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
            t.version('Chrome')>=11 && !$isMobile ||

            // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
            t.version('Safari')>=5.0 && !$isMobile ||

            // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
            t.version('Firefox')>=4.0 && !$isMobile ||

            // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
            t.version('MSIE')>=7.0 && !$isMobile ||

            // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
            // @reference: http://my.opera.com/community/openweb/idopera/
            t.version('Opera')>=10 && !$isMobile

            ){
            return 'A';
        }

        if (
            t.os('iOS') && t.version('iPad')<4.3 ||
            t.os('iOS') && t.version('iPhone')<3.1 ||
            t.os('iOS') && t.version('iPod')<3.1 ||

            // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
            t.is('Blackberry') && t.version('BlackBerry')>=5 && t.version('BlackBerry')<6 ||

            //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
            ( t.version('Opera Mini')>=5.0 && t.version('Opera Mini')<=6.5 &&
                (t.version('Android')>=2.3 || t.is('iOS')) ) ||

            // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
            t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') ||

            // @todo: report this (tested on Nokia N71)
            t.version('Opera Mobi')>=11 && t.is('SymbianOS')
            ){
            return 'B';
        }

        if (
        // Blackberry 4.x - Tested on the Curve 8330
            t.version('BlackBerry')<5.0 ||
            // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
            t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile')<=5.2

            ){
            return 'C';
        }

        //All older smartphone platforms and featurephones - Any device that doesn't support media queries
        //will receive the basic, C grade experience.
        return 'C';
    };

    impl.detectOS = function (ua) {
        return impl.findMatch(impl.mobileDetectRules.oss0, ua) ||
            impl.findMatch(impl.mobileDetectRules.oss, ua);
    };

    impl.getDeviceSmallerSide = function () {
        return window.screen.width < window.screen.height ?
            window.screen.width :
            window.screen.height;
    };

    /**
     * Constructor for MobileDetect object.
     * <br>
     * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
     * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
     *     <strong>Find information how to download and install:</strong>
     *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
     * </div>
     *
     * @example <pre>
     *     var md = new MobileDetect(window.navigator.userAgent);
     *     if (md.mobile()) {
     *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
     *     }
     * </pre>
     *
     * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
     * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
     *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
     *        as phone.
     *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
     *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
     *        for Android</a>.<br>
     *        If you provide a value < 0, then this "fuzzy" check is disabled.
     * @constructor
     * @global
     */
    function MobileDetect(userAgent, maxPhoneWidth) {
        this.ua = prepareUserAgent(userAgent);
        this._cache = {};
        //600dp is typical 7" tablet minimum width
        this.maxPhoneWidth = maxPhoneWidth || 600;
    }

    MobileDetect.prototype = {
        constructor: MobileDetect,

        /**
         * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
         * <br>
         * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
         * <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
         * @function MobileDetect#mobile
         */
        mobile: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.mobile;
        },

        /**
         * Returns the detected phone type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPhone, BlackBerry, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
         * NokiaLumia, Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile, SimValley,
         * Wolfgang, Alcatel, Nintendo, Amoi, INQ, GenericPhone</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the phone family or producer, e.g. "iPhone"
         * @function MobileDetect#phone
         */
        phone: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.phone;
        },

        /**
         * Returns the detected tablet type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPad, NexusTablet, GoogleTablet, SamsungTablet, Kindle, SurfaceTablet,
         * HPTablet, AsusTablet, BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet,
         * AcerTablet, ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet,
         * LenovoTablet, DellTablet, YarvikTablet, MedionTablet, ArnovaTablet,
         * IntensoTablet, IRUTablet, MegafonTablet, EbodaTablet, AllViewTablet,
         * ArchosTablet, AinolTablet, NokiaLumiaTablet, SonyTablet, PhilipsTablet,
         * CubeTablet, CobyTablet, MIDTablet, MSITablet, SMiTTablet, RockChipTablet,
         * FlyTablet, bqTablet, HuaweiTablet, NecTablet, PantechTablet, BronchoTablet,
         * VersusTablet, ZyncTablet, PositivoTablet, NabiTablet, KoboTablet, DanewTablet,
         * TexetTablet, PlaystationTablet, TrekstorTablet, PyleAudioTablet, AdvanTablet,
         * DanyTechTablet, GalapadTablet, MicromaxTablet, KarbonnTablet, AllFineTablet,
         * PROSCANTablet, YONESTablet, ChangJiaTablet, GUTablet, PointOfViewTablet,
         * OvermaxTablet, HCLTablet, DPSTablet, VistureTablet, CrestaTablet,
         * MediatekTablet, ConcordeTablet, GoCleverTablet, ModecomTablet, VoninoTablet,
         * ECSTablet, StorexTablet, VodafoneTablet, EssentielBTablet, RossMoorTablet,
         * iMobileTablet, TolinoTablet, AudioSonicTablet, AMPETablet, SkkTablet,
         * TecnoTablet, JXDTablet, iJoyTablet, FX2Tablet, XoroTablet, ViewsonicTablet,
         * VerizonTablet, OdysTablet, CaptivaTablet, IconbitTablet, TeclastTablet,
         * OndaTablet, JaytechTablet, BlaupunktTablet, DigmaTablet, EvolioTablet,
         * LavaTablet, AocTablet, MpmanTablet, CelkonTablet, WolderTablet, MediacomTablet,
         * MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
         * PocketBookTablet, KocasoTablet, HisenseTablet, Hudl, TelstraTablet,
         * GenericTablet</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
         * @function MobileDetect#tablet
         */
        tablet: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.tablet;
        },

        /**
         * Returns the (first) detected user-agent string or <tt>null</tt>.
         * <br>
         * The returned user-agent is one of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Puffin,
         * Mercury, ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {String} the key for the detected user-agent or <tt>null</tt>
         * @function MobileDetect#userAgent
         */
        userAgent: function () {
            if (this._cache.userAgent === undefined) {
                this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgent;
        },

        /**
         * Returns all detected user-agent strings.
         * <br>
         * The array is empty or contains one or more of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Puffin,
         * Mercury, ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
         * @function MobileDetect#userAgents
         */
        userAgents: function () {
            if (this._cache.userAgents === undefined) {
                this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgents;
        },

        /**
         * Returns the detected operating system string or <tt>null</tt>.
         * <br>
         * The operating system is one of following keys:<br>
         * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
         * iOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
         *
         * @returns {String} the key for the detected operating system.
         * @function MobileDetect#os
         */
        os: function () {
            if (this._cache.os === undefined) {
                this._cache.os = impl.detectOS(this.ua);
            }
            return this._cache.os;
        },

        /**
         * Get the version (as Number) of the given property in the User-Agent.
         * <br>
         * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
         *          Be careful when comparing this value with '==' operator!
         * @function MobileDetect#version
         */
        version: function (key) {
            return impl.getVersion(key, this.ua);
        },

        /**
         * Get the version (as String) of the given property in the User-Agent.
         * <br>
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
         *
         * @function MobileDetect#versionStr
         */
        versionStr: function (key) {
            return impl.getVersionStr(key, this.ua);
        },

        /**
         * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
         *
         * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
         *        tablet family.<br>
         *        For a complete list of possible values, see {@link MobileDetect#userAgent},
         *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
         *        Additionally you have following keys:<br>
         * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
         *
         * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
         *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
         * @function MobileDetect#is
         */
        is: function (key) {
            return containsIC(this.userAgents(), key) ||
                   equalIC(key, this.os()) ||
                   equalIC(key, this.phone()) ||
                   equalIC(key, this.tablet()) ||
                   containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
        },

        /**
         * Do a quick test against navigator::userAgent.
         *
         * @param {String|RegExp} pattern the pattern, either as String or RegExp
         *                        (a string will be converted to a case-insensitive RegExp).
         * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
         * @function MobileDetect#match
         */
        match: function (pattern) {
            if (!(pattern instanceof RegExp)) {
                pattern = new RegExp(pattern, 'i');
            }
            return pattern.test(this.ua);
        },

        /**
         * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
         * <br>
         * Obviously this method makes sense in browser environments only (not for Node.js)!
         * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
         *        The argument is optional and if not present or falsy, the value of the constructor is taken.
         * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
         *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
         *          Will always return <code>undefined</code> server-side.
         */
        isPhoneSized: function (maxPhoneWidth) {
            return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
        },

        /**
         * Returns the mobile grade ('A', 'B', 'C').
         *
         * @returns {String} one of the mobile grades ('A', 'B', 'C').
         * @function MobileDetect#mobileGrade
         */
        mobileGrade: function () {
            if (this._cache.grade === undefined) {
                this._cache.grade = impl.mobileGrade(this);
            }
            return this._cache.grade;
        }
    };

    // environment-dependent
    if (typeof window !== 'undefined' && window.screen) {
        MobileDetect.isPhoneSized = function (maxPhoneWidth) {
            return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
        };
    } else {
        MobileDetect.isPhoneSized = function () {};
    }

    // should not be replaced by a completely new object - just overwrite existing methods
    MobileDetect._impl = impl;
    
    MobileDetect.version = '1.4.3 2018-09-08';

    return MobileDetect;
}); // end of call of define()
})((function (undefined) {
    if (typeof module !== 'undefined' && module.exports) {
        return function (factory) { module.exports = factory(); };
    } else if (typeof define === 'function' && define.amd) {
        return define;
    } else if (typeof window !== 'undefined') {
        return function (factory) { window.MobileDetect = factory(); };
    } else {
        // please file a bug if you get this error!
        throw new Error('unknown environment');
    }
})());
},{}],234:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _InputModule2 = require('./InputModule');

var _InputModule3 = _interopRequireDefault(_InputModule2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * `DOMEventSubmodule` class.
 * The `DOMEventSubmodule` class allows to instantiate modules that provide
 * unified values (such as `AccelerationIncludingGravity`, `Acceleration`,
 * `RotationRate`, `Orientation`, `OrientationAlt) from the `devicemotion`
 * or `deviceorientation` DOM events.
 *
 * @class DOMEventSubmodule
 * @extends InputModule
 */
var DOMEventSubmodule = function (_InputModule) {
  _inherits(DOMEventSubmodule, _InputModule);

  /**
   * Creates a `DOMEventSubmodule` module instance.
   *
   * @constructor
   * @param {DeviceMotionModule|DeviceOrientationModule} DOMEventModule - The parent DOM event module.
   * @param {string} eventType - The name of the submodule / event (*e.g.* 'acceleration' or 'orientationAlt').
   * @see DeviceMotionModule
   * @see DeviceOrientationModule
   */
  function DOMEventSubmodule(DOMEventModule, eventType) {
    _classCallCheck(this, DOMEventSubmodule);

    /**
     * The DOM event parent module from which this module gets the raw values.
     *
     * @this DOMEventSubmodule
     * @type {DeviceMotionModule|DeviceOrientationModule}
     * @constant
     */
    var _this = _possibleConstructorReturn(this, (DOMEventSubmodule.__proto__ || Object.getPrototypeOf(DOMEventSubmodule)).call(this, eventType));

    _this.DOMEventModule = DOMEventModule;

    /**
     * Raw values coming from the `devicemotion` event sent by this module.
     *
     * @this DOMEventSubmodule
     * @type {number[]}
     * @default [0, 0, 0]
     */
    _this.event = [0, 0, 0];

    /**
     * Compass heading reference (iOS devices only, `Orientation` and `OrientationAlt` submodules only).
     *
     * @this DOMEventSubmodule
     * @type {number}
     * @default null
     */
    _this._webkitCompassHeadingReference = null;
    return _this;
  }

  /**
   * Initializes of the module.
   *
   * @return {Promise}
   */


  _createClass(DOMEventSubmodule, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      // Indicate to the parent module that this event is required
      this.DOMEventModule.required[this.eventType] = true;

      // If the parent event has not been initialized yet, initialize it
      var DOMEventPromise = this.DOMEventModule.promise;
      if (!DOMEventPromise) DOMEventPromise = this.DOMEventModule.init();

      return DOMEventPromise.then(function (module) {
        return _this2;
      });
    }
  }]);

  return DOMEventSubmodule;
}(_InputModule3.default);

exports.default = DOMEventSubmodule;

},{"./InputModule":238}],235:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _InputModule2 = require('./InputModule');

var _InputModule3 = _interopRequireDefault(_InputModule2);

var _DOMEventSubmodule = require('./DOMEventSubmodule');

var _DOMEventSubmodule2 = _interopRequireDefault(_DOMEventSubmodule);

var _MotionInput = require('./MotionInput');

var _MotionInput2 = _interopRequireDefault(_MotionInput);

var _platform = require('platform');

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Gets the current local time in seconds.
 * Uses `window.performance.now()` if available, and `Date.now()` otherwise.
 *
 * @return {number}
 */
function getLocalTime() {
  if (window.performance) return window.performance.now() / 1000;
  return Date.now() / 1000;
}

var chromeRegExp = /Chrome/;
var toDeg = 180 / Math.PI;

/**
 * `DeviceMotion` module singleton.
 * The `DeviceMotionModule` singleton provides the raw values
 * of the acceleration including gravity, acceleration, and rotation
 * rate provided by the `DeviceMotion` event.
 * It also instantiate the `AccelerationIncludingGravity`,
 * `Acceleration` and `RotationRate` submodules that unify those values
 * across platforms by making them compliant with {@link
 * http://www.w3.org/TR/orientation-event/|the W3C standard}.
 * When raw values are not provided by the sensors, this modules tries
 * to recalculate them from available values:
 * - `acceleration` is calculated from `accelerationIncludingGravity`
 *   with a high-pass filter;
 * - (coming soon — waiting for a bug on Chrome to be resolved)
 *   `rotationRate` is calculated from `orientation`.
 *
 * @class DeviceMotionModule
 * @extends InputModule
 */

var DeviceMotionModule = function (_InputModule) {
  _inherits(DeviceMotionModule, _InputModule);

  /**
   * Creates the `DeviceMotion` module instance.
   *
   * @constructor
   */
  function DeviceMotionModule() {
    _classCallCheck(this, DeviceMotionModule);

    /**
     * Raw values coming from the `devicemotion` event sent by this module.
     *
     * @this DeviceMotionModule
     * @type {number[]}
     * @default [null, null, null, null, null, null, null, null, null]
     */
    var _this = _possibleConstructorReturn(this, (DeviceMotionModule.__proto__ || Object.getPrototypeOf(DeviceMotionModule)).call(this, 'devicemotion'));

    _this.event = [null, null, null, null, null, null, null, null, null];

    /**
     * The `AccelerationIncludingGravity` module.
     * Provides unified values of the acceleration including gravity.
     *
     * @this DeviceMotionModule
     * @type {DOMEventSubmodule}
     */
    _this.accelerationIncludingGravity = new _DOMEventSubmodule2.default(_this, 'accelerationIncludingGravity');

    /**
     * The `Acceleration` submodule.
     * Provides unified values of the acceleration.
     * Estimates the acceleration values from `accelerationIncludingGravity`
     * raw values if the acceleration raw values are not available on the
     * device.
     *
     * @this DeviceMotionModule
     * @type {DOMEventSubmodule}
     */
    _this.acceleration = new _DOMEventSubmodule2.default(_this, 'acceleration');

    /**
     * The `RotationRate` submodule.
     * Provides unified values of the rotation rate.
     * (coming soon, waiting for a bug on Chrome to be resolved)
     * Estimates the rotation rate values from `orientation` values if
     * the rotation rate raw values are not available on the device.
     *
     * @this DeviceMotionModule
     * @type {DOMEventSubmodule}
     */
    _this.rotationRate = new _DOMEventSubmodule2.default(_this, 'rotationRate');

    /**
     * Required submodules / events.
     *
     * @this DeviceMotionModule
     * @type {object}
     * @property {bool} accelerationIncludingGravity - Indicates whether the `accelerationIncludingGravity` unified values are required or not (defaults to `false`).
     * @property {bool} acceleration - Indicates whether the `acceleration` unified values are required or not (defaults to `false`).
     * @property {bool} rotationRate - Indicates whether the `rotationRate` unified values are required or not (defaults to `false`).
     */
    _this.required = {
      accelerationIncludingGravity: false,
      acceleration: false,
      rotationRate: false
    };

    /**
     * Resolve function of the module's promise.
     *
     * @this DeviceMotionModule
     * @type {function}
     * @default null
     * @see DeviceMotionModule#init
     */
    _this._promiseResolve = null;

    /**
     * Unifying factor of the motion data values (`1` on Android, `-1` on iOS).
     *
     * @this DeviceMotionModule
     * @type {number}
     */
    _this._unifyMotionData = _platform2.default.os.family === 'iOS' ? -1 : 1;

    /**
     * Unifying factor of the period (`1` on Android, `1` on iOS). in sec
     * @todo - unify with e.interval specification (in ms) ?
     *
     * @this DeviceMotionModule
     * @type {number}
     */
    _this._unifyPeriod = _platform2.default.os.family === 'Android' ? 0.001 : 1;

    /**
     * Acceleration calculated from the `accelerationIncludingGravity` raw values.
     *
     * @this DeviceMotionModule
     * @type {number[]}
     * @default [0, 0, 0]
     */
    _this._calculatedAcceleration = [0, 0, 0];

    /**
     * Time constant (half-life) of the high-pass filter used to smooth the acceleration values calculated from the acceleration including gravity raw values (in seconds).
     *
     * @this DeviceMotionModule
     * @type {number}
     * @default 0.1
     * @constant
     */
    _this._calculatedAccelerationTimeConstant = 0.1;

    /**
     * Latest `accelerationIncludingGravity` raw value, used in the high-pass filter to calculate the acceleration (if the `acceleration` values are not provided by `'devicemotion'`).
     *
     * @this DeviceMotionModule
     * @type {number[]}
     * @default [0, 0, 0]
     */
    _this._lastAccelerationIncludingGravity = [0, 0, 0];

    /**
     * Rotation rate calculated from the orientation values.
     *
     * @this DeviceMotionModule
     * @type {number[]}
     * @default [0, 0, 0]
     */
    _this._calculatedRotationRate = [0, 0, 0];

    /**
     * Latest orientation value, used to calculate the rotation rate  (if the `rotationRate` values are not provided by `'devicemotion'`).
     *
     * @this DeviceMotionModule
     * @type {number[]}
     * @default [0, 0, 0]
     */
    _this._lastOrientation = [0, 0, 0];

    /**
     * Latest orientation timestamps, used to calculate the rotation rate (if the `rotationRate` values are not provided by `'devicemotion'`).
     *
     * @this DeviceMotionModule
     * @type {number[]}
     * @default [0, 0, 0]
     */
    _this._lastOrientationTimestamp = null;

    _this._processFunction = null;
    _this._process = _this._process.bind(_this);
    _this._devicemotionCheck = _this._devicemotionCheck.bind(_this);
    _this._devicemotionListener = _this._devicemotionListener.bind(_this);

    _this._checkCounter = 0;
    return _this;
  }

  /**
   * Decay factor of the high-pass filter used to calculate the acceleration from the `accelerationIncludingGravity` raw values.
   *
   * @type {number}
   * @readonly
   */


  _createClass(DeviceMotionModule, [{
    key: '_devicemotionCheck',


    /**
     * Sensor check on initialization of the module.
     * This method:
     * - checks whether the `accelerationIncludingGravity`, the `acceleration`,
     *   and the `rotationRate` values are valid or not;
     * - gets the period of the `'devicemotion'` event and sets the period of
     *   the `AccelerationIncludingGravity`, `Acceleration`, and `RotationRate`
     *   submodules;
     * - (in the case where acceleration raw values are not provided)
     *   indicates whether the acceleration can be calculated from the
     *   `accelerationIncludingGravity` unified values or not.
     *
     * @param {DeviceMotionEvent} e - The first `'devicemotion'` event caught.
     */
    value: function _devicemotionCheck(e) {
      // clear timeout (anti-Firefox bug solution, window event deviceorientation being nver called)
      // set the set timeout in init() function
      clearTimeout(this._checkTimeoutId);

      this.isProvided = true;
      this.period = e.interval / 1000;
      this.interval = e.interval;

      // Sensor availability for the acceleration including gravity
      this.accelerationIncludingGravity.isProvided = e.accelerationIncludingGravity && typeof e.accelerationIncludingGravity.x === 'number' && typeof e.accelerationIncludingGravity.y === 'number' && typeof e.accelerationIncludingGravity.z === 'number';
      this.accelerationIncludingGravity.period = e.interval * this._unifyPeriod;

      // Sensor availability for the acceleration
      this.acceleration.isProvided = e.acceleration && typeof e.acceleration.x === 'number' && typeof e.acceleration.y === 'number' && typeof e.acceleration.z === 'number';
      this.acceleration.period = e.interval * this._unifyPeriod;

      // Sensor availability for the rotation rate
      this.rotationRate.isProvided = e.rotationRate && typeof e.rotationRate.alpha === 'number' && typeof e.rotationRate.beta === 'number' && typeof e.rotationRate.gamma === 'number';
      this.rotationRate.period = e.interval * this._unifyPeriod;

      // in firefox android, accelerationIncludingGravity retrieve null values
      // on the first callback. so wait a second call to be sure.
      if (_platform2.default.os.family === 'Android' && /Firefox/.test(_platform2.default.name) && this._checkCounter < 1) {
        this._checkCounter++;
      } else {
        // now that the sensors are checked, replace the process function with
        // the final listener
        this._processFunction = this._devicemotionListener;

        // if acceleration is not provided by raw sensors, indicate whether it
        // can be calculated with `accelerationincludinggravity` or not
        if (!this.acceleration.isProvided) this.acceleration.isCalculated = this.accelerationIncludingGravity.isProvided;

        // WARNING
        // The lines of code below are commented because of a bug of Chrome
        // on some Android devices, where 'devicemotion' events are not sent
        // or caught if the listener is set up after a 'deviceorientation'
        // listener. Here, the _tryOrientationFallback method would add a
        // 'deviceorientation' listener and block all subsequent 'devicemotion'
        // events on these devices. Comments will be removed once the bug of
        // Chrome is corrected.

        // if (this.required.rotationRate && !this.rotationRate.isProvided)
        //   this._tryOrientationFallback();
        // else
        this._promiseResolve(this);
      }
    }

    /**
     * `'devicemotion'` event callback.
     * This method emits an event with the raw `'devicemotion'` values, and emits
     * events with the unified `accelerationIncludingGravity`, `acceleration`,
     * and / or `rotationRate` values if they are required.
     *
     * @param {DeviceMotionEvent} e - `'devicemotion'` event the values are calculated from.
     */

  }, {
    key: '_devicemotionListener',
    value: function _devicemotionListener(e) {
      // 'devicemotion' event (raw values)
      if (this.listeners.size > 0) this._emitDeviceMotionEvent(e);

      // alert(`${this.accelerationIncludingGravity.listeners.size} -
      //     ${this.required.accelerationIncludingGravity} -
      //     ${this.accelerationIncludingGravity.isValid}
      // `);

      // 'acceleration' event (unified values)
      if (this.accelerationIncludingGravity.listeners.size > 0 && this.required.accelerationIncludingGravity && this.accelerationIncludingGravity.isValid) {
        this._emitAccelerationIncludingGravityEvent(e);
      }

      // 'accelerationIncludingGravity' event (unified values)
      // the fallback calculation of the acceleration happens in the
      //  `_emitAcceleration` method, so we check if this.acceleration.isValid
      if (this.acceleration.listeners.size > 0 && this.required.acceleration && this.acceleration.isValid) {
        this._emitAccelerationEvent(e);
      }

      // 'rotationRate' event (unified values)
      // the fallback calculation of the rotation rate does NOT happen in the
      // `_emitRotationRate` method, so we only check if this.rotationRate.isProvided
      if (this.rotationRate.listeners.size > 0 && this.required.rotationRate && this.rotationRate.isProvided) {
        this._emitRotationRateEvent(e);
      }
    }

    /**
     * Emits the `'devicemotion'` raw values.
     *
     * @param {DeviceMotionEvent} e - `'devicemotion'` event the values are calculated from.
     */

  }, {
    key: '_emitDeviceMotionEvent',
    value: function _emitDeviceMotionEvent(e) {
      var outEvent = this.event;

      if (e.accelerationIncludingGravity) {
        outEvent[0] = e.accelerationIncludingGravity.x;
        outEvent[1] = e.accelerationIncludingGravity.y;
        outEvent[2] = e.accelerationIncludingGravity.z;
      }

      if (e.acceleration) {
        outEvent[3] = e.acceleration.x;
        outEvent[4] = e.acceleration.y;
        outEvent[5] = e.acceleration.z;
      }

      if (e.rotationRate) {
        outEvent[6] = e.rotationRate.alpha;
        outEvent[7] = e.rotationRate.beta;
        outEvent[8] = e.rotationRate.gamma;
      }

      this.emit(outEvent);
    }

    /**
     * Emits the `accelerationIncludingGravity` unified values.
     *
     * @param {DeviceMotionEvent} e - `'devicemotion'` event the values are calculated from.
     */

  }, {
    key: '_emitAccelerationIncludingGravityEvent',
    value: function _emitAccelerationIncludingGravityEvent(e) {
      var outEvent = this.accelerationIncludingGravity.event;

      outEvent[0] = e.accelerationIncludingGravity.x * this._unifyMotionData;
      outEvent[1] = e.accelerationIncludingGravity.y * this._unifyMotionData;
      outEvent[2] = e.accelerationIncludingGravity.z * this._unifyMotionData;

      this.accelerationIncludingGravity.emit(outEvent);
    }

    /**
     * Emits the `acceleration` unified values.
     * When the `acceleration` raw values are not available, the method
     * also calculates the acceleration from the
     * `accelerationIncludingGravity` raw values.
     *
     * @param {DeviceMotionEvent} e - The `'devicemotion'` event.
     */

  }, {
    key: '_emitAccelerationEvent',
    value: function _emitAccelerationEvent(e) {
      var outEvent = this.acceleration.event;

      if (this.acceleration.isProvided) {
        // If raw acceleration values are provided
        outEvent[0] = e.acceleration.x * this._unifyMotionData;
        outEvent[1] = e.acceleration.y * this._unifyMotionData;
        outEvent[2] = e.acceleration.z * this._unifyMotionData;
      } else if (this.accelerationIncludingGravity.isValid) {
        // Otherwise, if accelerationIncludingGravity values are provided,
        // estimate the acceleration with a high-pass filter
        var accelerationIncludingGravity = [e.accelerationIncludingGravity.x * this._unifyMotionData, e.accelerationIncludingGravity.y * this._unifyMotionData, e.accelerationIncludingGravity.z * this._unifyMotionData];
        var k = this._calculatedAccelerationDecay;

        // High-pass filter to estimate the acceleration (without the gravity)
        this._calculatedAcceleration[0] = (1 + k) * 0.5 * (accelerationIncludingGravity[0] - this._lastAccelerationIncludingGravity[0]) + k * this._calculatedAcceleration[0];
        this._calculatedAcceleration[1] = (1 + k) * 0.5 * (accelerationIncludingGravity[1] - this._lastAccelerationIncludingGravity[1]) + k * this._calculatedAcceleration[1];
        this._calculatedAcceleration[2] = (1 + k) * 0.5 * (accelerationIncludingGravity[2] - this._lastAccelerationIncludingGravity[2]) + k * this._calculatedAcceleration[2];

        this._lastAccelerationIncludingGravity[0] = accelerationIncludingGravity[0];
        this._lastAccelerationIncludingGravity[1] = accelerationIncludingGravity[1];
        this._lastAccelerationIncludingGravity[2] = accelerationIncludingGravity[2];

        outEvent[0] = this._calculatedAcceleration[0];
        outEvent[1] = this._calculatedAcceleration[1];
        outEvent[2] = this._calculatedAcceleration[2];
      }

      this.acceleration.emit(outEvent);
    }

    /**
     * Emits the `rotationRate` unified values.
     *
     * @param {DeviceMotionEvent} e - `'devicemotion'` event the values are calculated from.
     */

  }, {
    key: '_emitRotationRateEvent',
    value: function _emitRotationRateEvent(e) {
      var outEvent = this.rotationRate.event;

      // In all platforms, rotation axes are messed up according to the spec
      // https://w3c.github.io/deviceorientation/spec-source-orientation.html
      //
      // gamma should be alpha
      // alpha should be beta
      // beta should be gamma

      outEvent[0] = e.rotationRate.gamma;
      outEvent[1] = e.rotationRate.alpha, outEvent[2] = e.rotationRate.beta;

      // Chrome Android retrieve values that are in rad/s
      // cf. https://bugs.chromium.org/p/chromium/issues/detail?id=541607
      //
      // From spec: "The rotationRate attribute must be initialized with the rate
      // of rotation of the hosting device in space. It must be expressed as the
      // rate of change of the angles defined in section 4.1 and must be expressed
      // in degrees per second (deg/s)."
      //
      // fixed since Chrome 65
      // cf. https://github.com/immersive-web/webvr-polyfill/issues/307
      if (_platform2.default.os.family === 'Android' && chromeRegExp.test(_platform2.default.name) && parseInt(_platform2.default.version.split('.')[0]) < 65) {
        outEvent[0] *= toDeg;
        outEvent[1] *= toDeg, outEvent[2] *= toDeg;
      }

      this.rotationRate.emit(outEvent);
    }

    /**
     * Calculates and emits the `rotationRate` unified values from the `orientation` values.
     *
     * @param {number[]} orientation - Latest `orientation` raw values.
     */

  }, {
    key: '_calculateRotationRateFromOrientation',
    value: function _calculateRotationRateFromOrientation(orientation) {
      var now = getLocalTime();
      var k = 0.8; // TODO: improve low pass filter (frames are not regular)
      var alphaIsValid = typeof orientation[0] === 'number';

      if (this._lastOrientationTimestamp) {
        var rAlpha = null;
        var rBeta = void 0;
        var rGamma = void 0;

        var alphaDiscontinuityFactor = 0;
        var betaDiscontinuityFactor = 0;
        var gammaDiscontinuityFactor = 0;

        var deltaT = now - this._lastOrientationTimestamp;

        if (alphaIsValid) {
          // alpha discontinuity (+360 -> 0 or 0 -> +360)
          if (this._lastOrientation[0] > 320 && orientation[0] < 40) alphaDiscontinuityFactor = 360;else if (this._lastOrientation[0] < 40 && orientation[0] > 320) alphaDiscontinuityFactor = -360;
        }

        // beta discontinuity (+180 -> -180 or -180 -> +180)
        if (this._lastOrientation[1] > 140 && orientation[1] < -140) betaDiscontinuityFactor = 360;else if (this._lastOrientation[1] < -140 && orientation[1] > 140) betaDiscontinuityFactor = -360;

        // gamma discontinuities (+180 -> -180 or -180 -> +180)
        if (this._lastOrientation[2] > 50 && orientation[2] < -50) gammaDiscontinuityFactor = 180;else if (this._lastOrientation[2] < -50 && orientation[2] > 50) gammaDiscontinuityFactor = -180;

        if (deltaT > 0) {
          // Low pass filter to smooth the data
          if (alphaIsValid) rAlpha = k * this._calculatedRotationRate[0] + (1 - k) * (orientation[0] - this._lastOrientation[0] + alphaDiscontinuityFactor) / deltaT;

          rBeta = k * this._calculatedRotationRate[1] + (1 - k) * (orientation[1] - this._lastOrientation[1] + betaDiscontinuityFactor) / deltaT;
          rGamma = k * this._calculatedRotationRate[2] + (1 - k) * (orientation[2] - this._lastOrientation[2] + gammaDiscontinuityFactor) / deltaT;

          this._calculatedRotationRate[0] = rAlpha;
          this._calculatedRotationRate[1] = rBeta;
          this._calculatedRotationRate[2] = rGamma;
        }

        // TODO: resample the emission rate to match the devicemotion rate
        this.rotationRate.emit(this._calculatedRotationRate);
      }

      this._lastOrientationTimestamp = now;
      this._lastOrientation[0] = orientation[0];
      this._lastOrientation[1] = orientation[1];
      this._lastOrientation[2] = orientation[2];
    }

    /**
     * Checks whether the rotation rate can be calculated from the `orientation` values or not.
     *
     * @todo - this should be reviewed to comply with the axis order defined
     *  in the spec
     */
    // WARNING
    // The lines of code below are commented because of a bug of Chrome
    // on some Android devices, where 'devicemotion' events are not sent
    // or caught if the listener is set up after a 'deviceorientation'
    // listener. Here, the _tryOrientationFallback method would add a
    // 'deviceorientation' listener and block all subsequent 'devicemotion'
    // events on these devices. Comments will be removed once the bug of
    // Chrome is corrected.
    // _tryOrientationFallback() {
    //   MotionInput.requireModule('orientation')
    //     .then((orientation) => {
    //       if (orientation.isValid) {
    //         console.log(`
    //           WARNING (motion-input): The 'devicemotion' event does not exists or
    //           does not provide rotation rate values in your browser, so the rotation
    //           rate of the device is estimated from the 'orientation', calculated
    //           from the 'deviceorientation' event. Since the compass might not
    //           be available, only \`beta\` and \`gamma\` angles may be provided
    //           (\`alpha\` would be null).`
    //         );

    //         this.rotationRate.isCalculated = true;

    //         MotionInput.addListener('orientation', (orientation) => {
    //           this._calculateRotationRateFromOrientation(orientation);
    //         });
    //       }

    //       this._promiseResolve(this);
    //     });
    // }

  }, {
    key: '_process',
    value: function _process(data) {
      this._processFunction(data);
    }

    /**
     * Initializes of the module.
     *
     * @return {promise}
     */

  }, {
    key: 'init',
    value: function init() {
      var _this2 = this;

      return _get(DeviceMotionModule.prototype.__proto__ || Object.getPrototypeOf(DeviceMotionModule.prototype), 'init', this).call(this, function (resolve) {
        _this2._promiseResolve = resolve;

        if (window.DeviceMotionEvent) {
          _this2._processFunction = _this2._devicemotionCheck;
          window.addEventListener('devicemotion', _this2._process);

          // set fallback timeout for Firefox desktop (its window never calling the DeviceOrientation event, a
          // require of the DeviceOrientation service will result in the require promise never being resolved
          // hence the Experiment start() method never called)
          // > note 02/02/2018: this seems to create problems with ipods that
          // don't have enough time to start (sometimes), hence creating false
          // negative. So we only apply to Firefox desktop and put a really
          // large value (4sec) just in case.
          if (_platform2.default.name === 'Firefox' && _platform2.default.os.family !== 'Android' && _platform2.default.os.family !== 'iOS') {
            console.warn('[motion-input] register timer for Firefox desktop');
            _this2._checkTimeoutId = setTimeout(function () {
              return resolve(_this2);
            }, 4 * 1000);
          }
        }

        // WARNING
        // The lines of code below are commented because of a bug of Chrome
        // on some Android devices, where 'devicemotion' events are not sent
        // or caught if the listener is set up after a 'deviceorientation'
        // listener. Here, the _tryOrientationFallback method would add a
        // 'deviceorientation' listener and block all subsequent 'devicemotion'
        // events on these devices. Comments will be removed once the bug of
        // Chrome is corrected.

        // else if (this.required.rotationRate)
        // this._tryOrientationFallback();

        else resolve(_this2);
      });
    }
  }, {
    key: '_calculatedAccelerationDecay',
    get: function get() {
      return Math.exp(-2 * Math.PI * this.accelerationIncludingGravity.period / this._calculatedAccelerationTimeConstant);
    }
  }]);

  return DeviceMotionModule;
}(_InputModule3.default);

exports.default = new DeviceMotionModule();

},{"./DOMEventSubmodule":234,"./InputModule":238,"./MotionInput":239,"platform":246}],236:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _DOMEventSubmodule = require('./DOMEventSubmodule');

var _DOMEventSubmodule2 = _interopRequireDefault(_DOMEventSubmodule);

var _InputModule2 = require('./InputModule');

var _InputModule3 = _interopRequireDefault(_InputModule2);

var _MotionInput = require('./MotionInput');

var _MotionInput2 = _interopRequireDefault(_MotionInput);

var _platform = require('platform');

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Converts degrees to radians.
 *
 * @param {number} deg - Angle in degrees.
 * @return {number}
 */
function degToRad(deg) {
  return deg * Math.PI / 180;
}

/**
 * Converts radians to degrees.
 *
 * @param {number} rad - Angle in radians.
 * @return {number}
 */
function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

/**
 * Normalizes a 3 x 3 matrix.
 *
 * @param {number[]} m - Matrix to normalize, represented by an array of length 9.
 * @return {number[]}
 */
function normalize(m) {
  var det = m[0] * m[4] * m[8] + m[1] * m[5] * m[6] + m[2] * m[3] * m[7] - m[0] * m[5] * m[7] - m[1] * m[3] * m[8] - m[2] * m[4] * m[6];

  for (var i = 0; i < m.length; i++) {
    m[i] /= det;
  }return m;
}

/**
 * Converts a Euler angle `[alpha, beta, gamma]` to the W3C specification, where:
 * - `alpha` is in [0; +360[;
 * - `beta` is in [-180; +180[;
 * - `gamma` is in [-90; +90[.
 *
 * @param {number[]} eulerAngle - Euler angle to unify, represented by an array of length 3 (`[alpha, beta, gamma]`).
 * @see {@link http://www.w3.org/TR/orientation-event/}
 */
function unify(eulerAngle) {
  // Cf. W3C specification (http://w3c.github.io/deviceorientation/spec-source-orientation.html)
  // and Euler angles Wikipedia page (http://en.wikipedia.org/wiki/Euler_angles).
  //
  // W3C convention: Tait–Bryan angles Z-X'-Y'', where:
  //   alpha is in [0; +360[,
  //   beta is in [-180; +180[,
  //   gamma is in [-90; +90[.

  var alphaIsValid = typeof eulerAngle[0] === 'number';

  var _alpha = alphaIsValid ? degToRad(eulerAngle[0]) : 0;
  var _beta = degToRad(eulerAngle[1]);
  var _gamma = degToRad(eulerAngle[2]);

  var cA = Math.cos(_alpha);
  var cB = Math.cos(_beta);
  var cG = Math.cos(_gamma);
  var sA = Math.sin(_alpha);
  var sB = Math.sin(_beta);
  var sG = Math.sin(_gamma);

  var alpha = void 0,
      beta = void 0,
      gamma = void 0;

  var m = [cA * cG - sA * sB * sG, -cB * sA, cA * sG + cG * sA * sB, cG * sA + cA * sB * sG, cA * cB, sA * sG - cA * cG * sB, -cB * sG, sB, cB * cG];
  normalize(m);

  // Since we want gamma in [-90; +90[, cG >= 0.
  if (m[8] > 0) {
    // Case 1: m[8] > 0 <=> cB > 0                 (and cG != 0)
    //                  <=> beta in ]-pi/2; +pi/2[ (and cG != 0)
    alpha = Math.atan2(-m[1], m[4]);
    beta = Math.asin(m[7]); // asin returns a number between -pi/2 and +pi/2 => OK
    gamma = Math.atan2(-m[6], m[8]);
  } else if (m[8] < 0) {
    // Case 2: m[8] < 0 <=> cB < 0                            (and cG != 0)
    //                  <=> beta in [-pi; -pi/2[ U ]+pi/2; +pi] (and cG != 0)

    // Since cB < 0 and cB is in m[1] and m[4], the point is flipped by 180 degrees.
    // Hence, we have to multiply both arguments of atan2 by -1 in order to revert
    // the point in its original position (=> another flip by 180 degrees).
    alpha = Math.atan2(m[1], -m[4]);
    beta = -Math.asin(m[7]);
    beta += beta >= 0 ? -Math.PI : Math.PI; // asin returns a number between -pi/2 and pi/2 => make sure beta in [-pi; -pi/2[ U ]+pi/2; +pi]
    gamma = Math.atan2(m[6], -m[8]); // same remark as for alpha, multiplication by -1
  } else {
    // Case 3: m[8] = 0 <=> cB = 0 or cG = 0
    if (m[6] > 0) {
      // Subcase 1: cG = 0 and cB > 0
      //            cG = 0 <=> sG = -1 <=> gamma = -pi/2 => m[6] = cB
      //            Hence, m[6] > 0 <=> cB > 0 <=> beta in ]-pi/2; +pi/2[
      alpha = Math.atan2(-m[1], m[4]);
      beta = Math.asin(m[7]); // asin returns a number between -pi/2 and +pi/2 => OK
      gamma = -Math.PI / 2;
    } else if (m[6] < 0) {
      // Subcase 2: cG = 0 and cB < 0
      //            cG = 0 <=> sG = -1 <=> gamma = -pi/2 => m[6] = cB
      //            Hence, m[6] < 0 <=> cB < 0 <=> beta in [-pi; -pi/2[ U ]+pi/2; +pi]
      alpha = Math.atan2(m[1], -m[4]); // same remark as for alpha in a case above
      beta = -Math.asin(m[7]);
      beta += beta >= 0 ? -Math.PI : Math.PI; // asin returns a number between -pi/2 and +pi/2 => make sure beta in [-pi; -pi/2[ U ]+pi/2; +pi]
      gamma = -Math.PI / 2;
    } else {
      // Subcase 3: cB = 0
      // In the case where cos(beta) = 0 (i.e. beta = -pi/2 or beta = pi/2),
      // we have the gimbal lock problem: in that configuration, only the angle
      // alpha + gamma (if beta = +pi/2) or alpha - gamma (if beta = -pi/2)
      // are uniquely defined: alpha and gamma can take an infinity of values.
      // For convenience, let's set gamma = 0 (and thus sin(gamma) = 0).
      // (As a consequence of the gimbal lock problem, there is a discontinuity
      // in alpha and gamma.)
      alpha = Math.atan2(m[3], m[0]);
      beta = m[7] > 0 ? Math.PI / 2 : -Math.PI / 2;
      gamma = 0;
    }
  }

  // atan2 returns a number between -pi and pi => make sure that alpha is in [0, 2*pi[.
  alpha += alpha < 0 ? 2 * Math.PI : 0;

  eulerAngle[0] = alphaIsValid ? radToDeg(alpha) : null;
  eulerAngle[1] = radToDeg(beta);
  eulerAngle[2] = radToDeg(gamma);
}

/**
 * Converts a Euler angle `[alpha, beta, gamma]` to a Euler angle where:
 * - `alpha` is in [0; +360[;
 * - `beta` is in [-90; +90[;
 * - `gamma` is in [-180; +180[.
 *
 * @param {number[]} eulerAngle - Euler angle to convert, represented by an array of length 3 (`[alpha, beta, gamma]`).
 */
function unifyAlt(eulerAngle) {
  // Convention here: Tait–Bryan angles Z-X'-Y'', where:
  //   alpha is in [0; +360[,
  //   beta is in [-90; +90[,
  //   gamma is in [-180; +180[.

  var alphaIsValid = typeof eulerAngle[0] === 'number';

  var _alpha = alphaIsValid ? degToRad(eulerAngle[0]) : 0;
  var _beta = degToRad(eulerAngle[1]);
  var _gamma = degToRad(eulerAngle[2]);

  var cA = Math.cos(_alpha);
  var cB = Math.cos(_beta);
  var cG = Math.cos(_gamma);
  var sA = Math.sin(_alpha);
  var sB = Math.sin(_beta);
  var sG = Math.sin(_gamma);

  var alpha = void 0,
      beta = void 0,
      gamma = void 0;

  var m = [cA * cG - sA * sB * sG, -cB * sA, cA * sG + cG * sA * sB, cG * sA + cA * sB * sG, cA * cB, sA * sG - cA * cG * sB, -cB * sG, sB, cB * cG];
  normalize(m);

  alpha = Math.atan2(-m[1], m[4]);
  alpha += alpha < 0 ? 2 * Math.PI : 0; // atan2 returns a number between -pi and +pi => make sure alpha is in [0, 2*pi[.
  beta = Math.asin(m[7]); // asin returns a number between -pi/2 and pi/2 => OK
  gamma = Math.atan2(-m[6], m[8]); // atan2 returns a number between -pi and +pi => OK

  eulerAngle[0] = alphaIsValid ? radToDeg(alpha) : null;
  eulerAngle[1] = radToDeg(beta);
  eulerAngle[2] = radToDeg(gamma);
}

/**
 * `DeviceOrientationModule` singleton.
 * The `DeviceOrientationModule` singleton provides the raw values
 * of the orientation provided by the `DeviceMotion` event.
 * It also instantiate the `Orientation` submodule that unifies those
 * values across platforms by making them compliant with {@link
 * http://www.w3.org/TR/orientation-event/|the W3C standard} (*i.e.*
 * the `alpha` angle between `0` and `360` degrees, the `beta` angle
 * between `-180` and `180` degrees, and `gamma` between `-90` and
 * `90` degrees), as well as the `OrientationAlt` submodules (with
 * the `alpha` angle between `0` and `360` degrees, the `beta` angle
 * between `-90` and `90` degrees, and `gamma` between `-180` and
 * `180` degrees).
 * When the `orientation` raw values are not provided by the sensors,
 * this modules tries to recalculate `beta` and `gamma` from the
 * `AccelerationIncludingGravity` module, if available (in that case,
 * the `alpha` angle is impossible to retrieve since the compass is
 * not available).
 *
 * @class DeviceMotionModule
 * @extends InputModule
 */

var DeviceOrientationModule = function (_InputModule) {
  _inherits(DeviceOrientationModule, _InputModule);

  /**
   * Creates the `DeviceOrientation` module instance.
   *
   * @constructor
   */
  function DeviceOrientationModule() {
    _classCallCheck(this, DeviceOrientationModule);

    /**
     * Raw values coming from the `deviceorientation` event sent by this module.
     *
     * @this DeviceOrientationModule
     * @type {number[]}
     * @default [null, null, null]
     */
    var _this = _possibleConstructorReturn(this, (DeviceOrientationModule.__proto__ || Object.getPrototypeOf(DeviceOrientationModule)).call(this, 'deviceorientation'));

    _this.event = [null, null, null];

    /**
     * The `Orientation` module.
     * Provides unified values of the orientation compliant with {@link
     * http://www.w3.org/TR/orientation-event/|the W3C standard}
     * (`alpha` in `[0, 360]`, beta in `[-180, +180]`, `gamma` in `[-90, +90]`).
     *
     * @this DeviceOrientationModule
     * @type {DOMEventSubmodule}
     */
    _this.orientation = new _DOMEventSubmodule2.default(_this, 'orientation');

    /**
     * The `OrientationAlt` module.
     * Provides alternative values of the orientation
     * (`alpha` in `[0, 360]`, beta in `[-90, +90]`, `gamma` in `[-180, +180]`).
     *
     * @this DeviceOrientationModule
     * @type {DOMEventSubmodule}
     */
    _this.orientationAlt = new _DOMEventSubmodule2.default(_this, 'orientationAlt');

    /**
     * Required submodules / events.
     *
     * @this DeviceOrientationModule
     * @type {object}
     * @property {bool} orientation - Indicates whether the `orientation` unified values are required or not (defaults to `false`).
     * @property {bool} orientationAlt - Indicates whether the `orientationAlt` values are required or not (defaults to `false`).
     */
    _this.required = {
      orientation: false,
      orientationAlt: false
    };

    /**
     * Resolve function of the module's promise.
     *
     * @this DeviceOrientationModule
     * @type {function}
     * @default null
     * @see DeviceOrientationModule#init
     */
    _this._promiseResolve = null;

    /**
     * Gravity vector calculated from the `accelerationIncludingGravity` unified values.
     *
     * @this DeviceOrientationModule
     * @type {number[]}
     * @default [0, 0, 0]
     */
    _this._estimatedGravity = [0, 0, 0];

    _this._processFunction = null;
    _this._process = _this._process.bind(_this);
    _this._deviceorientationCheck = _this._deviceorientationCheck.bind(_this);
    _this._deviceorientationListener = _this._deviceorientationListener.bind(_this);
    return _this;
  }

  /**
   * Sensor check on initialization of the module.
   * This method:
   * - checks whether the `orientation` values are valid or not;
   * - (in the case where orientation raw values are not provided)
   *   tries to calculate the orientation from the
   *   `accelerationIncludingGravity` unified values.
   *
   * @param {DeviceMotionEvent} e - First `'devicemotion'` event caught, on which the check is done.
   */


  _createClass(DeviceOrientationModule, [{
    key: '_deviceorientationCheck',
    value: function _deviceorientationCheck(e) {
      // clear timeout (anti-Firefox bug solution, window event deviceorientation being nver called)
      // set the set timeout in init() function
      clearTimeout(this._checkTimeoutId);

      this.isProvided = true;

      // Sensor availability for the orientation and alternative orientation
      var rawValuesProvided = typeof e.alpha === 'number' && typeof e.beta === 'number' && typeof e.gamma === 'number';
      this.orientation.isProvided = rawValuesProvided;
      this.orientationAlt.isProvided = rawValuesProvided;

      // TODO(?): get pseudo-period

      // swap the process function to the
      this._processFunction = this._deviceorientationListener;

      // If orientation or alternative orientation are not provided by raw sensors but required,
      // try to calculate them with `accelerationIncludingGravity` unified values
      if (this.required.orientation && !this.orientation.isProvided || this.required.orientationAlt && !this.orientationAlt.isProvided) this._tryAccelerationIncludingGravityFallback();else this._promiseResolve(this);
    }

    /**
     * `'deviceorientation'` event callback.
     * This method emits an event with the raw `'deviceorientation'` values,
     * and emits events with the unified `orientation` and / or the
     * `orientationAlt` values if they are required.
     *
     * @param {DeviceOrientationEvent} e - `'deviceorientation'` event the values are calculated from.
     */

  }, {
    key: '_deviceorientationListener',
    value: function _deviceorientationListener(e) {
      // 'deviceorientation' event (raw values)
      var outEvent = this.event;

      outEvent[0] = e.alpha;
      outEvent[1] = e.beta;
      outEvent[2] = e.gamma;

      if (this.listeners.size > 0) this.emit(outEvent);

      // 'orientation' event (unified values)
      if (this.orientation.listeners.size > 0 && this.required.orientation && this.orientation.isProvided) {
        // On iOS, the `alpha` value is initialized at `0` on the first `deviceorientation` event
        // so we keep that reference in memory to calculate the North later on
        if (!this.orientation._webkitCompassHeadingReference && e.webkitCompassHeading && _platform2.default.os.family === 'iOS') this.orientation._webkitCompassHeadingReference = e.webkitCompassHeading;

        var _outEvent = this.orientation.event;

        _outEvent[0] = e.alpha;
        _outEvent[1] = e.beta;
        _outEvent[2] = e.gamma;

        // On iOS, replace the `alpha` value by the North value and unify the angles
        // (the default representation of the angles on iOS is not compliant with the W3C specification)
        if (this.orientation._webkitCompassHeadingReference && _platform2.default.os.family === 'iOS') {
          _outEvent[0] += 360 - this.orientation._webkitCompassHeadingReference;
          unify(_outEvent);
        }

        this.orientation.emit(_outEvent);
      }

      // 'orientationAlt' event
      if (this.orientationAlt.listeners.size > 0 && this.required.orientationAlt && this.orientationAlt.isProvided) {
        // On iOS, the `alpha` value is initialized at `0` on the first `deviceorientation` event
        // so we keep that reference in memory to calculate the North later on
        if (!this.orientationAlt._webkitCompassHeadingReference && e.webkitCompassHeading && _platform2.default.os.family === 'iOS') this.orientationAlt._webkitCompassHeadingReference = e.webkitCompassHeading;

        var _outEvent2 = this.orientationAlt.event;

        _outEvent2[0] = e.alpha;
        _outEvent2[1] = e.beta;
        _outEvent2[2] = e.gamma;

        // On iOS, replace the `alpha` value by the North value but do not convert the angles
        // (the default representation of the angles on iOS is compliant with the alternative representation)
        if (this.orientationAlt._webkitCompassHeadingReference && _platform2.default.os.family === 'iOS') {
          _outEvent2[0] -= this.orientationAlt._webkitCompassHeadingReference;
          _outEvent2[0] += _outEvent2[0] < 0 ? 360 : 0; // make sure `alpha` is in [0, +360[
        }

        // On Android, transform the angles to the alternative representation
        // (the default representation of the angles on Android is compliant with the W3C specification)
        if (_platform2.default.os.family === 'Android') unifyAlt(_outEvent2);

        this.orientationAlt.emit(_outEvent2);
      }
    }

    /**
     * Checks whether `beta` and `gamma` can be calculated from the `accelerationIncludingGravity` values or not.
     */

  }, {
    key: '_tryAccelerationIncludingGravityFallback',
    value: function _tryAccelerationIncludingGravityFallback() {
      var _this2 = this;

      _MotionInput2.default.requireModule('accelerationIncludingGravity').then(function (accelerationIncludingGravity) {
        if (accelerationIncludingGravity.isValid) {
          console.log("WARNING (motion-input): The 'deviceorientation' event does not exist or does not provide values in your browser, so the orientation of the device is estimated from DeviceMotion's 'accelerationIncludingGravity' event. Since the compass is not available, only the `beta` and `gamma` angles are provided (`alpha` is null).");

          if (_this2.required.orientation) {
            _this2.orientation.isCalculated = true;
            _this2.orientation.period = accelerationIncludingGravity.period;

            _MotionInput2.default.addListener('accelerationIncludingGravity', function (accelerationIncludingGravity) {
              _this2._calculateBetaAndGammaFromAccelerationIncludingGravity(accelerationIncludingGravity);
            });
          }

          if (_this2.required.orientationAlt) {
            _this2.orientationAlt.isCalculated = true;
            _this2.orientationAlt.period = accelerationIncludingGravity.period;

            _MotionInput2.default.addListener('accelerationIncludingGravity', function (accelerationIncludingGravity) {
              _this2._calculateBetaAndGammaFromAccelerationIncludingGravity(accelerationIncludingGravity, true);
            });
          }
        }

        _this2._promiseResolve(_this2);
      });
    }

    /**
     * Calculates and emits `beta` and `gamma` values as a fallback of the `orientation` and / or `orientationAlt` events, from the `accelerationIncludingGravity` unified values.
     *
     * @param {number[]} accelerationIncludingGravity - Latest `accelerationIncludingGravity raw values.
     * @param {bool} [alt=false] - Indicates whether we need the alternate representation of the angles or not.
     */

  }, {
    key: '_calculateBetaAndGammaFromAccelerationIncludingGravity',
    value: function _calculateBetaAndGammaFromAccelerationIncludingGravity(accelerationIncludingGravity) {
      var alt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var k = 0.8;

      // Low pass filter to estimate the gravity
      this._estimatedGravity[0] = k * this._estimatedGravity[0] + (1 - k) * accelerationIncludingGravity[0];
      this._estimatedGravity[1] = k * this._estimatedGravity[1] + (1 - k) * accelerationIncludingGravity[1];
      this._estimatedGravity[2] = k * this._estimatedGravity[2] + (1 - k) * accelerationIncludingGravity[2];

      var _gX = this._estimatedGravity[0];
      var _gY = this._estimatedGravity[1];
      var _gZ = this._estimatedGravity[2];

      var norm = Math.sqrt(_gX * _gX + _gY * _gY + _gZ * _gZ);

      _gX /= norm;
      _gY /= norm;
      _gZ /= norm;

      // Adopting the following conventions:
      // - each matrix operates by pre-multiplying column vectors,
      // - each matrix represents an active rotation,
      // - each matrix represents the composition of intrinsic rotations,
      // the rotation matrix representing the composition of a rotation
      // about the x-axis by an angle beta and a rotation about the y-axis
      // by an angle gamma is:
      //
      // [ cos(gamma)               ,  0          ,  sin(gamma)              ,
      //   sin(beta) * sin(gamma)   ,  cos(beta)  ,  -cos(gamma) * sin(beta) ,
      //   -cos(beta) * sin(gamma)  ,  sin(beta)  ,  cos(beta) * cos(gamma)  ].
      //
      // Hence, the projection of the normalized gravity g = [0, 0, 1]
      // in the device's reference frame corresponds to:
      //
      // gX = -cos(beta) * sin(gamma),
      // gY = sin(beta),
      // gZ = cos(beta) * cos(gamma),
      //
      // so beta = asin(gY) and gamma = atan2(-gX, gZ).

      // Beta & gamma equations (we approximate [gX, gY, gZ] by [_gX, _gY, _gZ])
      var beta = radToDeg(Math.asin(_gY)); // beta is in [-pi/2; pi/2[
      var gamma = radToDeg(Math.atan2(-_gX, _gZ)); // gamma is in [-pi; pi[

      if (alt) {
        // In that case, there is nothing to do since the calculations above gave the angle in the right ranges
        var outEvent = this.orientationAlt.event;
        outEvent[0] = null;
        outEvent[1] = beta;
        outEvent[2] = gamma;

        this.orientationAlt.emit(outEvent);
      } else {
        // Here we have to unify the angles to get the ranges compliant with the W3C specification
        var _outEvent3 = this.orientation.event;
        _outEvent3[0] = null;
        _outEvent3[1] = beta;
        _outEvent3[2] = gamma;
        unify(_outEvent3);

        this.orientation.emit(_outEvent3);
      }
    }
  }, {
    key: '_process',
    value: function _process(data) {
      this._processFunction(data);
    }

    /**
     * Initializes of the module.
     *
     * @return {Promise}
     */

  }, {
    key: 'init',
    value: function init() {
      var _this3 = this;

      return _get(DeviceOrientationModule.prototype.__proto__ || Object.getPrototypeOf(DeviceOrientationModule.prototype), 'init', this).call(this, function (resolve) {
        _this3._promiseResolve = resolve;

        if (window.DeviceOrientationEvent) {
          _this3._processFunction = _this3._deviceorientationCheck;
          window.addEventListener('deviceorientation', _this3._process, false);
          // set fallback timeout for Firefox (its window never calling the DeviceOrientation event, a 
          // require of the DeviceOrientation service will result in the require promise never being resolved
          // hence the Experiment start() method never called)
          _this3._checkTimeoutId = setTimeout(function () {
            return resolve(_this3);
          }, 500);
        } else if (_this3.required.orientation) {
          _this3._tryAccelerationIncludingGravityFallback();
        } else {
          resolve(_this3);
        }
      });
    }
  }]);

  return DeviceOrientationModule;
}(_InputModule3.default);

exports.default = new DeviceOrientationModule();

},{"./DOMEventSubmodule":234,"./InputModule":238,"./MotionInput":239,"platform":246}],237:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _InputModule2 = require('./InputModule');

var _InputModule3 = _interopRequireDefault(_InputModule2);

var _MotionInput = require('./MotionInput');

var _MotionInput2 = _interopRequireDefault(_MotionInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Energy module singleton.
 * The energy module singleton provides energy values (between 0 and 1)
 * based on the acceleration and the rotation rate of the device.
 * The period of the energy values is the same as the period of the
 * acceleration and the rotation rate values.
 *
 * @class EnergyModule
 * @extends InputModule
 */
var EnergyModule = function (_InputModule) {
  _inherits(EnergyModule, _InputModule);

  /**
   * Creates the energy module instance.
   *
   * @constructor
   */
  function EnergyModule() {
    _classCallCheck(this, EnergyModule);

    /**
     * Event containing the value of the energy, sent by the energy module.
     *
     * @this EnergyModule
     * @type {number}
     * @default 0
     */
    var _this = _possibleConstructorReturn(this, (EnergyModule.__proto__ || Object.getPrototypeOf(EnergyModule)).call(this, 'energy'));

    _this.event = 0;

    /**
     * The acceleration module, used in the calculation of the energy.
     *
     * @this EnergyModule
     * @type {DOMEventSubmodule}
     * @default null
     * @see DevicemotionModule
     */
    _this._accelerationModule = null;

    /**
     * Latest acceleration value sent by the acceleration module.
     *
     * @this EnergyModule
     * @type {number[]}
     * @default null
     */
    _this._accelerationValues = null;

    /**
     * Maximum value reached by the acceleration magnitude, clipped at `this._accelerationMagnitudeThreshold`.
     *
     * @this EnergyModule
     * @type {number}
     * @default 9.81
     */
    _this._accelerationMagnitudeCurrentMax = 1 * 9.81;

    /**
     * Clipping value of the acceleration magnitude.
     *
     * @this EnergyModule
     * @type {number}
     * @default 20
     * @constant
     */
    _this._accelerationMagnitudeThreshold = 4 * 9.81;

    /**
     * The rotation rate module, used in the calculation of the energy.
     *
     * @this EnergyModule
     * @type {DOMEventSubmodule}
     * @default null
     * @see DevicemotionModule
     */
    _this._rotationRateModule = null;

    /**
     * Latest rotation rate value sent by the rotation rate module.
     *
     * @this EnergyModule
     * @type {number[]}
     * @default null
     */
    _this._rotationRateValues = null;

    /**
     * Maximum value reached by the rotation rate magnitude, clipped at `this._rotationRateMagnitudeThreshold`.
     *
     * @this EnergyModule
     * @type {number}
     * @default 400
     */
    _this._rotationRateMagnitudeCurrentMax = 400;

    /**
     * Clipping value of the rotation rate magnitude.
     *
     * @this EnergyModule
     * @type {number}
     * @default 600
     * @constant
     */
    _this._rotationRateMagnitudeThreshold = 600;

    /**
     * Time constant (half-life) of the low-pass filter used to smooth the energy values (in seconds).
     *
     * @this EnergyModule
     * @type {number}
     * @default 0.1
     * @constant
     */
    _this._energyTimeConstant = 0.1;

    _this._onAcceleration = _this._onAcceleration.bind(_this);
    _this._onRotationRate = _this._onRotationRate.bind(_this);
    return _this;
  }

  /**
   * Decay factor of the low-pass filter used to smooth the energy values.
   *
   * @type {number}
   * @readonly
   */


  _createClass(EnergyModule, [{
    key: 'init',


    /**
     * Initializes of the module.
     *
     * @return {Promise}
     */
    value: function init() {
      var _this2 = this;

      return _get(EnergyModule.prototype.__proto__ || Object.getPrototypeOf(EnergyModule.prototype), 'init', this).call(this, function (resolve) {
        // The energy module requires the acceleration and the rotation rate modules
        Promise.all([_MotionInput2.default.requireModule('acceleration'), _MotionInput2.default.requireModule('rotationRate')]).then(function (modules) {
          var _modules = _slicedToArray(modules, 2),
              acceleration = _modules[0],
              rotationRate = _modules[1];

          _this2._accelerationModule = acceleration;
          _this2._rotationRateModule = rotationRate;
          _this2.isCalculated = _this2._accelerationModule.isValid || _this2._rotationRateModule.isValid;

          if (_this2._accelerationModule.isValid) _this2.period = _this2._accelerationModule.period;else if (_this2._rotationRateModule.isValid) _this2.period = _this2._rotationRateModule.period;

          resolve(_this2);
        });
      });
    }
  }, {
    key: 'addListener',
    value: function addListener(listener) {
      if (this.listeners.size === 0) {
        if (this._accelerationModule.isValid) this._accelerationModule.addListener(this._onAcceleration);
        if (this._rotationRateModule.isValid) this._rotationRateModule.addListener(this._onRotationRate);
      }

      _get(EnergyModule.prototype.__proto__ || Object.getPrototypeOf(EnergyModule.prototype), 'addListener', this).call(this, listener);
    }
  }, {
    key: 'removeListener',
    value: function removeListener(listener) {
      _get(EnergyModule.prototype.__proto__ || Object.getPrototypeOf(EnergyModule.prototype), 'removeListener', this).call(this, listener);

      if (this.listeners.size === 0) {
        if (this._accelerationModule.isValid) this._accelerationModule.removeListener(this._onAcceleration);
        if (this._rotationRateModule.isValid) this._rotationRateModule.removeListener(this._onRotationRate);
      }
    }

    /**
     * Acceleration values handler.
     *
     * @param {number[]} acceleration - Latest acceleration value.
     */

  }, {
    key: '_onAcceleration',
    value: function _onAcceleration(acceleration) {
      this._accelerationValues = acceleration;

      // If the rotation rate values are not available, we calculate the energy right away.
      if (!this._rotationRateModule.isValid) this._calculateEnergy();
    }

    /**
     * Rotation rate values handler.
     *
     * @param {number[]} rotationRate - Latest rotation rate value.
     */

  }, {
    key: '_onRotationRate',
    value: function _onRotationRate(rotationRate) {
      this._rotationRateValues = rotationRate;

      // We know that the acceleration and rotation rate values coming from the
      // same `devicemotion` event are sent in that order (acceleration > rotation rate)
      // so when the rotation rate is provided, we calculate the energy value of the
      // latest `devicemotion` event when we receive the rotation rate values.
      this._calculateEnergy();
    }

    /**
     * Energy calculation: emits an energy value between 0 and 1.
     *
     * This method checks if the acceleration modules is valid. If that is the case,
     * it calculates an estimation of the energy (between 0 and 1) based on the ratio
     * of the current acceleration magnitude and the maximum acceleration magnitude
     * reached so far (clipped at the `this._accelerationMagnitudeThreshold` value).
     * (We use this trick to get uniform behaviors among devices. If we calculated
     * the ratio based on a fixed value independent of what the device is capable of
     * providing, we could get inconsistent behaviors. For instance, the devices
     * whose accelerometers are limited at 2g would always provide very low values
     * compared to devices with accelerometers capable of measuring 4g accelerations.)
     * The same checks and calculations are made on the rotation rate module.
     * Finally, the energy value is the maximum between the energy value estimated
     * from the acceleration, and the one estimated from the rotation rate. It is
     * smoothed through a low-pass filter.
     */

  }, {
    key: '_calculateEnergy',
    value: function _calculateEnergy() {
      var accelerationEnergy = 0;
      var rotationRateEnergy = 0;

      // Check the acceleration module and calculate an estimation of the energy value from the latest acceleration value
      if (this._accelerationModule.isValid) {
        var aX = this._accelerationValues[0];
        var aY = this._accelerationValues[1];
        var aZ = this._accelerationValues[2];
        var accelerationMagnitude = Math.sqrt(aX * aX + aY * aY + aZ * aZ);

        // Store the maximum acceleration magnitude reached so far, clipped at `this._accelerationMagnitudeThreshold`
        if (this._accelerationMagnitudeCurrentMax < accelerationMagnitude) this._accelerationMagnitudeCurrentMax = Math.min(accelerationMagnitude, this._accelerationMagnitudeThreshold);
        // TODO(?): remove ouliers --- on some Android devices, the magnitude is very high on a few isolated datapoints,
        // which make the threshold very high as well => the energy remains around 0.5, even when you shake very hard.

        accelerationEnergy = Math.min(accelerationMagnitude / this._accelerationMagnitudeCurrentMax, 1);
      }

      // Check the rotation rate module and calculate an estimation of the energy value from the latest rotation rate value
      if (this._rotationRateModule.isValid) {
        var rA = this._rotationRateValues[0];
        var rB = this._rotationRateValues[1];
        var rG = this._rotationRateValues[2];
        var rotationRateMagnitude = Math.sqrt(rA * rA + rB * rB + rG * rG);

        // Store the maximum rotation rate magnitude reached so far, clipped at `this._rotationRateMagnitudeThreshold`
        if (this._rotationRateMagnitudeCurrentMax < rotationRateMagnitude) this._rotationRateMagnitudeCurrentMax = Math.min(rotationRateMagnitude, this._rotationRateMagnitudeThreshold);

        rotationRateEnergy = Math.min(rotationRateMagnitude / this._rotationRateMagnitudeCurrentMax, 1);
      }

      var energy = Math.max(accelerationEnergy, rotationRateEnergy);

      // Low-pass filter to smooth the energy values
      var k = this._energyDecay;
      this.event = k * this.event + (1 - k) * energy;

      // Emit the energy value
      this.emit(this.event);
    }
  }, {
    key: '_energyDecay',
    get: function get() {
      return Math.exp(-2 * Math.PI * this.period / this._energyTimeConstant);
    }
  }]);

  return EnergyModule;
}(_InputModule3.default);

exports.default = new EnergyModule();

},{"./InputModule":238,"./MotionInput":239}],238:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * `InputModule` class.
 * The `InputModule` class allows to instantiate modules that are part of the
 * motion input module, and that provide values (for instance, `deviceorientation`,
 * `acceleration`, `energy`).
 *
 * @class InputModule
 */
var InputModule = function () {

  /**
   * Creates an `InputModule` module instance.
   *
   * @constructor
   * @param {string} eventType - Name of the module / event (*e.g.* `deviceorientation, 'acceleration', 'energy').
   */
  function InputModule(eventType) {
    _classCallCheck(this, InputModule);

    /**
     * Event type of the module.
     *
     * @this InputModule
     * @type {string}
     * @constant
     */
    this.eventType = eventType;

    /**
     * Array of listeners attached to this module / event.
     *
     * @this InputModule
     * @type {Set<Function>}
     */
    this.listeners = new Set();

    /**
     * Event sent by this module.
     *
     * @this InputModule
     * @type {number|number[]}
     * @default null
     */
    this.event = null;

    /**
     * Module promise (resolved when the module is initialized).
     *
     * @this InputModule
     * @type {Promise}
     * @default null
     */
    this.promise = null;

    /**
     * Indicates if the module's event values are calculated from parent modules / events.
     *
     * @this InputModule
     * @type {bool}
     * @default false
     */
    this.isCalculated = false;

    /**
     * Indicates if the module's event values are provided by the device's sensors.
     * (*I.e.* indicates if the `'devicemotion'` or `'deviceorientation'` events provide the required raw values.)
     *
     * @this InputModule
     * @type {bool}
     * @default false
     */
    this.isProvided = false;

    /**
     * Period at which the module's events are sent (`undefined` if the events are not sent at regular intervals).
     *
     * @this InputModule
     * @type {number}
     * @default undefined
     */
    this.period = undefined;

    this.emit = this.emit.bind(this);
  }

  /**
   * Indicates whether the module can provide values or not.
   *
   * @type {bool}
   * @readonly
   */


  _createClass(InputModule, [{
    key: "init",


    /**
     * Initializes the module.
     *
     * @param {function} promiseFun - Promise function that takes the `resolve` and `reject` functions as arguments.
     * @return {Promise}
     */
    value: function init(promiseFun) {
      this.promise = new Promise(promiseFun);
      return this.promise;
    }

    /**
     * Adds a listener to the module.
     *
     * @param {function} listener - Listener to add.
     */

  }, {
    key: "addListener",
    value: function addListener(listener) {
      this.listeners.add(listener);
    }

    /**
     * Removes a listener from the module.
     *
     * @param {function} listener - Listener to remove.
     */

  }, {
    key: "removeListener",
    value: function removeListener(listener) {
      this.listeners.delete(listener);
    }

    /**
     * Propagates an event to all the module's listeners.
     *
     * @param {number|number[]} [event=this.event] - Event values to propagate to the module's listeners.
     */

  }, {
    key: "emit",
    value: function emit() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.event;

      this.listeners.forEach(function (listener) {
        return listener(event);
      });
    }
  }, {
    key: "isValid",
    get: function get() {
      return this.isProvided || this.isCalculated;
    }
  }]);

  return InputModule;
}();

exports.default = InputModule;

},{}],239:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * `MotionInput` singleton.
 * The `MotionInput` singleton allows to initialize motion events
 * and to listen to them.
 *
 * @class MotionInput
 */
var MotionInput = function () {

  /**
   * Creates the `MotionInput` module instance.
   *
   * @constructor
   */
  function MotionInput() {
    _classCallCheck(this, MotionInput);

    /**
     * Pool of all available modules.
     *
     * @this MotionInput
     * @type {object}
     * @default {}
     */
    this.modules = {};
  }

  /**
   * Adds a module to the `MotionInput` module.
   *
   * @param {string} eventType - Name of the event type.
   * @param {InputModule} module - Module to add to the `MotionInput` module.
   */


  _createClass(MotionInput, [{
    key: "addModule",
    value: function addModule(eventType, module) {
      this.modules[eventType] = module;
    }

    /**
     * Gets a module.
     *
     * @param {string} eventType - Name of the event type (module) to retrieve.
     * @return {InputModule}
     */

  }, {
    key: "getModule",
    value: function getModule(eventType) {
      return this.modules[eventType];
    }

    /**
     * Requires a module.
     * If the module has been initialized already, returns its promise. Otherwise,
     * initializes the module.
     *
     * @param {string} eventType - Name of the event type (module) to require.
     * @return {Promise}
     */

  }, {
    key: "requireModule",
    value: function requireModule(eventType) {
      var module = this.getModule(eventType);

      if (module.promise) return module.promise;

      return module.init();
    }

    /**
     * Initializes the `MotionInput` module.
     *
     * @param {Array<String>} eventTypes - Array of the event types to initialize.
     * @return {Promise}
     */

  }, {
    key: "init",
    value: function init() {
      var _this = this;

      for (var _len = arguments.length, eventTypes = Array(_len), _key = 0; _key < _len; _key++) {
        eventTypes[_key] = arguments[_key];
      }

      if (Array.isArray(eventTypes[0])) eventTypes = eventTypes[0];

      var modulePromises = eventTypes.map(function (value) {
        var module = _this.getModule(value);
        return module.init();
      });

      return Promise.all(modulePromises);
    }

    /**
     * Adds a listener.
     *
     * @param {string} eventType - Name of the event type (module) to add a listener to.
     * @param {function} listener - Listener to add.
     */

  }, {
    key: "addListener",
    value: function addListener(eventType, listener) {
      var module = this.getModule(eventType);
      module.addListener(listener);
    }

    /**
     * Removes a listener.
     *
     * @param {string} eventType - Name of the event type (module) to add a listener to.
     * @param {function} listener - Listener to remove.
     */

  }, {
    key: "removeListener",
    value: function removeListener(eventType, listener) {
      var module = this.getModule(eventType);
      module.removeListener(listener);
    }
  }]);

  return MotionInput;
}();

exports.default = new MotionInput();

},{}],240:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MotionInput = require('./MotionInput');

var _MotionInput2 = _interopRequireDefault(_MotionInput);

var _DeviceOrientationModule = require('./DeviceOrientationModule');

var _DeviceOrientationModule2 = _interopRequireDefault(_DeviceOrientationModule);

var _DeviceMotionModule = require('./DeviceMotionModule');

var _DeviceMotionModule2 = _interopRequireDefault(_DeviceMotionModule);

var _EnergyModule = require('./EnergyModule');

var _EnergyModule2 = _interopRequireDefault(_EnergyModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The motion input module can be used as follows
 *
 * @example
 * import motionInput from 'motion-input';
 * const requiredEvents = ;
 *
 * motionInput
 *  .init(['acceleration', 'orientation', 'energy'])
 *  .then(([acceleration, orientation, energy]) => {
 *    if (acceleration.isValid) {
 *      acceleration.addListener((data) => {
 *        console.log('acceleration', data);
 *        // do something with the acceleration values
 *      });
 *    }
 *
 *    // ...
 *  });
 */
_MotionInput2.default.addModule('devicemotion', _DeviceMotionModule2.default);
_MotionInput2.default.addModule('deviceorientation', _DeviceOrientationModule2.default);
_MotionInput2.default.addModule('accelerationIncludingGravity', _DeviceMotionModule2.default.accelerationIncludingGravity);
_MotionInput2.default.addModule('acceleration', _DeviceMotionModule2.default.acceleration);
_MotionInput2.default.addModule('rotationRate', _DeviceMotionModule2.default.rotationRate);
_MotionInput2.default.addModule('orientation', _DeviceOrientationModule2.default.orientation);
_MotionInput2.default.addModule('orientationAlt', _DeviceOrientationModule2.default.orientationAlt);
_MotionInput2.default.addModule('energy', _EnergyModule2.default);

exports.default = _MotionInput2.default;

},{"./DeviceMotionModule":235,"./DeviceOrientationModule":236,"./EnergyModule":237,"./MotionInput":239}],241:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],242:[function(require,module,exports){
/*! NoSleep.min.js v0.7.0 - git.io/vfn01 - Rich Tibbett - MIT license */
!function(A,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define([],B):"object"==typeof exports?exports.NoSleep=B():A.NoSleep=B()}(this,function(){return function(A){function B(e){if(Q[e])return Q[e].exports;var o=Q[e]={i:e,l:!1,exports:{}};return A[e].call(o.exports,o,o.exports,B),o.l=!0,o.exports}var Q={};return B.m=A,B.c=Q,B.d=function(A,Q,e){B.o(A,Q)||Object.defineProperty(A,Q,{configurable:!1,enumerable:!0,get:e})},B.n=function(A){var Q=A&&A.__esModule?function(){return A.default}:function(){return A};return B.d(Q,"a",Q),Q},B.o=function(A,B){return Object.prototype.hasOwnProperty.call(A,B)},B.p="",B(B.s=0)}([function(A,B,Q){"use strict";function e(A,B){if(!(A instanceof B))throw new TypeError("Cannot call a class as a function")}var o=function(){function A(A,B){for(var Q=0;Q<B.length;Q++){var e=B[Q];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(A,e.key,e)}}return function(B,Q,e){return Q&&A(B.prototype,Q),e&&A(B,e),B}}(),t=Q(1),n="undefined"!=typeof navigator&&parseFloat((""+(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent)||[0,""])[1]).replace("undefined","3_2").replace("_",".").replace("_",""))<10&&!window.MSStream,E=function(){function A(){e(this,A),n?this.noSleepTimer=null:(this.noSleepVideo=document.createElement("video"),this.noSleepVideo.setAttribute("playsinline",""),this.noSleepVideo.setAttribute("src",t),this.noSleepVideo.addEventListener("timeupdate",function(A){this.noSleepVideo.currentTime>.5&&(this.noSleepVideo.currentTime=Math.random())}.bind(this)))}return o(A,[{key:"enable",value:function(){n?(this.disable(),this.noSleepTimer=window.setInterval(function(){window.location.href="/",window.setTimeout(window.stop,0)},15e3)):this.noSleepVideo.play()}},{key:"disable",value:function(){n?this.noSleepTimer&&(window.clearInterval(this.noSleepTimer),this.noSleepTimer=null):this.noSleepVideo.pause()}}]),A}();A.exports=E},function(A,B,Q){"use strict";A.exports="data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQAD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"}])});
},{}],243:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],244:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],245:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":247}],246:[function(require,module,exports){
(function (global){
/*!
 * Platform.js <https://mths.be/platform>
 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <https://mths.be/mit>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object. */
  var oldRoot = root;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Possible global object. */
  var thisBinding = this;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4':  '10 Technical Preview',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
        (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope]. */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([
      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important). */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Electron',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },
      'Midori',
      'Nook Browser',
      'PaleMoon',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      { 'label': 'Samsung Internet', 'pattern': 'SamsungBrowser' },
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'Sunrise',
      'Swiftfox',
      'Waterfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important). */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      { 'label': 'Galaxy S5', 'pattern': 'SM-G900' },
      { 'label': 'Galaxy S6', 'pattern': 'SM-G920' },
      { 'label': 'Galaxy S6 Edge', 'pattern': 'SM-G925' },
      { 'label': 'Galaxy S7', 'pattern': 'SM-G930' },
      { 'label': 'Galaxy S7 Edge', 'pattern': 'SM-G935' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nexus',
      'Nook',
      'PlayBook',
      'PlayStation Vita',
      'PlayStation',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS([
      'Windows Phone',
      'Android',
      'CentOS',
      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'OpenBSD',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Tizen',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (
          value[product] ||
          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + ' *\\w+-[\\w]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // Split by forward slash and append product version if needed.
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // Clean up Google TV.
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // Detect Kubuntu.
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // Detect Android browsers.
    else if ((manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // Detect Silk desktop/accelerated modes.
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // Detect PaleMoon identifying as Firefox.
    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
      description.push('identifying as Firefox ' + data[1]);
    }
    // Detect Firefox OS and products running Firefox.
    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
      os || (os = 'Firefox OS');
      product || (product = data[1]);
    }
    // Detect false positives for Firefox/Safari.
    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // Escape the `/` for Firefox 1.
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // Clear name of false positives.
        name = null;
      }
      // Reassign a generic name.
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // Add Chrome version to description for Electron.
    else if (name == 'Electron' && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
      description.push('Chromium ' + data);
    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // Detect stubborn layout engines.
    if ((data =
          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
        )) {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8.x';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // Detect IE 11 identifying as other browsers.
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (name) {
        description.push('identifying as ' + name + (version ? ' ' + version : ''));
      }
      name = 'IE';
      version = data[1];
    }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
          os || (os = data[0].os || null);
          try {
            data[1] = context.require('ringo/engine').version;
            version = data[1].join('.');
            name = 'RingoJS';
          } catch(e) {
            if (data[0].global.system == context.system) {
              name = 'Narwhal';
            }
          }
        }
        else if (
          typeof context.process == 'object' && !context.process.browser &&
          (data = context.process)
        ) {
          if (typeof data.versions == 'object') {
            if (typeof data.versions.electron == 'string') {
              description.push('Node ' + data.versions.node);
              name = 'Electron';
              version = data.versions.electron;
            } else if (typeof data.versions.nw == 'string') {
              description.push('Chromium ' + version, 'Node ' + data.versions.node);
              name = 'NW.js';
              version = data.versions.nw;
            }
          } else {
            name = 'Node.js';
            arch = data.arch;
            os = data.platform;
            version = /[\d.]+/.exec(data.version)
            version = version ? version[0] : 'unknown';
          }
        }
        else if (rhino) {
          name = 'Rhino';
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // Detect PhantomJS.
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // Detect IE compatibility modes.
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // We're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode.
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      // Detect IE 11 masking as other browsers.
      else if (typeof doc.documentMode == 'number' && /^(?:Chrome|Firefox)\b/.test(name)) {
        description.push('masking as ' + name + ' ' + version);
        name = 'IE';
        version = '11.0';
        layout = ['Trident'];
        os = 'Windows';
      }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // Detect Xbox 360 and Xbox One.
    else if (/\bXbox\b/i.test(product)) {
      if (product == 'Xbox 360') {
        os = null;
      }
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // Add mobile postfix.
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // Detect IE platform preview.
    else if (name == 'IE' && useFeatures) {
      try {
        if (context.external === null) {
          description.unshift('platform preview');
        }
      } catch(e) {
        description.unshift('embedded');
      }
    }
    // Detect BlackBerry OS version.
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // Detect Opera identifying/masking itself as another browser.
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && product != 'Wii' && (
          (useFeatures && opera) ||
          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
          (name == 'IE' && (
            (os && !/^Win/.test(os) && version > 5.5) ||
            /\bWindows XP\b/.test(os) && version > 8 ||
            version == 8 && !/\bTrident\b/.test(ua)
          ))
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
      // When "identifying", the UA contains both Opera and the other browser's name.
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // When "masking", the UA contains only the other browser's name.
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // Use the full Chrome version when available.
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // Strip incorrect OS versions.
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (
        os && /^OS X/.test(os.family) &&
        name == 'Chrome' && parseFloat(version) >= 39
    ) {
      os.architecture = 64;
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * The list of common layout engines include:
     * "Blink", "EdgeHTML", "Gecko", "Trident" and "WebKit"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * The list of manufacturers include:
     * "Apple", "Archos", "Amazon", "Asus", "Barnes & Noble", "BlackBerry",
     * "Google", "HP", "HTC", "LG", "Microsoft", "Motorola", "Nintendo",
     * "Nokia", "Samsung" and "Sony"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * The list of common browser names include:
     * "Chrome", "Electron", "Firefox", "Firefox for iOS", "IE",
     * "Microsoft Edge", "PhantomJS", "Safari", "SeaMonkey", "Silk",
     * "Opera Mini" and "Opera"
     *
     * Mobile versions of some browsers have "Mobile" appended to their name:
     * eg. "Chrome Mobile", "Firefox Mobile", "IE Mobile" and "Opera Mobile"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * The list of common products include:
     *
     * "BlackBerry", "Galaxy S4", "Lumia", "iPad", "iPod", "iPhone", "Kindle",
     * "Kindle Fire", "Nexus", "Nook", "PlayBook", "TouchPad" and "Transformer"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    define(function() {
      return platform;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for CommonJS support.
    forOwn(platform, function(value, key) {
      freeExports[key] = value;
    });
  }
  else {
    // Export to the global object.
    root.platform = platform;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],247:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],248:[function(require,module,exports){
/*!
* screenfull
* v3.3.3 - 2018-09-04
* (c) Sindre Sorhus; MIT License
*/
(function () {
	'use strict';

	var document = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {};
	var isCommonjs = typeof module !== 'undefined' && module.exports;
	var keyboardAllowed = typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element;

	var fn = (function () {
		var val;

		var fnMap = [
			[
				'requestFullscreen',
				'exitFullscreen',
				'fullscreenElement',
				'fullscreenEnabled',
				'fullscreenchange',
				'fullscreenerror'
			],
			// New WebKit
			[
				'webkitRequestFullscreen',
				'webkitExitFullscreen',
				'webkitFullscreenElement',
				'webkitFullscreenEnabled',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			// Old WebKit (Safari 5.1)
			[
				'webkitRequestFullScreen',
				'webkitCancelFullScreen',
				'webkitCurrentFullScreenElement',
				'webkitCancelFullScreen',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			[
				'mozRequestFullScreen',
				'mozCancelFullScreen',
				'mozFullScreenElement',
				'mozFullScreenEnabled',
				'mozfullscreenchange',
				'mozfullscreenerror'
			],
			[
				'msRequestFullscreen',
				'msExitFullscreen',
				'msFullscreenElement',
				'msFullscreenEnabled',
				'MSFullscreenChange',
				'MSFullscreenError'
			]
		];

		var i = 0;
		var l = fnMap.length;
		var ret = {};

		for (; i < l; i++) {
			val = fnMap[i];
			if (val && val[1] in document) {
				for (i = 0; i < val.length; i++) {
					ret[fnMap[0][i]] = val[i];
				}
				return ret;
			}
		}

		return false;
	})();

	var eventNameMap = {
		change: fn.fullscreenchange,
		error: fn.fullscreenerror
	};

	var screenfull = {
		request: function (elem) {
			var request = fn.requestFullscreen;

			elem = elem || document.documentElement;

			// Work around Safari 5.1 bug: reports support for
			// keyboard in fullscreen even though it doesn't.
			// Browser sniffing, since the alternative with
			// setTimeout is even worse.
			if (/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)) {
				elem[request]();
			} else {
				elem[request](keyboardAllowed ? Element.ALLOW_KEYBOARD_INPUT : {});
			}
		},
		exit: function () {
			document[fn.exitFullscreen]();
		},
		toggle: function (elem) {
			if (this.isFullscreen) {
				this.exit();
			} else {
				this.request(elem);
			}
		},
		onchange: function (callback) {
			this.on('change', callback);
		},
		onerror: function (callback) {
			this.on('error', callback);
		},
		on: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.addEventListener(eventName, callback, false);
			}
		},
		off: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.removeEventListener(eventName, callback, false);
			}
		},
		raw: fn
	};

	if (!fn) {
		if (isCommonjs) {
			module.exports = false;
		} else {
			window.screenfull = false;
		}

		return;
	}

	Object.defineProperties(screenfull, {
		isFullscreen: {
			get: function () {
				return Boolean(document[fn.fullscreenElement]);
			}
		},
		element: {
			enumerable: true,
			get: function () {
				return document[fn.fullscreenElement];
			}
		},
		enabled: {
			enumerable: true,
			get: function () {
				// Coerce to boolean in case of old WebKit
				return Boolean(document[fn.fullscreenEnabled]);
			}
		}
	});

	if (isCommonjs) {
		module.exports = screenfull;
	} else {
		window.screenfull = screenfull;
	}
})();

},{}],249:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":250,"./socket":252,"./url":253,"debug":254,"socket.io-parser":257}],250:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":251,"./socket":252,"backo2":42,"component-bind":67,"component-emitter":68,"debug":254,"engine.io-client":209,"indexof":229,"socket.io-parser":257}],251:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

},{}],252:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var parseqs = require('parseqs');
var hasBin = require('has-binary2');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};

},{"./on":251,"component-bind":67,"component-emitter":68,"debug":254,"has-binary2":225,"parseqs":243,"socket.io-parser":257,"to-array":312}],253:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

},{"debug":254,"parseuri":244}],254:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":255,"_process":247}],255:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219,"ms":241}],256:[function(require,module,exports){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

},{"./is-buffer":258,"isarray":261}],257:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}

},{"./binary":256,"./is-buffer":258,"component-emitter":68,"debug":259,"isarray":261}],258:[function(require,module,exports){
(function (Buffer){

module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

}).call(this,require("buffer").Buffer)

},{"buffer":66}],259:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":260,"_process":247}],260:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219,"ms":241}],261:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"dup":226}],262:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Process2 = require('./Process');

var _Process3 = _interopRequireDefault(_Process2);

var _Signal = require('../../utils/Signal');

var _Signal2 = _interopRequireDefault(_Signal);

var _SignalAll = require('../../utils/SignalAll');

var _SignalAll2 = _interopRequireDefault(_SignalAll);

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

var _View = require('../views/View');

var _View2 = _interopRequireDefault(_View);

var _viewManager = require('./viewManager');

var _viewManager2 = _interopRequireDefault(_viewManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Internal base class for services and scenes. Basically a process with view
 * and optionnal network abilities.
 *
 * @memberof module:soundworks/client
 * @extends module:soundworks/client.Process
 */
var Activity = function (_Process) {
  (0, _inherits3.default)(Activity, _Process);

  /**
   * @param {String} id - Id of the activity.
   * @param {Boolean} hasNetwork - Define if the activity needs a socket
   *  connection or not.
   */
  function Activity(id) {
    var hasNetwork = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    (0, _classCallCheck3.default)(this, Activity);

    /**
     * If `true`, defines if the activity has already started once.
     * @type {Boolean}
     * @name hasStarted
     * @instance
     * @memberof module:soundworks/client.Activity
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Activity.__proto__ || (0, _getPrototypeOf2.default)(Activity)).call(this, id));

    _this.hasStarted = false;

    /**
     * Defines if the activity needs a connection to the server.
     * @type {Boolean}
     * @name hasNetwork
     * @instance
     * @memberof module:soundworks/client.Activity
     */
    _this.hasNetwork = !!hasNetwork;

    // register as a networked service, setup the socket connection
    if (_this.hasNetwork) _socket2.default.required = true;

    /**
     * Options of the activity.
     * @type {Object}
     * @name options
     * @instance
     * @memberof module:soundworks/client.Activity
     */
    _this.options = { viewPriority: 0 };

    /**
     * View of the activity.
     * @type {module:soundworks/client.View}
     * @name view
     * @instance
     * @memberof module:soundworks/client.Activity
     * @private
     */
    _this._view = null;

    /**
     * Define which signal the `Activity` requires to start.
     * @private
     */
    _this.requiredSignals = new _SignalAll2.default();

    _this.send = _this.send.bind(_this);
    _this.sendVolatile = _this.sendVolatile.bind(_this);
    _this.receive = _this.receive.bind(_this);
    _this.removeListener = _this.removeListener.bind(_this);
    return _this;
  }

  /**
   * Interface method to implement in child classes.
   * Define what to do when a service is required by an `Activity`.
   */


  (0, _createClass3.default)(Activity, [{
    key: 'require',
    value: function require() {}

    /**
     * Add a signal to the required signals in order for the `Scene` instance
     * to start.
     * @param {Signal} signal - The signal that must be waited for.
     * @private
     */

  }, {
    key: 'waitFor',
    value: function waitFor(signal) {
      this.requiredSignals.add(signal);
    }

    /**
     * Configure the activity with the given options.
     * @param {Object} options
     */

  }, {
    key: 'configure',
    value: function configure(options) {
      (0, _assign2.default)(this.options, options);
    }

    /**
     * Set the view of service.
     *
     * @param {Object} view - any object compliant with the view interface.
     */

  }, {
    key: 'show',


    /**
     * Request the view manager to display the view. The call of this method
     * doesn't guarantee a synchronized rendering or any rendering at all as the
     * view manager decides which view to display based on their priority.
     *
     * @return {Promise} - a promise that resolves when the view is actually
     *  displayed in the application.
     */
    value: function show() {
      return _viewManager2.default.register(this._view, this.options.viewPriority);
    }

    /**
     * Hide the view of the activity if it owns one.
     */

  }, {
    key: 'hide',
    value: function hide() {
      _viewManager2.default.remove(this._view);
    }

    /**
     * Send a web socket message to the server on a given channel.
     *
     * @param {String} channel - The channel of the message (is automatically
     *  namespaced with the activity's id: `${this.id}:channel`).
     * @param {...*} args - Arguments of the message (as many as needed, of any type).
     */

  }, {
    key: 'send',
    value: function send(channel) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      _socket2.default.send.apply(_socket2.default, [this.id + ':' + channel].concat(args));
    }

    /**
     * Send a web socket message to the server on a given channel.
     *
     * @param {String} channel - The channel of the message (is automatically
     *  namespaced with the activity's id: `${this.id}:channel`).
     * @param {...*} args - Arguments of the message (as many as needed, of any type).
     */

  }, {
    key: 'sendVolatile',
    value: function sendVolatile(channel) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      _socket2.default.sendVolatile.apply(_socket2.default, [this.id + ':' + channel].concat(args));
    }

    /**
     * Listen to web socket messages from the server on a given channel.
     *
     * @param {String} channel - The channel of the message (is automatically
     *  namespaced with the activity's id: `${this.id}:channel`).
     * @param {Function} callback - The callback to execute when a message is received.
     */

  }, {
    key: 'receive',
    value: function receive(channel, callback) {
      _socket2.default.receive(this.id + ':' + channel, callback);
    }

    /**
     * Stop listening for messages from the server on a given channel.
     *
     * @param {String} channel - The channel of the message (is automatically
     *  namespaced with the activity's id: `${this.id}:channel`).
     * @param {Function} callback - The callback to remove from the stack.
     */

  }, {
    key: 'stopReceiving',
    value: function stopReceiving(channel, callback) {
      _socket2.default.removeListener(this.id + ':' + channel, callback);
    }
  }, {
    key: 'view',
    set: function set(view) {
      this._view = view;
    },
    get: function get() {
      return this._view;
    }
  }]);
  return Activity;
}(_Process3.default);

exports.default = Activity;

},{"../../utils/Signal":308,"../../utils/SignalAll":309,"../views/View":302,"./Process":264,"./socket":268,"./viewManager":269,"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],263:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Activity2 = require('./Activity');

var _Activity3 = _interopRequireDefault(_Activity2);

var _serviceManager = require('./serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class to be extended in order to create the client-side of a custom
 * experience.
 *
 * The user defined `Experience` is the main component of a soundworks application.
 *
 * @memberof module:soundworks/client
 * @extends module:soundworks/client.Activity
 */
var Experience = function (_Activity) {
  (0, _inherits3.default)(Experience, _Activity);

  /**
   * @param {Boolean} [hasNetwork=true] - Define if the experience requires a
   *  socket connection.
   */
  function Experience() {
    var hasNetwork = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    (0, _classCallCheck3.default)(this, Experience);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Experience.__proto__ || (0, _getPrototypeOf2.default)(Experience)).call(this, 'experience', hasNetwork));

    _this.start = _this.start.bind(_this);

    _this.requiredSignals.addObserver(_this.start);
    _this.waitFor(_serviceManager2.default.signals.ready);

    // if the experience has network, require errorReporter service by default
    if (hasNetwork) _this._errorReporter = _this.require('error-reporter');
    return _this;
  }

  /**
   * Returns a service configured with the given options.
   * @param {String} id - The identifier of the service.
   * @param {Object} options - The options to configure the service.
   */


  (0, _createClass3.default)(Experience, [{
    key: 'require',
    value: function require(id, options) {
      return _serviceManager2.default.require(id, options);
    }

    /**
     * Start the experience. This lifecycle method is called when all the
     * required services are `ready` and thus the experience can begin with all
     * the necessary informations and services ready to be consumed.
     */

  }, {
    key: 'start',
    value: function start() {
      (0, _get3.default)(Experience.prototype.__proto__ || (0, _getPrototypeOf2.default)(Experience.prototype), 'start', this).call(this);

      if (this.hasNetwork) this.send('enter');
    }

    /** @private */
    // done() {
    //   if (this.hasNetwork)
    //     this.send('exit');

    //   super.done();
    // }

  }]);
  return Experience;
}(_Activity3.default);

exports.default = Experience;

},{"./Activity":262,"./serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],264:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _EventEmitter2 = require('../../utils/EventEmitter');

var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

var _Signal = require('../../utils/Signal');

var _Signal2 = _interopRequireDefault(_Signal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A process defines the simpliest unit of the framework.
 * It is defined by a signal `active` and 2 methods: `start` and `stop`.
 *
 * @memberof module:soundworks/client
 */
var Process = function (_EventEmitter) {
  (0, _inherits3.default)(Process, _EventEmitter);

  function Process(id) {
    (0, _classCallCheck3.default)(this, Process);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Process.__proto__ || (0, _getPrototypeOf2.default)(Process)).call(this));

    if (id === undefined) throw new Error('Undefined id for process ' + _this.constructor.name);

    /**
     * Name of the process.
     * @name id
     * @type {String}
     * @instanceof Process
     */
    _this.id = id;

    /**
     * Signals defining the process state.
     * @name signal
     * @type {Object}
     * @instanceof Process
     */
    _this.signals = {};
    _this.signals.active = new _Signal2.default();
    return _this;
  }

  /**
   * Start the process.
   */


  (0, _createClass3.default)(Process, [{
    key: 'start',
    value: function start() {
      this.signals.active.set(true);
    }

    /**
     * Stop the process.
     */

  }, {
    key: 'stop',
    value: function stop() {
      this.signals.active.set(false);
    }
  }]);
  return Process;
}(_EventEmitter3.default);

exports.default = Process;

},{"../../utils/EventEmitter":307,"../../utils/Signal":308,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],265:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Activity2 = require('./Activity');

var _Activity3 = _interopRequireDefault(_Activity2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _serviceManager = require('./serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _Signal = require('../../utils/Signal');

var _Signal2 = _interopRequireDefault(_Signal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('soundworks:services');

/**
 * Base class to be extended in order to create a new service.
 *
 * @memberof module:soundworks/client
 * @extends module:soundworks/client.Activity
 */

var Service = function (_Activity) {
  (0, _inherits3.default)(Service, _Activity);

  /**
   * @param {String} id - The id of the service (should be prefixed with `'service:'`).
   * @param {Boolean} hasNetwork - Define if the service needs an access to the socket
   *  connection.
   */
  function Service(id, hasNetwork) {
    (0, _classCallCheck3.default)(this, Service);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Service.__proto__ || (0, _getPrototypeOf2.default)(Service)).call(this, id, hasNetwork));

    _this.requiredSignals.addObserver(function (value) {
      if (value) {
        _this.start();
        _this.hasStarted = true; // keep this for Orbe/Nodal compatibility
      } else {
        _this.stop();
      }
    });

    /**
     * Is set to `true` when a signal is ready to be consumed.
     * @type {Signal}
     */
    _this.signals.ready = new _Signal2.default();
    // add the serviceManager bootstart signal to the required signals
    _this.waitFor(_serviceManager2.default.signals.start);

    _this.ready = _this.ready.bind(_this);
    return _this;
  }

  /**
   * Allow to require another service as a dependencies. When a service is
   * dependent from another service its `start` method is delayed until all
   * its dependencies are themselves `ready`.
   * @param {String} id - id of the service to require.
   * @param {Object} options - configuration object to be passed to the service.
   */


  (0, _createClass3.default)(Service, [{
    key: 'require',
    value: function require(id, options) {
      var service = _serviceManager2.default.require(id, options);
      var signal = service.signals.ready;

      if (signal) this.waitFor(signal);else throw new Error('signal "continue" doesn\'t exist on service :', service);

      return service;
    }

    /**
     * Method to call in the service lifecycle when it should be considered as
     * `ready` and thus allows all its dependent activities to start themselves.
     */

  }, {
    key: 'ready',
    value: function ready() {
      log('"' + this.id + '" ready');

      this.stop();
      this.signals.ready.set(true);
    }

    /** @inheritdoc */

  }, {
    key: 'start',
    value: function start() {
      log('"' + this.id + '" started');
      (0, _get3.default)(Service.prototype.__proto__ || (0, _getPrototypeOf2.default)(Service.prototype), 'start', this).call(this);
    }

    /** @inheritdoc */

  }, {
    key: 'stop',
    value: function stop() {
      log('"' + this.id + '" stopped');
      (0, _get3.default)(Service.prototype.__proto__ || (0, _getPrototypeOf2.default)(Service.prototype), 'stop', this).call(this);
    }
  }]);
  return Service;
}(_Activity3.default);

exports.default = Service;

},{"../../utils/Signal":308,"./Activity":262,"./serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"debug":304}],266:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _serviceManager = require('./serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

var _viewManager = require('./viewManager');

var _viewManager2 = _interopRequireDefault(_viewManager);

var _viewport = require('../views/viewport');

var _viewport2 = _interopRequireDefault(_viewport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Client side entry point for a `soundworks` application.
 *
 * This object hosts general informations about the user, as well as methods
 * to initialize and start the application.
 *
 * @memberof module:soundworks/client
 * @namespace
 *
 * @example
 * import * as soundworks from 'soundworks/client';
 * import MyExperience from './MyExperience';
 *
 * soundworks.client.init('player');
 * const myExperience = new MyExperience();
 * soundworks.client.start();
 */
var client = {
  /**
   * Unique id of the client, generated and retrieved by the server.
   *
   * @type {Number}
   */
  uuid: null,

  /**
   * The type of the client, this can generally be considered as the role of the
   * client in the application. This value is defined in the
   * [`client.init`]{@link module:soundworks/server.server~serverConfig} object
   * and defaults to `'player'`.
   *
   * @type {String}
   */
  type: null,

  /**
   * Configuration informations from the server configuration if any.
   *
   * @type {Object}
   * @see {@link module:soundworks/client.client~init}
   * @see {@link module:soundworks/client.SharedConfig}
   */
  config: {},

  /**
   * Array of optionnal parameters passed through the url
   *
   * @type {Array}
   */
  urlParams: null,

  /**
   * Information about the client platform. The properties are set by the
   * [`platform`]{@link module:soundworks/client.Platform} service.
   *
   * @type {Object}
   * @property {String} os - Operating system.
   * @property {Boolean} isMobile - Indicates whether the client is running on a
   *  mobile platform or not.
   * @property {String} audioFileExt - Audio file extension to use, depending on
   *  the platform.
   * @property {String} interaction - Type of interaction allowed by the
   *  viewport, `touch` or `mouse`
   *
   * @see {@link module:soundworks/client.Platform}
   */
  platform: {
    os: null,
    isMobile: null,
    audioFileExt: '',
    interaction: null
  },

  /**
   * Defines whether the user's device is compatible with the application
   * requirements.
   *
   * @type {Boolean}
   * @see {@link module:soundworks/client.Platform}
   */
  compatible: null,

  /**
   * Index (if any) given by a [`placer`]{@link module:soundworks/client.Placer}
   * or [`checkin`]{@link module:soundworks/client.Checkin} service.
   *
   * @type {Number}
   * @see {@link module:soundworks/client.Checkin}
   * @see {@link module:soundworks/client.Placer}
   */
  index: null,

  /**
   * Ticket label (if any) given by a [`placer`]{@link module:soundworks/client.Placer}
   * or [`checkin`]{@link module:soundworks/client.Checkin} service.
   *
   * @type {String}
   * @see {@link module:soundworks/client.Checkin}
   * @see {@link module:soundworks/client.Placer}
   */
  label: null,

  /**
   * Client coordinates (if any) given by a
   * [`locator`]{@link module:soundworks/client.Locator},
   * [`placer`]{@link module:soundworks/client.Placer} or
   * [`checkin`]{@link module:soundworks/client.Checkin} service.
   * (Format: `[x:Number, y:Number]`.)
   *
   * @type {Array<Number>}
   * @see {@link module:soundworks/client.Checkin}
   * @see {@link module:soundworks/client.Locator}
   * @see {@link module:soundworks/client.Placer}
   * @see {@link module:soundworks/client.Geolocation}
   */
  coordinates: null,

  /**
   * Full `geoposition` object as returned by `navigator.geolocation`, when
   * using the `geolocation` service.
   *
   * @type {Object}
   * @see {@link module:soundworks/client.Geolocation}
   */
  geoposition: null,

  /**
   * Socket object that handle communications with the server, if any.
   * This object is automatically created if the experience requires any service
   * having a server-side counterpart.
   *
   * @type {module:soundworks/client.socket}
   * @private
   */
  socket: _socket2.default,

  /**
   * Initialize the application.
   *
   * @param {String} [clientType='player'] - The type of the client, defines the
   *  socket connection namespace. Should match a client type defined server side.
   * @param {Object} [config={}]
   * @param {Object} [config.appContainer='#container'] - A css selector
   *  matching a DOM element where the views should be inserted.
   * @param {Object} [config.websockets.url=''] - The url where the socket should
   *  connect _(unstable)_.
   * @param {Object} [config.websockets.transports=['websocket']] - The transport
   *  used to create the url (overrides default socket.io mecanism) _(unstable)_.
   */
  init: function init() {
    var clientType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'player';
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this.type = clientType;

    this._parseUrlParams();
    // if socket config given, mix it with defaults
    var websockets = (0, _assign2.default)({
      url: '',
      transports: ['websocket'],
      path: ''
    }, config.websockets);

    // mix all other config and override with defined socket config
    (0, _assign2.default)(this.config, config, { websockets: websockets });

    _serviceManager2.default.init();
    _viewport2.default.init();

    var el = config.appContainer;
    var $container = el instanceof Element ? el : document.querySelector(el);
    _viewManager2.default.setAppContainer($container);

    return _promise2.default.resolve();
  },


  /**
   * Register a function to be executed when a service is instanciated.
   *
   * @param {serviceManager~serviceInstanciationHook} func - Function to
   *  register has a hook to be execute when a service is created.
   */
  /**
   * @callback serviceManager~serviceInstanciationHook
   * @param {String} id - id of the instanciated service.
   * @param {Service} instance - instance of the service.
   */
  setServiceInstanciationHook: function setServiceInstanciationHook(func) {
    _serviceManager2.default.setServiceInstanciationHook(func);
  },


  /**
   * Start the application.
   */
  start: function start() {
    if (_socket2.default.required) this._initSocket(function () {
      return _serviceManager2.default.start();
    });else _serviceManager2.default.start();
  },


  /**
   * Returns a service configured with the given options.
   * @param {String} id - Identifier of the service.
   * @param {Object} options - Options to configure the service.
   */
  require: function require(id, options) {
    return _serviceManager2.default.require(id, options);
  },


  /**
   * Retrieve an array of optionnal parameters from the url excluding the client type
   * and store it in `this.urlParams`.
   * Parameters can be defined in two ways :
   * - as a regular route (ex: `/player/param1/param2`)
   * - as a hash (ex: `/player#param1-param2`)
   * The parameters are send along with the socket connection
   *
   * @see {@link module:soundworks/client.socket}
   * @private
   * @todo - When handshake implemented, define if these informations should be part of it
   */
  _parseUrlParams: function _parseUrlParams() {
    var _this = this;

    var pathParams = null;
    var hashParams = null;
    // handle path name first
    var pathname = window.location.pathname;
    // sanitize
    pathname = pathname.replace(/^\//, '') // leading slash
    .replace(new RegExp('^' + this.type + '/?'), '') // remove clientType
    .replace(/\/$/, ''); // trailing slash

    if (pathname.length > 0) pathParams = pathname.split('/');

    // handle hash
    var hash = window.location.hash;
    hash = hash.replace(/^#/, '');

    if (hash.length > 0) hashParams = hash.split('-');

    if (pathParams || hashParams) {
      this.urlParams = [];

      if (pathParams) pathParams.forEach(function (param) {
        return _this.urlParams.push(param);
      });

      if (hashParams) hashParams.forEach(function (param) {
        return _this.urlParams.push(param);
      });
    }
  },


  /**
   * Initialize socket connection and perform handshake with the server.
   * @todo - refactor handshake.
   * @private
   */
  _initSocket: function _initSocket(callback) {
    var _this2 = this;

    _socket2.default.init(this.type, this.config.websockets);

    // see: http://socket.io/docs/client-api/#socket
    this.socket.addStateListener(function (eventName) {
      switch (eventName) {
        case 'connect':
          var payload = { urlParams: _this2.urlParams };

          if (_this2.config.env !== 'production') {
            (0, _assign2.default)(payload, {
              requiredServices: _serviceManager2.default.getRequiredServices()
            });
          }

          _this2.socket.send('handshake', payload);
          // wait for handshake response to mark client as `ready`
          _this2.socket.receive('client:start', function (uuid) {
            _this2.uuid = uuid;
            callback();
          });

          _this2.socket.receive('client:error', function (err) {
            switch (err.type) {
              case 'services':
                // can only append if env !== 'production'
                var msg = '"' + err.data.join(', ') + '" required client-side but not server-side';
                throw new Error(msg);
                break;
            }
          });
          break;
        // case 'reconnect':
        //   // serviceManager.start();
        //   break;
        // case 'disconnect':
        //   // can relaunch serviceManager on reconnection
        //   // serviceManager.reset();
        //   break;
        // case 'connect_error':
        // case 'reconnect_attempt':
        // case 'reconnecting':
        // case 'reconnect_error':
        // case 'reconnect_failed':
        //   break;
      }
    });
  }
};

exports.default = client;

},{"../views/viewport":303,"./serviceManager":267,"./socket":268,"./viewManager":269,"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/promise":27}],267:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _Signal = require('../../utils/Signal');

var _Signal2 = _interopRequireDefault(_Signal);

var _SignalAll = require('../../utils/SignalAll');

var _SignalAll2 = _interopRequireDefault(_SignalAll);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('soundworks:serviceManager');

var _instances = {};
var _ctors = {};

/**
 * Factory and initialisation manager for the services.
 * Lazy instanciate an instance of the given type and retrieve it on each call.
 */
var serviceManager = {
  _serviceInstanciationHook: null,

  /**
   * Initialize the manager.
   */
  init: function init() {
    var _this = this;

    log('init');
    this._requiredSignals = new _SignalAll2.default();
    this._requiredSignals.addObserver(function () {
      return _this.ready();
    });

    this.signals = {};
    this.signals.start = new _Signal2.default();
    this.signals.ready = new _Signal2.default();
  },


  /**
   * Sends the signal required by all services to start.
   */
  start: function start() {
    log('start');

    var networkedServices = [];

    this.signals.start.set(true);

    if (!this._requiredSignals.length) this.ready();
  },


  /**
   * Mark the services as ready. This signal is observed by {@link Experience}
   * instances and trigger their `start`.
   */
  ready: function ready() {
    log('ready');
    this.signals.ready.set(true);
  },


  /**
   * Returns an instance of a service with options to be applied to its constructor.
   * @param {String} id - The id of the service.
   * @param {Object} options - Options to pass to the service constructor.
   */
  require: function require(id) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    id = 'service:' + id;

    if (!_ctors[id]) throw new Error('Service "' + id + '" is not defined');

    var instance = _instances[id];

    if (!instance) {
      // throw an error if manager already started
      if (this.signals.start.get() === true) throw new Error('Service "' + id + '" required after serviceManager start');

      instance = new _ctors[id]();

      if (this._serviceInstanciationHook !== null) this._serviceInstanciationHook(id, instance);

      // add the instance ready signal as required for the manager
      this._requiredSignals.add(instance.signals.ready);
      // store instance
      _instances[id] = instance;
    }

    instance.configure(options);
    return instance;
  },


  /**
   * Register a function to be executed when a service is instanciated.
   *
   * @param {serviceManager~serviceInstanciationHook} func - Function to
   *  register has a hook to be execute when a service is created.
   */
  /**
   * @callback serviceManager~serviceInstanciationHook
   * @param {String} id - id of the instanciated service.
   * @param {Service} instance - instance of the service.
   */
  setServiceInstanciationHook: function setServiceInstanciationHook(func) {
    this._serviceInstanciationHook = func;
  },


  /**
   * Register a service with a given id.
   * @param {String} id - The id of the service.
   * @param {Function} ctor - The constructor of the service.
   */
  register: function register(id, ctor) {
    _ctors[id] = ctor;
  },
  getRequiredServices: function getRequiredServices() {
    return (0, _keys2.default)(_instances);
  }
};

exports.default = serviceManager;

},{"../../utils/Signal":308,"../../utils/SignalAll":309,"babel-runtime/core-js/object/keys":25,"debug":304}],268:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _socket2 = require('socket.io-client');

var _socket3 = _interopRequireDefault(_socket2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('soundworks:socket');

var socket = {
  /**
   * Store the instance of Socket.io Manager.
   */
  socket: null,

  /**
   * Is set to `true` when a `Activity` that requires network is instanciated.
   * Is checked by the `client` to initialize the connection or not.
   */
  required: false,

  /**
   * Initialize a namespaced connection with given options.
   *
   * @param {String} namespace - Correspond to the `client.type` {@link client}.
   * @param {Object} options - Options of the socket.
   * @param {String} options.url - The url where the socket should connect.
   * @param {Array<String>} options.transports - The transports to use for the socket (cf. socket.io).
   * @param {Array<String>} options.path - Defines where socket should find the `socket.io` file.
   */
  init: function init(namespace, options) {
    this.socket = (0, _socket3.default)(options.url + '/' + namespace, {
      transports: options.transports,
      path: options.path
    });

    log('initialized\n          - url: ' + options.url + '/' + namespace + '\n          - transports: ' + options.transports + '\n          - path: ' + options.path + '\n    ');

    this._stateListeners = new _set2.default();
    this._state = null;

    this._listenSocketState();
  },


  /**
   * Listen to the different states of the socket.
   *
   * @param {Function} callback - The function to be called when the state
   *  of the socket changes, the given function is called with the name of the
   *  event as argument.
   * @see {http://socket.io/docs/client-api/#socket}
   */
  addStateListener: function addStateListener(callback) {
    this._stateListeners.add(callback);

    if (this._state !== null) callback(this._state);
  },
  _listenSocketState: function _listenSocketState() {
    var _this = this;

    // see: http://socket.io/docs/client-api/#socket
    ['connect', 'reconnect', 'disconnect', 'connect_error', 'reconnect_attempt', 'reconnecting', 'reconnect_error', 'reconnect_failed'].forEach(function (eventName) {
      _this.socket.on(eventName, function () {
        _this._state = eventName;
        _this._stateListeners.forEach(function (listener) {
          return listener(_this._state);
        });
        log('state - ' + _this._state);
      });
    });
  },


  /**
   * Sends a WebSocket message to the server side socket.
   *
   * @param {String} channel - The channel of the message.
   * @param {...*} args - Arguments of the message (as many as needed, of any type).
   */
  send: function send(channel) {
    var _socket;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_socket = this.socket).emit.apply(_socket, [channel].concat(args));
    log.apply(undefined, ['send - channel: "' + channel + '"'].concat(args));
  },
  sendVolatile: function sendVolatile(channel) {
    var _socket$volatile;

    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    (_socket$volatile = this.socket.volatile).emit.apply(_socket$volatile, [channel].concat(args));
    log.apply(undefined, ['sendVolatile - channel: "' + channel + '"'].concat(args));
  },


  /**
   * Listen a WebSocket message from the server.
   *
   * @param {String} channel - The channel of the message.
   * @param {...*} callback - The callback to execute when a message is received.
   */
  receive: function receive(channel, callback) {
    this.socket.removeListener(channel, callback);
    this.socket.on(channel, callback);
    log('receive listener - channel: "' + channel + '"');
  },


  /**
   * Stop listening to a message from the server.
   *
   * @param {String} channel - The channel of the message.
   * @param {...*} callback - The callback to cancel.
   */
  removeListener: function removeListener(channel, callback) {
    this.socket.removeListener(channel, callback);
    log('remove listener - channel: "' + channel + '"');
  }
};

exports.default = socket;

},{"babel-runtime/core-js/set":28,"debug":304,"socket.io-client":249}],269:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('soundworks:viewManager');
var viewInfosMap = new _map2.default();

var $container = null;

/**
 * Handle activities' (services and scenes) views according to their priorities.
 */
var viewManager = {
  _timeoutId: null,

  _visibleView: null,

  /**
   * Sets the container of the views for all `Activity` instances. Is called by
   * {@link src/client/core/client.js~client}) during application bootstrap.
   * @param {Element} $el - The element to use as a container for the view.
   * @private
   */
  setAppContainer: function setAppContainer($el) {
    $container = $el;
  },


  /**
   * Register a view into the stack of views to display. The fact that the view is
   * actually displayed is defined by its priority and activities lifecycle.
   * @param {View} view - A view to add to the stack.
   */
  register: function register(view, priority) {
    var _this = this;

    log('register - id: "' + view.options.id + '" - priority: ' + priority);

    var infos = {};
    infos.$el = view.render();
    infos.priority = priority;
    var promise = new _promise2.default(function (resolve, reject) {
      return infos.promise = resolve;
    });

    viewInfosMap.set(view, infos);

    // trigger `_updateView` only once when several view are registered at once.
    clearTimeout(this._timeoutId);
    this._timeoutId = setTimeout(function () {
      return _this._updateView();
    }, 0);

    return promise;
  },


  /**
   * Remove view from the stack of views to display.
   * @param {View} view - A view to remove from the stack.
   */
  remove: function remove(view) {
    var _this2 = this;

    log('remove - id: "' + view.options.id + '"');

    // clean dictionnary
    viewInfosMap.delete(view);

    if (this._visibleView === view) {
      this._visibleView.remove();
      this._visibleView = null;
    }

    clearTimeout(this._timeoutId);
    this._timeoutId = setTimeout(function () {
      return _this2._updateView();
    }, 0);
  },


  /**
   * Defines whether the view should be updated according to defined priorities.
   * @private
   */
  _updateView: function _updateView() {
    var visibleView = this._visibleView;
    var nextViewPriority = -Infinity;
    var nextView = null;

    viewInfosMap.forEach(function (infos, view) {
      if (infos.priority > nextViewPriority) {
        nextViewPriority = infos.priority;
        nextView = view;
      }
    });

    if (nextView) {
      log('update view - next: "' + nextView.options.id + '"');

      if (visibleView === null) {
        $container.appendChild(viewInfosMap.get(nextView).$el);
        nextView.show();
        // resolve the promise created when the view were registered
        viewInfosMap.get(nextView).promise();
        this._visibleView = nextView;
      } else {
        var visibleViewPriority = viewInfosMap.get(this._visibleView).priority;

        if (visibleViewPriority < nextViewPriority) {
          visibleView.remove(); // hide but keep in stack

          $container.appendChild(viewInfosMap.get(nextView).$el);
          nextView.show();

          viewInfosMap.get(nextView).promise();
          this._visibleView = nextView;
        }
      }
    }
  }
};

exports.default = viewManager;

},{"babel-runtime/core-js/map":19,"babel-runtime/core-js/promise":27,"debug":304}],270:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SquaredView = exports.SpaceView = exports.SelectView = exports.ControllerExperience = exports.ControllerScene = exports.viewport = exports.View = exports.TouchSurface = exports.SegmentedView = exports.CanvasView = exports.CanvasRenderingGroup = exports.Canvas2dRenderer = exports.SyncScheduler = exports.Sync = exports.SharedRecorder = exports.SharedParams = exports.SharedConfig = exports.RawSocket = exports.Platform = exports.Placer = exports.Network = exports.MotionInput = exports.MetricScheduler = exports.Locator = exports.Language = exports.Geolocation = exports.FileSystem = exports.ErrorReporter = exports.Checkin = exports.Auth = exports.AudioScheduler = exports.AudioStreamManager = exports.AudioBufferManager = exports.serviceManager = exports.Service = exports.Process = exports.Experience = exports.client = exports.Activity = exports.version = exports.audioContext = exports.audio = undefined;

var _wavesAudio = require('waves-audio');

Object.defineProperty(exports, 'audioContext', {
  enumerable: true,
  get: function get() {
    return _wavesAudio.audioContext;
  }
});

var _Activity = require('./core/Activity');

Object.defineProperty(exports, 'Activity', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Activity).default;
  }
});

var _client = require('./core/client');

Object.defineProperty(exports, 'client', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_client).default;
  }
});

var _Experience = require('./core/Experience');

Object.defineProperty(exports, 'Experience', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Experience).default;
  }
});

var _Process = require('./core/Process');

Object.defineProperty(exports, 'Process', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Process).default;
  }
});

var _Service = require('./core/Service');

Object.defineProperty(exports, 'Service', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Service).default;
  }
});

var _serviceManager = require('./core/serviceManager');

Object.defineProperty(exports, 'serviceManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_serviceManager).default;
  }
});

var _AudioBufferManager = require('./services/AudioBufferManager');

Object.defineProperty(exports, 'AudioBufferManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_AudioBufferManager).default;
  }
});

var _AudioStreamManager = require('./services/AudioStreamManager');

Object.defineProperty(exports, 'AudioStreamManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_AudioStreamManager).default;
  }
});

var _AudioScheduler = require('./services/AudioScheduler');

Object.defineProperty(exports, 'AudioScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_AudioScheduler).default;
  }
});

var _Auth = require('./services/Auth');

Object.defineProperty(exports, 'Auth', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Auth).default;
  }
});

var _Checkin = require('./services/Checkin');

Object.defineProperty(exports, 'Checkin', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Checkin).default;
  }
});

var _ErrorReporter = require('./services/ErrorReporter');

Object.defineProperty(exports, 'ErrorReporter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ErrorReporter).default;
  }
});

var _FileSystem = require('./services/FileSystem');

Object.defineProperty(exports, 'FileSystem', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_FileSystem).default;
  }
});

var _Geolocation = require('./services/Geolocation');

Object.defineProperty(exports, 'Geolocation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Geolocation).default;
  }
});

var _Language = require('./services/Language');

Object.defineProperty(exports, 'Language', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Language).default;
  }
});

var _Locator = require('./services/Locator');

Object.defineProperty(exports, 'Locator', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Locator).default;
  }
});

var _MetricScheduler = require('./services/MetricScheduler');

Object.defineProperty(exports, 'MetricScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_MetricScheduler).default;
  }
});

var _MotionInput = require('./services/MotionInput');

Object.defineProperty(exports, 'MotionInput', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_MotionInput).default;
  }
});

var _Network = require('./services/Network');

Object.defineProperty(exports, 'Network', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Network).default;
  }
});

var _Placer = require('./services/Placer');

Object.defineProperty(exports, 'Placer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Placer).default;
  }
});

var _Platform = require('./services/Platform');

Object.defineProperty(exports, 'Platform', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Platform).default;
  }
});

var _RawSocket = require('./services/RawSocket');

Object.defineProperty(exports, 'RawSocket', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RawSocket).default;
  }
});

var _SharedConfig = require('./services/SharedConfig');

Object.defineProperty(exports, 'SharedConfig', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SharedConfig).default;
  }
});

var _SharedParams = require('./services/SharedParams');

Object.defineProperty(exports, 'SharedParams', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SharedParams).default;
  }
});

var _SharedRecorder = require('./services/SharedRecorder');

Object.defineProperty(exports, 'SharedRecorder', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SharedRecorder).default;
  }
});

var _Sync = require('./services/Sync');

Object.defineProperty(exports, 'Sync', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Sync).default;
  }
});

var _SyncScheduler = require('./services/SyncScheduler');

Object.defineProperty(exports, 'SyncScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SyncScheduler).default;
  }
});

var _Canvas2dRenderer = require('./views/Canvas2dRenderer');

Object.defineProperty(exports, 'Canvas2dRenderer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Canvas2dRenderer).default;
  }
});

var _CanvasRenderingGroup = require('./views/CanvasRenderingGroup');

Object.defineProperty(exports, 'CanvasRenderingGroup', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasRenderingGroup).default;
  }
});

var _CanvasView = require('./views/CanvasView');

Object.defineProperty(exports, 'CanvasView', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_CanvasView).default;
  }
});

var _SegmentedView = require('./views/SegmentedView');

Object.defineProperty(exports, 'SegmentedView', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SegmentedView).default;
  }
});

var _TouchSurface = require('./views/TouchSurface');

Object.defineProperty(exports, 'TouchSurface', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TouchSurface).default;
  }
});

var _View = require('./views/View');

Object.defineProperty(exports, 'View', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_View).default;
  }
});

var _viewport = require('./views/viewport');

Object.defineProperty(exports, 'viewport', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_viewport).default;
  }
});

var _ControllerScene = require('./prefabs/ControllerScene');

Object.defineProperty(exports, 'ControllerScene', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ControllerScene).default;
  }
});

var _ControllerExperience = require('./prefabs/ControllerExperience');

Object.defineProperty(exports, 'ControllerExperience', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ControllerExperience).default;
  }
});

var _SelectView = require('./prefabs/SelectView');

Object.defineProperty(exports, 'SelectView', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SelectView).default;
  }
});

var _SpaceView = require('./prefabs/SpaceView');

Object.defineProperty(exports, 'SpaceView', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SpaceView).default;
  }
});

var _SquaredView = require('./prefabs/SquaredView');

Object.defineProperty(exports, 'SquaredView', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SquaredView).default;
  }
});

var _audio = _interopRequireWildcard(_wavesAudio);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audio = exports.audio = _audio; /**
                                     * Client-side entry point of the *soundworks* framework.
                                     *
                                     * @module soundworks/client
                                     * @example
                                     * import * as soundworks from 'soundworks/client';
                                     */

// export * as audio from 'waves-audio';


// version (cf. bin/javascripts)
var version = exports.version = '2.1.7';

// core

},{"./core/Activity":262,"./core/Experience":263,"./core/Process":264,"./core/Service":265,"./core/client":266,"./core/serviceManager":267,"./prefabs/ControllerExperience":271,"./prefabs/ControllerScene":272,"./prefabs/SelectView":273,"./prefabs/SpaceView":274,"./prefabs/SquaredView":275,"./services/AudioBufferManager":276,"./services/AudioScheduler":277,"./services/AudioStreamManager":278,"./services/Auth":279,"./services/Checkin":280,"./services/ErrorReporter":281,"./services/FileSystem":282,"./services/Geolocation":283,"./services/Language":284,"./services/Locator":285,"./services/MetricScheduler":286,"./services/MotionInput":287,"./services/Network":288,"./services/Placer":289,"./services/Platform":290,"./services/RawSocket":291,"./services/SharedConfig":292,"./services/SharedParams":293,"./services/SharedRecorder":294,"./services/Sync":295,"./services/SyncScheduler":296,"./views/Canvas2dRenderer":297,"./views/CanvasRenderingGroup":298,"./views/CanvasView":299,"./views/SegmentedView":300,"./views/TouchSurface":301,"./views/View":302,"./views/viewport":303,"waves-audio":322}],271:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Experience2 = require('../core/Experience');

var _Experience3 = _interopRequireDefault(_Experience2);

var _View = require('../views/View');

var _View2 = _interopRequireDefault(_View);

var _ControllerScene = require('./ControllerScene');

var _ControllerScene2 = _interopRequireDefault(_ControllerScene);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Predefined experience to create a 1 line shared controller
 *
 * @memberof module:soundworks/client
 */
var ControllerExperience = function (_Experience) {
  (0, _inherits3.default)(ControllerExperience, _Experience);

  function ControllerExperience() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, ControllerExperience);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ControllerExperience.__proto__ || (0, _getPrototypeOf2.default)(ControllerExperience)).call(this));

    _this.sharedParams = _this.require('shared-params');
    _this.controllerScene = new _ControllerScene2.default(_this, _this.sharedParams);

    if (options.auth) _this.auth = _this.require('auth');
    return _this;
  }

  (0, _createClass3.default)(ControllerExperience, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(ControllerExperience.prototype.__proto__ || (0, _getPrototypeOf2.default)(ControllerExperience.prototype), 'start', this).call(this);

      this.view = new _View2.default();
      this.show();

      this.controllerScene.enter();
    }

    /**
     * Configure the GUI for a given parameter, this method only makes sens if
     * `options.hasGUI=true`.
     * @param {String} name - Name of the parameter to configure.
     * @param {Object} options - Options to configure the parameter GUI.
     * @param {String} options.type - Type of GUI to use. Each type of parameter can
     *  used with different GUI according to their type and comes with acceptable
     *  default values.
     * @param {Boolean} [options.show=true] - Display or not the GUI for this parameter.
     * @param {Boolean} [options.confirm=false] - Ask for confirmation when the value changes.
     */

  }, {
    key: 'setGuiOptions',
    value: function setGuiOptions(name, options) {
      this.controllerScene.setGuiOptions(name, options);
    }
  }, {
    key: 'container',
    get: function get() {
      return this.view.$el;
    }
  }]);
  return ControllerExperience;
}(_Experience3.default);

exports.default = ControllerExperience;

},{"../core/Experience":263,"../views/View":302,"./ControllerScene":272,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],272:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _basicControllers = require('basic-controllers');

var controllers = _interopRequireWildcard(_basicControllers);

var _View = require('../views/View');

var _View2 = _interopRequireDefault(_View);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

controllers.setTheme('dark');

/* --------------------------------------------------------- */
/* GUIs
/* --------------------------------------------------------- */

/** @private */

var _BooleanGui = function () {
  function _BooleanGui($container, param, guiOptions) {
    (0, _classCallCheck3.default)(this, _BooleanGui);
    var label = param.label,
        value = param.value;


    this.controller = new controllers.Toggle({
      label: label,
      default: value,
      container: $container,
      callback: function callback(value) {
        if (guiOptions.confirm) {
          var msg = 'Are you sure you want to propagate "' + param.name + ':' + value + '"';
          if (!window.confirm(msg)) {
            return;
          }
        }

        param.update(value);
      }
    });
  }

  (0, _createClass3.default)(_BooleanGui, [{
    key: 'set',
    value: function set(val) {
      this.controller.value = val;
    }
  }]);
  return _BooleanGui;
}();

/** @private */


var _EnumGui = function () {
  function _EnumGui($container, param, guiOptions) {
    (0, _classCallCheck3.default)(this, _EnumGui);
    var label = param.label,
        options = param.options,
        value = param.value;


    var ctor = guiOptions.type === 'buttons' ? controllers.SelectButtons : controllers.SelectList;

    this.controller = new ctor({
      label: label,
      options: options,
      default: value,
      container: $container,
      callback: function callback(value) {
        if (guiOptions.confirm) {
          var msg = 'Are you sure you want to propagate "' + param.name + ':' + value + '"';
          if (!window.confirm(msg)) {
            return;
          }
        }

        param.update(value);
      }
    });
  }

  (0, _createClass3.default)(_EnumGui, [{
    key: 'set',
    value: function set(val) {
      this.controller.value = val;
    }
  }]);
  return _EnumGui;
}();

/** @private */


var _NumberGui = function () {
  function _NumberGui($container, param, guiOptions) {
    (0, _classCallCheck3.default)(this, _NumberGui);
    var label = param.label,
        min = param.min,
        max = param.max,
        step = param.step,
        value = param.value;


    if (guiOptions.type === 'slider') {
      this.controller = new controllers.Slider({
        label: label,
        min: min,
        max: max,
        step: step,
        default: value,
        unit: guiOptions.param ? guiOptions.param : '',
        size: guiOptions.size,
        container: $container
      });
    } else {
      this.controller = new controllers.NumberBox({
        label: label,
        min: min,
        max: max,
        step: step,
        default: value,
        container: $container
      });
    }

    this.controller.addListener(function (value) {
      if (guiOptions.confirm) {
        var msg = 'Are you sure you want to propagate "' + param.name + ':' + value + '"';
        if (!window.confirm(msg)) {
          return;
        }
      }

      param.update(value);
    });
  }

  (0, _createClass3.default)(_NumberGui, [{
    key: 'set',
    value: function set(val) {
      this.controller.value = val;
    }
  }]);
  return _NumberGui;
}();

/** @private */


var _TextGui = function () {
  function _TextGui($container, param, guiOptions) {
    (0, _classCallCheck3.default)(this, _TextGui);
    var label = param.label,
        value = param.value;


    this.controller = new controllers.Text({
      label: label,
      default: value,
      readonly: guiOptions.readonly,
      container: $container
    });

    if (!guiOptions.readonly) {
      this.controller.addListener(function (value) {
        if (guiOptions.confirm) {
          var msg = 'Are you sure you want to propagate "' + param.name + '"';
          if (!window.confirm(msg)) {
            return;
          }
        }

        param.update(value);
      });
    }
  }

  (0, _createClass3.default)(_TextGui, [{
    key: 'set',
    value: function set(val) {
      this.controller.value = val;
    }
  }]);
  return _TextGui;
}();

/** @private */


var _TriggerGui = function () {
  function _TriggerGui($container, param, guiOptions) {
    (0, _classCallCheck3.default)(this, _TriggerGui);
    var label = param.label;


    this.controller = new controllers.TriggerButtons({
      options: [label],
      container: $container,
      callback: function callback() {
        if (guiOptions.confirm) {
          var msg = 'Are you sure you want to propagate "' + param.name + '"';
          if (!window.confirm(msg)) {
            return;
          }
        }

        param.update();
      }
    });
  }

  (0, _createClass3.default)(_TriggerGui, [{
    key: 'set',
    value: function set(val) {/* nothing to set here */}
  }]);
  return _TriggerGui;
}();

var SCENE_ID = 'basic-shared-controller';

/**
 * The `ControllerScene` scene propose a simple / default way to create
 * a controller view for the `shared-params` service.
 *
 * Each controller comes with a set of options that can be passed to the
 * constructor.
 *
 * @memberof module:soundworks/client
 * @see [`shared-params` service]{@link module:soundworks/client.SharedParams}
 */

var ControllerScene = function () {
  /**
   * _<span class="warning">__WARNING__</span> This API is unstable, and
   * subject to change in further versions.
   */
  function ControllerScene(experience, sharedParams) {
    (0, _classCallCheck3.default)(this, ControllerScene);

    if (!sharedParams) throw new Error('This service requires the "shared params" service');

    this._guiOptions = {};

    this.experience = experience;
    this.sharedParams = sharedParams;
  }

  (0, _createClass3.default)(ControllerScene, [{
    key: 'enter',
    value: function enter() {
      var _this = this;

      this.view = new _View2.default();
      this.view.options.id = 'basic-shared-controller';

      this.view.render();
      this.view.appendTo(this.experience.container);

      var _loop = function _loop(name) {
        var param = _this.sharedParams.params[name];
        var gui = _this._createGui(param);

        param.addListener('update', function (val) {
          return gui.set(val);
        });
      };

      for (var name in this.sharedParams.params) {
        _loop(name);
      }
    }
  }, {
    key: 'exit',
    value: function exit() {
      for (var name in this.sharedParams.params) {
        var param = this.sharedParams.params[name];
        param.removeListener('update');
      }

      this.view.remove();
    }

    /**
     * Configure the GUI for a given parameter, this method only makes sens if
     * `options.hasGUI=true`.
     * @param {String} name - Name of the parameter to configure.
     * @param {Object} options - Options to configure the parameter GUI.
     * @param {String} options.type - Type of GUI to use. Each type of parameter can
     *  used with different GUI according to their type and comes with acceptable
     *  default values.
     * @param {Boolean} [options.show=true] - Display or not the GUI for this parameter.
     * @param {Boolean} [options.confirm=false] - Ask for confirmation when the value changes.
     */

  }, {
    key: 'setGuiOptions',
    value: function setGuiOptions(name, options) {
      this._guiOptions[name] = options;
    }

    /** @private */

  }, {
    key: '_createGui',
    value: function _createGui(param) {
      var config = (0, _assign2.default)({
        show: true,
        confirm: false
      }, this._guiOptions[param.name]);

      if (config.show === false) return null;

      var gui = null;
      var $container = this.view.$el;

      switch (param.type) {
        case 'boolean':
          gui = new _BooleanGui($container, param, config); // `Toggle`
          break;
        case 'enum':
          gui = new _EnumGui($container, param, config); // `SelectList` or `SelectButtons`
          break;
        case 'number':
          gui = new _NumberGui($container, param, config); // `NumberBox` or `Slider`
          break;
        case 'text':
          gui = new _TextGui($container, param, config); // `Text`
          break;
        case 'trigger':
          gui = new _TriggerGui($container, param, config);
          break;
      }

      return gui;
    }
  }]);
  return ControllerScene;
}();

exports.default = ControllerScene;

},{"../views/View":302,"babel-runtime/core-js/object/assign":20,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"basic-controllers":57}],273:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _View2 = require('../views/View');

var _View3 = _interopRequireDefault(_View2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultTemplate = '\n  <option class="small"><%= instructions %></option>\n  <% entries.forEach(function(entry) { %>\n    <option value="<%= entry.index %>"><%= entry.label %></option>\n  <% }); %>\n';

/**
 * View with a drop down list.
 *
 * @memberof module:soundworks/client
 */

var SelectView = function (_View) {
  (0, _inherits3.default)(SelectView, _View);

  function SelectView(content) {
    var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, SelectView);

    options = (0, _assign2.default)({ el: 'select', className: 'select' }, options);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SelectView.__proto__ || (0, _getPrototypeOf2.default)(SelectView)).call(this, defaultTemplate, content, events, options));

    _this.entries = content.entries;
    return _this;
  }

  /**
   * why noop ?
   * @private
   */


  (0, _createClass3.default)(SelectView, [{
    key: 'onResize',
    value: function onResize() {}

    /**
     * Return the entry corresponding to the selected item.
     */

  }, {
    key: 'enableIndex',


    /**
     * Enable selection of a specific item.
     *
     * @param {Number} index - Index of the entry.
     */
    value: function enableIndex(index) {
      var $option = this.$el.querySelector('option[value="' + index + '"]');
      if ($option) $option.removeAttribute('disabled');
    }

    /**
     * Disable selection of a specific item.
     *
     * @param {Number} index - Index of the entry.
     */

  }, {
    key: 'disableIndex',
    value: function disableIndex(index) {
      var $option = this.$el.querySelector('option[value="' + index + '"]');
      if ($option) $option.setAttribute('disabled', 'disabled');
    }
  }, {
    key: 'value',
    get: function get() {
      var index = parseInt(this.$el.value);
      var entry = this.entries.find(function (entry) {
        return entry.index === index;
      });
      return entry || null;
    }
  }]);
  return SelectView;
}(_View3.default);

exports.default = SelectView;

},{"../views/View":302,"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],274:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _View2 = require('../views/View');

var _View3 = _interopRequireDefault(_View2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var svgTemplate = '\n<div class="svg-container">\n  <svg></svg>\n</div>';

var ns = 'http://www.w3.org/2000/svg';

/**
 * A view that render an `area` object (as defined in server configuration).
 *
 * @param {String} template - Template of the view.
 * @param {Object} content - Object containing the variables used to populate
 *  the template. {@link module:soundworks/client.View#content}.
 * @param {Object} events - Listeners to install in the view
 *  {@link module:soundworks/client.View#events}.
 * @param {Object} options - Options of the view.
 *  {@link module:soundworks/client.View#options}.
 *
 * @memberof module:soundworks/client
 */

var SpaceView = function (_View) {
  (0, _inherits3.default)(SpaceView, _View);

  function SpaceView() {
    var template = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : svgTemplate;
    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck3.default)(this, SpaceView);

    options = (0, _assign2.default)({ className: 'space' }, options);

    /**
     * The area to display.
     *
     * @type {Object}
     * @property {Number} area.width - Width of the area.
     * @property {Number} area.height - Height of the area.
     * @property {String} area.background - Optionnal background image to
     *  display in background.
     * @name area
     * @instance
     * @memberof module:soundworks/client.SpaceView
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SpaceView.__proto__ || (0, _getPrototypeOf2.default)(SpaceView)).call(this, template, content, events, options));

    _this.area = null;

    /**
     * Width of the rendered area in pixels.
     *
     * @type {Number}
     * @name areaWidth
     * @instance
     * @memberof module:soundworks/client.SpaceView
     */
    _this.areaWidth = null;

    /**
     * Height of the rendered area in pixels.
     *
     * @type {Number}
     * @name areaHeight
     * @instance
     * @memberof module:soundworks/client.SpaceView
     */
    _this.areaHeight = null;

    /**
     * Map associating `$shapes` and their relative `point` object.
     *
     * @type {Map}
     * @name shapePointMap
     * @instance
     * @memberof module:soundworks/client.SpaceView
     */
    _this.shapePointMap = new _map2.default();

    /**
     * Expose a Map of the $shapes and their relative line object.
     * @type {Map}
     * @private
     */
    _this.shapeLineMap = new _map2.default();

    _this._renderedPoints = new _map2.default();
    _this._renderedLines = new _map2.default();
    return _this;
  }

  /**
   * Set the `area` to be renderered.
   *
   * @type {Object} area - Object describing the area, generally defined in
   *  server configuration.
   * @property {Number} area.width - Width of the area.
   * @property {Number} area.height - Height of the area.
   * @property {String} area.background - Optionnal background image to
     *  display in background.
   */


  (0, _createClass3.default)(SpaceView, [{
    key: 'setArea',
    value: function setArea(area) {
      this.area = area;
    }

    /** @private */

  }, {
    key: 'onRender',
    value: function onRender() {
      this.$svgContainer = this.$el.querySelector('.svg-container');
      this.$svg = this.$el.querySelector('svg');
      this.addDefinitions();
      this.renderArea();
    }

    /** @private */

  }, {
    key: 'onResize',
    value: function onResize(viewportWidth, viewportHeight, orientation) {
      (0, _get3.default)(SpaceView.prototype.__proto__ || (0, _getPrototypeOf2.default)(SpaceView.prototype), 'onResize', this).call(this, viewportWidth, viewportHeight, orientation);
      // override size to match parent size if component of another view
      this.$el.style.width = '100%';
      this.$el.style.height = '100%';

      this.renderArea();
    }

    /**
     * Add svg definitions.
     *
     * @private
     */

  }, {
    key: 'addDefinitions',
    value: function addDefinitions() {
      this.$defs = document.createElementNS(ns, 'defs');

      var markerArrow = '\n      <marker id="marker-arrow" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">\n          <path d="M0,0 L0,10 L10,5 L0,0" class="marker-arrow" />\n      </marker>\n    ';

      this.$defs.innerHTML = markerArrow;
      this.$svg.insertBefore(this.$defs, this.$svg.firstChild);
    }

    /**
     * Update the displayed area, according to changes in `area` definition or
     * if a `resize` event has been trigerred.
     */

  }, {
    key: 'renderArea',
    value: function renderArea() {
      var area = this.area;
      // use `this.$el` size instead of `this.$parent` size to ignore parent padding
      var boundingRect = this.$el.getBoundingClientRect();
      var containerWidth = boundingRect.width;
      var containerHeight = boundingRect.height;

      this.ratio = Math.min(containerWidth / area.width, containerHeight / area.height);
      var svgWidth = area.width * this.ratio;
      var svgHeight = area.height * this.ratio;

      var top = (containerHeight - svgHeight) / 2;
      var left = (containerWidth - svgWidth) / 2;

      this.$svgContainer.style.width = svgWidth + 'px';
      this.$svgContainer.style.height = svgHeight + 'px';
      this.$svg.setAttribute('width', svgWidth);
      this.$svg.setAttribute('height', svgHeight);
      // center the svg into the parent
      this.$svgContainer.style.position = 'absolute';
      this.$svgContainer.style.top = top + 'px';
      this.$svgContainer.style.left = left + 'px';

      this.$svg.style.position = 'absolute';
      this.$svg.style.top = '0px';
      this.$svg.style.left = '0px';

      // display background if any
      if (area.background) {
        this.$el.style.backgroundImage = 'url(' + area.background + ')';
        this.$el.style.backgroundPosition = '50% 50%';
        this.$el.style.backgroundRepeat = 'no-repeat';
        this.$el.style.backgroundSize = 'contain';
        // force $svg to be transparent
        this.$svg.style.backgroundColor = 'transparent';
      }

      // update existing points position
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.shapePointMap), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
              $shape = _step$value[0],
              point = _step$value[1];

          this.updatePoint(point);
        } // expose the size of the area in pixel
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.areaWidth = svgWidth;
      this.areaHeight = svgHeight;
    }

    /**
     * Method used to render a specific point. Override this method to display
     * points with user defined shapes. The shape returned by this method is
     * inserted into the `svg` element.
     *
     * @param {Object} point - Point to render.
     * @param {String|Number} point.id - Unique identifier for the point.
     * @param {Number} point.x - Value in the x axis in the area coordinate system.
     * @param {Number} point.y - Value in the y axis in the area coordinate system.
     * @param {Number} [point.radius=0.3] - Radius of the point (relative to the
     *  area width and height).
     * @param {String} [point.color=undefined] - Optionnal color of the point.
     */

  }, {
    key: 'renderPoint',
    value: function renderPoint(point) {
      var $shape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if ($shape === null) {
        $shape = document.createElementNS(ns, 'circle');
        $shape.classList.add('point');
      }

      $shape.setAttribute('data-id', point.id);
      $shape.setAttribute('cx', '' + point.x * this.ratio);
      $shape.setAttribute('cy', '' + point.y * this.ratio);
      $shape.setAttribute('r', point.radius || 8); // radius is relative to area size

      if (point.color) $shape.style.fill = point.color;

      var method = point.selected ? 'add' : 'remove';
      $shape.classList[method]('selected');

      return $shape;
    }

    /**
     * Replace all the existing points with the given array of points.
     *
     * @param {Array<Object>} points - Points to render.
     */

  }, {
    key: 'setPoints',
    value: function setPoints(points) {
      this.clearPoints();
      this.addPoints(points);
    }

    /**
     * Delete all points.
     */

  }, {
    key: 'clearPoints',
    value: function clearPoints() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this._renderedPoints.keys()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var id = _step2.value;

          this.deletePoint(id);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     * Add new points to the area.
     *
     * @param {Array<Object>} points - New points to add to the view.
     */

  }, {
    key: 'addPoints',
    value: function addPoints(points) {
      var _this2 = this;

      points.forEach(function (point) {
        return _this2.addPoint(point);
      });
    }

    /**
     * Add a new point to the area.
     *
     * @param {Object} point - New point to add to the view.
     */

  }, {
    key: 'addPoint',
    value: function addPoint(point) {
      var $shape = this.renderPoint(point);
      this.$svg.appendChild($shape);
      this._renderedPoints.set(point.id, $shape);
      // map for easier retrieving of the point
      this.shapePointMap.set($shape, point);
    }

    /**
     * Update a point.
     *
     * @param {Object} point - Point to update.
     */

  }, {
    key: 'updatePoint',
    value: function updatePoint(point) {
      var $shape = this._renderedPoints.get(point.id);
      this.renderPoint(point, $shape);
    }

    /**
     * Delete a point.
     *
     * @param {String|Number} id - Id of the point to delete.
     */

  }, {
    key: 'deletePoint',
    value: function deletePoint(id) {
      var $shape = this._renderedPoints.get(id);
      this.$svg.removeChild($shape);
      this._renderedPoints.delete(id);
      // map for easier retrieving of the point
      this.shapePointMap.delete($shape);
    }
  }]);
  return SpaceView;
}(_View3.default);

exports.default = SpaceView;

},{"../views/View":302,"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/map":19,"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"babel-runtime/helpers/slicedToArray":38}],275:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _View2 = require('../views/View');

var _View3 = _interopRequireDefault(_View2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultTemplate = '\n  <div class="section-square flex-middle"></div>\n  <div class="section-float flex-middle"></div>\n';

/**
 * A view that define a squared zone of maximum size on the top of the screen
 * in `portrait` orientation or on the left of the screen in 'landscape'
 * orientation.
 *
 * @param {String} template - Template of the view.
 * @param {Object} content - Object containing the variables used to populate
 *  the template. {@link module:soundworks/client.View#content}.
 * @param {Object} events - Listeners to install in the view
 *  {@link module:soundworks/client.View#events}.
 * @param {Object} options - Options of the view.
 *  {@link module:soundworks/client.View#options}.
 *
 * @memberof module:soundworks/client
 */

var SquaredView = function (_View) {
  (0, _inherits3.default)(SquaredView, _View);

  function SquaredView(template) {
    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck3.default)(this, SquaredView);

    template = !template ? defaultTemplate : template;

    return (0, _possibleConstructorReturn3.default)(this, (SquaredView.__proto__ || (0, _getPrototypeOf2.default)(SquaredView)).call(this, template, content, events, options));
  }

  /** @private */


  (0, _createClass3.default)(SquaredView, [{
    key: 'onRender',
    value: function onRender() {
      this.$square = this.$el.querySelector('.section-square');
      this.$float = this.$el.querySelector('.section-float');

      this.$square.style.float = 'left';
      this.$float.style.float = 'left';
    }

    /** @private */

  }, {
    key: 'onResize',
    value: function onResize(viewportWidth, viewportHeight, orientation) {
      (0, _get3.default)(SquaredView.prototype.__proto__ || (0, _getPrototypeOf2.default)(SquaredView.prototype), 'onResize', this).call(this, viewportWidth, viewportHeight, orientation);

      var size = void 0,
          floatHeight = void 0,
          floatWidth = void 0;

      if (orientation === 'portrait') {
        size = viewportWidth;
        floatHeight = viewportHeight - size;
        floatWidth = viewportWidth;
      } else {
        size = viewportHeight;
        floatHeight = viewportHeight;
        floatWidth = viewportWidth - size;
      }

      this.$square.style.width = size + 'px';
      this.$square.style.height = size + 'px';

      this.$float.style.width = floatWidth + 'px';
      this.$float.style.height = floatHeight + 'px';
    }
  }]);
  return SquaredView;
}(_View3.default);

exports.default = SquaredView;

},{"../views/View":302,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],276:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _wavesAudio = require('waves-audio');

var _wavesLoaders = require('waves-loaders');

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * API of a compliant view for the `audio-buffer-manager` service.
 *
 * @memberof module:soundworks/client
 * @interface AbstractAudioBufferManagerView
 * @extends module:soundworks/client.AbstractView
 * @abstract
 */
/**
 * Update the progress bar of the view with the given ratio.
 *
 * @name setProgressRatio
 * @memberof module:soundworks/client.AbstractAudioBufferManagerView
 * @function
 * @abstract
 * @instance
 *
 * @param {Number} ratio - Progress ratio of the loaded assets (between 0 and 1).
 */

var SERVICE_ID = 'service:audio-buffer-manager';
var log = (0, _debug2.default)('soundworks:services:audio-buffer-manager');

function flattenLists(a) {
  var ret = [];
  var fun = function fun(val) {
    return Array.isArray(val) ? val.forEach(fun) : ret.push(val);
  };
  fun(a);
  return ret;
}

function clonePathObj(value) {
  if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {
    var className = value.constructor.name;
    var clone = null;

    if (className === 'Object') clone = {};else if (className === 'Array') clone = [];else return value;

    for (var key in value) {
      clone[key] = clonePathObj(value[key]);
    }return clone;
  }

  return value;
}

// const regexp = /\.[a-zA-Z0-9]{3,4}$/;

// supported media formats + json
// https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats
var regexp = /\.(wav|mp3|mp4|aac|aif|aiff|ogg|webm|json)$/i;

function isFilePath(str) {
  return typeof str === 'string' && regexp.test(str);
}

function isDirSpec(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object' && typeof obj.path === 'string';
}

function decomposePathObj(obj, pathList, refList) {
  var dirs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var key in obj) {
    var value = obj[key];

    if (!dirs && isFilePath(value) || dirs && isDirSpec(value)) {
      var ref = { obj: obj, key: key };
      var index = -1;

      if (!dirs) index = pathList.indexOf(value);

      if (index === -1) {
        var length = pathList.push(value);

        index = length - 1;
        refList[index] = [];
      }

      refList[index].push(ref);

      obj[key] = null;
    } else if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {
      decomposePathObj(value, pathList, refList, dirs);
    }
  }
}

function populateRefList(refList, loadedObjList) {
  var length = refList.length;

  if (length !== loadedObjList.length) {
    throw new Error('[' + SERVICE_ID + '] Loaded Buffers do not match file definion');
  }

  for (var i = 0; i < length; i++) {
    var refs = refList[i];

    for (var j = 0, l = refs.length; j < l; j++) {
      var ref = refs[j];
      var obj = ref.obj;
      var key = ref.key;

      obj[key] = loadedObjList[i];
    }
  }
}

function createObjFromPathList(pathList, commonPath) {
  var obj = [];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(pathList), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var path = _step.value;

      var subPathIndex = path.indexOf(commonPath);

      if (subPathIndex >= 0) {
        subPathIndex += commonPath.length;

        if (path[subPathIndex] === '/') subPathIndex++;

        var subPath = path.substring(subPathIndex);
        var nodes = subPath.split('/');
        var depth = nodes.length;
        var ref = obj;
        var i = void 0;

        for (i = 0; i < depth - 1; i++) {
          var key = nodes[i];

          if (ref[key] === undefined) ref[key] = [];

          ref = ref[key];
        }

        ref.push(path);
      }

      // transform empty array to object
      if (obj.length === 0) obj = (0, _assign2.default)({}, obj);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return obj;
}

function prefixPaths(pathList, prefix) {
  // test absolute urls (or protocol relative)
  var isAbsolute = /^https?:\/\/|^\/\//i;

  pathList = pathList.map(function (path) {
    if (isAbsolute.test(path) || prefix === '/') return path;else return prefix + path;
  });

  return pathList;
}

/**
 * Interface for the client `'audio-buffer-manager'` service.
 *
 * This service allows to preload files and store them into buffers
 * before the beginning of the experience. Audio files will be converted and
 * stored into AudioBuffer objects.
 *
 * @param {Object} options
 * @param {Array<String>} options.assetsDomain - Prefix concatenated to all
 *  given paths.
 * @param {Object} options.files - Definition of files to load.
 * @param {Object} options.directories - Definition of directories to load.
 * @param {Array<String>} options.directories - List of directories to load.
 * @param {String|module:soundworks/client.FileSystem~ListConfig} [options.directories=null] -
 *  Load all the files in particular directories. If setted this option relies
 *  on the {@link module:soundworks/client.FileSystem} which itself relies on
 *  its server counterpart, the audio-buffer-manager can then no longer be
 *  considered as a client-only service.
 *
 * @memberof module:soundworks/client
 * @example
 * // require and configure the `audio-buffer-manager` inside the experience
 * // constructor
 * // Defining a single array of audio files results in a single
 * // array of audio buffers associated to the identifier `default`.
 *
 * // There are two different ways to specify the files to be loaded and the
 * // data structure in which the loaded data objects are arranged:
 * //
 * // (1.) With the 'files' option, the files and structure are defined by an
 * // object of any depth that contains file paths. All specified files are
 * // loaded and the loaded data objects are stored into an object of the same
 * // structure as the definition object.
 *
 * this.audioBufferManager = this.require('audio-buffer-manager', { files: [
 *   'sounds/drums/kick.mp3',
 *   'sounds/drums/snare.mp3'
 * ]});
 *
 * this.audioBufferManager = this.require('audio-buffer-manager', { files: {
 *   kick: 'sounds/kick_44kHz.mp3',
 *   snare: 'sounds/808snare.mp3'
 * }});
 *
 * this.audioBufferManager = this.require('audio-buffer-manager', { files: {
 *   latin: {
 *     audio: 'loops/sheila-e-raspberry.mp3',
 *     markers: 'loops/sheila-e-raspberry-markers.json',
 *   },
 *   jazz: {
 *     audio: 'loops/nussbaum-shuffle.mp3',
 *     markers: 'loops/nussbaum-shuffle-markers.json',
 *   },
 * }});
 *
 * this.audioBufferManager = this.require('audio-buffer-manager', { files: {
 *   instruments: [
 *     'sounds/instruments/kick_44kHz.mp3',
 *     'sounds/instruments/808snare.mp3'],
 *   loops: [
 *     'sounds/loops/sheila-e-raspberry.mp3',
 *     'sounds/loops/nussbaum-shuffle.mp3'],
 * }});
 *
 * //(2.) The 'directories' option can be used to load the files of a
 * // given directory. Each directory is specified by an object that has a
 * // property 'path' with the directory path and optionally the keys
 * // 'recursive' (specifying whether the directory's sub-directories are
 * // considered) and a key 'match' (specifying a regexp to select the files
 * // in the given directory).
 *
 * // With the option 'recursive' set to false, all (matching) files
 * // in a given directoriy are loaded into an arrays of objects without
 * // considering sub-directories. The arrays of loaded data objects are
 * // arranged in the same data structure as the definition object.
 *
 * this.audioBufferManager = this.require('audio-buffer-manager', {
 *   directories: {
 *     instruments: { path: 'sounds/instruments', recursive: false },
 *     loops: { path: 'sounds/instruments', recursive: false },
 *   },
 * });
 *
 * // When 'recursive' is set to true, all (matching) files in the given
 * // directories and their sub-directories are loaded as arrays of objects.
 * // With the option 'flatten' set to true, all files in the defined directory
 * // and its sub-directories are loaded into a single array. When the option
 * // 'flatten' set to false, the files of each sub-directory are assembled
 * // into an array and all of these arrays are arranged to a data structure
 * // that reproduces the sub-directory tree of the defined directories.
 * // The resulting data structure corresponds to the structure of the
 * // definition object extended by the defined sub-directory trees.
 *
 * // The following option results in a single array of pre-loaded files:
 * this.audioBufferManager = this.require('audio-buffer-manager', {
 *   directories: {
 *     path: 'sounds',
 *     recursive: true,
 *     flatten: true,
 *     match: /\.mp3/,
 *   },
 * });
 *
 * // This variant results in a data structure that reproduces the
 * // sub-directory tree of the 'sounds' directory:
 * this.audioBufferManager = this.require('audio-buffer-manager', {
 *   directories: {
 *     path: 'sounds',
 *     recursive: true,
 *     match: /\.mp3/,
 *   },
 * });
 *
 * // The loaded objects can be retrieved according to their definition, as for example :
 * const kickBuffer = this.audioBufferManager.data.kick;
 * const audioBuffer = this.audioBufferManager.data.latin.audio;
 * const markerArray = this.audioBufferManager.data.jazz.markers;
 * const snareBuffer = this.audioBufferManager.data.instruments[1];
 * const nussbaumLoop = this.audioBufferManager.data.loops[1];
 */

var AudioBufferManager = function (_Service) {
  (0, _inherits3.default)(AudioBufferManager, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function AudioBufferManager() {
    (0, _classCallCheck3.default)(this, AudioBufferManager);

    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioBufferManager.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferManager)).call(this, SERVICE_ID, false));

    var defaults = {
      assetsDomain: '',
      files: null,
      directories: null,
      audioWrapTail: 0,
      viewPriority: 4,
      debug: false // if set to true, the service never "ready" to debug the view
    };

    _this.view = null;

    /**
     * Data structure correponding to the structure of requested files.
     * @private
     */
    _this.data = [];

    _this.configure(defaults);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(AudioBufferManager, [{
    key: 'configure',
    value: function configure(options) {
      (0, _get3.default)(AudioBufferManager.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferManager.prototype), 'configure', this).call(this, options);

      var directories = this.options.directories;

      if (directories !== null) this._fileSystem = this.require('file-system');
    }

    /** @private */

  }, {
    key: 'start',
    value: function start() {
      (0, _get3.default)(AudioBufferManager.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferManager.prototype), 'start', this).call(this);

      this.show();

      if (this.options.files || this.options.directories) {
        if (this.options.files) this.loadFiles(this.options.files, this.view);

        if (this.options.directories) this.loadDirectories(this.options.directories, this.view);
      } else {
        this.ready();
      }
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      this.hide();
      (0, _get3.default)(AudioBufferManager.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferManager.prototype), 'stop', this).call(this);
    }
  }, {
    key: 'ready',
    value: function ready() {
      if (this.options.debug === false) (0, _get3.default)(AudioBufferManager.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferManager.prototype), 'ready', this).call(this);
    }

    /**
     * Load files defined as a set of file paths.
     * @param {Object} defObj - Definition of files to load
     * @returns {Promise} - Promise resolved with the resulting data structure
     */

  }, {
    key: 'loadFiles',
    value: function loadFiles(defObj) {
      var _this2 = this;

      var view = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var promise = new _promise2.default(function (resolve, reject) {
        var pathList = [];
        var refList = [];

        if (typeof defObj === 'string') defObj = [defObj];

        // create data object copying the strcuture of the file definion object
        var dataObj = clonePathObj(defObj);
        decomposePathObj(dataObj, pathList, refList, false);

        // prefix relative paths with assetsDomain
        pathList = prefixPaths(pathList, _this2.options.assetsDomain);

        log(pathList, refList);

        // load files
        if (pathList.length > 0) {
          var loader = new _wavesLoaders.SuperLoader();
          loader.setAudioContext(_wavesAudio.audioContext);

          if (view && view.setProgressRatio) {
            var progressPerFile = pathList.map(function () {
              return 0;
            }); // track files loading progress

            loader.progressCallback = function (e) {
              progressPerFile[e.index] = e.value;

              var totalProgress = 0;

              for (var i = 0; i < progressPerFile.length; i++) {
                totalProgress += progressPerFile[i];
              }totalProgress /= progressPerFile.length;

              view.setProgressRatio(totalProgress);
            };
          }

          loader.load(pathList, {
            wrapAroundExtention: _this2.options.audioWrapTail
          }).then(function (loadedObjList) {
            // place loaded objects (i.e. audio buffers and json files) into the structure of the file definition object
            populateRefList(refList, loadedObjList);

            // mix loaded objects into data
            (0, _assign2.default)(_this2.data, dataObj);
            _this2.ready();
            resolve(dataObj);
          }).catch(function (error) {
            reject(error);
            console.error(error);
          });
        } else {
          _this2.ready();
          resolve([]);
        }
      });

      return promise;
    }

    /**
     * Load files defined as a set of directory paths.
     * @param {Object} defObj - Definition of files to load
     * @returns {Promise} - Promise resolved with the resulting data structure
     */

  }, {
    key: 'loadDirectories',
    value: function loadDirectories(defObj) {
      var _this3 = this;

      var view = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var promise = new _promise2.default(function (resolve, reject) {
        var dirDefList = [];
        var dirRefList = [];

        // for the case that just a directory object is given as definition,
        // we have to wrap it temporarily into a dummy object
        defObj = { def: defObj };

        var fileDefObj = clonePathObj(defObj); // clone definition object

        // decompose directory definition into list of directory paths (strings)
        decomposePathObj(fileDefObj, dirDefList, dirRefList, true);

        _this3._fileSystem.getList(dirDefList).then(function (filePathListList) {
          var subDirList = [];
          var length = filePathListList.length;

          // create sub directory file definitions (list of file paths structured into sub directory trees derived from file paths)
          if (length === dirDefList.length) {
            for (var i = 0; i < length; i++) {
              var dirPath = dirDefList[i].path;
              var flatten = !!dirDefList[i].flatten;
              var pathList = filePathListList[i];
              var subDir = pathList;

              if (!flatten) subDir = createObjFromPathList(pathList, dirPath);

              subDirList.push(subDir);
            }

            // replace directory paths in initial definition by sub directory file definitions
            // to create a complete file definition object
            populateRefList(dirRefList, subDirList);
          } else {
            throw new Error('[' + SERVICE_ID + '] Cannot retrieve file paths from defined directories');
          }

          // unwrap subDir from dummy object
          fileDefObj = fileDefObj.def;

          // load files
          _this3.loadFiles(fileDefObj, view).then(function (data) {
            _this3.ready();
            resolve(data);
          }).catch(function (error) {
            return reject(error);
          });
        }).catch(function (error) {
          return reject(error);
        });
      });

      return promise;
    }

    /**
     * wrapAround, copy the begining input buffer to the end of an output buffer
     * @private
     * @param {arraybuffer} inBuffer {arraybuffer} - The input buffer
     * @returns {arraybuffer} - The processed buffer (with frame copied from the begining to the end)
     */

  }, {
    key: '_wrapAround',
    value: function _wrapAround(inBuffer) {
      var inLength = inBuffer.length;
      var outLength = inLength + this.options.wrapAroundExtension * inBuffer.sampleRate;
      var outBuffer = _wavesAudio.audioContext.createBuffer(inBuffer.numberOfChannels, outLength, inBuffer.sampleRate);
      var arrayChData = void 0,
          arrayOutChData = void 0;

      for (var ch = 0; ch < inBuffer.numberOfChannels; ch++) {
        arrayChData = inBuffer.getChannelData(ch);
        arrayOutChData = outBuffer.getChannelData(ch);

        for (var i = 0; i < inLength; i++) {
          arrayOutChData[i] = arrayChData[i];
        }for (var _i = inLength; _i < outLength; _i++) {
          arrayOutChData[_i] = arrayChData[_i - inLength];
        }
      }

      return outBuffer;
    }

    /** deprecated */

  }, {
    key: 'load',
    value: function load(files) {
      var view = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return this.loadFiles(files, view);
    }

    /**
     * Retrieve a loaded object.
     * @param {String} id - Object or group identifier.
     * @param {String} key - Member key in group.
     * @returns {Promise} - Returns the loaded object.
     */

  }, {
    key: 'get',
    value: function get(id) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var obj = this.data[id];

      if (obj && key !== null) return obj[key];

      return obj;
    }
  }]);
  return AudioBufferManager;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, AudioBufferManager);

exports.default = AudioBufferManager;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/promise":27,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"babel-runtime/helpers/typeof":41,"debug":304,"waves-audio":322,"waves-loaders":329}],277:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _wavesAudio = require('waves-audio');

var audio = _interopRequireWildcard(_wavesAudio);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:audio-scheduler';

/**
 * Interface for the client `'audio-scheduler'` service.
 *
 * The `audio-scheduler` provides an access to the basic audio scheduler using the
 * scheduler provided by the [`wavesjs`]{@link https://github.com/wavesjs/audio}
 * library.
 *
 * @param {Object} options
 * @param {Number} [options.period] - Period of the scheduler (defauts to
 *  current value).
 * @param {Number} [options.lookahead] - Lookahead of the scheduler (defauts
 *  to current value).
 *
 * @memberof module:soundworks/client
 * @see [`wavesAudio.Scheduler`]{@link http://wavesjs.github.io/audio/#audio-scheduler}
 * @see [`platform` service]{@link module:soundworks/client.Platform}
 *
 * @example
 * // inside the experience constructor
 * this.audioScheduler = this.require('audio-scheduler');
 *
 * // when the experience has started
 * const nextTime = this.audioScheduler.currentTime + 2;
 * this.audioScheduler.add(timeEngine, nextTime);
 */

var AudioScheduler = function (_Service) {
  (0, _inherits3.default)(AudioScheduler, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function AudioScheduler() {
    (0, _classCallCheck3.default)(this, AudioScheduler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioScheduler.__proto__ || (0, _getPrototypeOf2.default)(AudioScheduler)).call(this, SERVICE_ID, false));

    _this._platform = _this.require('platform', { features: 'web-audio' });

    // initialize sync option
    _this._sync = null;
    _this._syncedQueue = null;

    // get audio time based scheduler
    _this._scheduler = audio.getScheduler();

    var defaults = {
      lookahead: _this._scheduler.lookahead,
      period: _this._scheduler.period
    };

    // call super.configure (activate sync option only if required)
    (0, _get3.default)(AudioScheduler.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioScheduler.prototype), 'configure', _this).call(_this, defaults);
    return _this;
  }

  /**
   * Override default `configure` to configure the scheduler.
   *
   * @param {Object} options - The options to apply to the service.
   * @private
   */


  (0, _createClass3.default)(AudioScheduler, [{
    key: 'configure',
    value: function configure(options) {
      // check and set scheduler period option
      if (options.period !== undefined) {
        if (options.period > 0.010) this._scheduler.period = options.period;else throw new Error('Invalid scheduler period: ' + options.period);
      }

      // check and set scheduler lookahead option
      if (options.lookahead !== undefined) {
        if (options.lookahead > 0.010) this._scheduler.lookahead = options.lookahead;else throw new Error('Invalid scheduler lookahead: ' + options.lookahead);
      }

      (0, _get3.default)(AudioScheduler.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioScheduler.prototype), 'configure', this).call(this, options);
    }

    /** @private */

  }, {
    key: 'start',
    value: function start() {
      (0, _get3.default)(AudioScheduler.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioScheduler.prototype), 'start', this).call(this);
      this.ready();
    }

    /**
     * Current audio time of the scheduler.
     * @type {Number}
     * @instance
     */

  }, {
    key: 'defer',


    /**
     * Call a function at a given time.
     *
     * @param {Function} fun - Function to be deferred.
     * @param {Number} time - The time at which the function should be executed.
     * @param {Boolean} [lookahead=false] - Defines whether the function is called
     *  anticipated (e.g. for audio events) or precisely at the given time (default).
     */
    value: function defer(fun, time) {
      var lookahead = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var scheduler = this._scheduler;
      var schedulerService = this;
      var engine = void 0;

      if (lookahead) {
        scheduler.defer(fun, time);
      } else {
        engine = {
          advanceTime: function advanceTime(time) {
            var delta = schedulerService.deltaTime;

            if (delta > 0) setTimeout(fun, 1000 * delta, time); // bridge scheduler lookahead with timeout
            else fun(time);
          }
        };

        scheduler.add(engine, time); // add without checks
      }
    }

    /**
     * Add a time engine to the queue.
     *
     * @param {Function} engine - Engine to schedule.
     * @param {Number} time - The time at which the function should be executed.
     */

  }, {
    key: 'add',
    value: function add(engine, time) {
      this._scheduler.add(engine, time);
    }

    /**
     * Remove the given engine from the queue.
     *
     * @param {Function} engine - Engine to remove from the scheduler.
     */

  }, {
    key: 'remove',
    value: function remove(engine) {
      this._scheduler.remove(engine);
    }

    /**
     * Remove all scheduled functions and time engines (synchronized or not) from
     * the scheduler.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this._scheduler.clear();
    }
  }, {
    key: 'audioTime',
    get: function get() {
      return this._scheduler.currentTime;
    }

    /**
     * Current audio time of the scheduler (alias `this.audioTime`).
     * @type {Number}
     * @instance
     */

  }, {
    key: 'currentTime',
    get: function get() {
      return this._scheduler.currentTime;
    }

    /**
     * Difference between the scheduler's logical audio time and the `currentTime`
     * of the audio context.
     * @type {Number}
     * @instance
     */

  }, {
    key: 'deltaTime',
    get: function get() {
      return this._scheduler.currentTime - audio.audioContext.currentTime;
    }
  }]);
  return AudioScheduler;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, AudioScheduler);

exports.default = AudioScheduler;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"waves-audio":322}],278:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _wavesAudio = require('waves-audio');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:audio-stream-manager';
var log = (0, _debug2.default)('soundworks:services:audio-stream-manager');

// TODO:
// - support streaming of files of total duration shorter than packet duration

function loadAudioBuffer(url) {
  var promise = new _promise2.default(function (resolve, reject) {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';

    request.onload = function () {
      var response = request.response;
      _wavesAudio.audioContext.decodeAudioData(response, resolve, reject);
    };

    request.send();
  });

  return promise;
}

/**
 * Interface for the client `'audio-stream-manager'` service.
 *
 * This service allows to stream audio buffers to the client during the experience
 * (not preloaded). Input audio files are segmented by the server upon startup
 * and sent to the clients upon request. Service only accepts .wav files at the
 * moment. The service main objective is to 1) enable synced streaming between
 * clients (not precise if based on mediaElementSources), and 2) provide an
 * equivalent to the mediaElementSource object (streaming as a Web Audio API
 * node) that could be plugged to any other node in Safari (bypassing e.g. gain
 * or analyzer nodes when plugged to mediaElementSource).
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.AudioStreamManager}*__
 *
 * @param {Object} options
 * @param {Number} options.monitorInterval - Interval time (in sec) at which the
 *  client will check if it has enough preloaded audio data to ensure streaming
 *  or if it needs to require some more.
 * @param {Number} options.requiredAdvanceThreshold - Threshold time (in sec) of
 *  preloaded audio data below which the client will require a new audio chunk.
 *
 * @memberof module:soundworks/client
 * @example
 * // require the `audio-stream-manager` (in experience constructor)
 * this.audioStreamManager = this.require('audio-stream-manager', {
 *   monitorInterval: 1,
 *   requiredAdvanceThreshold: 10
 * });
 *
 * // request new audio stream from the stream manager (in experience start method)
 * const audioStream = this.audioStreamManager.getAudioStream();
 * // setup and start audio stream
 * audioStream.url = 'my-audio-file-name'; // without extension
 * // connect as you would any audio node from the web audio api
 * audioStream.connect(audioContext.destination);
 * audioStream.loop = false; // disable loop
 * audioStream.sync = false; // disable synchronization
 * // mimics AudioBufferSourceNode onended method
 * audioStream.onended = function(){ console.log('stream ended'); };
 * audioStream.start(); // start audio stream
 */

var AudioStreamManager = function (_Service) {
  (0, _inherits3.default)(AudioStreamManager, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instantiated manually_ */
  function AudioStreamManager() {
    (0, _classCallCheck3.default)(this, AudioStreamManager);

    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioStreamManager.__proto__ || (0, _getPrototypeOf2.default)(AudioStreamManager)).call(this, SERVICE_ID, false));

    _this.bufferInfos = new _map2.default();
    // define general offset in sync loop (in sec) (not propagated to
    // already created audio streams when modified)
    _this.syncStartTime = 0;

    // configure options
    var defaults = {
      monitorInterval: 1, // in seconds
      requiredAdvanceThreshold: 10, // in seconds
      assetsDomain: ''
    };

    _this.configure(defaults);

    _this.syncService = _this.require('sync');

    _this._onAcknowledgeResponse = _this._onAcknowledgeResponse.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(AudioStreamManager, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      (0, _get3.default)(AudioStreamManager.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioStreamManager.prototype), 'start', this).call(this);
      // send request for infos on "streamable" audio files
      this.receive('acknowlegde', this._onAcknowledgeResponse);
      this.receive('syncStartTime', function (value) {
        return _this2.syncStartTime = value;
      });
      this.send('request');

      // @todo - should receive a sync start time from server
    }

    /**
     * @private
     * @param {Object} bufferInfos - info on audio files that can be streamed
     */

  }, {
    key: '_onAcknowledgeResponse',
    value: function _onAcknowledgeResponse(bufferInfos) {
      var _this3 = this;

      bufferInfos.forEach(function (item) {
        // @todo - this has to be reviewed, not robust
        var chunkPath = item[0].name;
        var dirname = _path2.default.dirname(chunkPath);
        var parts = dirname.split('/');
        var bufferId = parts.pop();

        item.forEach(function (chunk) {
          chunk.url = chunk.name.replace('public/', _this3.options.assetsDomain);
        });

        _this3.bufferInfos.set(bufferId, item);
      });

      this.ready();
    }

    /**
     * Return a new audio stream node.
     */

  }, {
    key: 'getAudioStream',
    value: function getAudioStream() {
      // console.log(this.syncStartTime, this.syncService.getSyncTime());
      return new AudioStream(this.bufferInfos, this.syncService, this.options.monitorInterval, this.options.requiredAdvanceThreshold, this.syncStartTime);
    }
  }]);
  return AudioStreamManager;
}(_Service3.default);

/**
 * An audio stream node, behaving as would a mediaElementSource node.
 *
 * @param {Object} bufferInfos - Map of streamable buffer chunks infos.
 * @param {Object} syncService - Soundworks sync service, used for sync mode.
 * @param {Number} monitorInterval - See AudioStreamManager's.
 * @param {Number} requiredAdvanceThreshold - See AudioStreamManager's.
 *
 * @memberof module:soundworks/client.AudioStreamManager
 */


var AudioStream = function () {
  /** _<span class="warning">__WARNING__</span> This class should never be instantiated manually_ */
  function AudioStream(bufferInfos, syncService, monitorInterval, requiredAdvanceThreshold, syncStartTime) {
    (0, _classCallCheck3.default)(this, AudioStream);

    // arguments
    this.bufferInfos = bufferInfos;
    this.syncService = syncService;
    this.monitorInterval = monitorInterval * 1000; // in ms
    this.requiredAdvanceThreshold = requiredAdvanceThreshold;
    this.syncStartTime = syncStartTime;

    // local attr.
    this._sync = false;
    this._loop = false;
    this._periodic = false;
    this._metaData = undefined;
    this._url = null;

    this.output = _wavesAudio.audioContext.createGain();

    // stream monitoring
    this._intervalId = undefined;
    this._queueEndTime = 0;
    this._srcMap = new _map2.default();
    this._stopRequired = false;

    this._reset();

    this._requestChunks = this._requestChunks.bind(this);
    this._onended = this._onended.bind(this);
  }

  /**
   * Init / reset local attributes (at stream creation and stop() ).
   * @private
   */


  (0, _createClass3.default)(AudioStream, [{
    key: '_reset',
    value: function _reset() {
      this._firstChunkNetworkLatencyOffset = undefined;
      this._currentChunkIndex = -1;
      this._firstPacketState = 0;
    }

    /**
     * Define url of audio file to stream, send meta data request to server concerning this file.
     *
     * @param {String} url - Requested file name, without extension
     */

  }, {
    key: 'connect',


    /**
     * Connect the stream to an audio node.
     *
     * @param {AudioNode} node - Audio node to connect to.
     */
    value: function connect(node) {
      this.output.connect(node);
    }

    /**
     * Method called when stream finished playing on its own (won't fire if loop
     * enabled).
     */

  }, {
    key: 'onended',
    value: function onended() {}

    /**
     * Method called when stream drops a packet (arrived too late).
     */

  }, {
    key: 'ondrop',
    value: function ondrop() {
      console.warn('audiostream: too long loading, discarding buffer');
    }

    /**
     * Method called when stream received a packet late, but not too much to drop
     * it (gap in audio).
     * @param {Number} time - delay time.
     */

  }, {
    key: 'onlate',
    value: function onlate(time) {}

    /**
     * Start streaming audio source.
     * @warning - offset doesn't seem to make sens when not loop and not periodic
     *
     * @param {Number} offset - time in buffer from which to start (in sec)
     */

  }, {
    key: 'start',
    value: function start() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.isPlaying) {
        console.warn('[WARNING] - start() discarded, must stop first');
        return;
      }

      // check if we dispose of valid url to execute start
      if (this._url === null) {
        console.warn('[WARNING] - start() discarded, must define valid url first');
        return;
      }

      // we consider the stream started now
      this.isPlaying = true;

      var bufferInfo = this.bufferInfos.get(this._url);
      var duration = this.duration;

      if (this.sync) {
        var syncTime = this.syncService.getSyncTime();
        var startTime = this.syncStartTime;
        offset = syncTime - startTime + offset;
      }

      if (this.loop) offset = offset % duration;

      // this looks coherent for all combinations of `loop` and `sync`
      // console.log('offset', offset);
      // console.log('duration', duration);

      if (offset >= duration) {
        console.warn('[WARNING] - start() discarded, requested offset\n        (' + offset + ' sec) larger than file duration (' + duration + ' sec)');
        return;
      }

      // find index of the chunk corresponding to given offset
      var index = 0;
      var offsetInFirstChunk = 0;
      // console.log(bufferInfo, index, bufferInfo[index]);

      while (this._currentChunkIndex === -1 && index < bufferInfo.length) {
        var chunkInfos = bufferInfo[index];
        var start = chunkInfos.start;
        var end = start + chunkInfos.duration;

        if (offset >= start && offset < end) {
          this._currentChunkIndex = index;
          offsetInFirstChunk = offset - start;
        }

        index += 1;
      }

      // handle negative offset, pick first chunk. This can be usefull to start
      // synced stream while give them some delay to preload the first chunk
      if (this._currentChunkIndex === -1 && offset < 0) this._currentChunkIndex = 0;

      // console.log('AudioStream.start()', this._url, this._currentChunkIndex);
      this._stopRequired = false;
      this._queueEndTime = this.syncService.getSyncTime() - offsetInFirstChunk;

      // @important - never change the order of these 2 calls
      this._intervalId = setInterval(this._requestChunks, this.monitorInterval);
      this._requestChunks();
    }
  }, {
    key: '_onended',
    value: function _onended() {
      this.isPlaying = false;
      this.onended();
    }

    /**
     * Stop the audio stream. Mimics AudioBufferSourceNode stop() method. A stopped
     * audio stream can be started (no need to create a new one as required when
     * using an AudioBufferSourceNode).
     *
     * @param {Number} offset - offset time (in sec) from now at which
     *  the audio stream should stop playing.
     */

  }, {
    key: 'stop',
    value: function stop() {
      var _this4 = this;

      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (!this.isPlaying) {
        console.warn('[WARNING] - stop discarded, not started or already ended');
        return;
      }

      if (this._intervalId !== undefined) this._clearRequestChunks();

      this._stopRequired = true; // avoid playing buffer that are currently loading
      this._reset();

      var now = this.syncService.getSyncTime();
      var audioTime = _wavesAudio.audioContext.currentTime;
      var size = this._srcMap.size;
      var counter = 0;

      this._srcMap.forEach(function (src, startTime) {
        counter += 1;
        src.onended = null;

        // pick a source arbitrarily to trigger the `onended` event properly
        if (counter === size) src.onended = _this4._onended;

        if (startTime < now + offset || src.onended !== null) src.stop(audioTime + offset);else src.stop(audioTime);
      });

      this._srcMap.clear();
    }

    /**
     * Check if we have enough "local buffer time" for the audio stream,
     * request new buffer chunks otherwise.
     * @private
     */

  }, {
    key: '_requestChunks',
    value: function _requestChunks() {
      var _this5 = this;

      var bufferInfo = this.bufferInfos.get(this._url);
      var now = this.syncService.getSyncTime();

      // have to deal properly with

      var _loop = function _loop() {
        // in non sync mode, we want the start time to be delayed when the first
        // buffer is actually received, so we load it before requesting next ones
        if (_this5._firstPacketState === 1 && !_this5._sync) return {
            v: void 0
          };

        var chunkInfos = bufferInfo[_this5._currentChunkIndex];
        var chunkStartTime = _this5._queueEndTime - chunkInfos.overlapStart;
        var url = chunkInfos.url;

        // flag that first packet has been required and that we must await for its
        // arrival in unsync mode before asking for more, as the network delay
        // will define the `true` start time
        if (_this5._firstPacketState === 0 && !_this5._sync) _this5._firstPacketState = 1;

        // console.log('currentChunkIndex', this._currentChunkIndex);
        // console.log('timeAtQueueEnd', this._queueEndTime);
        // console.log('chunkStartTime', chunkStartTime);

        var currentChunkIndex = _this5._currentChunkIndex;

        _this5._currentChunkIndex += 1;
        _this5._queueEndTime += chunkInfos.duration;

        var isLastChunk = false;

        if (_this5._currentChunkIndex === bufferInfo.length) {
          if (_this5._loop) {
            _this5._currentChunkIndex = 0;
          } else {
            // has this method is called once outside the loop, it might append
            // that we finish the whole loading without actually having an
            // intervalId, maybe handle this more properly with reccursive
            // `setTimeout`s
            if (_this5._intervalId) _this5._clearRequestChunks();
            // but reset later as the last chunk still needs the current offsets
            isLastChunk = true;
          }
        }

        // load and add buffer to queue
        loadAudioBuffer(url).then(function (buffer) {
          if (_this5._stopRequired) return;

          // mark that first packet arrived and that we can ask for more
          if (_this5._firstPacketState === 1 && !_this5._sync) _this5._firstPacketState = 2;

          var overlapStart = chunkInfos.overlapStart,
              overlapEnd = chunkInfos.overlapEnd;

          _this5._addBufferToQueue(buffer, chunkStartTime, overlapStart, overlapEnd, isLastChunk);

          if (isLastChunk) _this5._reset();
        });

        if (isLastChunk) return 'break';
      };

      _loop2: while (this._queueEndTime - now <= this.requiredAdvanceThreshold) {
        var _ret = _loop();

        switch (_ret) {
          case 'break':
            break _loop2;

          default:
            if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
        }
      }
    }

    /**
     * Stop looking for new chunks
     * @private
     */

  }, {
    key: '_clearRequestChunks',
    value: function _clearRequestChunks() {
      // console.log(`AudioStream._clearRequestChunks() ${this._url} - clearInterval`, this._intervalId);
      clearInterval(this._intervalId);
      this._intervalId = undefined;
    }

    /**
     * Add audio buffer to stream queue.
     *
     * @param {AudioBuffer} buffer - Audio buffer to add to playing queue.
     * @param {Number} startTime - Time at which audio buffer playing is due.
     * @param {Number} overlapStart - Duration (in sec) of the additional audio
     *  content added by the node-audio-slicer (on server side) at audio buffer's
     *  head (used in fade-in mechanism to avoid perceiving potential .mp3
     *  encoding artifacts introduced when buffer starts with non-zero value)
     * @param {Number} overlapEnd - Duration (in sec) of the additional audio
     *  content added at audio buffer's tail.
     * @private
     */

  }, {
    key: '_addBufferToQueue',
    value: function _addBufferToQueue(buffer, startTime, overlapStart, overlapEnd, isLastChunk) {
      var _this6 = this;

      // hard-code overlap fade-in and out in buffer
      var numSamplesFadeIn = Math.floor(overlapStart * buffer.sampleRate);
      var numSamplesFadeOut = Math.floor(overlapEnd * buffer.sampleRate);
      // loop over audio channels
      for (var channel = 0; channel < buffer.numberOfChannels; channel++) {
        var channelData = buffer.getChannelData(channel);

        // fade in
        for (var i = 0; i < numSamplesFadeIn; i++) {
          var gain = i / (numSamplesFadeIn - 1);
          channelData[i] = channelData[i] * gain;
        }

        // fade out
        for (var _i = channelData.length - numSamplesFadeOut; _i < channelData.length; _i++) {
          var _gain = (channelData.length - _i - 1) / (numSamplesFadeOut - 1);
          channelData[_i] = channelData[_i] * _gain;
        }
      }

      var syncTime = this.syncService.getSyncTime();
      var now = _wavesAudio.audioContext.currentTime;
      var offset = startTime - syncTime;

      // - in `non sync` scenario, we want to take in account the latency induced
      // by the loading of the first chunk. This latency must then be applied
      // to all subsequent chunks.
      // - in `sync` scenarios, we just let the logical start time and computed
      // offset do their job...
      // - in `periodic` scenarios we don't want to compensate for the loading time
      if (!this._sync && !this._periodic) {
        //
        if (this._firstChunkNetworkLatencyOffset === undefined) {
          this._firstChunkNetworkLatencyOffset = offset;
        }

        offset -= this._firstChunkNetworkLatencyOffset;
      }

      // if computed offset is smaller than duration
      if (-offset <= buffer.duration) {
        // create audio source
        var src = _wavesAudio.audioContext.createBufferSource();
        src.connect(this.output);
        src.buffer = buffer;

        if (offset < 0) {
          src.start(now, -offset);
          // the callback should be called after start
          this.onlate(-offset);
        } else {
          src.start(now + offset, 0);
        }

        // keep and clean reference to source
        this._srcMap.set(startTime, src);

        src.onended = function () {
          _this6._srcMap.delete(startTime);

          if (isLastChunk) _this6._onended();
        };
      } else {
        this.ondrop();
      }
    }
  }, {
    key: 'url',
    set: function set(filename) {
      if (this.isPlaying) {
        console.warn('[WARNING] - Cannot set url while playing');
        return;
      }

      // check if url corresponds to a streamable file
      if (this.bufferInfos.get(filename)) this._url = filename;else console.error('[ERROR] - ' + filename + ' url not in ' + this.bufferInfos + ' \n ### url discarded');
    },
    get: function get() {
      return this._url;
    }

    /**
     * Set/Get synchronized mode status. in non sync. mode, the stream audio
     * will start whenever the first audio buffer is downloaded. in sync. mode,
     * the stream audio will start (again whan the audio buffer is downloaded)
     * with an offset in the buffer, as if it started playing exactly when the
     * start() command was issued.
     *
     * @param {Bool} val - Enable / disable sync
     */

  }, {
    key: 'sync',
    set: function set(val) {
      if (this.isPlaying) {
        console.warn('[WARNING] - Cannot set sync while playing');
        return;
      }

      this._sync = val;
    },
    get: function get() {
      return this._sync;
    }

    /**
     * Set/Get loop mode. onended() method not called if loop enabled.
     * @param {Bool} val - enable / disable sync
     */

  }, {
    key: 'loop',
    set: function set(val) {
      if (this.isPlaying) {
        console.warn('[WARNING] - Cannot set loop while playing');
        return;
      }

      this._loop = val;
    },
    get: function get() {
      return this._loop;
    }

    /**
     * Set/Get periodic mode. we don't want the stream to be synchronized to
     * a common origin, but have them aligned on a grid. aka, we don't wan't to
     * compensate for the loading time, when starting with an offset.
     * @param {Bool} val - enable / disable periodic
     */

  }, {
    key: 'periodic',
    set: function set(val) {
      if (this.isPlaying) {
        console.warn('[WARNING] - Cannot set loop while playing');
        return;
      }

      this._periodic = val;
    },
    get: function get() {
      return this._periodic;
    }

    /**
     * Return the total duration (in secs) of the audio file currently streamed.
     */

  }, {
    key: 'duration',
    get: function get() {
      var bufferInfo = this.bufferInfos.get(this._url);
      var lastChunk = bufferInfo[bufferInfo.length - 1];
      var duration = lastChunk.start + lastChunk.duration;
      return duration;
    }
  }]);
  return AudioStream;
}();

_serviceManager2.default.register(SERVICE_ID, AudioStreamManager);
exports.default = AudioStreamManager;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/map":19,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/promise":27,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"babel-runtime/helpers/typeof":41,"debug":304,"path":245,"waves-audio":322}],279:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _SegmentedView = require('../views/SegmentedView');

var _SegmentedView2 = _interopRequireDefault(_SegmentedView);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * API of a compliant view for the `auth` service.
 *
 * @memberof module:soundworks/client
 * @interface AbstractAuthView
 * @extends module:soundworks/client.AbstractView
 * @abstract
 */
/**
 * Register the function that should be executed when the password is submitted
 * by the user.
 *
 * @name setSendPasswordCallback
 * @memberof module:soundworks/client.AbstractAuthView
 * @function
 * @abstract
 * @instance
 *
 * @param {sendPasswordCallback} callback - Callback to execute when the user
 *  submit the password
 */
/**
 * Register the function that should be executed when the password is reset
 * by the user.
 *
 * @name setResetPasswordCallback
 * @memberof module:soundworks/client.AbstractAuthView
 * @function
 * @abstract
 * @instance
 *
 * @param {setResetCallback} callback -
 *  Callback to execute when the user reset the password
 */
/**
 * Update the view according to the response to the submitted password.
 *
 * @name updateRejectedStatus
 * @memberof module:soundworks/client.AbstractAuthView
 * @function
 * @abstract
 * @instance
 *
 * @param {Boolean} value - `true` if the submitted password is rejected,
 *  `false` when the password is reset.
 */

/**
 * Callback to execute when the user submit the password.
 *
 * @callback
 * @name sendPasswordCallback
 * @memberof module:soundworks/client.AbstractAuthView
 *
 * @param {String} password - Password given by the user.
 */
/**
 * Callback to execute when the user reset the password.
 *
 * @callback
 * @name resetCallback
 * @memberof module:soundworks/client.AbstractAuthView
 */

var SERVICE_ID = 'service:auth';
var LOCAL_STORAGE_KEY = 'soundworks:' + SERVICE_ID;

/**
 * Interface for the client `auth` service.
 *
 * This service allows to lock the application to specific users by adding a
 * simple logging page to the client.
 *
 * <span class="warning">__WARNING__</span>: This service shouldn't be considered
 * secure from a production prespective.
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.Auth}*__
 *
 * @memberof module:soundworks/client
 * @example
 * this.auth = this.require('auth');
 */

var Auth = function (_Service) {
  (0, _inherits3.default)(Auth, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function Auth() {
    (0, _classCallCheck3.default)(this, Auth);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Auth.__proto__ || (0, _getPrototypeOf2.default)(Auth)).call(this, SERVICE_ID, true));

    var defaults = {
      viewPriority: 100
    };

    _this.configure(defaults);

    _this._password = null;

    _this._onAccesGrantedResponse = _this._onAccesGrantedResponse.bind(_this);
    _this._onAccesRefusedResponse = _this._onAccesRefusedResponse.bind(_this);
    _this._sendPassword = _this._sendPassword.bind(_this);
    _this._resetPassword = _this._resetPassword.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Auth, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(Auth.prototype.__proto__ || (0, _getPrototypeOf2.default)(Auth.prototype), 'start', this).call(this);

      this.view.setSendPasswordCallback(this._sendPassword);
      this.view.setResetCallback(this._resetPassword);

      this.receive('granted', this._onAccesGrantedResponse);
      this.receive('refused', this._onAccesRefusedResponse);

      var storedPassword = localStorage.getItem(LOCAL_STORAGE_KEY);

      if (storedPassword !== null) this._sendPassword(storedPassword);

      this.show();
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(Auth.prototype.__proto__ || (0, _getPrototypeOf2.default)(Auth.prototype), 'stop', this).call(this);

      this.removeListener('granted', this._onAccesGrantedResponse);
      this.removeListener('refused', this._onAccesRefusedResponse);

      this.hide();
    }

    /**
     * Remove the stored password from local storage. This method is aimed at
     * being called from inside an experience / controller. Any UI update
     * resulting from the call of this method should then be handled from the
     * experience.
     */

  }, {
    key: 'logout',
    value: function logout() {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
    }

    /** @private */

  }, {
    key: '_sendPassword',
    value: function _sendPassword(password) {
      this._password = password;
      this.send('password', password);
    }

    /** @private */

  }, {
    key: '_resetPassword',
    value: function _resetPassword() {
      this._password = null;
      localStorage.removeItem(LOCAL_STORAGE_KEY);

      this.view.updateRejectedStatus(false);
    }

    /** @private */

  }, {
    key: '_onAccesGrantedResponse',
    value: function _onAccesGrantedResponse() {
      localStorage.setItem(LOCAL_STORAGE_KEY, this._password);
      this.ready();
    }

    /** @private */

  }, {
    key: '_onAccesRefusedResponse',
    value: function _onAccesRefusedResponse() {
      this.view.updateRejectedStatus(true);
    }
  }]);
  return Auth;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Auth);

exports.default = Auth;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"../views/SegmentedView":300,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],280:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * API of a compliant view for the `checkin` service.
 *
 * @memberof module:soundworks/client
 * @interface AbstractCheckinView
 * @extends module:soundworks/client.AbstractView
 * @abstract
 */
/**
 * Register the function that should be executed when the user is ready to
 * continue.
 *
 * @name setReadyCallback
 * @memberof module:soundworks/client.AbstractCheckinView
 * @function
 * @abstract
 * @instance
 *
 * @param {readyCallback} callback - Callback to execute when the user
 *  is ready to continue.
 */
/**
 * Update the label retrieved by the server.
 *
 * @name updateLabel
 * @memberof module:soundworks/client.AbstractCheckinView
 * @function
 * @abstract
 * @instance
 *
 * @param {String} label - Label to be displayed in the view.
 */
/**
 * Method executed when an error is received from the server (when no place is
 * is available in the experience).
 *
 * @name updateErrorStatus
 * @memberof module:soundworks/client.AbstractCheckinView
 * @function
 * @abstract
 * @instance
 *
 * @param {Boolean} value
 */

/**
 * Callback to execute when the user is ready to continue.
 *
 * @callback
 * @name readyCallback
 * @memberof module:soundworks/client.AbstractCheckinView
 */

var SERVICE_ID = 'service:checkin';

/**
 * Interface for the client `'checkin'` service.
 *
 * This service is one of the provided services aimed at identifying clients inside
 * the experience along with the [`'locator'`]{@link module:soundworks/client.Locator}
 * and [`'placer'`]{@link module:soundworks/client.Placer} services.
 *
 * The `'checkin'` service is the most simple among these services as the server
 * simply assigns a ticket to the client among the available ones. The ticket can
 * optionally be associated with coordinates or labels according to the server
 * `setup` configuration.
 *
 * The service requires the ['platform']{@link module:soundworks/client.Platform}
 * service, as it is considered that an index should be given only to clients who
 * actively entered the application.
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.Checkin}*__
 *
 * @see {@link module:soundworks/client.Locator}
 * @see {@link module:soundworks/client.Placer}
 *
 * @param {Object} options
 * @param {Boolean} [options.showDialog=false] - Define if the service should
 *  display a view informing the client of its position.
 *
 * @memberof module:soundworks/client
 * @example
 * // inside the experience constructor
 * this.checkin = this.require('checkin', { showDialog: true });
 */

var Checkin = function (_Service) {
  (0, _inherits3.default)(Checkin, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function Checkin() {
    (0, _classCallCheck3.default)(this, Checkin);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Checkin.__proto__ || (0, _getPrototypeOf2.default)(Checkin)).call(this, SERVICE_ID, true));

    var defaults = {
      showDialog: false,
      order: 'ascending',
      viewPriority: 6
    };

    _this.configure(defaults);

    _this.require('platform');

    /**
     * Index given by the server.
     * @type {Number}
     */
    _this.index = -1;

    /**
     * Optionnal label given by the server.
     * @type {String}
     */
    _this.label = null;

    /**
     * Optionnal coordinates given by the server.
     * @type {String}
     */
    _this.coordinates = null;

    // bind callbacks to the current instance
    _this._onPositionResponse = _this._onPositionResponse.bind(_this);
    _this._onUnavailableResponse = _this._onUnavailableResponse.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Checkin, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(Checkin.prototype.__proto__ || (0, _getPrototypeOf2.default)(Checkin.prototype), 'start', this).call(this);

      this.setup = this._sharedConfigService;

      // send request to the server
      this.send('request', this.options.order);

      // setup listeners for the server's response
      this.receive('position', this._onPositionResponse);
      this.receive('unavailable', this._onUnavailableResponse);

      this.show();
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(Checkin.prototype.__proto__ || (0, _getPrototypeOf2.default)(Checkin.prototype), 'stop', this).call(this);
      // Remove listeners for the server's response
      this.removeListener('position', this._onPositionResponse);
      this.removeListener('unavailable', this._onUnavailableResponse);

      this.hide();
    }

    /** @private */

  }, {
    key: '_onPositionResponse',
    value: function _onPositionResponse(index, label, coordinates) {
      _client2.default.index = this.index = index;
      _client2.default.label = this.label = label;
      this.coordinates = coordinates;

      if (coordinates !== null && !_client2.default.coordinates) _client2.default.coordinates = coordinates;

      if (this.options.showDialog) {
        var displayLabel = label || (index + 1).toString();
        this.view.updateLabel(displayLabel);
        this.view.setReadyCallback(this.ready.bind(this));
      } else {
        this.ready();
      }
    }

    /** @private */

  }, {
    key: '_onUnavailableResponse',
    value: function _onUnavailableResponse() {
      this.view.updateErrorStatus(true);
    }
  }]);
  return Checkin;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Checkin);

exports.default = Checkin;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],281:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:error-reporter';

/**
 * Interface for the client `'error-reporter'` service.
 *
 * This service allows to log javascript errors that could occur during the
 * application life cycle. Errors are caught and sent to the server in order
 * to be persisted in a file.
 * By default, the log files are located in the `logs/clients` directory inside
 * the application directory.
 *
 * *The service is automatically launched whenever the application detects the
 * use of a networked activity. It should never be required manually inside
 * an application.*
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.ErrorReporter}*__
 *
 * @memberof module:soundworks/client
 */

var ErrorReporter = function (_Service) {
  (0, _inherits3.default)(ErrorReporter, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function ErrorReporter() {
    (0, _classCallCheck3.default)(this, ErrorReporter);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ErrorReporter.__proto__ || (0, _getPrototypeOf2.default)(ErrorReporter)).call(this, SERVICE_ID, true));

    _this._onError = _this._onError.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(ErrorReporter, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(ErrorReporter.prototype.__proto__ || (0, _getPrototypeOf2.default)(ErrorReporter.prototype), 'start', this).call(this);

      window.addEventListener('error', this._onError);
      this.ready();
    }

    /** @private */

  }, {
    key: '_onError',
    value: function _onError(e) {
      var stack = void 0;
      var file = e.filename;
      file = file.replace(window.location.origin, '');
      var line = e.lineno;
      var col = e.colno;
      var msg = e.message;
      var userAgent = navigator.userAgent;

      this.send('error', file, line, col, msg, userAgent);
    }
  }]);
  return ErrorReporter;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, ErrorReporter);

exports.default = ErrorReporter;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],282:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:file-system';
var isString = function isString(value) {
  return typeof value === 'string' || value instanceof String;
};

/**
 * Interface for the client `'file-system'` service.
 *
 * This service allow to retrieve a list of files or directories from a given path.
 * If a `list` option is given when requiring the service, the service marks
 * itself as `ready` when the file list is returned by the server.
 * The service can be used later to retrieve new file lists, each required list is
 * cached client-side to prevent useless network traffic.
 *
 * @param {Object} options
 * @param {String|module:soundworks/client.FileSystem~ListConfig|Array<String>|Array<module:soundworks/client.FileSystem~ListConfig>} option.list -
 *  List to
 *
 * __*The service must be used with its [client-side counterpart]{@link module:soundworks/client.FileSystem}*__
 *
 * @memberof module:soundworks/client
 * @example
 * // require and configure the `file-system` service inside the experience
 * // constructor, the file list to be retrive can be configured as a simple string
 * this.fileSystem = this.require('file-system', { list: 'audio' });
 * // ... or as a full {@link module:soundworks/client.FileSystem~ListConfig}
 * // object for better control over the returned file list
 * this.fileSystem = this.require('file-system', { list: {
 *     path: 'audio',
 *     match: /\.wav$/,
 *     recursive: true,
 *   }
 * });
 *
 * // given the following file system
 * // audio/
 * //   voice.mp3
 * //   voice.wav
 * //   drum/
 * //     kick.mp3
 * //     kick.wav
 * // the first query will return the following result:
 * > ['/audio/voice.mp3', 'audio/voice.wav']
 * // while the second one will return:
 * > ['/audio/voice.wav', 'audio/drum/kick.wav']
 *
 * @see {@link module:soundworks/client.FileSystem~ListConfig}
 */

var FileSystem = function (_Service) {
  (0, _inherits3.default)(FileSystem, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function FileSystem() {
    (0, _classCallCheck3.default)(this, FileSystem);

    var _this = (0, _possibleConstructorReturn3.default)(this, (FileSystem.__proto__ || (0, _getPrototypeOf2.default)(FileSystem)).call(this, SERVICE_ID, true));

    var defaults = { list: null };
    _this.configure(defaults);

    _this._cache = {};
    // as file system is async (server side), nothing guarantees response order
    _this._requestId = 0;
    return _this;
  }

  (0, _createClass3.default)(FileSystem, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(FileSystem.prototype.__proto__ || (0, _getPrototypeOf2.default)(FileSystem.prototype), 'start', this).call(this);

      if (this.options.list !== null) this.getList(this.options.list);else this.ready();
    }
  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(FileSystem.prototype.__proto__ || (0, _getPrototypeOf2.default)(FileSystem.prototype), 'stop', this).call(this);
    }

    /**
     * @typedef {Object} module:soundworks/client.FileSystem~ListConfig
     * @property {String} path - Name of the folder to search into.
     * @property {RegExp} [match='*'] - RegExp used to filter the results.
     * @property {Boolean} [recursive=false] - Flag whether the search should be
     *  recursive.
     * @property {Boolean} [directories=false] - If true only return directories,
     *  files otherwise.
     */
    /**
     * Return a list of file according to the given configuration.
     *
     * @param {String|module:soundworks/client.FileSystem~ListConfig|Array<String>|Array<module:soundworks/client.FileSystem~ListConfig>} config -
     *  Details of the requested list(s). The requested files or directories must
     *  be publicly accessible.
     * @return {Promise<Array>|Promise<Array<Array>>} - Promise resolving with an
     *  an array containing the absolute urls of the files or directories.
     *  If `config` is an array, the results will be an array of arrays
     *  containing the result of each different request.
     *
     * @example:
     * // 1. Single list
     * // retrieve all the file in a folder
     * fileSystem.getList('my-directory').then((list) => ... );
     * // or, retrieve all the `.wav` files inside a given folder,
     * //search recursively
     * fileSystem.getList({
     *   path: 'my-directory',
     *   match: /\.wav/,
     *   recursive: true,
     * }).then((list) => ... );
     *
     * // 2. Multiple Requests
     * // retrieve all the file in 2 different folders, the returned value will be
     * // an array containing the 2 lists
     * fileSystem.getList(['my-directory1', 'my-directory2'])
     *   .then((lists) => ... );
     * // or
     * fileSystem.getList([{ ... }, { ... }])
     *   .then((lists) => ... );
     */

  }, {
    key: 'getList',
    value: function getList(config) {
      var _this2 = this;

      // serialize the json config to properly handle RegExp, adapted from:
      // http://stackoverflow.com/questions/12075927/serialization-of-regexp#answer-33416684
      var _config = (0, _stringify2.default)(config, function (key, value) {
        if (value instanceof RegExp) return '__REGEXP ' + value.toString();else return value;
      });

      var key = isString(config) ? config : _config;

      if (this._cache[key]) return this._cache[key];

      var promise = new _promise2.default(function (resolve, reject) {
        var id = _this2._requestId;
        var channel = 'list:' + id;
        _this2._requestId += 1;

        _this2.receive(channel, function (results) {
          // @note - socket.io remove the first listener if no func argument given
          //         should be done properly -> update socket and Activity
          _this2.removeListener(channel);
          resolve(results);

          if (_this2.options.list !== null && channel === 'list:0') _this2.fileList = results;
          _this2.ready();
        });

        _this2.send('request', id, _config);

        _this2._requestId += 1;
      });

      this._cache[key] = promise;
      return promise;
    }
  }]);
  return FileSystem;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, FileSystem);

exports.default = FileSystem;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/json/stringify":18,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/promise":27,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],283:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:geolocation';
var geolocation = navigator.geolocation;

function geopositionToJson(geoposition) {
  return {
    timestamp: geoposition.timestamp,
    coords: {
      accuracy: geoposition.coords.accuracy,
      altitude: geoposition.coords.altitude,
      altitudeAccuracy: geoposition.coords.altitudeAccuracy,
      heading: geoposition.coords.heading,
      latitude: geoposition.coords.latitude,
      longitude: geoposition.coords.longitude,
      speed: geoposition.coords.speed
    }
  };
}

function getRandomGeoposition() {
  return {
    timestamp: new Date().getTime(),
    coords: {
      accuracy: 10,
      altitude: 10,
      altitudeAccuracy: 10,
      heading: 0,
      latitude: Math.random() * 180 - 90,
      longitude: Math.random() * 360 - 180,
      speed: 1
    }
  };
}

// this is quite a large update...
function updateRandomGeoposition(geoposition) {
  geoposition.timestamp = new Date().getTime();
  geoposition.coords.latitude += Math.random() * 1e-4 - 1e-4 / 2;
  geoposition.coords.longitude += Math.random() * 1e-4 - 1e-4 / 2;
}

/**
 * Interface for the client `'geolocation'` service.
 *
 * The `'geolocation'` service allows to retrieve the latitude and longitude
 * of the client using `gps`. The current values are store into the
 * `client.coordinates` member.
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.Geolocation}*__
 *
 * @param {Object} options - Override default options.
 * @param {'start'|'stop'} [options.state='start'] - Default state when the
 *  service is launched.
 * @param {Boolean} [options.enableHighAccuracy=true] - Define if the application
 *  would like to receive the best possible results (cf. [https://dev.w3.org/geo/api/spec-source.html#high-accuracy](https://dev.w3.org/geo/api/spec-source.html#high-accuracy)).
 *
 * @memberof module:soundworks/client
 */

var Geolocation = function (_Service) {
  (0, _inherits3.default)(Geolocation, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function Geolocation() {
    (0, _classCallCheck3.default)(this, Geolocation);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Geolocation.__proto__ || (0, _getPrototypeOf2.default)(Geolocation)).call(this, SERVICE_ID, true));

    var defaults = {
      state: 'start',
      enableHighAccuracy: true
      // bypass: false,
    };

    _this.platform = _this.require('platform');

    _this._onSuccess = _this._onSuccess.bind(_this);
    _this._onError = _this._onError.bind(_this);
    _this._watchId = null;
    _this.state = null;
    return _this;
  }

  (0, _createClass3.default)(Geolocation, [{
    key: 'configure',
    value: function configure(options) {
      var _options = (0, _assign2.default)({}, this.defaults, options);

      if (!this.options.feature) {
        var feature = 'geolocation';

        if (options.bypass !== undefined && options.bypass === true) feature = 'geolocation-mock';

        this.options.feature = feature;
        this.platform.requireFeature(feature);
      }

      (0, _get3.default)(Geolocation.prototype.__proto__ || (0, _getPrototypeOf2.default)(Geolocation.prototype), 'configure', this).call(this, options);
    }

    /** @private */

  }, {
    key: 'start',
    value: function start() {
      (0, _get3.default)(Geolocation.prototype.__proto__ || (0, _getPrototypeOf2.default)(Geolocation.prototype), 'start', this).call(this);

      if (this.options.feature === 'geolocation-mock') {
        var geoposition = getRandomGeoposition();
        this._updateClient(geoposition);
      }

      // only sync values retrieved from `platform` with server before getting ready
      this.emit('geoposition', _client2.default.geoposition);
      this.send('geoposition', geopositionToJson(_client2.default.geoposition));
      this.ready();

      this.setState(this.options.state);
    }

    /**
     * Set the state of the service.
     *
     * @param {'start'|'stop'} String - New state of the service.
     */

  }, {
    key: 'setState',
    value: function setState(state) {
      if (this.state !== state) {
        this.state = state;

        if (this.state === 'start') this._startWatch();else this._stopWatch();
      }
    }

    /**
     * Resume the refresh of the position.
     * @private
     */

  }, {
    key: '_startWatch',
    value: function _startWatch() {
      var _this2 = this;

      if (this.options.debug === false) {
        this._watchId = geolocation.watchPosition(this._onSuccess, this._onError, this.options);
      } else {
        this._watchId = setInterval(function () {
          updateRandomGeoposition(_client2.default.geoposition);
          _this2._onSuccess(_client2.default.geoposition);
        }, 3000);
      }
    }

    /**
     * Pause the refresh of the position.
     * @private
     */

  }, {
    key: '_stopWatch',
    value: function _stopWatch() {
      if (this.options.debug === false) navigator.geolocation.clearWatch(this._watchId);else clearInterval(this._watchId);
    }

    /** @private */

  }, {
    key: '_onSuccess',
    value: function _onSuccess(geoposition) {
      this._updateClient(geoposition);
      this.emit('geoposition', geoposition);
      this.send('geoposition', geopositionToJson(geoposition));
    }

    /** @private */

  }, {
    key: '_updateClient',
    value: function _updateClient(geoposition) {
      var coords = geoposition.coords;
      _client2.default.coordinates = [coords.latitude, coords.longitude];
      _client2.default.geoposition = geoposition;
    }

    /** @private */

  }, {
    key: '_onError',
    value: function _onError(err) {
      console.error(err.stack);
    }
  }]);
  return Geolocation;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Geolocation);

exports.default = Geolocation;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],284:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _SegmentedView = require('../views/SegmentedView');

var _SegmentedView2 = _interopRequireDefault(_SegmentedView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:language';

var defaultViewTemplate = '\n <div class="section-top"></div>\n <div class="section-center">\n   <% Object.keys(options).forEach(function(key,index) { %>\n     <button class="btn" data-id="<%= key %>"><%= options[key] %></button>\n   <% }); %>\n </div>\n <div class="section-bottom"></div>\n';

/**
 * API of a compliant view for the `language` service.
 *
 * @memberof module:soundworks/client
 * @interface AbstractLanguageView
 * @extends module:soundworks/client.AbstractView
 * @abstract
 */
/**
 * Register the function that should be executed when the password is submitted
 * by the user.
 *
 * @name setSelectionCallback
 * @memberof module:soundworks/client.AbstractLanguageView
 * @function
 * @abstract
 * @instance
 *
 * @param {selectionCallback} callback - Callback to execute when the user
 *  choose its language
 */

/**
 * Callback to execute when the user choose its language.
 *
 * @callback
 * @name selectionCallback
 * @memberof module:soundworks/client.AbstractLanguageView
 *
 * @param {String} id - id of the language.
 */

/**
 * Interface for the client `language` service.
 *
 * This service present a view that allows to define a langage for the client.
 * Using this service implies that the application should handle itself this
 * information in the views of the the services as well as in the experience.
 *
 * @memberof module:soundworks/client
 * @example
 * this.language = this.require('language', { options: { en: 'English', fr:'Français' }});
 */

var Language = function (_Service) {
  (0, _inherits3.default)(Language, _Service);

  function Language() {
    (0, _classCallCheck3.default)(this, Language);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Language.__proto__ || (0, _getPrototypeOf2.default)(Language)).call(this, SERVICE_ID, false));

    var defaults = {
      viewPriority: 9,
      options: {}
    };

    _this.configure(defaults);

    _this._onSelection = _this._onSelection.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Language, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(Language.prototype.__proto__ || (0, _getPrototypeOf2.default)(Language.prototype), 'start', this).call(this);

      this.view.model.options = this.options.options;
      this.view.setSelectionCallback(this._onSelection);

      this.show();
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(Language.prototype.__proto__ || (0, _getPrototypeOf2.default)(Language.prototype), 'stop', this).call(this);
      this.hide();
    }
  }, {
    key: '_onSelection',
    value: function _onSelection(id) {
      _client2.default.language = id;
      this.ready();
    }
  }]);
  return Language;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Language);

exports.default = Language;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"../views/SegmentedView":300,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],285:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * API of a compliant view for the `locator` service.
 *
 * @memberof module:soundworks/client
 * @interface AbstractLocatorView
 * @extends module:soundworks/client.AbstractView
 * @abstract
 */
/**
 * Set and display the `area` definition (as defined in server configuration).
 *
 * @name setArea
 * @memberof module:soundworks/client.AbstractLocatorView
 * @function
 * @abstract
 * @instance
 *
 * @param {Object} area - Area defintion as declared in server configuration.
 * @param {Number} area.width - With of the area.
 * @param {Number} area.height - Height of the area.
 * @param {Number} [area.labels=[]] - Labels of the position.
 * @param {Number} [area.coordinates=[]] - Coordinates of the area.
 */
/**
 * Register the callback to be executed when the user select a position.
 *
 * @name setSelectCallback
 * @memberof module:soundworks/client.AbstractLocatorView
 * @function
 * @abstract
 * @instance
 *
 * @param {selectCallback} callback - Callback to be executed
 *  when a position is selected. This callback should be called with the `index`,
 * `label` and `coordinates` of the requested position.
 */

/**
 * Callback to execute when the user select a position.
 *
 * @callback
 * @name selectCallback
 * @memberof module:soundworks/client.AbstractLocatorView
 * @param {Number} index - Index of the selected location.
 * @param {String} label - Label of the selected location if any.
 * @param {Array<Number>} coordinates - Coordinates (`[x, y]`) of the selected
 *  location if any.
 */

var SERVICE_ID = 'service:locator';

/**
 * Interface for the client `'locator'` service.
 *
 * This service is one of the provided services aimed at identifying clients inside
 * the experience along with the [`'placer'`]{@link module:soundworks/client.Placer}
 * and [`'checkin'`]{@link module:soundworks/client.Checkin} services.
 *
 * The `'locator'` service allows a client to give its approximate location inside
 * a graphical representation of the `area` as defined in the server's `setup`
 * configuration member.
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.Locator}*__
 *
 * @see {@link module:soundworks/client.Placer}
 * @see {@link module:soundworks/client.Checkin}
 *
 * @param {Object} options
 * @param {Boolean} [options.random=false] - Defines whether the location is
 *  set randomly (mainly for development purposes).
 *
 * @memberof module:soundworks/client
 * @example
 * // inside the experience constructor
 * this.locator = this.require('locator');
 */

var Locator = function (_Service) {
  (0, _inherits3.default)(Locator, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function Locator() {
    (0, _classCallCheck3.default)(this, Locator);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Locator.__proto__ || (0, _getPrototypeOf2.default)(Locator)).call(this, SERVICE_ID, true));

    var defaults = {
      random: false,
      viewPriority: 6
    };

    _this.configure(defaults);

    _this._sharedConfig = _this.require('shared-config');

    _this._onAknowledgeResponse = _this._onAknowledgeResponse.bind(_this);
    _this._sendCoordinates = _this._sendCoordinates.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Locator, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(Locator.prototype.__proto__ || (0, _getPrototypeOf2.default)(Locator.prototype), 'start', this).call(this);
      this.show();

      this.send('request');
      this.receive('acknowledge', this._onAknowledgeResponse);
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(Locator.prototype.__proto__ || (0, _getPrototypeOf2.default)(Locator.prototype), 'stop', this).call(this);
      this.removeListener('acknowledge', this._onAknowledgeResponse);
      this.hide();
    }

    /**
     * @private
     * @param {Object} areaConfigPath - Path to the area in the configuration.
     */

  }, {
    key: '_onAknowledgeResponse',
    value: function _onAknowledgeResponse(areaConfigPath) {
      if (this.options.random) {
        var x = Math.random() * area.width;
        var y = Math.random() * area.height;
        this._sendCoordinates(x, y);
      } else {
        var _area = this._sharedConfig.get(areaConfigPath);
        this.view.setArea(_area);
        this.view.setSelectCallback(this._sendCoordinates);
      }
    }

    /**
     * Send coordinates to the server.
     * @private
     * @param {Number} x - The `x` coordinate of the client.
     * @param {Number} y - The `y` coordinate of the client.
     */

  }, {
    key: '_sendCoordinates',
    value: function _sendCoordinates(x, y) {
      _client2.default.coordinates = [x, y];

      this.send('coordinates', _client2.default.coordinates);
      this.ready();
    }
  }]);
  return Locator;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Locator);

exports.default = Locator;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],286:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _wavesAudio = require('waves-audio');

var audio = _interopRequireWildcard(_wavesAudio);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioScheduler = audio.getScheduler();

var SERVICE_ID = 'service:metric-scheduler';

var EPSILON = 1e-12;

var SyncSchedulerHook = function (_audio$TimeEngine) {
  (0, _inherits3.default)(SyncSchedulerHook, _audio$TimeEngine);

  function SyncSchedulerHook(syncScheduler, metricScheduler) {
    (0, _classCallCheck3.default)(this, SyncSchedulerHook);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SyncSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(SyncSchedulerHook)).call(this));

    _this.nextPosition = Infinity;
    _this.nextTime = Infinity;

    _this.syncScheduler = syncScheduler;
    _this.metricScheduler = metricScheduler;

    syncScheduler.add(_this, Infinity); // add hook to sync (master) scheduler
    return _this;
  }

  (0, _createClass3.default)(SyncSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(syncTime) {
      var metricScheduler = this.metricScheduler;
      var nextPosition = metricScheduler._advancePosition(syncTime, this.nextPosition, metricScheduler._metricSpeed);
      var nextTime = metricScheduler.getSyncTimeAtMetricPosition(nextPosition);

      this.nextPosition = nextPosition;
      this.nextTime = nextTime;

      return nextTime;
    }
  }, {
    key: 'reschedule',
    value: function reschedule() {
      var metricScheduler = this.metricScheduler;
      var nextPosition = metricScheduler._engineQueue.time;
      var syncTime = metricScheduler.getSyncTimeAtMetricPosition(nextPosition);

      if (syncTime !== this.nextTime) {
        this.nextPosition = nextPosition;
        this.nextTime = syncTime;

        this.resetTime(syncTime);
      }
    }
  }]);
  return SyncSchedulerHook;
}(audio.TimeEngine);

var SyncEventEngine = function (_audio$TimeEngine2) {
  (0, _inherits3.default)(SyncEventEngine, _audio$TimeEngine2);

  function SyncEventEngine(syncScheduler, metricScheduler) {
    (0, _classCallCheck3.default)(this, SyncEventEngine);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (SyncEventEngine.__proto__ || (0, _getPrototypeOf2.default)(SyncEventEngine)).call(this));

    _this2.syncScheduler = syncScheduler;
    _this2.metricScheduler = metricScheduler;

    _this2.syncTime = undefined;
    _this2.metricPosition = undefined;
    _this2.tempo = undefined;
    _this2.tempoUnit = undefined;
    _this2.event = undefined;

    syncScheduler.add(_this2, Infinity);
    return _this2;
  }

  (0, _createClass3.default)(SyncEventEngine, [{
    key: 'advanceTime',
    value: function advanceTime(syncTime) {
      this.metricScheduler._sync(this.syncTime, this.metricPosition, this.tempo, this.tempoUnit, this.event);
      return Infinity;
    }
  }, {
    key: 'set',
    value: function set(syncTime, metricPosition, tempo, tempoUnit, event) {
      this.syncTime = syncTime;
      this.metricPosition = metricPosition;
      this.tempo = tempo;
      this.tempoUnit = tempoUnit;
      this.event = event;

      this.resetTime(syncTime);
    }
  }, {
    key: 'reset',
    value: function reset(syncTime, metricPosition, tempo, tempoUnit, event) {
      this.syncTime = undefined;
      this.metricPosition = undefined;
      this.tempo = undefined;
      this.tempoUnit = undefined;
      this.event = undefined;

      this.resetTime(Infinity);
    }
  }]);
  return SyncEventEngine;
}(audio.TimeEngine);

var BeatEngine = function (_audio$TimeEngine3) {
  (0, _inherits3.default)(BeatEngine, _audio$TimeEngine3);

  function BeatEngine(metro) {
    (0, _classCallCheck3.default)(this, BeatEngine);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (BeatEngine.__proto__ || (0, _getPrototypeOf2.default)(BeatEngine)).call(this));

    _this3.metro = metro;
    audioScheduler.add(_this3, Infinity);
    return _this3;
  }

  // generate next beat


  (0, _createClass3.default)(BeatEngine, [{
    key: 'advanceTime',
    value: function advanceTime(audioTime) {
      var metro = this.metro;

      var cont = metro.callback(metro.measureCount, metro.beatCount);
      metro.beatCount++;

      if (cont === undefined || cont === true) {
        if (metro.beatCount >= metro.numBeats) return Infinity;

        return audioTime + metro.beatPeriod;
      }

      metro.resetPosition(Infinity);
      return Infinity;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.metro = null;

      if (this.master) this.master.remove(this);
    }
  }]);
  return BeatEngine;
}(audio.TimeEngine);

var MetronomeEngine = function (_audio$TimeEngine4) {
  (0, _inherits3.default)(MetronomeEngine, _audio$TimeEngine4);

  function MetronomeEngine(startPosition, numBeats, beatLength, startOnBeat, callback) {
    (0, _classCallCheck3.default)(this, MetronomeEngine);

    var _this4 = (0, _possibleConstructorReturn3.default)(this, (MetronomeEngine.__proto__ || (0, _getPrototypeOf2.default)(MetronomeEngine)).call(this));

    _this4.startPosition = startPosition;
    _this4.numBeats = numBeats;
    _this4.beatLength = beatLength;
    _this4.startOnBeat = startOnBeat;
    _this4.callback = callback;

    _this4.measureLength = numBeats * beatLength;
    _this4.beatPeriod = 0;
    _this4.measureCount = 0;
    _this4.beatCount = 0;

    if (numBeats > 1) _this4.beatEngine = new BeatEngine(_this4);
    return _this4;
  }

  // return position of next measure


  (0, _createClass3.default)(MetronomeEngine, [{
    key: 'syncSpeed',
    value: function syncSpeed(syncTime, metricPosition, metricSpeed) {
      if (metricSpeed <= 0 && this.beatEngine) this.beatEngine.resetTime(Infinity);
    }

    // return position of next measure

  }, {
    key: 'syncPosition',
    value: function syncPosition(syncTime, metricPosition, metricSpeed) {
      var startPosition = this.startPosition;

      if (this.beatEngine) this.beatEngine.resetTime(Infinity);

      // since we are anyway a little in advance, make sure that we don't skip
      // the start point due to rounding errors
      metricPosition -= EPSILON;

      this.beatPeriod = this.beatLength / metricSpeed;
      this.beatCount = 0;

      if (metricPosition >= startPosition) {
        var relativePosition = metricPosition - startPosition;
        var floatMeasures = relativePosition / this.measureLength;
        var measureCount = Math.floor(floatMeasures);
        var measurePhase = floatMeasures - measureCount;

        if (this.beatEngine && this.startOnBeat) {
          var floatBeats = this.numBeats * measurePhase;
          var nextBeatCount = Math.ceil(floatBeats) % this.numBeats;

          this.beatCount = nextBeatCount; // next beat

          if (nextBeatCount !== 0) {
            var audioTime = audioScheduler.currentTime;
            var nextBeatDelay = (nextBeatCount - floatBeats) * this.beatPeriod;
            this.beatEngine.resetTime(audioTime + nextBeatDelay);
          }
        }

        if (measurePhase > 0) measureCount++;

        this.measureCount = measureCount - 1;

        return startPosition + measureCount * this.measureLength;
      }

      this.measureCount = 0;
      return startPosition;
    }

    // generate next measure

  }, {
    key: 'advancePosition',
    value: function advancePosition(syncTime, metricPosition, metricSpeed) {
      var audioTime = audioScheduler.currentTime;

      this.measureCount++;

      // whether metronome continues (default is true)
      var cont = this.callback(this.measureCount, 0);

      this.beatCount = 1;

      if (cont === undefined || cont === true) {
        if (this.beatEngine) this.beatEngine.resetTime(audioTime + this.beatPeriod);

        return metricPosition + this.measureLength;
      }

      if (this.beatEngine) this.beatEngine.resetTime(Infinity);

      return Infinity;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.beatEngine) this.beatEngine.destroy();

      if (this.master) this.master.remove(this);
    }
  }]);
  return MetronomeEngine;
}(audio.TimeEngine);

var MetricScheduler = function (_Service) {
  (0, _inherits3.default)(MetricScheduler, _Service);

  function MetricScheduler() {
    (0, _classCallCheck3.default)(this, MetricScheduler);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (MetricScheduler.__proto__ || (0, _getPrototypeOf2.default)(MetricScheduler)).call(this, SERVICE_ID, true));

    _this5._syncScheduler = _this5.require('sync-scheduler');

    _this5._engineQueue = new audio.PriorityQueue();
    _this5._engineSet = new _set2.default();
    _this5._metronomeEngineMap = new _map2.default();

    _this5._tempo = 60; // tempo in beats per minute (BPM)
    _this5._tempoUnit = 0.25; // tempo unit expressed in fractions of a whole note
    _this5._metricSpeed = 0.25; // whole notes per second

    _this5._syncTime = 0;
    _this5._metricPosition = 0;

    _this5._syncSchedulerHook = null;
    _this5._syncEventEngine = null;

    _this5._listeners = new _map2.default();
    _this5._callingEventListeners = false;

    // const defaults = {};
    // this.configure(defaults);

    _this5._onInit = _this5._onInit.bind(_this5);
    _this5._onSync = _this5._onSync.bind(_this5);
    _this5._onClear = _this5._onClear.bind(_this5);
    return _this5;
  }

  (0, _createClass3.default)(MetricScheduler, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(MetricScheduler.prototype.__proto__ || (0, _getPrototypeOf2.default)(MetricScheduler.prototype), 'start', this).call(this);

      this._syncSchedulerHook = new SyncSchedulerHook(this._syncScheduler, this);
      this._syncEventEngine = new SyncEventEngine(this._syncScheduler, this);

      this.send('request');
      this.receive('init', this._onInit);
      this.receive('clear', this._onClear);
      this.receive('sync', this._onSync);
    }
  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(MetricScheduler.prototype.__proto__ || (0, _getPrototypeOf2.default)(MetricScheduler.prototype), 'stop', this).call(this);
    }
  }, {
    key: '_callEventListeners',
    value: function _callEventListeners(event) {
      var listeners = this._listeners.get(event);

      if (listeners) {
        this._callingEventListeners = true;

        var data = {
          syncTime: this._syncTime,
          metricPosition: this._metricPosition,
          tempo: this._tempo,
          tempoUnit: this._tempoUnit
        };

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(listeners), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var callback = _step.value;

            callback(event, data);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this._callingEventListeners = false;
      }
    }
  }, {
    key: '_rescheduleMetricEngines',
    value: function _rescheduleMetricEngines() {
      var syncTime = this.syncTime;
      var metricPosition = this.getMetricPositionAtSyncTime(syncTime);

      this._engineQueue.clear();

      if (this._metricSpeed > 0) {
        // position engines
        var metricSpeed = this._metricSpeed;
        var queue = this._engineQueue;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(this._engineSet), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var engine = _step2.value;

            var nextEnginePosition = engine.syncPosition(syncTime, metricPosition, metricSpeed);
            queue.insert(engine, nextEnginePosition);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        // stop engines
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _getIterator3.default)(this._engineSet), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _engine = _step3.value;

            if (_engine.syncSpeed) _engine.syncSpeed(syncTime, metricPosition, 0);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      this._syncSchedulerHook.reschedule();
    }
  }, {
    key: '_clearEngines',
    value: function _clearEngines() {
      this._engineQueue.clear();
      this._engineSet.clear();

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator3.default)(this._metronomeEngineMap), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _step4$value = (0, _slicedToArray3.default)(_step4.value, 2),
              key = _step4$value[0],
              engine = _step4$value[1];

          engine.destroy();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this._metronomeEngineMap.clear();

      this._syncSchedulerHook.reschedule();
    }
  }, {
    key: '_advancePosition',
    value: function _advancePosition(syncTime, metricPosition, metricSpeed) {
      var engine = this._engineQueue.head;
      var nextEnginePosition = engine.advancePosition(syncTime, metricPosition, metricSpeed);

      if (nextEnginePosition === undefined) this._engineSet.delete(engine);

      return this._engineQueue.move(engine, nextEnginePosition);
    }
  }, {
    key: '_sync',
    value: function _sync(syncTime, metricPosition, tempo, tempoUnit, event) {
      this._syncTime = syncTime;
      this._metricPosition = metricPosition;

      this._tempo = tempo;
      this._tempoUnit = tempoUnit;
      this._metricSpeed = tempo * tempoUnit / 60;

      if (event) this._callEventListeners(event);

      this._rescheduleMetricEngines();
    }
  }, {
    key: '_clearSyncEvent',
    value: function _clearSyncEvent() {
      this._syncEventEngine.reset();
    }
  }, {
    key: '_setSyncEvent',
    value: function _setSyncEvent(syncTime, metricPosition, tempo, tempoUnit, event) {
      this._clearSyncEvent();

      if (syncTime > this.syncTime) this._syncEventEngine.set(syncTime, metricPosition, tempo, tempoUnit, event);else this._sync(syncTime, metricPosition, tempo, tempoUnit, event);
    }
  }, {
    key: '_onInit',
    value: function _onInit(syncTime, metricPosition, tempo, tempoUnit) {
      this._sync(syncTime, metricPosition, tempo, tempoUnit);
      this.ready();
    }
  }, {
    key: '_onClear',
    value: function _onClear() {
      this._clearSyncEvent();
      this._clearEngines();
    }
  }, {
    key: '_onSync',
    value: function _onSync(syncTime, metricPosition, tempo, tempoUnit, event) {
      this._setSyncEvent(syncTime, metricPosition, tempo, tempoUnit, event);
    }

    /**
     * Current audio time.
     * @type {Number}
     */

  }, {
    key: 'getMetricPositionAtAudioTime',


    /**
     * Get metric position corrsponding to a given audio time (regarding the current tempo).
     * @param  {Number} time - time
     * @return {Number} - metric position
     */
    value: function getMetricPositionAtAudioTime(audioTime) {
      if (this._tempo > 0) {
        var syncTime = this._syncScheduler.getSyncTimeAtAudioTime(audioTime);
        return this._metricPosition + (syncTime - this._syncTime) * this._metricSpeed;
      }

      return this._metricPosition;
    }

    /**
     * Get metric position corrsponding to a given sync time (regarding the current tempo).
     * @param  {Number} time - time
     * @return {Number} - metric position
     */

  }, {
    key: 'getMetricPositionAtSyncTime',
    value: function getMetricPositionAtSyncTime(syncTime) {
      if (this._tempo > 0) return this._metricPosition + (syncTime - this._syncTime) * this._metricSpeed;

      return this._metricPosition;
    }

    /**
     * Get sync time corresponding to a given metric position (regarding the current tempo).
     * @param  {Number} position - metric position
     * @return {Number} - sync time
     */

  }, {
    key: 'getSyncTimeAtMetricPosition',
    value: function getSyncTimeAtMetricPosition(metricPosition) {
      var metricSpeed = this._metricSpeed;

      if (metricPosition < Infinity && metricSpeed > 0) return this._syncTime + (metricPosition - this._metricPosition) / metricSpeed;

      return Infinity;
    }

    /**
     * Get audio time corresponding to a given metric position (regarding the current tempo).
     * @param  {Number} position - metric position
     * @return {Number} - audio time
     */

  }, {
    key: 'getAudioTimeAtMetricPosition',
    value: function getAudioTimeAtMetricPosition(metricPosition) {
      var metricSpeed = this._metricSpeed;

      if (metricPosition < Infinity && metricSpeed > 0) {
        var syncTime = this._syncTime + (metricPosition - this._metricPosition) / metricSpeed;
        return this._syncScheduler.getAudioTimeAtSyncTime(syncTime);
      }

      return Infinity;
    }
  }, {
    key: 'addEventListener',
    value: function addEventListener(event, callback) {
      var listeners = this._listeners.get(event);

      if (!listeners) {
        listeners = new _set2.default();
        this._listeners.set(event, listeners);
      }

      listeners.add(callback);
    }
  }, {
    key: 'removeEventListener',
    value: function removeEventListener(callback) {
      var listeners = this._listeners.get(event);

      if (listeners) listeners.remove(callback);
    }

    /**
     * Call a function at a given metric position.
     *
     * @param {Function} fun - Function to be deferred.
     * @param {Number} metricPosition - The metric position at which the function should be executed.
     * @param {Boolean} [lookahead=false] - Defines whether the function is called
     *  anticipated (e.g. for audio events) or precisely at the given time (default).
     */

  }, {
    key: 'addEvent',
    value: function addEvent(fun, metricPosition) {
      var lookahead = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var schedulerService = this;
      var engine = {
        timeout: null,
        syncSpeed: function syncSpeed(time, position, speed) {
          if (speed === 0) clearTimeout(this.timeout);
        },
        syncPosition: function syncPosition(time, position, speed) {
          clearTimeout(this.timeout);

          if (metricPosition >= position) return metricPosition;

          return Infinity;
        },
        advancePosition: function advancePosition(time, position, speed) {
          var delta = schedulerService.deltaTime;

          if (delta > 0) this.timeout = setTimeout(fun, 1000 * delta, position); // bridge scheduler lookahead with timeout
          else fun(position);

          return Infinity;
        }
      };

      this.add(engine, metricPosition); // add without checks
    }
  }, {
    key: 'add',
    value: function add(engine) {
      var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.metricPosition;

      this._engineSet.add(engine);

      var metricPosition = Math.max(startPosition, this.metricPosition);

      // schedule engine
      if (!this._callingEventListeners && this._metricSpeed > 0) {
        var syncTime = this.syncTime;
        var nextEnginePosition = engine.syncPosition(syncTime, metricPosition, this._metricSpeed);

        this._engineQueue.insert(engine, nextEnginePosition);
        this._syncSchedulerHook.reschedule();
      }
    }
  }, {
    key: 'remove',
    value: function remove(engine) {
      var syncTime = this.syncTime;
      var metricPosition = this.getMetricPositionAtSyncTime(syncTime);

      // stop engine
      if (engine.syncSpeed) engine.syncSpeed(syncTime, metricPosition, 0);

      if (this._engineSet.delete(engine) && !this._callingEventListeners && this._metricSpeed > 0) {
        this._engineQueue.remove(engine);
        this._syncSchedulerHook.reschedule();
      }
    }

    /**
     * Add a periodic callback starting at a given metric position.
     * @param {Function} callback - callback function (cycle, beat)
     * @param {Integer} numBeats - number of beats (time signature numerator)
     * @param {Number} metricDiv - metric division of whole note (time signature denominator)
     * @param {Number} tempoScale - linear tempo scale factor (in respect to master tempo)
     * @param {Integer} startPosition - metric start position of the beat
     */

  }, {
    key: 'addMetronome',
    value: function addMetronome(callback) {
      var numBeats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
      var metricDiv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
      var tempoScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var startPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var startOnBeat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      var beatLength = 1 / (metricDiv * tempoScale);
      var engine = new MetronomeEngine(startPosition, numBeats, beatLength, startOnBeat, callback);

      this._metronomeEngineMap.set(callback, engine);
      this.add(engine, startPosition);
    }

    /**
     * Remove periodic callback.
     * @param {Function} callback callback function
     */

  }, {
    key: 'removeMetronome',
    value: function removeMetronome(callback /*, endPosition */) {
      var engine = this._metronomeEngineMap.get(callback);

      if (engine) {
        this._metronomeEngineMap.delete(callback);
        this.remove(engine);
      }
    }
  }, {
    key: 'audioTime',
    get: function get() {
      return audioScheduler.currentTime;
    }
  }, {
    key: 'syncTime',
    get: function get() {
      return this._syncScheduler.syncTime;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this._syncScheduler.syncTime;
    }
  }, {
    key: 'metricPosition',
    get: function get() {
      if (this._tempo > 0) return this._metricPosition + (this._syncScheduler.syncTime - this._syncTime) * this._metricSpeed;

      return this._metricPosition;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.metricPosition;
    }

    /**
     * Difference between the audio scheduler's logical audio time and the `currentTime`
     * of the audio context.
     */

  }, {
    key: 'deltaTime',
    get: function get() {
      return audioScheduler.currentTime - audio.audioContext.currentTime;
    }

    /**
     * Current tempo.
     * @return {Number} - Tempo in BPM.
     */

  }, {
    key: 'tempo',
    get: function get() {
      return this._tempo;
    }

    /**
     * Current tempo unit.
     * @return {Number} - Tempo unit in respect to whole note.
     */

  }, {
    key: 'tempoUnit',
    get: function get() {
      return this._tempoUnit;
    }
  }]);
  return MetricScheduler;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, MetricScheduler);

exports.default = MetricScheduler;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/map":19,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"babel-runtime/helpers/slicedToArray":38,"waves-audio":322}],287:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _motionInput = require('motion-input');

var _motionInput2 = _interopRequireDefault(_motionInput);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:motion-input';

/**
 * Interface for the client `'motion-input'` service.
 *
 * This service provides a wrapper for the
 * [`motionInput`]{@link https://github.com/collective-soundworks/motion-input}
 * external module.
 *
 * @memberof module:soundworks/client
 * @example
 * // in the experince constructor
 * this.motionInput = this.require('motion-input', { descriptors: ['energy'] });
 * // when the experience has started
 * if (this.motionInput.isAvailable('energy')) {
 *   this.motionInput.addListener('energy', (data) => {
 *     // digest motion data
 *   });
 * } else {
 *   // handle error
 * }
 */

var MotionInput = function (_Service) {
  (0, _inherits3.default)(MotionInput, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function MotionInput() {
    (0, _classCallCheck3.default)(this, MotionInput);

    var _this = (0, _possibleConstructorReturn3.default)(this, (MotionInput.__proto__ || (0, _getPrototypeOf2.default)(MotionInput)).call(this, SERVICE_ID, false));

    var defaults = {
      descriptors: []
      // @todo - how to handle if only some descriptors are invalid ?
      // showError: false,
    };

    _this.configure(defaults);
    // @todo - should be handled directly inside the motionInput
    _this._descriptorsValidity = {};
    _this._descriptorsPeriod = {};
    return _this;
  }

  /**
   * Override default configure to add descriptors from multiple calls.
   * @private
   * @param {Object} options - The options to apply to the service.
   */


  (0, _createClass3.default)(MotionInput, [{
    key: 'configure',
    value: function configure(options) {
      if (this.options.descriptors) options.descriptors = this.options.descriptors.concat(options.descriptors);

      (0, _get3.default)(MotionInput.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotionInput.prototype), 'configure', this).call(this, options);
    }

    /** @private */

  }, {
    key: 'start',
    value: function start() {
      var _this2 = this;

      (0, _get3.default)(MotionInput.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotionInput.prototype), 'start', this).call(this);

      _motionInput2.default.init.apply(_motionInput2.default, (0, _toConsumableArray3.default)(this.options.descriptors)).then(function (modules) {
        _this2.options.descriptors.forEach(function (name, index) {
          _this2._descriptorsValidity[name] = modules[index].isValid;
          _this2._descriptorsPeriod[name] = modules[index].period;
        });

        _this2.ready();
      }).catch(function (err) {
        return console.error(err.stack);
      });
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(MotionInput.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotionInput.prototype), 'stop', this).call(this);
    }

    /**
     * Define if a given descriptor is available or not
     * @param {String} name - Descriptor name.
     * @returns {Boolean} - Returns `true` if available, `false` otherwise.
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(name) {
      return this._descriptorsValidity[name];
    }

    /**
     * Returns the event period of a descriptor
     * @param {String} name - Descriptor name.
     * @returns {Number} - Event period (in seconds).
     */

  }, {
    key: 'getPeriod',
    value: function getPeriod(name) {
      return this._descriptorsPeriod[name];
    }

    /**
     * Add a listener to a given descriptor.
     * @param {String} name - Descriptor name.
     * @param {Function} callback - Callback to register.
     */

  }, {
    key: 'addListener',
    value: function addListener(name, callback) {
      if (this._descriptorsValidity[name]) _motionInput2.default.addListener(name, callback);
    }

    /**
     * Remove a listener of events triggered by a given descriptor.
     * @param {String} name - Descriptor name.
     * @param {Function} callback - Callback to remove.
     */

  }, {
    key: 'removeListener',
    value: function removeListener(name, callback) {
      if (this._descriptorsValidity[name]) _motionInput2.default.removeListener(name, callback);
    }
  }]);
  return MotionInput;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, MotionInput);

exports.default = MotionInput;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"babel-runtime/helpers/toConsumableArray":40,"motion-input":240}],288:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:network';

/**
 * Interface for the client `'network'` service.
 *
 * This service provides a generic way to create client to client communications
 * through websockets without server side custom code.
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.Network}*__
 *
 * @memberof module:soundworks/client
 * @example
 * // inside the experience constructor
 * this.network = this.require('network');
 * // after the experience has started, listens to events
 * this.network.receive('my:channel', (...args) => {
 *   // do something with `args`
 * });
 * // somewhere in the experience
 * this.network.send('player', 'my:channel', 42, false);
 */

var Network = function (_Service) {
  (0, _inherits3.default)(Network, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function Network() {
    (0, _classCallCheck3.default)(this, Network);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Network.__proto__ || (0, _getPrototypeOf2.default)(Network)).call(this, SERVICE_ID, true));

    var defaults = {};
    _this.configure(defaults);

    _this._listeners = {};
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Network, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      (0, _get3.default)(Network.prototype.__proto__ || (0, _getPrototypeOf2.default)(Network.prototype), 'start', this).call(this);

      // common logic for receivers
      (0, _get3.default)(Network.prototype.__proto__ || (0, _getPrototypeOf2.default)(Network.prototype), 'receive', this).call(this, 'receive', function () {
        for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        var channel = values.shift();
        var listeners = _this2._listeners[channel];

        if (Array.isArray(listeners)) listeners.forEach(function (callback) {
          return callback.apply(undefined, values);
        });
      });

      this.ready();
    }

    /**
     * Send a message to given client type(s).
     * @param {String|Array<String>} clientTypes - Client type(s) to send the
     *  message to.
     * @param {String} channel - Channel of the message.
     * @param {...Mixed} values - Values to send in the message.
     */

  }, {
    key: 'send',
    value: function send(clientTypes, channel) {
      for (var _len2 = arguments.length, values = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        values[_key2 - 2] = arguments[_key2];
      }

      values.unshift(clientTypes, channel);
      (0, _get3.default)(Network.prototype.__proto__ || (0, _getPrototypeOf2.default)(Network.prototype), 'send', this).call(this, 'send', values);
    }

    /**
     * Send a message to all the connected clients.
     * @param {String} channel - Channel of the message.
     * @param {...Mixed} values - Values to send in the message.
     */

  }, {
    key: 'broadcast',
    value: function broadcast(channel) {
      for (var _len3 = arguments.length, values = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        values[_key3 - 1] = arguments[_key3];
      }

      values.unshift(channel);
      (0, _get3.default)(Network.prototype.__proto__ || (0, _getPrototypeOf2.default)(Network.prototype), 'send', this).call(this, 'broadcast', values);
    }

    /**
     * Register a callback to be executed when a message is received on a given
     * channel.
     * @param {String} channel - Channel to listen to.
     * @param {Function} callback - Function to execute when a message is received.
     */

  }, {
    key: 'receive',
    value: function receive(channel, callback) {
      if (!this._listeners[channel]) this._listeners[channel] = [];

      this._listeners[channel].push(callback);
    }

    /**
     * Remove a callback from listening a given channel.
     * @param {String} channel - Channel to stop listening to.
     * @param {Function} callback - The previously registered callback function.
     */

  }, {
    key: 'removeListener',
    value: function removeListener(channel, callback) {
      var listeners = this._listeners[channel];

      if (Array.isArray(listeners)) {
        var index = listeners.indexOf(callback);

        if (index !== -1) listeners.splice(index, 1);
      }
    }
  }]);
  return Network;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Network);

exports.default = Network;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],289:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _SelectView = require('../prefabs/SelectView');

var _SelectView2 = _interopRequireDefault(_SelectView);

var _SpaceView = require('../prefabs/SpaceView');

var _SpaceView2 = _interopRequireDefault(_SpaceView);

var _SquaredView = require('../prefabs/SquaredView');

var _SquaredView2 = _interopRequireDefault(_SquaredView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * API of a compliant view for the `placer` service.
 *
 * @memberof module:soundworks/client
 * @interface AbstractPlacerView
 * @extends module:soundworks/client.AbstractView
 * @abstract
 */
/**
 * Set and display the `area` definition (as defined in server configuration).
 *
 * @name setReadyCallback
 * @memberof module:soundworks/client.AbstractPlacerView
 * @function
 * @abstract
 * @instance
 *
 * @param {Object} area - Definition of the area.
 * @param {Number} area.width - With of the area.
 * @param {Number} area.height - Height of the area.
 * @param {Number} [area.labels=[]] - Labels of the position.
 * @param {Number} [area.coordinates=[]] - Coordinates of the area.
 */
/**
 * Register the callback to be executed when the user select a position.
 *
 * @name setSelectCallback
 * @memberof module:soundworks/client.AbstractPlacerView
 * @function
 * @abstract
 * @instance
 *
 * @param {String} callback - Callback to execute when the user select a position.
 *  This callback should be called with the `index`, `label` and `coordinates` of
 *  the requested position.
 */
/**
 * Display the available positions.
 *
 * @name displayPosition
 * @memberof module:soundworks/client.AbstractPlacerView
 * @function
 * @abstract
 * @instance
 *
 * @param {Number} capacity - The maximum number of clients allowed.
 * @param {Array<String>} [labels=null] - An array of the labels for the positions
 * @param {Array<Array<Number>>} [coordinates=null] - An array of the coordinates of the positions
 * @param {Number} [maxClientsPerPosition=1] - Number of clients allowed for each position.
 */
/**
 * Update the view accroding to the disabled positions.
 *
 * @name updateDisabledPositions
 * @memberof module:soundworks/client.AbstractPlacerView
 * @function
 * @abstract
 * @instance
 *
 * @param {Array<Number>} disabledPositions - Array containing the indexes of
 *  the disabled positions.
 */
/**
 * Update the view when the position selected by the user is no longer available.
 *
 * @name reject
 * @memberof module:soundworks/client.AbstractPlacerView
 * @function
 * @abstract
 * @instance
 *
 * @param {Array<Number>} disabledPositions - Array containing the indexes of
 *  the disabled positions.
 */

/**
 * Callback to execute when the user select a position.
 *
 * @callback
 * @name selectCallback
 * @memberof module:soundworks/client.AbstractPlacerView
 * @param {Number} index - Index of the selected location.
 * @param {String} label - Label of the selected location if any.
 * @param {Array<Number>} coordinates - Coordinates (`[x, y]`) of the selected
 *  location if any.
 */

var SERVICE_ID = 'service:placer';

/**
 * Interface for the `'placer'` service.
 *
 * This service is one of the provided services aimed at identifying clients inside
 * the experience along with the [`'locator'`]{@link module:soundworks/client.Locator}
 * and [`'checkin'`]{@link module:soundworks/client.Checkin} services.
 *
 * The `'placer'` service allows a client to choose its location among a set of
 * positions defined in the server's `setup` configuration entry.
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.Placer}*__
 *
 * @see {@link module:soundworks/client.Locator}
 * @see {@link module:soundworks/client.Checkin}
 *
 * @param {Object} options
 * @param {String} [options.mode='list'] - Sets the interaction mode for the
 *  client to choose its position, the `'list'` mode proposes a drop-down menu
 *  while the `'graphic'` mode (which requires located positions) proposes an
 *  interface representing the area and dots for each available location.
 *
 * @memberof module:soundworks/client
 * @example
 * // inside the experience constructor
 * this.placer = this.require('placer', { mode: 'graphic' });
 */

var Placer = function (_Service) {
  (0, _inherits3.default)(Placer, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function Placer() {
    (0, _classCallCheck3.default)(this, Placer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Placer.__proto__ || (0, _getPrototypeOf2.default)(Placer)).call(this, SERVICE_ID, true));

    var defaults = {
      mode: 'list',
      viewPriority: 6
    };

    _this.configure(defaults);

    /**
     * Index of the position selected by the user.
     * @type {Number}
     */
    _this.index = null;

    /**
     * Label of the position selected by the user.
     * @type {String}
     */
    _this.label = null;

    _this._onAknowledgeResponse = _this._onAknowledgeResponse.bind(_this);
    _this._onClientJoined = _this._onClientJoined.bind(_this);
    _this._onClientLeaved = _this._onClientLeaved.bind(_this);
    _this._onSelect = _this._onSelect.bind(_this);
    _this._onConfirmResponse = _this._onConfirmResponse.bind(_this);
    _this._onRejectResponse = _this._onRejectResponse.bind(_this);

    _this._sharedConfigService = _this.require('shared-config');
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Placer, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(Placer.prototype.__proto__ || (0, _getPrototypeOf2.default)(Placer.prototype), 'start', this).call(this);
      this.show();

      this.send('request');

      this.receive('aknowlegde', this._onAknowledgeResponse);
      this.receive('confirm', this._onConfirmResponse);
      this.receive('reject', this._onRejectResponse);
      this.receive('client-joined', this._onClientJoined);
      this.receive('client-leaved', this._onClientLeaved);
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      this.removeListener('aknowlegde', this._onAknowledgeResponse);
      this.removeListener('confirm', this._onConfirmResponse);
      this.removeListener('reject', this._onRejectResponse);
      this.removeListener('client-joined', this._onClientJoined);
      this.removeListener('client-leaved', this._onClientLeaved);

      this.hide();
    }

    /** @private */

  }, {
    key: '_onAknowledgeResponse',
    value: function _onAknowledgeResponse(setupConfigItem, disabledPositions) {
      var setup = this._sharedConfigService.get(setupConfigItem);
      var area = setup.area;
      var capacity = setup.capacity;
      var labels = setup.labels;
      var coordinates = setup.coordinates;
      var maxClientsPerPosition = setup.maxClientsPerPosition;

      this.nbrPositions = capacity / maxClientsPerPosition;

      if (area) this.view.setArea(area);

      this.view.displayPositions(capacity, labels, coordinates, maxClientsPerPosition);
      this.view.updateDisabledPositions(disabledPositions);
      this.view.setSelectCallack(this._onSelect);
    }

    /** @private */

  }, {
    key: '_onSelect',
    value: function _onSelect(index, label, coordinates) {
      this.send('position', index, label, coordinates);
    }

    /** @private */

  }, {
    key: '_onConfirmResponse',
    value: function _onConfirmResponse(index, label, coordinates) {
      _client2.default.index = this.index = index;
      _client2.default.label = this.label = label;
      _client2.default.coordinates = coordinates;

      this.ready();
    }

    /** @private */

  }, {
    key: '_onClientJoined',
    value: function _onClientJoined(disabledPositions) {
      if (disabledPositions.length >= this.nbrPositions) this.view.reject(disabledPositions);else this.view.updateDisabledPositions(disabledPositions);
    }

    /** @private */

  }, {
    key: '_onClientLeaved',
    value: function _onClientLeaved(disabledPositions) {
      this.view.updateDisabledPositions(disabledPositions);
    }

    /** @private */

  }, {
    key: '_onRejectResponse',
    value: function _onRejectResponse(disabledPositions) {
      if (disabledPositions.length >= this.nbrPositions) this.view.reject(disabledPositions);else this.view.updateDisabledPositions(disabledPositions);
    }
  }]);
  return Placer;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Placer);

exports.default = Placer;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"../prefabs/SelectView":273,"../prefabs/SpaceView":274,"../prefabs/SquaredView":275,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],290:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _wavesAudio = require('waves-audio');

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

var _mobileDetect = require('mobile-detect');

var _mobileDetect2 = _interopRequireDefault(_mobileDetect);

var _NoSleep = require('nosleep.js/dist/NoSleep.min');

var _NoSleep2 = _interopRequireDefault(_NoSleep);

var _screenfull = require('screenfull');

var _screenfull2 = _interopRequireDefault(_screenfull);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * API of a compliant view for the `platform` service.
 *
 * @memberof module:soundworks/client
 * @interface AbstractPlatformView
 * @extends module:soundworks/client.AbstractView
 * @abstract
 */
/**
 * Register the callback to execute when the user touches the screen for the first time.
 *
 * @name setTouchStartCallback
 * @memberof module:soundworks/client.AbstractPlatformView
 * @function
 * @abstract
 * @instance
 *
 * @param {touchStartCallback} callback - Callback to execute when the user
 *  touches the screen for the first time.
 */
/**
 * Register the callback to execute when the user clicks the screen for the first time.
 *
 * @name setMousedownCallback
 * @memberof module:soundworks/client.AbstractPlatformView
 * @function
 * @abstract
 * @instance
 *
 * @param {mouseDownCallback} callback - Callback to execute when the user
 *  clicks the screen for the first time.
 */
/**
 * Update the view to notify that the compatibility checks are terminated.
 *
 * @name updateCheckingStatus
 * @memberof module:soundworks/client.AbstractPlatformView
 * @function
 * @abstract
 * @instance
 *
 * @param {Boolean} value
 */
/**
 * Update the view to notify if the device is compatible or not.
 *
 * @name updateIsCompatibleStatus
 * @memberof module:soundworks/client.AbstractPlatformView
 * @function
 * @abstract
 * @instance
 *
 * @param {Boolean} value
 */
/**
 * Update the view to notify if the application obtained all the authorizations
 * or not.
 *
 * @name updateHasAuthorizationsStatus
 * @memberof module:soundworks/client.AbstractPlatformView
 * @function
 * @abstract
 * @instance
 *
 * @param {Boolean} value
 */

/**
 * Callback to execute when the user touches the screen for the first time.
 *
 * @callback
 * @name touchStartCallback
 * @memberof module:soundworks/client.AbstractPlatformView
 *
 * @param {String} password - Password given by the user.
 */
/**
 * Callback to execute when the user clicks the screen for the first time.
 *
 * @callback
 * @name mouseDownCallback
 * @memberof module:soundworks/client.AbstractPlatformView
 */

/**
 * Structure of the definition for the test of a feature.
 *
 * @typedef {Object} module:soundworks/client.Platform~definition
 *
 * @property {String} id - Id of the definition.
 * @property {Function} check - A function that should return `true` if the
 *  feature is available on the platform, `false` otherwise.
 * @property {Function} [startHook] - A function returning a `Promise` to be
 *  executed on start (for example to ask access to microphone or geolocation).
 *  The returned promise should be resolved on `true` is the process succeded or
 *  `false` is the precess failed (e.g. permission not granted).
 * @property {Function} [interactionHook] - A function returning a Promiseto be
 *  executed on the first interaction (i.e. `click` or `touchstart`) of the user
 *  with application (for example, to initialize AudioContext on iOS devices).
 *  The returned promise should be resolved on `true` is the process succeded or
 *  `false` is the precess failed (e.g. permission not granted).
 */
var defaultDefinitions = [{
  id: 'web-audio',
  check: function check() {
    return !!_wavesAudio.audioContext;
  },
  interactionHook: function interactionHook() {
    return _wavesAudio.audioContext.resume().then(function () {
      if (!_client2.default.platform.isMobile) return _promise2.default.resolve(true);

      var g = _wavesAudio.audioContext.createGain();
      g.connect(_wavesAudio.audioContext.destination);
      g.gain.value = 0.000000001; // -180dB ?

      var o = _wavesAudio.audioContext.createOscillator();
      o.connect(g);
      o.frequency.value = 20;
      o.start(0);

      // prevent android to stop audio by keeping the oscillator active
      if (_client2.default.platform.os !== 'android') o.stop(_wavesAudio.audioContext.currentTime + 0.01);

      return _promise2.default.resolve(true);
    });
  }
}, {
  id: 'fix-ios-samplerate',
  check: function check() {
    return true;
  },
  interactionHook: function interactionHook() {
    if (_client2.default.platform.os === 'ios') {
      // in ipod, when the problem occurs, sampleRate has been observed
      // to be set at 16000Hz, as no exhaustive testing has been done
      // assume < 40000 is a bad value.
      var localStorageKey = 'soundworks:fix-ios-samplerate';

      if (_wavesAudio.audioContext.sampleRate < 40000) {
        window.localStorage.setItem(localStorageKey, true);
        window.location.reload(true);
        return;
      }

      var hasReloaded = !!window.localStorage.getItem(localStorageKey);

      if (hasReloaded) {
        window.localStorage.removeItem(localStorageKey);
        _client2.default.platform.hasReloaded = true;
      }
    }

    return _promise2.default.resolve(true);
  }
}, {
  // @note: `touch` feature workaround
  // cf. http://www.stucox.com/blog/you-cant-detect-a-touchscreen/
  id: 'mobile-device',
  check: function check() {
    return _client2.default.platform.isMobile;
  }
}, {
  id: 'audio-input',
  check: function check() {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

    return !!navigator.getUserMedia;
  },
  startHook: function startHook() {
    // @todo - use new navigator.mediaDevices if available
    return new _promise2.default(function (resolve, reject) {
      navigator.getUserMedia({ audio: true }, function (stream) {
        stream.getAudioTracks()[0].stop();
        resolve(true);
      }, function (err) {
        resolve(false);
        throw err;
      });
    });
  }
}, {
  id: 'full-screen',
  check: function check() {
    // functionnality that cannot brake the application
    return true;
  },
  interactionHook: function interactionHook() {
    if (_screenfull2.default.enabled) _screenfull2.default.request();

    return _promise2.default.resolve(true);
  }
}, {
  id: 'geolocation',
  check: function check() {
    return !!navigator.geolocation.getCurrentPosition;
  },
  startHook: function startHook() {
    return new _promise2.default(function (resolve, reject) {
      navigator.geolocation.getCurrentPosition(function (position) {
        // populate client with first value
        var coords = position.coords;
        _client2.default.coordinates = [coords.latitude, coords.longitude];
        _client2.default.geoposition = position;

        resolve(true);
      }, function (err) {
        resolve(false);
        throw err;
      }, {});
    });
  }
}, {
  id: 'geolocation-mock',
  check: function check() {
    return true;
  },
  startHook: function startHook() {
    var lat = Math.random() * 360 - 180;
    var lng = Math.random() * 180 - 90;
    _client2.default.coordinates = [lat, lng];
    return _promise2.default.resolve(true);
  }
}, {
  // adapted from https://github.com/richtr/NoSleep.js/blob/master/NoSleep.js
  // warning: cause 150% cpu use in chrome desktop...
  id: 'wake-lock',
  check: function check() {
    // functionnality that cannot brake the application
    return true;
  },
  interactionHook: function interactionHook() {
    var noSleep = new _NoSleep2.default();
    noSleep.enable();

    return _promise2.default.resolve(true);
  }
}];

var SERVICE_ID = 'service:platform';

/**
 * Interface for the client `'platform'` service.
 *
 * The `platform` services is responsible for giving general informations
 * about the user's device as well as checking availability and providing hooks
 * in order to initialize the features required by the application (audio,
 * microphone, etc.).
 * If one of the required definitions is not available, a view is created with
 * an error message and `client.compatible` is set to `false`.
 *
 * Available built-in definitions are:
 * - 'web-audio'
 * - 'mobile-device': only-accept mobile devices in the application (based on
 *   User-Agent sniffing)
 * - 'audio-input': Android Only
 * - 'full-screen': Android Only, this feature won't block the application if
 *   not available.
 * - 'geolocation': check if the navigator supports geolocation. The `coordinates`
 *   and `geoposition` of the `client` are populated when the plaform service
 *   resolves. (if no update of the coordinates are needed in the application,
 *   requiring geolocation feature without using the Geolocation service should
 *   suffice).
 * - 'wake-lock': use with caution, has been observed consumming
 *   150% cpu in chrome desktop.
 *
 *
 * _<span class="warning">__WARNING__</span> This class should never be
 * instanciated manually_
 *
 * @param {Object} options
 * @param {Array<String>|String} options.features - Id(s) of the feature(s)
 *  required by the application. Available build-in features are:
 *  - 'web-audio'
 *  - 'mobile-device': only accept mobile devices (recognition based User-Agent)
 *  - 'audio-input': Android only
 *  - 'full-screen': Android only
 *  - 'geolocation': accept geolocalized devices. Populate the client with
 *     current position
 *  - 'wake-lock': this feature should be used with caution as
 *     it has been observed to use 150% of cpu in chrome desktop.
 * @param {Boolean} [options.showDialog=true] - If set to `false`, the service
 *  execute all hooks without waiting for a user interaction and doesn't show
 *  the service's view. This option should only be used on controlled
 *  environnements where the target platform is known for working without
 *  this need (e.g. is not iOS).
 *
 * @memberof module:soundworks/client
 * @example
 * // inside the experience constructor
 * this.platform = this.require('platform', { features: 'web-audio' });
 *
 * @see {@link module:soundworks/client.client#platform}
 */

var Platform = function (_Service) {
  (0, _inherits3.default)(Platform, _Service);

  function Platform() {
    (0, _classCallCheck3.default)(this, Platform);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Platform.__proto__ || (0, _getPrototypeOf2.default)(Platform)).call(this, SERVICE_ID, false));

    var defaults = {
      showDialog: true,
      view: null,
      viewPriority: 10
    };

    _this.configure(defaults);

    _this.view = null;

    // this._defaultViewTemplate = defaultViewTemplate;
    // this._defaultViewContent = defaultViewContent;

    _this._requiredFeatures = new _set2.default();
    _this._featureDefinitions = {};

    defaultDefinitions.forEach(function (def) {
      return _this.addFeatureDefinition(def);
    });
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Platform, [{
    key: 'configure',
    value: function configure(options) {
      if (options.features) {
        var features = options.features;

        if (typeof features === 'string') features = [features];

        if (features.indexOf('web-audio') !== -1) features.push('fix-ios-samplerate');

        this.requireFeature.apply(this, (0, _toConsumableArray3.default)(features));

        delete options.features;
      }

      (0, _get3.default)(Platform.prototype.__proto__ || (0, _getPrototypeOf2.default)(Platform.prototype), 'configure', this).call(this, options);
    }

    /**
     *  Start the client.
     *  Algorithm:
     *  - check required features
     *  - if (false)
     *     show 'sorry' screen
     *  - else
     *     show 'welcome' screen
     *     execute start hook (promise)
     *     - if (promise === true)
     *        show touch to start
     *        bind events
     *     - else
     *        show 'sorry' screen
     * @private
     */

  }, {
    key: 'start',
    value: function start() {
      var _this2 = this;

      (0, _get3.default)(Platform.prototype.__proto__ || (0, _getPrototypeOf2.default)(Platform.prototype), 'start', this).call(this);

      this._defineAudioFileExtention();
      this._definePlatform();

      // resolve required features from the application
      _client2.default.compatible = this._checkRequiredFeatures();

      // handle `showDialog === false`
      if (this.options.showDialog === false) {
        if (_client2.default.compatible) {
          var startPromises = this._getHooks('startHook');
          var interactionPromises = this._getHooks('interactionHook');
          var promises = [].concat(startPromises, interactionPromises);

          _promise2.default.all(promises).then(function (results) {
            var resolved = true;
            results.forEach(function (bool) {
              return resolved = resolved && bool;
            });

            if (resolved) _this2.ready();else throw new Error('service:platform - didn\'t obtain the necessary authorizations');
          });
        } else {
          throw new Error('service:platform - client not compatible');
        }
      } else {
        // default view values
        this.view.updateCheckingStatus(false);
        this.view.updateIsCompatibleStatus(null);
        this.view.updateHasAuthorizationsStatus(null);

        if (!_client2.default.compatible) {
          this.view.updateIsCompatibleStatus(false);
          this.show();
        } else {
          this.view.updateIsCompatibleStatus(true);
          this.view.updateCheckingStatus(true);
          this.show();

          // execute start hook
          var _startPromises = this._getHooks('startHook');

          _promise2.default.all(_startPromises).then(function (results) {
            // if one of the start hook failed
            var hasAuthorizations = true;
            results.forEach(function (success) {
              return hasAuthorizations = hasAuthorizations && success;
            });

            _this2.view.updateHasAuthorizationsStatus(hasAuthorizations);
            _this2.view.updateCheckingStatus(false);

            if (hasAuthorizations) {
              // move to 'touchend' and 'mouseup' because 'touchstart' is no
              // longer recognized as a user gesture in android
              // @todo - define what to do with the template...
              // cf. https://docs.google.com/document/d/1oF1T3O7_E4t1PYHV6gyCwHxOi3ystm0eSL5xZu7nvOg/edit#heading=h.qq59ev3u8fba
              _this2.view.$el.addEventListener('touchend', _this2._onInteraction('touch'));
              _this2.view.$el.addEventListener('mouseup', _this2._onInteraction('mouse'));
              // this.view.setTouchStartCallback(this._onInteraction('touch'));
              // this.view.setMouseDownCallback(this._onInteraction('mouse'));
            }
          }).catch(function (err) {
            return console.error(err.stack);
          });
        }
      }
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      this.hide();
      (0, _get3.default)(Platform.prototype.__proto__ || (0, _getPrototypeOf2.default)(Platform.prototype), 'stop', this).call(this);
    }

    /**
     * Structure of the definition for the test of a feature.
     *
     * @param {module:soundworks/client.Platform~definition} obj - Definition of
     *  the feature.
     */

  }, {
    key: 'addFeatureDefinition',
    value: function addFeatureDefinition(obj) {
      this._featureDefinitions[obj.id] = obj;
    }

    /**
     * Require features for the application.
     *
     * @param {...String} features - Id(s) of the feature(s) to be required.
     * @private
     */

  }, {
    key: 'requireFeature',
    value: function requireFeature() {
      var _this3 = this;

      for (var _len = arguments.length, features = Array(_len), _key = 0; _key < _len; _key++) {
        features[_key] = arguments[_key];
      }

      features.forEach(function (id) {
        return _this3._requiredFeatures.add(id);
      });
    }

    /**
     * Execute `interactions` hooks from the `platform` service.
     * Also activate the media according to the `options`.
     *
     * @private
     */

  }, {
    key: '_onInteraction',
    value: function _onInteraction(type) {
      var _this4 = this;

      return function (e) {
        e.preventDefault();
        e.stopPropagation();

        var noSleep = new _NoSleep2.default();
        noSleep.enable();

        _client2.default.platform.interaction = type;
        // execute interaction hooks from the platform
        var interactionPromises = _this4._getHooks('interactionHook');

        _promise2.default.all(interactionPromises).then(function (results) {
          var resolved = true;
          results.forEach(function (bool) {
            return resolved = resolved && bool;
          });

          if (resolved) {
            _this4.ready();
          } else {
            _this4.view.updateHasAuthorizationsStatus(resolved);
          }
        }).catch(function (err) {
          return console.error(err.stack);
        });
      };
    }

    /**
     * Execute all `check` functions defined in the required features.
     *
     * @return {Boolean} - `true` if all checks pass, `false` otherwise.
     * @private
     */

  }, {
    key: '_checkRequiredFeatures',
    value: function _checkRequiredFeatures() {
      var _this5 = this;

      var result = true;

      this._requiredFeatures.forEach(function (feature) {
        var checkFunction = _this5._featureDefinitions[feature].check;

        if (!(typeof checkFunction === 'function')) throw new Error('No check function defined for ' + feature + ' feature');

        result = result && checkFunction();
      });

      return result;
    }

    /** @private */

  }, {
    key: '_getHooks',
    value: function _getHooks(type) {
      var _this6 = this;

      var hooks = [];

      this._requiredFeatures.forEach(function (feature) {
        var hook = _this6._featureDefinitions[feature][type];

        if (hook) hooks.push(hook);
      });

      // return an array of Promises instead of function
      return hooks.map(function (hook) {
        return hook();
      });
    }

    /**
     * Populate `client.platform` with the prefered audio file extention
     * for the platform.
     *
     * @private
     */

  }, {
    key: '_defineAudioFileExtention',
    value: function _defineAudioFileExtention() {
      var a = document.createElement('audio');
      // http://diveintohtml5.info/everything.html
      if (!!(a.canPlayType && a.canPlayType('audio/mpeg;'))) _client2.default.platform.audioFileExt = '.mp3';else if (!!(a.canPlayType && a.canPlayType('audio/ogg; codecs="vorbis"'))) _client2.default.platform.audioFileExt = '.ogg';else _client2.default.platform.audioFileExt = '.wav';
    }

    /**
     * Populate `client.platform` with the os name.
     *
     * @private
     */

  }, {
    key: '_definePlatform',
    value: function _definePlatform() {
      var ua = window.navigator.userAgent;
      var md = new _mobileDetect2.default(ua);

      _client2.default.platform.isMobile = md.mobile() !== null; // true if phone or tablet
      _client2.default.platform.os = function () {
        var os = md.os();

        if (os === 'AndroidOS') return 'android';else if (os === 'iOS') return 'ios';else return 'other';
      }();
    }
  }]);
  return Platform;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Platform);

exports.default = Platform;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/promise":27,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"babel-runtime/helpers/toConsumableArray":40,"mobile-detect":233,"nosleep.js/dist/NoSleep.min":242,"screenfull":248,"waves-audio":322}],291:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _SegmentedView = require('../views/SegmentedView');

var _SegmentedView2 = _interopRequireDefault(_SegmentedView);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:raw-socket';

/**
 * Interface for the `raw-socket` service.
 *
 * This service creates an additionnal native socket with its binary type set
 * to `arraybuffer` and focused on performances.
 * It allows the transfert of `TypedArray` data wrapped with a minimal channel
 * mechanism (up to 256 channels).
 *
 * __*The service must be used with its [server-side counterpart]{@link module:soundworks/server.RawSocket}*__
 *
 * @memberof module:soundworks/client
 */

var RawSocket = function (_Service) {
  (0, _inherits3.default)(RawSocket, _Service);

  function RawSocket() {
    (0, _classCallCheck3.default)(this, RawSocket);

    var _this = (0, _possibleConstructorReturn3.default)(this, (RawSocket.__proto__ || (0, _getPrototypeOf2.default)(RawSocket)).call(this, SERVICE_ID, true));

    var defaults = {
      viewCtor: _SegmentedView2.default,
      viewPriority: 5
    };

    _this.configure(defaults);

    /**
     * Listeners for the incomming messages.
     *
     * @type {Object<String, Set<Function>>}
     * @name _listeners
     * @memberof module:soundworks/server.RawSocket
     * @instance
     * @private
     */
    _this._listeners = {};

    _this._protocol = null;
    _this._onReceiveConnectionInfos = _this._onReceiveConnectionInfos.bind(_this);
    _this._onReceiveAcknoledgement = _this._onReceiveAcknoledgement.bind(_this);
    _this._onMessage = _this._onMessage.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(RawSocket, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'start', this).call(this);
      this.show();

      (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'send', this).call(this, 'request');
      (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'receive', this).call(this, 'infos', this._onReceiveConnectionInfos);
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      this.hide();
      (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'stop', this).call(this);
    }

    /**
     * Method executed when the service receive connection informations from the
     * server.
     *
     * @param {Number} port - Port on which open the new socket.
     * @param {Object} protocol - User-defined protocol to be used in raw socket
     *  exchanges.
     * @param {Number} token - Unique token to retrieve in the first message to
     *  identy the client server-side, allow to match the socket with its
     *  corresponding client.
     *
     * @private
     */

  }, {
    key: '_onReceiveConnectionInfos',
    value: function _onReceiveConnectionInfos(port, protocol, token) {
      var _this2 = this;

      this._protocol = protocol;
      this._channels = protocol.map(function (entry) {
        return entry.channel;
      });

      this.removeListener('connection-infos', this._onReceiveConnectionInfos);

      var socketProtocol = window.location.protocol.replace(/^http?/, 'ws');
      var socketHostname = window.location.hostname;
      var url = socketProtocol + '//' + socketHostname + ':' + port;

      this.socket = new WebSocket(url);
      this.socket.binaryType = 'arraybuffer';
      // send token back to the server and wait for acknoledgement
      var data = new Uint32Array(1);
      data[0] = token;

      this.socket.addEventListener('open', function () {
        _this2.send('service:handshake', data);
      });

      this.socket.addEventListener('message', this._onReceiveAcknoledgement);
    }

    /**
     * Callback executed when the server acknoledges the matching between a
     * client and a socket.
     *
     * @private
     */

  }, {
    key: '_onReceiveAcknoledgement',
    value: function _onReceiveAcknoledgement(e) {
      var index = new Uint8Array(e.data)[0];
      var _protocol$index = this._protocol[index],
          channel = _protocol$index.channel,
          type = _protocol$index.type;

      // ignore incomming messages that could occur if
      // acknoledgement was not yet received

      if (channel === 'service:handshake-ack') {
        this.socket.removeEventListener('message', this._onReceiveAcknoledgement);
        this.socket.addEventListener('message', this._onMessage);
        this.ready();
      }
    }

    /**
     * Callback function of the socket `message` event. Unwrap the channel and
     * the data contained in the payload and execute the registered callback.
     *
     * @private
     */

  }, {
    key: '_onMessage',
    value: function _onMessage(e) {
      var index = new Uint8Array(e.data)[0];

      if (!this._protocol[index]) throw new Error('Invalid protocol index: ' + index);

      var _protocol$index2 = this._protocol[index],
          channel = _protocol$index2.channel,
          type = _protocol$index2.type;

      var viewCtor = window[type + 'Array'];
      var data = new viewCtor(e.data, viewCtor.BYTES_PER_ELEMENT);
      var callbacks = this._listeners[channel];

      if (callbacks) callbacks.forEach(function (callback) {
        return callback(data);
      });
    }

    /**
     * Register a callback to be executed when receiving a message on a specific
     * channel.
     *
     * @param {String} channel - Channel of the message.
     * @param {Function} callback - Callback function.
     */

  }, {
    key: 'receive',
    value: function receive(channel, callback) {
      var listeners = this._listeners;

      if (!listeners[channel]) listeners[channel] = new _set2.default();

      listeners[channel].add(callback);
    }

    /**
     * Send data on a specific channel.
     *
     * @param {String} channel - Channel of the message.
     * @param {TypedArray} data - Data.
     */

  }, {
    key: 'send',
    value: function send(channel, data) {
      var index = this._channels.indexOf(channel);

      if (index === -1) throw new Error('Undefined channel "' + channel + '"');

      var type = this._protocol[index].type;

      var viewCtor = window[type + 'Array'];
      var size = data ? 1 + data.length : 1;
      var view = new viewCtor(size);

      var channelView = new Uint8Array(viewCtor.BYTES_PER_ELEMENT);
      channelView[0] = index;
      // populate buffer
      view.set(new viewCtor(channelView.buffer), 0);

      if (data) view.set(data, 1);

      this.socket.send(view.buffer);
    }
  }]);
  return RawSocket;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, RawSocket);

exports.default = RawSocket;

},{"../core/Service":265,"../core/serviceManager":267,"../views/SegmentedView":300,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],292:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _client = require('../core/client');

var _client2 = _interopRequireDefault(_client);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:shared-config';

/**
 * Interface for the client `'shared-config'` service.
 *
 * The `shared-config` service allows clients to access items of the server
 * configuration.
 * All configuration items retrieved by the server are also stored in the
 * `client.config` attribute.
 *
 * __*The service must be used with its
 * [server-side counterpart]{@link module:soundworks/server.SharedConfig}*__
 *
 * _<span class="warning">__WARNING__</span> This class should never be
 * instanciated manually_
 *
 * @param {Object} options
 * @param {Array<String>} options.items - List of the configuration items
 *  required by the server. The given strings follow a convention defining a path
 *  to the required configuration item.
 *  _example:_ `'setup.area'` will retrieve the value (here an object)
 *  corresponding to the `area` key inside the `setup` entry of the server
 *  configuration.
 *
 * @memberof module:soundworks/client
 * @example
 * // inside the experience constructor
 * this.sharedConfig = this.require('shared-config', { items: ['setup.area'] });
 * // when the experience has started
 * const areaWidth = this.sharedConfig.get('setup.area.width');
 */

var SharedConfig = function (_Service) {
  (0, _inherits3.default)(SharedConfig, _Service);

  function SharedConfig() {
    (0, _classCallCheck3.default)(this, SharedConfig);

    /**
     * Configuration items required by the client.
     * @type {Array}
     * @private
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SharedConfig.__proto__ || (0, _getPrototypeOf2.default)(SharedConfig)).call(this, SERVICE_ID, true));

    _this._items = [];

    /**
     * Object containing all the configuration items shared by the server. The
     * object is flattened in order to minimize the needed communications between
     * the client and the server.
     * @type {Object}
     */
    _this.data = null;

    _this._onConfigResponse = _this._onConfigResponse.bind(_this);
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(SharedConfig, [{
    key: 'configure',
    value: function configure(options) {
      if (options.items) {
        this._items = this._items.concat(options.items);
        delete options.items;
      }

      (0, _get3.default)(SharedConfig.prototype.__proto__ || (0, _getPrototypeOf2.default)(SharedConfig.prototype), 'configure', this).call(this, options);
    }

    /** @private */

  }, {
    key: 'start',
    value: function start() {
      (0, _get3.default)(SharedConfig.prototype.__proto__ || (0, _getPrototypeOf2.default)(SharedConfig.prototype), 'start', this).call(this);

      this.send('request', this._items);
      this.receive('config', this._onConfigResponse);
    }

    /** @private */

  }, {
    key: '_onConfigResponse',
    value: function _onConfigResponse(data) {
      this.data = _client2.default.config = data;
      this.ready();
    }

    /**
     * Retrieve a configuration value from its key, as defined in server side
     * service's `addItem` method or in client-side `items` option.
     *
     * @param {String} item - Key to the configuration item (_ex:_ `'setup.area'`)
     * @return {Mixed}
     */

  }, {
    key: 'get',
    value: function get(item) {
      var parts = item.split('.');
      var tmp = this.data;

      parts.forEach(function (attr) {
        return tmp = tmp[attr];
      });

      return tmp;
    }
  }]);
  return SharedConfig;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, SharedConfig);

exports.default = SharedConfig;

},{"../core/Service":265,"../core/client":266,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],293:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _EventEmitter2 = require('../../utils/EventEmitter');

var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* --------------------------------------------------------- */
/* CONTROL UNITS
/* --------------------------------------------------------- */

/** @private */
var _Param = function (_EventEmitter) {
  (0, _inherits3.default)(_Param, _EventEmitter);

  function _Param(parent, type, name, label) {
    (0, _classCallCheck3.default)(this, _Param);

    var _this = (0, _possibleConstructorReturn3.default)(this, (_Param.__proto__ || (0, _getPrototypeOf2.default)(_Param)).call(this));

    _this.parent = parent;
    _this.type = type;
    _this.name = name;
    _this.label = label;
    _this.value = undefined;
    return _this;
  }

  (0, _createClass3.default)(_Param, [{
    key: 'set',
    value: function set(val) {
      this.value = value;
    }
  }, {
    key: '_propagate',
    value: function _propagate() {
      var sendToServer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.emit('update', this.value); // call event listeners

      if (sendToServer) this.parent.send('update', this.name, this.value); // send to server

      this.parent.emit('update', this.name, this.value); // call parent listeners
    }
  }, {
    key: 'update',
    value: function update(val) {
      var sendToServer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.set(val);
      this._propagate(sendToServer);
    }
  }]);
  return _Param;
}(_EventEmitter3.default);

/** @private */


var _BooleanParam = function (_Param2) {
  (0, _inherits3.default)(_BooleanParam, _Param2);

  function _BooleanParam(parent, name, label, init) {
    (0, _classCallCheck3.default)(this, _BooleanParam);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (_BooleanParam.__proto__ || (0, _getPrototypeOf2.default)(_BooleanParam)).call(this, parent, 'boolean', name, label));

    _this2.set(init);
    return _this2;
  }

  (0, _createClass3.default)(_BooleanParam, [{
    key: 'set',
    value: function set(val) {
      this.value = val;
    }
  }]);
  return _BooleanParam;
}(_Param);

/** @private */


var _EnumParam = function (_Param3) {
  (0, _inherits3.default)(_EnumParam, _Param3);

  function _EnumParam(parent, name, label, options, init) {
    (0, _classCallCheck3.default)(this, _EnumParam);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (_EnumParam.__proto__ || (0, _getPrototypeOf2.default)(_EnumParam)).call(this, parent, 'enum', name, label));

    _this3.options = options;
    _this3.set(init);
    return _this3;
  }

  (0, _createClass3.default)(_EnumParam, [{
    key: 'set',
    value: function set(val) {
      var index = this.options.indexOf(val);

      if (index >= 0) {
        this.index = index;
        this.value = val;
      }
    }
  }]);
  return _EnumParam;
}(_Param);

/** @private */


var _NumberParam = function (_Param4) {
  (0, _inherits3.default)(_NumberParam, _Param4);

  function _NumberParam(parent, name, label, min, max, step, init) {
    (0, _classCallCheck3.default)(this, _NumberParam);

    var _this4 = (0, _possibleConstructorReturn3.default)(this, (_NumberParam.__proto__ || (0, _getPrototypeOf2.default)(_NumberParam)).call(this, parent, 'number', name, label));

    _this4.min = min;
    _this4.max = max;
    _this4.step = step;
    _this4.set(init);
    return _this4;
  }

  (0, _createClass3.default)(_NumberParam, [{
    key: 'set',
    value: function set(val) {
      this.value = Math.min(this.max, Math.max(this.min, val));
    }
  }]);
  return _NumberParam;
}(_Param);

/** @private */


var _TextParam = function (_Param5) {
  (0, _inherits3.default)(_TextParam, _Param5);

  function _TextParam(parent, name, label, init) {
    (0, _classCallCheck3.default)(this, _TextParam);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (_TextParam.__proto__ || (0, _getPrototypeOf2.default)(_TextParam)).call(this, parent, 'text', name, label));

    _this5.set(init);
    return _this5;
  }

  (0, _createClass3.default)(_TextParam, [{
    key: 'set',
    value: function set(val) {
      this.value = val;
    }
  }]);
  return _TextParam;
}(_Param);

/** @private */


var _TriggerParam = function (_Param6) {
  (0, _inherits3.default)(_TriggerParam, _Param6);

  function _TriggerParam(parent, name, label) {
    (0, _classCallCheck3.default)(this, _TriggerParam);
    return (0, _possibleConstructorReturn3.default)(this, (_TriggerParam.__proto__ || (0, _getPrototypeOf2.default)(_TriggerParam)).call(this, parent, 'trigger', name, label));
  }

  (0, _createClass3.default)(_TriggerParam, [{
    key: 'set',
    value: function set(val) {/* nothing to set here */}
  }]);
  return _TriggerParam;
}(_Param);

var SERVICE_ID = 'service:shared-params';

/**
 * Interface for the client `'shared-params'` service.
 *
 * The `shared-params` service is used to maintain and update global parameters
 * used among all connected clients. Each defined parameter can be of the
 * following data types:
 * - boolean
 * - enum
 * - number
 * - text
 * - trigger
 *
 * The parameters are configured in the server side counterpart of the service.
 *
 * To create a control surface from the parameters definitions, a dedicated scene
 * [`BasicSharedController`]{@link module:soundworks/client.BasicSharedController}
 * is available.
 *
 * __*The service must be used along with its
 * [server-side counterpart]{@link module:soundworks/server.SharedParams}*__
 *
 * _<span class="warning">__WARNING__</span> This class should never be
 * instanciated manually_
 *
 * @memberof module:soundworks/client
 *
 * @example
 * // inside the experience constructor
 * this.sharedParams = this.require('shared-params');
 * // when the experience starts, listen for parameter updates
 * this.sharedParams.addParamListener('synth:gain', (value) => {
 *   this.synth.setGain(value);
 * });
 *
 * @see [`BasicSharedController` scene]{@link module:soundworks/client.BasicSharedController}
 */

var SharedParams = function (_Service) {
  (0, _inherits3.default)(SharedParams, _Service);

  function SharedParams() {
    (0, _classCallCheck3.default)(this, SharedParams);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (SharedParams.__proto__ || (0, _getPrototypeOf2.default)(SharedParams)).call(this, SERVICE_ID, true));

    var defaults = {};
    _this7.configure(defaults);

    /**
     * Dictionary of all the parameters and commands.
     * @type {Object}
     * @name params
     * @instance
     * @memberof module:soundworks/client.SharedParams
     *
     * @private
     */
    _this7.params = {};

    _this7._onInitResponse = _this7._onInitResponse.bind(_this7);
    _this7._onUpdateResponse = _this7._onUpdateResponse.bind(_this7);
    return _this7;
  }

  /** @private */


  (0, _createClass3.default)(SharedParams, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(SharedParams.prototype.__proto__ || (0, _getPrototypeOf2.default)(SharedParams.prototype), 'start', this).call(this);

      this.send('request');

      this.receive('init', this._onInitResponse);
      this.receive('update', this._onUpdateResponse);
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      (0, _get3.default)(SharedParams.prototype.__proto__ || (0, _getPrototypeOf2.default)(SharedParams.prototype), 'stop', this).call(this);
      // don't remove 'update' listener, as the control is runnig as a background process
      this.removeListener('init', this._onInitResponse);
    }

    /** @private */

  }, {
    key: '_onInitResponse',
    value: function _onInitResponse(config) {
      var _this8 = this;

      config.forEach(function (entry) {
        var param = _this8._createParam(entry);
        _this8.params[param.name] = param;
      });

      this.ready();
    }

    /** @private */

  }, {
    key: '_onUpdateResponse',
    value: function _onUpdateResponse(name, val) {
      // update, but don't send back to server
      this.update(name, val, false);
    }

    /** @private */

  }, {
    key: '_createParam',
    value: function _createParam(init) {
      var param = null;

      switch (init.type) {
        case 'boolean':
          param = new _BooleanParam(this, init.name, init.label, init.value);
          break;

        case 'enum':
          param = new _EnumParam(this, init.name, init.label, init.options, init.value);
          break;

        case 'number':
          param = new _NumberParam(this, init.name, init.label, init.min, init.max, init.step, init.value);
          break;

        case 'text':
          param = new _TextParam(this, init.name, init.label, init.value);
          break;

        case 'trigger':
          param = new _TriggerParam(this, init.name, init.label);
          break;
      }

      return param;
    }

    /**
     * @callback module:soundworks/client.SharedParams~paramCallback
     * @param {Mixed} value - Updated value of the shared parameter.
     */

    /**
     * Add a listener to listen a specific parameter changes. The listener is
     * executed immediately when added with the parameter current value.
     *
     * @param {String} name - Name of the parameter.
     * @param {module:soundworks/client.SharedParams~paramCallback} listener -
     *  Listener to add.
     */

  }, {
    key: 'addParamListener',
    value: function addParamListener(name, listener) {
      var param = this.params[name];

      if (param) {
        param.addListener('update', listener);

        if (param.type !== 'trigger') listener(param.value);
      } else {
        console.log('unknown param "' + name + '"');
      }
    }

    /**
     * Remove a listener from listening a specific parameter changes.
     *
     * @param {String} name - Name of the parameter.
     * @param {module:soundworks/client.SharedParams~paramCallback} listener -
     *  Listener to remove.
     */

  }, {
    key: 'removeParamListener',
    value: function removeParamListener(name, listener) {
      var param = this.params[name];

      if (param) param.removeListener('update', listener);else console.log('unknown param "' + name + '"');
    }

    /**
     * Get the value of a given parameter.
     *
     * @param {String} name - Name of the parameter.
     * @returns {Mixed} - Current value of the parameter.
     */

  }, {
    key: 'getValue',
    value: function getValue(name) {
      return this.params[name].value;
    }

    /**
     * Update the value of a parameter (used when `options.hasGUI=true`)
     *
     * @param {String} name - Name of the parameter.
     * @param {Mixed} val - New value of the parameter.
     * @param {Boolean} [sendToServer=true] - Flag whether the value should be
     *  propagated to the server.
     */

  }, {
    key: 'update',
    value: function update(name, val) {
      var sendToServer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var param = this.params[name];

      if (param) param.update(val, sendToServer);else console.log('unknown shared parameter "' + name + '"');
    }
  }]);
  return SharedParams;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, SharedParams);

exports.default = SharedParams;

},{"../../utils/EventEmitter":307,"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],294:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _wavesAudio = require('waves-audio');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:shared-recorder';

// const filter = filename => true;

var SharedRecorder = function (_Service) {
  (0, _inherits3.default)(SharedRecorder, _Service);

  function SharedRecorder() {
    (0, _classCallCheck3.default)(this, SharedRecorder);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SharedRecorder.__proto__ || (0, _getPrototypeOf2.default)(SharedRecorder)).call(this, SERVICE_ID));

    var defaults = {
      recorder: false
    };

    _this.configure(defaults);

    _this._rawSocket = _this.require('raw-socket');
    _this._audioBufferManager = _this.require('audio-buffer-manager');
    _this._platfform = null;

    _this._gain = 1;

    _this._listeners = new _map2.default();
    _this._streams = {};
    _this._buffers = {};
    _this._bufferNames = [];

    _this._onAvailableFile = _this._onAvailableFile.bind(_this);
    return _this;
  }

  (0, _createClass3.default)(SharedRecorder, [{
    key: 'configure',
    value: function configure(options) {
      if (options.recorder === true) {
        this._platfform = this.require('platform', {
          features: ['audio-input', 'web-audio']
        });
      }

      (0, _get3.default)(SharedRecorder.prototype.__proto__ || (0, _getPrototypeOf2.default)(SharedRecorder.prototype), 'configure', this).call(this, options);
    }
  }, {
    key: 'start',
    value: function start() {
      (0, _get3.default)(SharedRecorder.prototype.__proto__ || (0, _getPrototypeOf2.default)(SharedRecorder.prototype), 'start', this).call(this);

      this.receive('available-file', this._onAvailableFile);

      // @todo - implement a handshake to notify the server about who
      // is a consumer and who is a recorder.
      this.ready();
    }
  }, {
    key: 'setGain',
    value: function setGain(value) {
      this._gain = value;
    }

    /** Consumer interface */

    /**
     * Get notifications for new available files
     *
     * @param {String} name - Id of the buffer.
     * @param {Number} phase - If ring buffer, phase of the buffer.
     * @param {String} filename - Path of the file on the server.
     */

  }, {
    key: '_onAvailableFile',
    value: function _onAvailableFile(name, phase, filename) {
      var _this2 = this;

      var listener = this._listeners.get(name);

      if (listener) {
        var filter = listener.filter,
            callback = listener.callback;


        if (filter.length === 0 || filter.indexOf(phase) !== -1) {
          var description = (0, _defineProperty3.default)({}, name, (0, _defineProperty3.default)({}, phase, filename));

          this._audioBufferManager.loadFiles(description).then(function () {
            var audioBuffer = _this2._audioBufferManager.get(name, phase);
            callback(audioBuffer, phase);
          }).catch(function (err) {
            return console.error(err.stack);
          });
        }
      }
    }

    /**
     *
     *
     */

  }, {
    key: 'addListener',
    value: function addListener(name, filter, callback) {
      this._listeners.set(name, { filter: filter, callback: callback });
    }
  }, {
    key: 'removeListener',
    value: function removeListener(name) {
      this._listeners.delete(name);
    }

    /** Recorder interface */

  }, {
    key: '_getIndex',
    value: function _getIndex(name) {
      var index = this._bufferNames.indexOf(name);

      if (index === -1) {
        index = this._bufferNames.length;
        this._bufferNames[index] = name;
      }

      return index;
    }

    /**
     * @param {String} name - Name of the record buffer.
     * @param {Number} chunkDuration - Duration of each chunk in second.
     * @param {Number} chunkPeriod - Period between each chunk.
     * @param {Number} numChunks - Number of chunk in the recording.
     * @param {Boolean} cyclic - Define if ring buffer or not.
     */

  }, {
    key: 'createBuffer',
    value: function createBuffer(name, chunkDuration, chunkPeriod, numChunks) {
      var cyclic = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

      // client specific index of the given name
      var index = this._getIndex(name);
      var infos = { index: index, name: name, chunkDuration: chunkDuration, chunkPeriod: chunkPeriod, numChunks: numChunks, cyclic: cyclic };
      var sampleRate = _wavesAudio.audioContext.sampleRate;
      var length = void 0;

      if (!cyclic) length = chunkPeriod * (numChunks - 1) + chunkDuration;else length = chunkPeriod * numChunks;

      infos.length = length * sampleRate;
      infos.sampleRate = sampleRate;

      // keep a local copy of the informations
      this._buffers[name] = infos;
      this.send('create-buffer', infos);
    }
  }, {
    key: 'startRecord',
    value: function startRecord(name) {
      var _this3 = this;

      var infos = this._buffers[name];
      var stream = this._streams[name];

      if (!infos) throw new Error('Cannot start non existing buffer: "' + name + '"');else if (stream) this._disconnectGraph(name);

      var index = infos.index;

      // if not cyclic to be able to stop the record
      if (infos.cyclic === false) infos.pointer = 0;

      // send start message (reinit buffer pointer)
      var msg = new Uint8Array(1);
      msg[0] = index;
      this._rawSocket.send('shared-recorder:start-record', msg);

      // start recording
      var bufferSize = 4096;
      var buffer = new Float32Array(bufferSize + 1);
      buffer[0] = index;

      navigator.getUserMedia({ audio: true }, function (stream) {
        var scriptProcessor = _wavesAudio.audioContext.createScriptProcessor(bufferSize, 1, 1);
        scriptProcessor.connect(_wavesAudio.audioContext.destination);
        scriptProcessor.onaudioprocess = function (e) {
          var data = e.inputBuffer.getChannelData(0);

          if (_this3._gain !== 1) {
            var gain = _this3._gain;
            var length = data.length;

            for (var i = 0; i < length; i++) {
              data[i] *= gain;
            }
          }

          buffer.set(data, 1);
          _this3._rawSocket.send('shared-recorder:new-block', buffer);

          // maintain a local pointer to trigger `stopRecord` at the end of the buffer
          if (infos.cyclic === false) {
            infos.pointer += bufferSize;

            if (infos.pointer >= infos.length) _this3._disconnectGraph(infos.name);
          }
        };

        var audioIn = _wavesAudio.audioContext.createMediaStreamSource(stream);
        audioIn.connect(scriptProcessor);

        _this3._streams[name] = { stream: stream, audioIn: audioIn, scriptProcessor: scriptProcessor };
      }, function (err) {
        console.error(err.stack);
      });
    }

    /**
     * @param {String} name - Name of the buffer.
     */

  }, {
    key: 'stopRecord',
    value: function stopRecord(name) {
      if (!this._streams[name]) return;

      // send stop message
      var index = this._getIndex(name);
      var msg = new Uint8Array(1);
      msg[0] = index;
      this._rawSocket.send('shared-recorder:stop-record', msg);

      this._disconnectGraph(name);
    }
  }, {
    key: '_disconnectGraph',
    value: function _disconnectGraph(name) {
      var _streams$name = this._streams[name],
          stream = _streams$name.stream,
          audioIn = _streams$name.audioIn,
          scriptProcessor = _streams$name.scriptProcessor;

      scriptProcessor.disconnect();
      audioIn.disconnect();

      stream.getTracks()[0].stop();
      delete this._streams[name];
    }
  }]);
  return SharedRecorder;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, SharedRecorder);

exports.default = SharedRecorder;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/map":19,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/defineProperty":34,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"waves-audio":322}],295:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _wavesAudio = require('waves-audio');

var _SegmentedView = require('../views/SegmentedView');

var _SegmentedView2 = _interopRequireDefault(_SegmentedView);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _client = require('sync/client');

var _client2 = _interopRequireDefault(_client);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:sync';

/**
 * Interface for the client `'sync'` service.
 *
 * The `sync` service synchronizes the local audio clock of the client with the
 * clock of the server (master clock). It internally relies on the `WebAudio`
 * clock and then requires the `platform` service to access this feature.
 *
 * __*The service must be used with its
 * [server-side counterpart]{@link module:soundworks/server.Sync}*__
 *
 * _<span class="warning">__WARNING__</span> This class should never be
 * instanciated manually_
 *
 * _Note:_ the service is based on
 * [`github.com/collective-soundworks/sync`](https://github.com/collective-soundworks/sync).
 *
 * @memberof module:soundworks/client
 *
 * @example
 * // inside the experience constructor
 * this.sync = this.require('sync');
 * // when the experience has started, translate the sync time in local time
 * const syncTime = this.sync.getSyncTime();
 * const localTime = this.sync.getAudioTime(syncTime);
 */

var Sync = function (_Service) {
  (0, _inherits3.default)(Sync, _Service);

  function Sync() {
    (0, _classCallCheck3.default)(this, Sync);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Sync.__proto__ || (0, _getPrototypeOf2.default)(Sync)).call(this, SERVICE_ID, true));

    var defaults = {
      viewPriority: 3,
      useAudioTime: true
      // @todo - add options to configure the sync service
    };

    _this.configure(defaults);

    var getTime = _this.options.useAudioTime ? function () {
      return _wavesAudio.audioContext.currentTime;
    } : function () {
      return new Date().getTime() * 0.001;
    };

    _this._sync = new _client2.default(getTime);
    _this._ready = false;

    _this.require('platform', { features: 'web-audio' });

    _this._syncStatusReport = _this._syncStatusReport.bind(_this);
    _this._reportListeners = [];
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Sync, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      (0, _get3.default)(Sync.prototype.__proto__ || (0, _getPrototypeOf2.default)(Sync.prototype), 'start', this).call(this);
      this.show();

      var sendFunction = function sendFunction() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this2.send.apply(_this2, ['ping'].concat(args));
      };
      var receiveFunction = function receiveFunction(callback) {
        return _this2.receive('pong', callback);
      };

      this._sync.start(sendFunction, receiveFunction, this._syncStatusReport);
    }

    /** @private */

  }, {
    key: 'stop',
    value: function stop() {
      this.hide();
      (0, _get3.default)(Sync.prototype.__proto__ || (0, _getPrototypeOf2.default)(Sync.prototype), 'stop', this).call(this);
    }

    /**
     * Return the time in the local clock. If no arguments provided,
     * returns the current local time.
     * @param {Number} syncTime - Time from the sync clock (in _seconds_).
     * @return {Number} - Local time corresponding to the given
     *  `syncTime` (in _seconds_).
     */

  }, {
    key: 'getAudioTime',
    value: function getAudioTime(syncTime) {
      return this._sync.getLocalTime(syncTime);
    }
  }, {
    key: 'getLocalTime',
    value: function getLocalTime(syncTime) {
      return this._sync.getLocalTime(syncTime);
    }

    /**
     * Return the time in the sync clock. If no arguments provided,
     * returns the current sync time.
     * @param {Number} audioTime - Time from the local clock (in _seconds_).
     * @return {Number} - Sync time corresponding to the given
     *  `audioTime` (in _seconds_).
     */

  }, {
    key: 'getSyncTime',
    value: function getSyncTime(audioTime) {
      return this._sync.getSyncTime(audioTime);
    }

    /**
     * Add a callback function to the synchronization reports from the server.
     * @param {Function} callback
     */

  }, {
    key: 'addListener',
    value: function addListener(callback) {
      this._reportListeners.push(callback);
    }
  }, {
    key: '_syncStatusReport',
    value: function _syncStatusReport(report) {
      if (report.status === 'training' || report.status === 'sync') {
        this._reportListeners.forEach(function (callback) {
          return callback(report);
        });

        if (!this._ready) {
          this._ready = true;
          this.ready();
        }
      }
    }
  }]);
  return Sync;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, Sync);

exports.default = Sync;

},{"../core/Service":265,"../core/serviceManager":267,"../views/SegmentedView":300,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"sync/client":311,"waves-audio":322}],296:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _wavesAudio = require('waves-audio');

var audio = _interopRequireWildcard(_wavesAudio);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioScheduler = audio.getScheduler();

var SyncTimeSchedulingQueue = function (_audio$SchedulingQueu) {
  (0, _inherits3.default)(SyncTimeSchedulingQueue, _audio$SchedulingQueu);

  function SyncTimeSchedulingQueue(sync, scheduler) {
    (0, _classCallCheck3.default)(this, SyncTimeSchedulingQueue);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SyncTimeSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(SyncTimeSchedulingQueue)).call(this));

    _this.sync = sync;
    _this.scheduler = scheduler;
    _this.scheduler.add(_this, Infinity);
    _this.nextSyncTime = Infinity;

    // call this.resync in sync callback
    _this.resync = _this.resync.bind(_this);
    _this.sync.addListener(_this.resync);
    return _this;
  }

  (0, _createClass3.default)(SyncTimeSchedulingQueue, [{
    key: 'advanceTime',
    value: function advanceTime(audioTime) {
      var nextSyncTime = (0, _get3.default)(SyncTimeSchedulingQueue.prototype.__proto__ || (0, _getPrototypeOf2.default)(SyncTimeSchedulingQueue.prototype), 'advanceTime', this).call(this, this.nextSyncTime);
      var nextAudioTime = this.sync.getAudioTime(nextSyncTime);

      this.nextSyncTime = nextSyncTime;

      return nextAudioTime;
    }
  }, {
    key: 'resetTime',
    value: function resetTime(syncTime) {
      if (syncTime === undefined) syncTime = this.sync.getSyncTime();

      this.nextSyncTime = syncTime;

      var audioTime = this.sync.getAudioTime(syncTime);
      this.master.resetEngineTime(this, audioTime);
    }
  }, {
    key: 'resync',
    value: function resync() {
      if (this.nextSyncTime !== Infinity) {
        var nextAudioTime = this.sync.getAudioTime(this.nextSyncTime);
        this.master.resetEngineTime(this, nextAudioTime);
      } else {
        this.master.resetEngineTime(this, Infinity);
      }
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.sync.getSyncTime(this.scheduler.currentTime);
    }
  }]);
  return SyncTimeSchedulingQueue;
}(audio.SchedulingQueue);

var SERVICE_ID = 'service:sync-scheduler';

/**
 * Interface for the client `'sync-scheduler'` service.
 *
 * The `sync-scheduler` provides a scheduler synchronised among all client using the
 * [`sync`]{@link module:soundworks/client.Sync} service.
 *
 * While this service has no direct server counterpart, its dependency on the
 * [`sync`]{@link module:soundworks/client.Sync} service which requires the
 * existence of a server.
 *
 * @param {Object} options
 * @param {Number} [options.period] - Period of the scheduler (defauts to
 *  current value).
 * @param {Number} [options.lookahead] - Lookahead of the scheduler (defauts
 *  to current value).
 *
 * @memberof module:soundworks/client
 * @see [`wavesAudio.Scheduler`]{@link http://wavesjs.github.io/audio/#audio-scheduler}
 * @see [`platform` service]{@link module:soundworks/client.Platform}
 * @see [`sync` service]{@link module:soundworks/client.Sync}
 *
 * @example
 * // inside the experience constructor
 * this.syncScheduler = this.require('scheduler');
 *
 * // when the experience has started
 * const nextSyncTime = this.syncScheduler.current + 2;
 * this.syncScheduler.add(timeEngine, nextSyncTime);
 */

var SyncScheduler = function (_Service) {
  (0, _inherits3.default)(SyncScheduler, _Service);

  /** _<span class="warning">__WARNING__</span> This class should never be instanciated manually_ */
  function SyncScheduler() {
    (0, _classCallCheck3.default)(this, SyncScheduler);

    // initialize sync option
    var _this2 = (0, _possibleConstructorReturn3.default)(this, (SyncScheduler.__proto__ || (0, _getPrototypeOf2.default)(SyncScheduler)).call(this, SERVICE_ID, false));

    _this2._sync = null;
    _this2._syncedQueue = null;

    // init audio time based scheduler, sync service, and queue
    _this2._platform = _this2.require('platform', { features: 'web-audio' });
    _this2._sync = _this2.require('sync');
    _this2._syncedQueue = null;
    return _this2;
  }

  /** @private */


  (0, _createClass3.default)(SyncScheduler, [{
    key: 'start',
    value: function start() {
      (0, _get3.default)(SyncScheduler.prototype.__proto__ || (0, _getPrototypeOf2.default)(SyncScheduler.prototype), 'start', this).call(this);

      this._syncedQueue = new SyncTimeSchedulingQueue(this._sync, audioScheduler);
      this.ready();
    }

    /**
     * Current audio time of the scheduler.
     * @instance
     * @type {Number}
     */

  }, {
    key: 'getSyncTimeAtAudioTime',


    /**
     * Get sync time corresponding to given audio time.
     *
     * @param  {Number} audioTime - audio time.
     * @return {Number} - sync time corresponding to given audio time.
     */
    value: function getSyncTimeAtAudioTime(audioTime) {
      return this._sync.getSyncTime(audioTime);
    }

    /**
     * Get audio time corresponding to given sync time.
     *
     * @param  {Number} syncTime - sync time.
     * @return {Number} - audio time corresponding to given sync time.
     */

  }, {
    key: 'getAudioTimeAtSyncTime',
    value: function getAudioTimeAtSyncTime(syncTime) {
      return this._sync.getAudioTime(syncTime);
    }

    /**
     * Call a function at a given time.
     *
     * @param {Function} fun - Function to be deferred.
     * @param {Number} time - The time at which the function should be executed.
     * @param {Boolean} [lookahead=false] - Defines whether the function is called
     *  anticipated (e.g. for audio events) or precisely at the given time (default).
     */

  }, {
    key: 'defer',
    value: function defer(fun, time) {
      var lookahead = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var scheduler = this._syncedQueue;
      var schedulerService = this;
      var engine = void 0;

      if (lookahead) {
        scheduler.defer(fun, time);
      } else {
        engine = {
          advanceTime: function advanceTime(time) {
            var delta = schedulerService.deltaTime;

            if (delta > 0) setTimeout(fun, 1000 * delta, time); // bridge scheduler lookahead with timeout
            else fun(time);
          }
        };

        scheduler.add(engine, time); // add without checks
      }
    }

    /**
     * Add a time engine to the queue.
     *
     * @param {Function} engine - Engine to schedule.
     * @param {Number} time - The time at which the function should be executed.
     */

  }, {
    key: 'add',
    value: function add(engine, time) {
      this._syncedQueue.add(engine, time);
    }

    /**
     * Remove the given engine from the queue.
     *
     * @param {Function} engine - Engine to remove from the scheduler.
     */

  }, {
    key: 'remove',
    value: function remove(engine) {
      this._syncedQueue.remove(engine);
    }

    /**
     * Remove all scheduled functions and time engines from the scheduler.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this._syncedQueue.clear();
    }
  }, {
    key: 'audioTime',
    get: function get() {
      return audioScheduler.currentTime;
    }

    /**
     * Current sync time of the scheduler.
     * @instance
     * @type {Number}
     */

  }, {
    key: 'syncTime',
    get: function get() {
      return this._syncedQueue.currentTime;
    }

    /**
     * Current sync time of the scheduler (alias `this.syncTime`).
     * @instance
     * @type {Number}
     */

  }, {
    key: 'currentTime',
    get: function get() {
      return this._syncedQueue.currentTime;
    }

    /**
     * Difference between the scheduler's logical audio time and the `currentTime`
     * of the audio context.
     * @instance
     * @type {Number}
     */

  }, {
    key: 'deltaTime',
    get: function get() {
      return audioScheduler.currentTime - audio.audioContext.currentTime;
    }
  }]);
  return SyncScheduler;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, SyncScheduler);

exports.default = SyncScheduler;

},{"../core/Service":265,"../core/serviceManager":267,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"waves-audio":322}],297:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class to extend in order to be used in conjonction with a
 * [`CanvasView`]{@link module:soundworks/client.CanvasView}. These classes
 * provide altogether a clean way to manage the `update` and `render` cycles
 * of an animation.
 *
 * @param {Number} [updatePeriod=0] - Logical time (in _second_) between
 *  each subsequent updates. If `0`, the update period is slaved on the
 *  `requestAnimationFrame` period (which is appriopriate for most of the
 *  use-cases).
 *
 * @memberof module:soundworks/client
 * @see {@link module:soundworks/client.CanvasView}
 */
var Canvas2dRenderer = function () {
  function Canvas2dRenderer() {
    var updatePeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    (0, _classCallCheck3.default)(this, Canvas2dRenderer);

    this.updatePeriod = updatePeriod;

    /**
     * Current (logical) time of the Canvas2dRenderer.
     *
     * @type {Number}
     * @name currentTime
     * @instance
     * @memberof module:soundworks/client.Canvas2dRenderer
     * @readonly
     */
    this.currentTime = null;

    /**
     * Current width of the canvas.
     *
     * @type {Number}
     * @name canvasWidth
     * @instance
     * @memberof module:soundworks/client.Canvas2dRenderer
     * @readonly
     */
    this.canvasWidth = 0;

    /**
     * Current height of the canvas.
     *
     * @type {Number}
     * @name canvasHeight
     * @instance
     * @memberof module:soundworks/client.Canvas2dRenderer
     * @readonly
     */
    this.canvasHeight = 0;

    /**
     * Orientation of the canvas.
     *
     * @type {String}
     * @name orientation
     * @instance
     * @memberof module:soundworks/client.Canvas2dRenderer
     * @readonly
     */
    this.orientation = null;
  }

  /** @private */


  (0, _createClass3.default)(Canvas2dRenderer, [{
    key: "onResize",
    value: function onResize(canvasWidth, canvasHeight, orientation) {
      this.canvasWidth = canvasWidth;
      this.canvasHeight = canvasHeight;
      this.orientation = orientation;
    }

    /**
     * Interface method called when the instance is added to a `CanvasView`.
     * `this.canvasWidth` and `this.canvasHeight` should be available at this
     * point.
     */

  }, {
    key: "init",
    value: function init() {}

    /**
     * Interface method that should host the code that updates the properties
     * of the Canvas2dRenderer (physics, etc.)
     *
     * @param {Number} dt - Logical time since the last update. If
     *  `this.updatePeriod` is equal to zero 0, `dt` is the elasped time since
     *  the last render.
     */

  }, {
    key: "update",
    value: function update(dt) {}

    /**
     * Interface method that should host the code that draw into the canvas.
     *
     * @param {CanvasRenderingContext2D} ctx - 2d context of the canvas.
     */

  }, {
    key: "render",
    value: function render(ctx) {}
  }]);
  return Canvas2dRenderer;
}();

exports.default = Canvas2dRenderer;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],298:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Rendering loop handling the `requestAnimationFrame` and the `update` /
 * `render` cycles.
 *
 * @private
 */
var loop = {
  renderingGroups: [],

  _isRunning: false,

  /**
   * @return {Number} - Current time in seconds.
   */
  getTime: function getTime() {
    return 0.001 * (window.performance && window.performance.now ? window.performance.now() : new Date().getTime());
  },


  /**
   * Start the rendering loop if not started.
   */
  requireStart: function requireStart() {
    if (this._isRunning) {
      return;
    }
    this._isRunning = true;
    this.lastRenderTime = this.getTime();

    (function (self) {
      function loop() {
        var time = self.getTime();
        var dt = time - self.lastRenderTime;
        var renderingGroups = self.renderingGroups;

        for (var i = 0, l = renderingGroups.length; i < l; i++) {
          var group = renderingGroups[i];
          // let the group handle the updatePeriod of each renderer
          group.update(time, dt);
          group.render(dt); // forward `dt` for `preRender` method
        }

        self.lastRenderTime = time;
        self.rAFid = requestAnimationFrame(loop);
      }

      self.rAFid = requestAnimationFrame(loop);
    })(this);
  },


  /**
   * Stop the loop if no renderer are still present. If not abort.
   */
  requireStop: function requireStop() {
    // @todo - handle several parallel groups
    var shouldStop = true;

    for (var i = 0, l = this.renderingGroups.length; i < l; i++) {
      if (this.renderingGroups[i].renderers.length > 0) {
        shouldStop = false;
      }
    }

    if (shouldStop) {
      cancelAnimationFrame(this.rAFid);
      this._isRunning = false;
    }
  },


  /**
   * Add a rendering group to the loop.
   */
  registerRenderingGroup: function registerRenderingGroup(group) {
    this.renderingGroups.push(group);
  }
};

/**
 * Handle a group of renderers on a single full screen canvas.
 *
 * <span class="warning">This class is a property of
 * {@link module:soundworks/client.CanvasView} should be considered private.</span>
 *
 * @param {CanvasRenderingContext2D} ctx - Canvas context in which
 *  the renderer should draw.
 * @param {Boolean} [preservePixelRatio=false] - Define if the canvas should
 *  take account of the device pixel ratio for the drawing. When set to `true`,
 *  quality if favored over performance.
 *
 * @memberof module:soundworks/client
 */

var Canvas2dRenderingGroup = function () {
  function Canvas2dRenderingGroup(ctx) {
    var preservePixelRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var skipFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    (0, _classCallCheck3.default)(this, Canvas2dRenderingGroup);

    /**
     * 2d context of the canvas.
     *
     * @type {CanvasRenderingContext2D}
     * @name ctx
     * @instance
     * @memberof module:soundworks/client.Canvas2dRenderingGroup
     */
    this.ctx = ctx;

    /**
     * Stack of the registered renderers.
     *
     * @type {Array<module:soundworks/client.Renderer>}
     * @name renderers
     * @instance
     * @memberof module:soundworks/client.Canvas2dRenderingGroup
     */
    this.renderers = [];

    /**
     * Hooks executed at the beginning and end of each rAF call.
     * @private
     */
    this.preRender = null;
    this.postRender = null;

    /**
     * Pixel ratio of the device, set to 1 if `false`.
     *
     * @type {Number}
     * @name pixelRatio
     * @instance
     * @memberof module:soundworks/client.Canvas2dRenderingGroup
     */
    this.pixelRatio = function (ctx) {
      var dPR = window.devicePixelRatio || 1;
      var bPR = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

      return preservePixelRatio ? dPR / bPR : 1;
    }(this.ctx);

    this.frameCount = 0;
    this.frameModulo = skipFrames + 1;
    this.accumDt = 0;

    // register the group into the loop
    loop.registerRenderingGroup(this);
  }

  /**
   * Updates the size of the canvas. Propagate new logical `width` and `height`
   * according to `this.pixelRatio` to all registered renderers.
   *
   * @param {Number} viewportWidth - Width of the viewport.
   * @param {Number} viewportHeight - Height of the viewport.
   * @param {Number} orientation - Orientation of the viewport.
   */


  (0, _createClass3.default)(Canvas2dRenderingGroup, [{
    key: "onResize",
    value: function onResize(viewportWidth, viewportHeight, orientation) {
      var ctx = this.ctx;
      var pixelRatio = this.pixelRatio;

      this.canvasWidth = viewportWidth * pixelRatio;
      this.canvasHeight = viewportHeight * pixelRatio;
      this.orientation = orientation;

      ctx.canvas.width = this.canvasWidth;
      ctx.canvas.height = this.canvasHeight;
      ctx.canvas.style.width = viewportWidth + "px";
      ctx.canvas.style.height = viewportHeight + "px";

      // propagate logical size to renderers
      for (var i = 0, l = this.renderers.length; i < l; i++) {
        this.renderers[i].onResize(this.canvasWidth, this.canvasHeight, orientation);
      }
    }

    /**
     * Propagate `update` to all registered renderers. The `update` method
     * for each renderer is called according to their update period.
     *
     * @param {Number} time - Current time.
     * @param {Number} dt - Delta time in seconds since last update.
     */

  }, {
    key: "update",
    value: function update(time, dt) {
      var renderers = this.renderers;

      for (var i = 0, l = renderers.length; i < l; i++) {
        var renderer = renderers[i];
        var updatePeriod = renderer.updatePeriod;

        if (updatePeriod === 0) {
          renderer.update(dt);
          renderer.currentTime = time;
        } else {
          while (renderer.currentTime < time) {
            renderer.update(updatePeriod);
            renderer.currentTime += updatePeriod;
          }
        }
      }
    }

    /**
     * Propagate `render` to all the registered renderers.
     *
     * @param {Number} dt - Delta time in seconds since the last
     *  `requestAnimationFrame` call.
     */

  }, {
    key: "render",
    value: function render(dt) {
      var accumDt = this.accumDt + dt;

      if (this.frameCount === 0) {
        var ctx = this.ctx,
            renderers = this.renderers;


        if (this.preRender !== null) this.preRender(ctx, accumDt, this.canvasWidth, this.canvasHeight);

        for (var i = 0, l = renderers.length; i < l; i++) {
          renderers[i].render(ctx);
        }if (this.postRender !== null) this.postRender(ctx, accumDt, this.canvasWidth, this.canvasHeight);

        accumDt = 0;
      }

      this.frameCount = (this.frameCount + 1) % this.frameModulo;
      this.accumDt = accumDt;
    }

    /**
     * Add a `Renderer` instance to the group.
     *
     * @param {module:soundworks/client.Renderer} renderer - Renderer to add to
     *  the group.
     */

  }, {
    key: "add",
    value: function add(renderer) {
      this.renderers.push(renderer);
      this.currentTime = loop.getTime();
      // update the current time of the renderer
      renderer.currentTime = this.currentTime;
      renderer.pixelRatio = this.pixelRatio;
      renderer.onResize(this.canvasWidth, this.canvasHeight, this.orientation);
      renderer.init();
      // if first renderer added, start the loop
      if (this.renderers.length === 1) loop.requireStart();
    }

    /**
     * Remove a `Renderer` instance from the group.
     *
     * @param {module:soundworks/client.Renderer} renderer - Renderer to remove
     *  from the group.
     */

  }, {
    key: "remove",
    value: function remove(renderer) {
      var index = this.renderers.indexOf(renderer);

      if (index !== -1) {
        this.renderers.splice(index, 1);
        // if last renderer removed, stop the loop
        if (this.renderers.length === 0) loop.requireStop();
      }
    }
  }]);
  return Canvas2dRenderingGroup;
}();

exports.default = Canvas2dRenderingGroup;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],299:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _SegmentedView2 = require('./SegmentedView');

var _SegmentedView3 = _interopRequireDefault(_SegmentedView2);

var _CanvasRenderingGroup = require('./CanvasRenderingGroup');

var _CanvasRenderingGroup2 = _interopRequireDefault(_CanvasRenderingGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultCanvasTemplate = '\n  <canvas class="background"></canvas>\n  <div class="foreground">\n    <div class="section-top flex-middle"><%= top %></div>\n    <div class="section-center flex-center"><%= center %></div>\n    <div class="section-bottom flex-middle"><%= bottom %></div>\n  </div>\n';

/**
 * View designed for experiences where 2d graphical rendering is needed.
 * The view is basically a `SegmentedView` with a `canvas` element in
 * the background and a set of helpers to handle the __renderers__ (objects
 * that draw something into the canvas).
 *
 * _<span class="warning">__WARNING__</span> Views should preferably by
 * created using the [`Experience#createView`]{@link module:soundworks/client.Experience#createView}
 * method._
 *
 * @param {String} template - Template of the view.
 * @param {Object} content - Object containing the variables used to populate
 *  the template. {@link module:soundworks/client.View#content}.
 * @param {Object} events - Listeners to install in the view
 *  {@link module:soundworks/client.View#events}.
 * @param {Object} options - Options of the view.
 *  {@link module:soundworks/client.View#options}.
 *
 * @memberof module:soundworks/client
 * @extends {module:soundworks/client.SegmentedView}
 *
 * @see {@link module:soundworks/client.View}
 * @see {@link module:soundworks/client.Renderer}
 */

var CanvasView = function (_SegmentedView) {
  (0, _inherits3.default)(CanvasView, _SegmentedView);

  function CanvasView(template, content, events, options) {
    (0, _classCallCheck3.default)(this, CanvasView);

    template = template || defaultCanvasTemplate;
    options = (0, _assign2.default)({
      preservePixelRatio: false,
      skipFrames: 0
    }, options);

    /**
     * Temporary stack the renderers when the view is not visible.
     *
     * @type {Set}
     * @name _rendererStack
     * @instance
     * @memberof module:soundworks/client.CanvasView
     * @private
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (CanvasView.__proto__ || (0, _getPrototypeOf2.default)(CanvasView)).call(this, template, content, events, options));

    _this._rendererStack = new _set2.default();

    /**
     * Flag to track the first `onRender` call.
     *
     * @type {Boolean}
     * @name _hasRenderedOnce
     * @instance
     * @memberof module:soundworks/client.CanvasView
     * @private
     */
    _this._hasRenderedOnce = false;

    /**
     * Default rendering group.
     *
     * @type {module:soundworks/client.CanvasRenderingGroup}
     * @name _renderingGroup
     * @instance
     * @memberof module:soundworks/client.CanvasView
     * @private
     */
    _this._renderingGroup = null;

    /**
     * Canvas DOM element to draw into.
     *
     * @type {Element}
     * @name $canvas
     * @instance
     * @memberof module:soundworks/client.$canvas
     */
    _this.$canvas = null;

    /**
     * 2d context of the canvas.
     *
     * @type {CanvasRenderingContext2D}
     * @name $canvas
     * @instance
     * @memberof module:soundworks/client.$canvas
     */
    _this.ctx = null;
    return _this;
  }

  (0, _createClass3.default)(CanvasView, [{
    key: 'onRender',


    /** @private */
    value: function onRender() {
      (0, _get3.default)(CanvasView.prototype.__proto__ || (0, _getPrototypeOf2.default)(CanvasView.prototype), 'onRender', this).call(this);

      this.$canvas = this.$el.querySelector('canvas');
      this.ctx = this.$canvas.getContext('2d');

      // update the rendering group if the canvas instance has changed after a render
      if (this._renderingGroup) this._renderingGroup.ctx = this.ctx;

      if (!this._hasRenderedOnce) {
        var preservePixelRatio = this.options.preservePixelRatio;
        var skipFrames = this.options.skipFrames;
        this._renderingGroup = new _CanvasRenderingGroup2.default(this.ctx, preservePixelRatio, skipFrames);

        // prevent creating a new rendering group each time the view is re-rendered
        this._hasRenderedOnce = true;
        this.init();
      }
    }

    /**
     * Entry point called when the renderingGroup for the view is ready.
     * Basically allows to instanciate some renderers from inside the view.
     */

  }, {
    key: 'init',
    value: function init() {}

    /** @private */

  }, {
    key: 'onResize',
    value: function onResize(viewportWidth, viewportHeight, orientation) {
      var _this2 = this;

      (0, _get3.default)(CanvasView.prototype.__proto__ || (0, _getPrototypeOf2.default)(CanvasView.prototype), 'onResize', this).call(this, viewportWidth, viewportHeight, orientation);
      this._renderingGroup.onResize(viewportWidth, viewportHeight, orientation);

      // add stacked renderers to the rendering group
      this._rendererStack.forEach(function (renderer) {
        return _this2._renderingGroup.add(renderer);
      });
      this._rendererStack.clear();
    }

    /**
     * Callback executed at the beginning of each `requestAnimationFrame`
     * cycle, before the execution of the renderers.
     * @callback module:soundworks/client.CanvasView~preRenderer
     *
     * @param {CanvasRenderingContext2D} ctx - Context of the canvas.
     * @param {Number} dt - Delta time in seconds since last rendering.
     * @param {Number} canvasWidth - Current width of the canvas.
     * @param {Number} canvasHeight - Current height of the canvas.
     */
    /**
     * Register a function to execute at the beginning of each
     * `requestAnimationFrame` cycle.
     *
     * @param {module:soundworks/client.CanvasView~preRenderer} callback -
     *  Function to execute before each rendering cycle.
     */

  }, {
    key: 'setPreRender',
    value: function setPreRender(callback) {
      this._renderingGroup.preRender = callback;
    }

    /**
     * Callback executed at the end of each `requestAnimationFrame`
     * cycle, after the execution of the renderers.
     * @callback module:soundworks/client.CanvasView~postRenderer
     *
     * @param {CanvasRenderingContext2D} ctx - Context of the canvas.
     * @param {Number} dt - Delta time in seconds since last rendering.
     * @param {Number} canvasWidth - Current width of the canvas.
     * @param {Number} canvasHeight - Current height of the canvas.
     */
    /**
     * Register a function to execute at the end of each
     * `requestAnimationFrame` cycle.
     *
     * @param {module:soundworks/client.CanvasView~postRenderer} callback -
     *  Function to execute before each rendering cycle.
     */

  }, {
    key: 'setPostRender',
    value: function setPostRender(callback) {
      this._renderingGroup.postRender = callback;
    }

    /**
     * Add a renderer to the `RenderingGroup`. The renderer is automatically
     * activated when added to the group.
     *
     * @param {module:soundworks/client.Renderer} renderer - Renderer to add.
     */

  }, {
    key: 'addRenderer',
    value: function addRenderer(renderer) {
      if (this.isVisible) this._renderingGroup.add(renderer);else this._rendererStack.add(renderer);
    }

    /**
     * Remove a renderer from the `RenderingGroup`. The renderer is automatically
     * disactivated when removed from the group.
     *
     * @param {module:soundworks/client.Renderer} renderer - Renderer to remove.
     */

  }, {
    key: 'removeRenderer',
    value: function removeRenderer(renderer) {
      if (this.isVisible) this._renderingGroup.remove(renderer);else this._rendererStack.delete(renderer);
    }
  }, {
    key: 'pixelRatio',
    get: function get() {
      return this._renderingGroup.pixelRatio;
    }
  }]);
  return CanvasView;
}(_SegmentedView3.default);

exports.default = CanvasView;

},{"./CanvasRenderingGroup":298,"./SegmentedView":300,"babel-runtime/core-js/object/assign":20,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],300:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _View2 = require('./View');

var _View3 = _interopRequireDefault(_View2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultTemplate = '\n  <div class="section-top flex-middle"><p><%= top %></p></div>\n  <div class="section-center flex-center"><p><%= center %></p></div>\n  <div class="section-bottom flex-middle"><p><%= bottom %></p></div>\n';

/**
 * Create views which keep defined vertical ratios among elements. These ratios
 * are kept between the different parts in portrait and landscape orientation.
 * The default Segmented view defines a layout with 3 verticals parts.
 *
 * Others ratios can be defined by creating a new template and defining the
 * ratios of the different elements by overriding the `ratio` option.
 * The sum of all the ratios should be equal to 1.
 *
 * _<span class="warning">__WARNING__</span> Views should be created using
 * {@link module:soundworks/client.Activity#createView} method._
 *
 * @param {String} template - Template of the view.
 * @param {Object} content - Object containing the variables used to populate
 *  the template. {@link module:soundworks/client.View#content}.
 * @param {Object} events - Event listeners to install to the view
 *  {@link module:soundworks/client.View#events}.
 * @param {Object} options - Options of the view.
 *  {@link module:soundworks/client.View#options}.
 *
 * @memberof module:soundworks/client
 * @extends {module:soundworks/client.View}
 */

var SegmentedView = function (_View) {
  (0, _inherits3.default)(SegmentedView, _View);

  function SegmentedView(template) {
    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck3.default)(this, SegmentedView);

    // fallback on default template if `template = null`
    template = !template ? defaultTemplate : template;

    /**
     * Object associating selectors as defined in the given template associated
     * with their vertical ratio, the ratio is applyed in both 'portrait' and
     * 'landscape' orientation.
     *
     * @type {Object<String:Number>}
     * @name ratios
     * @instance
     * @memberof module:soundworks/client.SegmentedView
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentedView.__proto__ || (0, _getPrototypeOf2.default)(SegmentedView)).call(this, template, content, events, options));

    _this.ratios = options.ratios || {
      '.section-top': 0.3,
      '.section-center': 0.5,
      '.section-bottom': 0.2
    };

    /**
     * An object containing selectors defined in the template associated
     * with their vertical ratio, the ratio is applyed in both 'portrait'
     * and 'landscape' orientation.
     *
     * @type {Object<String:Element>}
     * @name ratios
     * @instance
     * @memberof module:soundworks/client.SegmentedView
     * @private
     */
    _this._$sections = {};
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(SegmentedView, [{
    key: 'onRender',
    value: function onRender() {
      var _this2 = this;

      (0, _keys2.default)(this.ratios).forEach(function (sel) {
        var $el = _this2.$el.querySelector(sel);

        if ($el === null) throw new Error('Unknow selector "' + sel + '"');

        _this2._$sections[sel] = $el;
      });
    }

    /** @private */

  }, {
    key: 'onResize',
    value: function onResize(width, height, orientation) {
      (0, _get3.default)(SegmentedView.prototype.__proto__ || (0, _getPrototypeOf2.default)(SegmentedView.prototype), 'onResize', this).call(this, width, height, orientation);

      for (var sel in this.ratios) {
        var ratio = this.ratios[sel];
        var $el = this._$sections[sel];

        $el.style.minHeight = ratio * height + 'px';
      }
    }
  }]);
  return SegmentedView;
}(_View3.default);

exports.default = SegmentedView;

},{"./View":302,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/object/keys":25,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],301:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to handle `touch` events on a given element. Decompose a multitouch
 * event in several parallel events, propagate normalized values according to
 * the size of the container.
 *
 * @param {Element} $el - Element to listen for `touch` events.
 *
 * @memberof module:soundworks/client
 */
var TouchSurface = function () {
  function TouchSurface($el) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, TouchSurface);

    /**
     * Element to listen.
     *
     * @type {Element}
     * @name $el
     * @instance
     * @memberof  module:soundworks/client.TouchSurface
     */
    this.$el = $el;

    /**
     * Touch id, normalized position pairs for each current touches.
     *
     * @type {Number:<Array<Number>>}
     * @name touches
     * @instance
     * @memberof  module:soundworks/client.TouchSurface
     */
    this.touches = {};

    /**
     * Bounding rect of `this.$el`.
     *
     * @type {Object}
     * @name _elBoundingRect
     * @instance
     * @memberof  module:soundworks/client.TouchSurface
     * @private
     */
    this._elBoundingRect = null;

    /**
     * Registered callbacks.
     *
     * @type {Object}
     * @name _listeners
     * @instance
     * @memberof  module:soundworks/client.TouchSurface
     * @private
     */
    this._listeners = {};

    this._normalizeCoordinates = options.normalizeCoordinates !== undefined ? options.normalizeCoordinates : true;

    // cache bounding rect values and listen for window resize
    this._updateBoundingRect = this._updateBoundingRect.bind(this);
    window.addEventListener('resize', this._updateBoundingRect);
    this._updateBoundingRect();

    /** @private */
    this._handleTouchStart = this._handleTouch(function (id, x, y, t, e) {
      _this.touches[id] = [x, y];
      _this._propagate('touchstart', id, x, y, t, e);
    });

    /** @private */
    this._handleTouchMove = this._handleTouch(function (id, x, y, t, e) {
      _this.touches[id] = [x, y];
      _this._propagate('touchmove', id, x, y, t, e);
    });

    /** @private */
    this._handleTouchEnd = this._handleTouch(function (id, x, y, t, e) {
      delete _this.touches[id];
      _this._propagate('touchend', id, x, y, t, e);
    });

    this.$el.addEventListener('touchstart', this._handleTouchStart);
    this.$el.addEventListener('touchmove', this._handleTouchMove);
    this.$el.addEventListener('touchend', this._handleTouchEnd);
    this.$el.addEventListener('touchcancel', this._handleTouchEnd);

    // fallback for mouse interactions
  }

  /**
   * Destroy the `TouchSurface`, remove all event listeners from `this.$el`
   * and delete all pointers.
   */


  (0, _createClass3.default)(TouchSurface, [{
    key: 'destroy',
    value: function destroy() {
      window.removeEventListener('resize', this._updateBoundingRect);
      this.$el.removeEventListener('touchstart', this._handleTouchStart);
      this.$el.removeEventListener('touchmove', this._handleTouchMove);
      this.$el.removeEventListener('touchend', this._handleTouchEnd);
      this.$el.removeEventListener('touchcancel', this._handleTouchEnd);
      // delete pointers
      this.$el = null;
      this.listeners = null;
    }

    /**
     * Update bounding rect of `this.$el`
     *
     * @private
     */

  }, {
    key: '_updateBoundingRect',
    value: function _updateBoundingRect() {
      this._elBoundingRect = this.$el.getBoundingClientRect();

      // this has been introduced in 6c8234bb83d2df3e56f1b21a0caea4e4ef657eb4 and
      // breaks a lot of things... respecify the behavior when
      // normalizeCoordinates === false, because is not related to the given
      // element (this.$el) as implemented.
      // (the only app that depends on this option is probably coloop, so check it)
      // this._elBoundingRect = {
      //   top: 0,
      //   bottom: 0,
      //   left: 0,
      //   right: 0,
      //   width: window.innerWidth,
      //   height: window.innerHeight,
      // };
    }

    /**
     * Generic moethod to handle a touch event.
     *
     * @private
     */

  }, {
    key: '_handleTouch',
    value: function _handleTouch(callback) {
      var _this2 = this;

      return function (e) {
        e.preventDefault();
        // if `_updateBoundingRect` has not been been called or
        // has been called when $el was in `display:none` state
        if (!_this2._elBoundingRect || _this2._elBoundingRect.width === 0 && _this2._elBoundingRect.height === 0) {
          _this2._updateBoundingRect();
        }

        var touches = e.changedTouches;
        var boundingRect = _this2._elBoundingRect;

        for (var i = 0; i < touches.length; i++) {
          var touchEvent = touches[i];
          var touchId = touchEvent.identifier;

          if (_this2._normalizeCoordinates) {
            var relX = touchEvent.clientX - boundingRect.left;
            var relY = touchEvent.clientY - boundingRect.top;
            var normX = relX / boundingRect.width;
            var normY = relY / boundingRect.height;
            callback(touchId, normX, normY, touchEvent, e);
          } else {
            callback(touchId, touchEvent.clientX, touchEvent.clientY, touchEvent, e);
          }
        }
      };
    }

    /**
     * Propagate the touch event and normalized values to the listeners.
     *
     * @param {String} eventName - Type of event.
     * @param {Number} touchId - Id of the touch event.
     * @param {Number} x - x-position (maybe normalized to the elements width depending on normalizeCoordinates option)
     * @param {Number} y - y-position (maybe normalized to the elements height depending on normalizeCoordinates option)
     *  according to the height of the element.
     * @param {Object} touchEvent - Original touch event (`e.changedTouches[n]`).
     * @param {Object} originalEvent - Original event.
     * @private
     */

  }, {
    key: '_propagate',
    value: function _propagate(eventName, touchId, x, y, touchEvent, originalEvent) {
      var listeners = this._listeners[eventName];

      if (listeners && listeners.length) {
        listeners.forEach(function (listener) {
          listener(touchId, x, y, touchEvent, originalEvent);
        });
      }
    }

    /**
     * Callback for touch events
     *
     * @callback module:soundworks/client.TouchSurface~EventListener
     * @param {Number} touchId - Id of the touch.
     * @param {Number} x - x-position (maybe normalized to the elements width depending on normalizeCoordinates option)
     * @param {Number} y - y-position (maybe normalized to the elements height depending on normalizeCoordinates option)
     * @param {Touch} touchEvent - The original Touch event.
     * @param {Event} originalEvent - The original event.
     */

    /**
     * Register a listener. __note: `touchcancel` is merge with `touchend`.
     *
     * @param {String} eventName - Name of the event to listen (`touchstart`,
     *  `touchend` or `touchmove`)
     * @param {module:soundworks/client.TouchSurface~EventListener} callback
     */

  }, {
    key: 'addListener',
    value: function addListener(eventName, callback) {
      if (!this._listeners[eventName]) this._listeners[eventName] = [];

      this._listeners[eventName].push(callback);
    }

    /**
     * Remove a listener. __note: `touchcancel` is merge with `touchend`.
     *
     * @param {String} eventName - Name of the event to listen (`touchstart`,
     *  `touchend` or `touchmove`)
     * @param {module:soundworks/client.TouchSurface~EventListener} callback
     */

  }, {
    key: 'removeListener',
    value: function removeListener(eventName, callback) {
      var listeners = this._listeners[eventName];
      if (!listeners) {
        return;
      }

      var index = listeners.indexOf(callback);

      if (index !== -1) listeners.splice(index, 1);
    }
  }]);
  return TouchSurface;
}();

exports.default = TouchSurface;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],302:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toArray2 = require('babel-runtime/helpers/toArray');

var _toArray3 = _interopRequireDefault(_toArray2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash.template');

var _lodash2 = _interopRequireDefault(_lodash);

var _viewport = require('./viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _domDelegate = require('dom-delegate');

var _domDelegate2 = _interopRequireDefault(_domDelegate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Interface required to create a soundworks compatible view.
 *
 * To comply with the soundwork's internal view system (cf. viewManager) any
 * view should implement an interface composed of 2 methods: `render` and `remove`
 *
 * @memberof module:soundworks/client
 * @interface AbstractView
 * @abstract
 *
 * @example
 * // minimal implementation of a soundworks compliant view
 * class MyView {
 *   constructor(text) {
 *     this.msg = msg;
 *     this.$el = document.createElement('div');
 *   }
 *
 *   render() {
 *     this.$el.innerHTML = `<h1>${this.msg}</h1>`;
 *     return this.$el;
 *   }
 *
 *   remove() {
 *     this.$el.remove();
 *   }
 * }
 */
/**
 * Method called when the view is inserted into the DOM by the service manager.
 *
 * @name show
 * @memberof module:soundworks/client.AbstractView
 * @function
 * @abstract
 * @instance
 *
 * @return {Element} - immutable DOM element containing the view.
 */
/**
 * Method called when the view has to be updated. The returned DOM element
 * should contain the whole view content and should not be mutated during the
 * whole lifecycle of the view.
 *
 * @name render
 * @memberof module:soundworks/client.AbstractView
 * @function
 * @abstract
 * @instance
 *
 * @return {Element} - immutable DOM element containing the view.
 */
/**
 * Method called when the view is removed in the DOM by the `viewManager`.
 *
 * @name remove
 * @memberof module:soundworks/client.AbstractView
 * @function
 * @abstract
 * @instance
 */

/**
 * Base class for views.
 *
 * _<span class="warning">__WARNING__</span> Views should be created using
 * {@link module:soundworks/client.Activity#createView} method._
 *
 * @param {String} template - Template of the view.
 * @param {Object} content - Object containing the variables used to populate
 *  the template. {@link module:soundworks/client.View#content}.
 * @param {Object} events - Listeners to install in the view
 *  {@link module:soundworks/client.View#events}.
 * @param {Object} options - Options of the view.
 *  {@link module:soundworks/client.View#options}.
 *
 * @memberof module:soundworks/client
 */
var View = function () {
  function View(template) {
    var model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck3.default)(this, View);

    /**
     * Function created from the given `template`, to be executed with the
     * `content` object.
     *
     * @type {Function}
     * @name tmpl
     * @instance
     * @memberof module:soundworks/client.View
     * @private
     */
    this._tmpl = null;

    this.template = template;

    /**
     * Data used to populate variables defined in the template.
     *
     * @type {Object}
     * @name content
     * @instance
     * @memberof module:soundworks/client.View
     */
    this.model = model; // model

    /**
     * Events to attach to the view. The key / value pairs must follow the
     * convention: `'eventName [cssSelector]': callbackFunction`
     *
     * @type {Object}
     * @name events
     * @instance
     * @memberof module:soundworks/client.View
     */
    this.events = events;

    /**
     * Options of the View.
     *
     * @type {Object}
     * @property {String} [el='div'] - Type of DOM element of the main container
     *  of the view. Basically the argument of `document.createElement`.
     * @property {String} [id=null] - Id of the main container.
     * @property {Array<String>} [className=null] - Classes of the main container.
     * @property {Array<String>} [priority=0] - Priority of the view. This value
     *  is used by the `viewManager` to define which view should appear first.
     * @name options
     * @instance
     * @memberof module:soundworks/client.View
     *
     * @see {@link module:soundworks/client.view#$el}
     * @see {@link module:soundworks/client.viewManager}
     */
    this.options = (0, _assign2.default)({
      el: 'div',
      id: null,
      className: null
    }, options);

    /**
     * Viewport width.
     *
     * @type {Number}
     * @name viewWidth
     * @instance
     * @memberof module:soundworks/client.View
     * @see {@link module:soundworks/client.viewport}
     */
    this.viewportWidth = null;

    /**
     * Viewport height.
     *
     * @type {Number}
     * @name viewWidth
     * @instance
     * @memberof module:soundworks/client.View
     * @see {@link module:soundworks/client.viewport}
     */
    this.viewportHeight = null;

    /**
     * Orientation of the view ('portrait'|'landscape')
     *
     * @type {String}
     * @name orientation
     * @instance
     * @memberof module:soundworks/client.View
     * @see {@link module:soundworks/client.viewport}
     */
    this.orientation = null;

    /**
     * Indicates if the view is visible or not.
     *
     * @type {Boolean}
     * @name isVisible
     * @instance
     * @memberof module:soundworks/client.View
     */
    this.isVisible = false;

    /**
     * DOM element of the main container of the view. Defaults to `<div>`.
     *
     * @type {Element}
     * @name $el
     * @instance
     * @memberof module:soundworks/client.View
     */
    this.$el = document.createElement(this.options.el);

    // initialize event delegation
    this._delegate = new _domDelegate2.default(this.$el);
    this.onResize = this.onResize.bind(this);

    this.installEvents(this.events, false);
  }

  (0, _createClass3.default)(View, [{
    key: 'appendTo',
    value: function appendTo($container) {
      $container.appendChild(this.$el);
    }

    /**
     * Partially re-render the view according to the given selector. If the
     * selector is associated to a `component`, the `component` is rendered.
     *
     * @param {String} selector - Css selector of the element to render. The
     *  element itself is not updated, only its content.
     * @private
     */

  }, {
    key: '_renderPartial',
    value: function _renderPartial(selector) {
      var $container = this.$el.querySelector(selector);

      if ($container === null) throw new Error('selector ' + selector + ' doesn\'t match any element');

      var html = this._tmpl(this.model);
      var $tmp = document.createElement('div');

      $tmp.innerHTML = html;
      $container.innerHTML = $tmp.querySelector(selector).innerHTML;
      this.onRender();
    }

    /**
     * Render the whole view and its components.
     *
     * @private
     */

  }, {
    key: '_renderAll',
    value: function _renderAll() {
      var options = this.options;
      // set id of the container id given
      if (options.id) this.$el.id = options.id;
      // set classes of the container if given
      if (options.className) {
        var _$el$classList;

        var className = options.className;
        var classes = typeof className === 'string' ? [className] : className;
        (_$el$classList = this.$el.classList).add.apply(_$el$classList, (0, _toConsumableArray3.default)(classes));
      }

      // render template and insert it in the main element
      var html = this._tmpl(this.model);
      this.$el.innerHTML = html;
      this.onRender();
    }

    // LIFE CYCLE METHODS ----------------------------------

    /**
     * Render the view according to the given template and content.
     *
     * @param {String} [selector=null] - If not `null`, renders only the part of
     *  the view inside the matched element. If this element contains a component
     *  (sub-view), the component is rendered. Render the whole view otherwise.
     */

  }, {
    key: 'render',
    value: function render() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (selector !== null) this._renderPartial(selector);else this._renderAll();

      if (this.isVisible) this.onResize(_viewport2.default.width, _viewport2.default.height, _viewport2.default.orientation);

      return this.$el;
    }

    /**
     * Show the view. Executed by the `viewManager`.
     *
     * @private
     */

  }, {
    key: 'show',
    value: function show() {
      this.$el.style.display = 'block';
      this.isVisible = true;
      // must resize before child component
      this._delegateEvents();
      _viewport2.default.addResizeListener(this.onResize);
    }

    /**
     * Hide the view and uninstall events. Executed by the `viewManager`.
     *
     * @private
     */

  }, {
    key: 'hide',
    value: function hide() {
      this.$el.style.display = 'none';
      this.isVisible = false;

      this._undelegateEvents();
      _viewport2.default.removeResizeListener(this.onResize);
    }

    /**
     * Remove the view from it's container. Executed by the `viewManager`.
     * @private
     */

  }, {
    key: 'remove',
    value: function remove() {
      this.hide();
      this.$el.remove();
    }

    /**
     * Interface method to extend, executed when the DOM is created.
     */

  }, {
    key: 'onRender',
    value: function onRender() {}

    /**
     * Callback executed on `resize` events. By default, maintains the size
     * of the container to fit the viewport size. The method is also executed when
     * the view is inserted in the DOM.
     *
     * @param {Number} viewportWidth - Width of the viewport.
     * @param {Number} viewportHeight - Height of the viewport.
     * @param {String} orientation - Orientation of the viewport.
     * @see {@link module:soundworks/client.viewport}
     */

  }, {
    key: 'onResize',
    value: function onResize(viewportWidth, viewportHeight, orientation) {
      this.viewportWidth = viewportWidth;
      this.viewportHeight = viewportHeight;
      this.orientation = orientation;

      this.$el.style.width = viewportWidth + 'px';
      this.$el.style.height = viewportHeight + 'px';
      this.$el.classList.remove('portrait', 'landscape');
      this.$el.classList.add(orientation);
    }

    // EVENTS ----------------------------------------

    /**
     * Install events on the view.
     *
     * @param {Object<String, Function>} events - An object of events.
     * @param {Boolean} [override=false] - Defines if the new events added to the
     *  the old one or if they replace them.
     */

  }, {
    key: 'installEvents',
    value: function installEvents(events) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.isVisible) this._undelegateEvents();

      this.events = override ? events : (0, _assign2.default)(this.events, events);

      if (this.isVisible) this._delegateEvents();
    }

    /**
     * Add event listeners on the view.
     *
     * @private
     */

  }, {
    key: '_delegateEvents',
    value: function _delegateEvents() {
      for (var key in this.events) {
        var _key$split = key.split(/ +/),
            _key$split2 = (0, _toArray3.default)(_key$split),
            event = _key$split2[0],
            selector = _key$split2.slice(1);

        var callback = this.events[key];

        this._delegate.on(event, selector.length ? selector.join(' ') : null, callback);
      }
    }

    /**
     * Remove event listeners from the view.
     *
     * @private
     */

  }, {
    key: '_undelegateEvents',
    value: function _undelegateEvents() {
      this._delegate.off();
    }
  }, {
    key: 'template',
    set: function set(template) {
      try {
        this._tmpl = (0, _lodash2.default)(template);
      } catch (err) {
        throw new Error('Invalid template (make sure you do not use es6 syntax in Safari mobile): ' + template);
      }
    }
  }]);
  return View;
}();

exports.default = View;

},{"./viewport":303,"babel-runtime/core-js/object/assign":20,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/toArray":39,"babel-runtime/helpers/toConsumableArray":40,"dom-delegate":208,"lodash.template":231}],303:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Track the viewport size and orientation.
 * All views add their {@link module:soundworks/client.View#onResize} method as
 * listener of this helper.
 *
 * @namespace
 * @memberof module:soundworks/client
 *
 * @see {@link module:soundworks/client.View#onResize}
 */
var viewport = {
  /**
   * Width of the viewport.
   *
   * @type {Number}
   */
  width: null,

  /**
   * Height of the viewport.
   *
   * @type {Number}
   */
  height: null,

  /**
   * Orientation of the viewport (`'portrait'|'landscape'`).
   *
   * @type {String}
   */
  orientation: null,

  /**
   * List of callbacks to execute on each `resize` event.
   *
   * @type {Set}
   * @private
   */
  _callbacks: new _set2.default(),

  /**
   * Initialize the service, is called in `client._initViews`.
   * @private
   */
  init: function init() {
    this._onResize = this._onResize.bind(this);

    this._onResize();
    window.addEventListener('resize', this._onResize, false);
  },


  /** @private */
  _onResize: function _onResize() {
    var _this = this;

    this.width = document.documentElement.clientWidth || window.innerWidth;
    this.height = document.documentElement.clientHeight || window.innerHeight;
    this.orientation = this.width > this.height ? 'landscape' : 'portrait';

    this._callbacks.forEach(function (callback) {
      callback(_this.width, _this.height, _this.orientation);
    });
  },


  /**
   * Callback to execute on a `resize` event.
   *
   * @callback module:soundworks/client.viewport~resizeCallback
   * @param {Number} width - Width of the viewport.
   * @param {Number} height - Height of the viewport.
   * @param {String} orientation - Orientation of the viewport.
   */

  /**
   * Add a listener to the `resize` event. The callback is immediately
   * invoked with the current `width`, `height` and `orientation` values.
   *
   * @param {module:soundworks/client.viewport~resizeCallback} callback -
   *  Callback to add to listeners.
   */
  addResizeListener: function addResizeListener(callback) {
    this._callbacks.add(callback);
    // execute immediatly with current values
    callback(this.width, this.height, this.orientation);
  },


  /**
   * Remove a listener from the `resize` event.
   *
   * @param {module:soundworks/client.viewport~resizeCallback} callback -
   *  Callback to remove from listeners.
   */
  removeResizeListener: function removeResizeListener(callback) {
    this._callbacks.delete(callback);
  }
};

exports.default = viewport;

},{"babel-runtime/core-js/set":28}],304:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,require('_process'))

},{"./common":305,"_process":247}],305:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":306}],306:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],307:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Lightweight EventEmitter mimicing node EventEmitter's API.
 */
var EventEmitter = function () {
  function EventEmitter() {
    (0, _classCallCheck3.default)(this, EventEmitter);

    /**
     * Events
     * @name _events
     * @type {Map<String, Set>}
     * @instanceof Process
     * @private
     */
    this._events = new _map2.default();
  }

  /**
   * Add a callback to a named event
   * @param {String} channel - Name of the event.
   * @param {Function} callback - Callback executed when the event is emitted.
   */


  (0, _createClass3.default)(EventEmitter, [{
    key: "addListener",
    value: function addListener(channel, callback) {
      if (!this._events.has(channel)) this._events.set(channel, new _set2.default());

      var stack = this._events.get(channel);
      stack.add(callback);
    }

    /**
     * Remove a callback from a named event
     * @param {String} channel - Name of the event.
     * @param {Function} callback - Callback to remove.
     */

  }, {
    key: "removeListener",
    value: function removeListener(channel, callback) {
      var stack = this._events.get(channel);

      if (stack) stack.delete(callback);
    }

    /**
     * Emit a named event
     * @param {String} channel - Name of the event.
     * @param {...Mixed} args - Arguments to pass to the callback.
     */

  }, {
    key: "emit",
    value: function emit(channel) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var stack = this._events.get(channel);

      if (stack) stack.forEach(function (callback) {
        return callback.apply(undefined, args);
      });
    }
  }]);
  return EventEmitter;
}();

exports.default = EventEmitter;

},{"babel-runtime/core-js/map":19,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],308:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 *
 */
var Signal = function () {
  function Signal() {
    (0, _classCallCheck3.default)(this, Signal);

    this._state = false;
    this._observers = new _set2.default();
  }

  (0, _createClass3.default)(Signal, [{
    key: "set",
    value: function set(value) {
      if (value !== this._state) {
        this._state = value;

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(this._observers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var observer = _step.value;

            observer(value);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }, {
    key: "get",
    value: function get() {
      return this._state;
    }
  }, {
    key: "addObserver",
    value: function addObserver(observer) {
      this._observers.add(observer);
    }
  }, {
    key: "removeObserver",
    value: function removeObserver(observer) {
      this._observers.delete(observer);
    }
  }]);
  return Signal;
}();

exports.default = Signal;

},{"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],309:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Signal2 = require('./Signal');

var _Signal3 = _interopRequireDefault(_Signal2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Compound signal that is `true` when all signals it depends on are `true`.
 * Dependencies are added through the `add` method.
 * @private
 */
var SignalAll = function (_Signal) {
  (0, _inherits3.default)(SignalAll, _Signal);

  function SignalAll() {
    (0, _classCallCheck3.default)(this, SignalAll);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SignalAll.__proto__ || (0, _getPrototypeOf2.default)(SignalAll)).call(this));

    _this._dependencies = new _set2.default();
    return _this;
  }

  (0, _createClass3.default)(SignalAll, [{
    key: 'add',
    value: function add(signal) {
      var _this2 = this;

      this._dependencies.add(signal);

      signal.addObserver(function () {
        var value = true;

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(_this2._dependencies), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _signal = _step.value;

            value = value && _signal.get();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        (0, _get3.default)(SignalAll.prototype.__proto__ || (0, _getPrototypeOf2.default)(SignalAll.prototype), 'set', _this2).call(_this2, value);
      });
    }
  }, {
    key: 'set',
    value: function set(value) {/* noop */}
  }, {
    key: 'length',
    get: function get() {
      return this._dependencies.size;
    }
  }]);
  return SignalAll;
}(_Signal3.default);

exports.default = SignalAll;

},{"./Signal":308,"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],310:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearToDecibel = linearToDecibel;
exports.decibelToLinear = decibelToLinear;
exports.powerToDecibel = powerToDecibel;
exports.decibelToPower = decibelToPower;
exports.linearToCent = linearToCent;
exports.centToLinear = centToLinear;
exports.getScaler = getScaler;
function linearToDecibel(val) {
  return 8.685889638065035 * Math.log(val); // 20 * log10(val)
};

function decibelToLinear(val) {
  return Math.exp(0.11512925464970229 * val); // pow(10, val / 20)
};

function powerToDecibel(val) {
  return 4.3429448190325175 * Math.log(val); // 10 * log10(val)
};

function decibelToPower(val) {
  return Math.exp(0.23025850929940458 * val); // pow(10, val / 10)
};

function linearToCent(val) {
  return 1731.23404906675611 * Math.log(val); // 1200 * log2(val)
};

function centToLinear(val) {
  return Math.exp(0.0005776226504666211 * val); // pow(2, val / 1200)
};

function getScaler(minIn, maxIn, minOut, maxOut) {
  var a = (maxOut - minOut) / (maxIn - minIn);
  var b = minOut - a * minIn;
  return function (x) {
    return a * x + b;
  };
};

},{}],311:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('sync');

////// helpers

/**
 * Order min and max attributes.
 *
 * @private
 * @param {Object} that with min and max attributes
 * @returns {Object} with min and man attributes, swapped if that.min > that.max
 */
function orderMinMax(that) {
  if (typeof that !== 'undefined' && typeof that.min !== 'undefined' && typeof that.max !== 'undefined' && that.min > that.max) {
    var tmp = that.min;
    that.min = that.max;
    that.max = tmp;
  }
  return that;
}

/**
 * Mean over an array, selecting one dimension of the array values.
 *
 * @private
 * @param {Array.<Array.<Number>>} array
 * @param {Number} [dimension=0]
 * @returns {Number} mean
 */
function mean(array) {
  var dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  return array.reduce(function (p, q) {
    return p + q[dimension];
  }, 0) / array.length;
}

var SyncClient = function () {
  /**
   * @callback SyncClient~getTimeFunction
   * @return {Number} monotonic, ever increasing, time in second. When possible
   *  the server code should define its own origin (i.e. `time=0`) in order to
   *  maximize the resolution of the clock for a long period of time. When
   *  `SyncServer~start` is called the clock should be running
   *  (cf. `audioContext.currentTime` that needs user interaction to start)
   **/

  /**
   * @callback SyncClient~sendFunction
   * @see {@linkcode SyncServer~receiveFunction}
   * @param {Number} pingId unique identifier
   * @param {Number} clientPingTime time-stamp of ping emission
   **/

  /**
   * @callback SyncClient~receiveFunction
   * @see {@linkcode SyncServer~sendFunction}
   * @param {SyncClient~receiveCallback} receiveCallback called on
   * each message matching messageType.
   **/

  /**
   * @callback SyncClient~receiveCallback
   * @param {Number} pingId unique identifier
   * @param {Number} clientPingTime time-stamp of ping emission
   * @param {Number} serverPingTime time-stamp of ping reception
   * @param {Number} serverPongTime time-stamp of pong emission
   * @param {Number} clientPongTime time-stamp of pong reception
   **/

  /**
   * @callback SyncClient~reportFunction
   * @param {Object} report
   * @param {String} report.status `new`, `startup`,
   * `training` (offset adaptation), or `sync` (offset and ratio adaptation).
   * @param {Number} report.statusDuration duration since last status
   * change.
   * @param {Number} report.timeOffset time difference between local
   * time and sync time, in seconds.
   * @param {Number} report.frequencyRatio time ratio between local
   * time and sync time.
   * @param {String} report.connection `offline` or `online`
   * @param {Number} report.connectionDuration duration since last connection
   * change.
   * @param {Number} report.connectionTimeOut duration, in seconds, before
   * a time-out occurs.
   * @param {Number} report.travelDuration duration of a
   * ping-pong round-trip, in seconds, mean over the the last
   * ping-pong series.
   * @param {Number} report.travelDurationMin duration of a
   * ping-pong round-trip, in seconds, minimum over the the last
   * ping-pong series.
   * @param {Number} report.travelDurationMax duration of a
   * ping-pong round-trip, in seconds, maximum over the the last
   * ping-pong series.
   **/

  /**
   * This is the constructor. See {@linkcode SyncClient~start} method to
   * actually start a synchronisation process.
   *
   * @constructs SyncClient
   * @param {SyncClient~getTimeFunction} getTimeFunction
   * @param {Object} [options]
   * @param {Object} [options.pingTimeOutDelay] range of duration (in seconds) to
   * consider a ping was not ponged back
   * @param {Number} [options.pingTimeOutDelay.min=1] min and max must be set together
   * @param {Number} [options.pingTimeOutDelay.max=30] min and max must be set together
   * @param {Number} [options.pingSeriesIterations=10] number of ping-pongs in a
   * series
   * @param {Number} [options.pingSeriesPeriod=0.250] interval (in seconds) between pings
   * in a series
   * @param {Number} [options.pingSeriesDelay] range of interval (in
   * seconds) between ping-pong series
   * @param {Number} [options.pingSeriesDelay.min=10] min and max must be set together
   * @param {Number} [options.pingSeriesDelay.max=20] min and max must be set together
   * @param {Number} [options.longTermDataTrainingDuration=120] duration of
   * training, in seconds, approximately, before using the estimate of
   * clock frequency
   * @param {Number} [options.longTermDataDuration=900] estimate synchronisation over
   *  this duration, in seconds, approximately
   */
  function SyncClient(getTimeFunction) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, SyncClient);

    this.pingTimeoutDelay = options.pingTimeoutDelay || { min: 1, max: 30 };
    orderMinMax(this.pingTimeoutDelay);

    this.pingSeriesIterations = options.pingSeriesIterations || 10;
    this.pingSeriesPeriod = options.pingSeriesPeriod || 0.250;
    this.pingSeriesDelay = options.pingSeriesDelay || { min: 10, max: 20 };
    orderMinMax(this.pingSeriesDelay);

    this.pingDelay = 0; // current delay before next ping
    this.pingTimeoutId = 0; // to cancel timeout on sync_pinc
    this.pingId = 0; // absolute ID to mach pong against

    this.pingSeriesCount = 0; // elapsed pings in a series
    this.seriesData = []; // circular buffer
    this.seriesDataNextIndex = 0; // next index to write in circular buffer
    this.seriesDataLength = this.pingSeriesIterations; // size of circular buffer

    this.longTermDataTrainingDuration = options.longTermDataTrainingDuration || 120;

    // use a fixed-size circular buffer, even if it does not match
    // exactly the required duration
    this.longTermDataDuration = options.longTermDataDuration || 900;
    this.longTermDataLength = Math.max(2, this.longTermDataDuration / (0.5 * (this.pingSeriesDelay.min + this.pingSeriesDelay.max)));

    this.longTermData = []; // circular buffer
    this.longTermDataNextIndex = 0; // next index to write in circular buffer

    this.timeOffset = 0; // mean of (serverTime - clientTime) in the last series
    this.travelDuration = 0;
    this.travelDurationMin = 0;
    this.travelDurationMax = 0;

    // T(t) = T0 + R * (t - t0)
    this.serverTimeReference = 0; // T0
    this.clientTimeReference = 0; // t0
    this.frequencyRatio = 1; // R

    this.pingTimeoutDelay.current = this.pingTimeoutDelay.min;

    this.getTimeFunction = getTimeFunction;

    this.status = 'new';
    this.statusChangedTime = 0;

    this.connectionStatus = 'offline';
    this.connectionStatusChangedTime = 0;
  }

  /**
   * Set status, and set this.statusChangedTime, to later
   * use see {@linkcode SyncClient~getStatusDuration}
   * and {@linkcode SyncClient~reportStatus}.
   *
   * @function SyncClient~setStatus
   * @param {String} status
   * @returns {Object} this
   */


  (0, _createClass3.default)(SyncClient, [{
    key: 'setStatus',
    value: function setStatus(status) {
      if (status !== this.status) {
        this.status = status;
        this.statusChangedTime = this.getLocalTime();
      }
      return this;
    }

    /**
     * Get time since last status change. See {@linkcode SyncClient~setStatus}
     *
     * @function SyncClient~getStatusDuration
     * @returns {Number} time, in seconds, since last status change.
     */

  }, {
    key: 'getStatusDuration',
    value: function getStatusDuration() {
      return Math.max(0, this.getLocalTime() - this.statusChangedTime);
    }

    /**
     * Set connectionStatus, and set this.connectionStatusChangedTime,
     * to later use see {@linkcode SyncClient~getConnectionStatusDuration}
     * and {@linkcode SyncClient~reportStatus}.
     *
     * @function SyncClient~setConnectionStatus
     * @param {String} connectionStatus
     * @returns {Object} this
     */

  }, {
    key: 'setConnectionStatus',
    value: function setConnectionStatus(connectionStatus) {
      if (connectionStatus !== this.connectionStatus) {
        this.connectionStatus = connectionStatus;
        this.connectionStatusChangedTime = this.getLocalTime();
      }
      return this;
    }

    /**
     * Get time since last connectionStatus change.
     * See {@linkcode SyncClient~setConnectionStatus}
     *
     * @function SyncClient~getConnectionStatusDuration
     * @returns {Number} time, in seconds, since last connectionStatus
     * change.
     */

  }, {
    key: 'getConnectionStatusDuration',
    value: function getConnectionStatusDuration() {
      return Math.max(0, this.getLocalTime() - this.connectionStatusChangedTime);
    }

    /**
     * Report the status of the synchronisation process, if
     * reportFunction is defined.
     *
     * @function SyncClient~reportStatus
     * @param {SyncClient~reportFunction} reportFunction
     */

  }, {
    key: 'reportStatus',
    value: function reportStatus(reportFunction) {
      if (typeof reportFunction !== 'undefined') {
        reportFunction({
          status: this.status,
          statusDuration: this.getStatusDuration(),
          timeOffset: this.timeOffset,
          frequencyRatio: this.frequencyRatio,
          connection: this.connectionStatus,
          connectionDuration: this.getConnectionStatusDuration(),
          connectionTimeOut: this.pingTimeoutDelay.current,
          travelDuration: this.travelDuration,
          travelDurationMin: this.travelDurationMin,
          travelDurationMax: this.travelDurationMax
        });
      }
    }

    /**
     * Process to send ping messages.
     *
     * @private
     * @function SyncClient~__syncLoop
     * @param {SyncClient~sendFunction} sendFunction
     * @param {SyncClient~reportFunction} reportFunction
     */

  }, {
    key: '__syncLoop',
    value: function __syncLoop(sendFunction, reportFunction) {
      var _this = this;

      clearTimeout(this.timeoutId);
      ++this.pingId;
      sendFunction(this.pingId, this.getLocalTime());

      this.timeoutId = setTimeout(function () {
        // increase timeout duration on timeout, to avoid overflow
        _this.pingTimeoutDelay.current = Math.min(_this.pingTimeoutDelay.current * 2, _this.pingTimeoutDelay.max);
        log('sync:ping timeout > %s', _this.pingTimeoutDelay.current);
        _this.setConnectionStatus('offline');
        _this.reportStatus(reportFunction);
        // retry (yes, always increment pingId)
        _this.__syncLoop(sendFunction, reportFunction);
      }, Math.ceil(1000 * this.pingTimeoutDelay.current));
    }

    /**
     * Start a synchronisation process by registering the receive
     * function passed as second parameter. Then, send regular messages
     * to the server, using the send function passed as first parameter.
     *
     * @function SyncClient~start
     * @param {SyncClient~sendFunction} sendFunction
     * @param {SyncClient~receiveFunction} receiveFunction to register
     * @param {SyncClient~reportFunction} reportFunction if defined,
     * is called to report the status, on each status change
     */

  }, {
    key: 'start',
    value: function start(sendFunction, receiveFunction, reportFunction) {
      var _this2 = this;

      this.setStatus('startup');
      this.setConnectionStatus('offline');

      this.seriesData = [];
      this.seriesDataNextIndex = 0;

      this.longTermData = [];
      this.longTermDataNextIndex = 0;

      receiveFunction(function (pingId, clientPingTime, serverPingTime, serverPongTime) {
        // accept only the pong that corresponds to the last ping
        if (pingId === _this2.pingId) {
          ++_this2.pingSeriesCount;
          clearTimeout(_this2.timeoutId);
          _this2.setConnectionStatus('online');
          // reduce timeout duration on pong, for better reactivity
          _this2.pingTimeoutDelay.current = Math.max(_this2.pingTimeoutDelay.current * 0.75, _this2.pingTimeoutDelay.min);

          // time-differences are valid on a single-side only (client or server)
          var clientPongTime = _this2.getLocalTime();
          var clientTime = 0.5 * (clientPongTime + clientPingTime);
          var serverTime = 0.5 * (serverPongTime + serverPingTime);
          var travelDuration = Math.max(0, clientPongTime - clientPingTime - (serverPongTime - serverPingTime));
          var offsetTime = serverTime - clientTime;

          // order is important for sorting, later.
          _this2.seriesData[_this2.seriesDataNextIndex] = [travelDuration, offsetTime, clientTime, serverTime];
          _this2.seriesDataNextIndex = ++_this2.seriesDataNextIndex % _this2.seriesDataLength;

          // log('ping %s, travel = %s, offset = %s, client = %s, server = %s',
          //       pingId, travelDuration, offsetTime, clientTime, serverTime);

          // end of a series
          if (_this2.pingSeriesCount >= _this2.pingSeriesIterations && _this2.seriesData.length >= _this2.seriesDataLength) {
            // plan the begining of the next series
            _this2.pingDelay = _this2.pingSeriesDelay.min + Math.random() * (_this2.pingSeriesDelay.max - _this2.pingSeriesDelay.min);
            _this2.pingSeriesCount = 0;

            // sort by travel time first, then offset time.
            var sorted = _this2.seriesData.slice(0).sort();

            var seriesTravelDuration = sorted[0][0];

            // When the clock tick is long enough,
            // some travel times (dimension 0) might be identical.
            // Then, use the offset median (dimension 1 is the second sort key)
            var s = 0;
            while (s < sorted.length && sorted[s][0] <= seriesTravelDuration * 1.01) {
              ++s;
            }
            s = Math.max(0, s - 1);
            var median = Math.floor(s / 2);

            var seriesClientTime = sorted[median][2];
            var seriesServerTime = sorted[median][3];
            var seriesClientSquaredTime = seriesClientTime * seriesClientTime;
            var seriesClientServerTime = seriesClientTime * seriesServerTime;

            _this2.longTermData[_this2.longTermDataNextIndex] = [seriesTravelDuration, seriesClientTime, seriesServerTime, seriesClientSquaredTime, seriesClientServerTime];
            _this2.longTermDataNextIndex = ++_this2.longTermDataNextIndex % _this2.longTermDataLength;

            // mean of the time offset over 3 samples around median
            // (it might use a longer travel duration)
            var aroundMedian = sorted.slice(Math.max(0, median - 1), Math.min(sorted.length, median + 1));
            _this2.timeOffset = mean(aroundMedian, 3) - mean(aroundMedian, 2);

            if (_this2.status === 'startup' || _this2.status === 'training' && _this2.getStatusDuration() < _this2.longTermDataTrainingDuration) {
              // set only the phase offset, not the frequency
              _this2.serverTimeReference = _this2.timeOffset;
              _this2.clientTimeReference = 0;
              _this2.frequencyRatio = 1;
              _this2.setStatus('training');
              log('T = %s + %s * (%s - %s) = %s', _this2.serverTimeReference, _this2.frequencyRatio, seriesClientTime, _this2.clientTimeReference, _this2.getSyncTime(seriesClientTime));
            }

            if (_this2.status === 'training' && _this2.getStatusDuration() >= _this2.longTermDataTrainingDuration || _this2.status === 'sync') {
              // linear regression, R = covariance(t,T) / variance(t)
              var regClientTime = mean(_this2.longTermData, 1);
              var regServerTime = mean(_this2.longTermData, 2);
              var regClientSquaredTime = mean(_this2.longTermData, 3);
              var regClientServerTime = mean(_this2.longTermData, 4);

              var covariance = regClientServerTime - regClientTime * regServerTime;
              var variance = regClientSquaredTime - regClientTime * regClientTime;
              if (variance > 0) {
                // update freq and shift
                _this2.frequencyRatio = covariance / variance;
                _this2.clientTimeReference = regClientTime;
                _this2.serverTimeReference = regServerTime;

                // 0.05% is a lot (500 PPM, like an old mechanical clock)
                if (_this2.frequencyRatio > 0.9995 && _this2.frequencyRatio < 1.0005) {
                  _this2.setStatus('sync');
                } else {
                  log('clock frequency ratio out of sync: %s, training again', _this2.frequencyRatio);
                  // start the training again from the last series
                  _this2.serverTimeReference = _this2.timeOffset; // offset only
                  _this2.clientTimeReference = 0;
                  _this2.frequencyRatio = 1;
                  _this2.setStatus('training');

                  _this2.longTermData[0] = [seriesTravelDuration, seriesClientTime, seriesServerTime, seriesClientSquaredTime, seriesClientServerTime];
                  _this2.longTermData.length = 1;
                  _this2.longTermDataNextIndex = 1;
                }
              }

              log('T = %s + %s * (%s - %s) = %s', _this2.serverTimeReference, _this2.frequencyRatio, seriesClientTime, _this2.clientTimeReference, _this2.getSyncTime(seriesClientTime));
            }

            _this2.travelDuration = mean(sorted, 0);
            _this2.travelDurationMin = sorted[0][0];
            _this2.travelDurationMax = sorted[sorted.length - 1][0];

            _this2.reportStatus(reportFunction);
          } else {
            // we are in a series, use the pingInterval value
            _this2.pingDelay = _this2.pingSeriesPeriod;
          }

          _this2.timeoutId = setTimeout(function () {
            _this2.__syncLoop(sendFunction, reportFunction);
          }, Math.ceil(1000 * _this2.pingDelay));
        } // ping and pong ID match
      }); // receive function

      this.__syncLoop(sendFunction, reportFunction);
    }

    /**
     * Get local time, or convert a synchronised time to a local time.
     *
     * @function SyncClient~getLocalTime
     * @param {Number} syncTime undefined to get local time
     * @returns {Number} local time, in seconds
     */

  }, {
    key: 'getLocalTime',
    value: function getLocalTime(syncTime) {
      if (typeof syncTime !== 'undefined') {
        // conversion: t(T) = t0 + (T - T0) / R
        return this.clientTimeReference + (syncTime - this.serverTimeReference) / this.frequencyRatio;
      } else {
        // read local clock
        return this.getTimeFunction();
      }
    }

    /**
     * Get synchronised time, or convert a local time to a synchronised time.
     *
     * @function SyncClient~getSyncTime
     * @param {Number} localTime undefined to get synchronised time
     * @returns {Number} synchronised time, in seconds.
     */

  }, {
    key: 'getSyncTime',
    value: function getSyncTime() {
      var localTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLocalTime();

      // always convert: T(t) = T0 + R * (t - t0)
      return this.serverTimeReference + this.frequencyRatio * (localTime - this.clientTimeReference);
    }
  }]);
  return SyncClient;
}();

exports.default = SyncClient;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"debug":205}],312:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],313:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var AudioContext = window.AudioContext || window.webkitAudioContext;

/**
 * Expose a unique audio context singleton as the default audio
 * context used by the components of the Waves Audio library and
 * applications using the library.
 *
 * @type AudioContext
 * @name audioContext
 * @constant
 * @global
 * @instance
 *
 * @example
 * import * as audio from 'waves-audio';
 * const audioContext = audio.audioContext;
 */
var audioContext = null;

if (AudioContext) {
  audioContext = new AudioContext();

  if (/(iPhone|iPad)/i.test(navigator.userAgent) && audioContext.sampleRate < 44100) {
    var buffer = audioContext.createBuffer(1, 1, 44100);
    var dummy = audioContext.createBufferSource();
    dummy.buffer = buffer;
    dummy.connect(audioContext.destination);
    dummy.start(0);
    dummy.disconnect();
  }
}

exports.default = audioContext;

},{}],314:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _audioContext = require('./audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is the base class for all audio related time engine components. It is
 * used to handle audio related events such as the playback of a media stream.
 * It extends the TimeEngine class by the standard web audio node methods
 * connect and disconnect.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/audio-time-engine.html}
 *
 * @extends TimeEngine
 * @example
 * import audio from 'waves-audio';
 *
 * class MyEngine extends audio.AudioTimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 */
var AudioTimeEngine = function (_TimeEngine) {
  (0, _inherits3.default)(AudioTimeEngine, _TimeEngine);

  function AudioTimeEngine() {
    var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;
    (0, _classCallCheck3.default)(this, AudioTimeEngine);

    /**
     * Audio context used by the TimeEngine, default to the global audioContext
     *
     * @name audioContext
     * @type AudioContext
     * @memberof AudioTimeEngine
     * @see audioContext
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioTimeEngine.__proto__ || (0, _getPrototypeOf2.default)(AudioTimeEngine)).call(this));

    _this.audioContext = audioContext;

    /**
     * Output audio node. By default the connect method connects a given node
     * to this output node.
     *
     * @name outputNode
     * @type AudioNode
     * @memberof AudioTimeEngine
     * @default null
     */
    _this.outputNode = null;
    return _this;
  }

  /**
   * Connect to an audio node (e.g. audioContext.destination)
   *
   * @param {AudioNode} target - Target audio node
   */


  (0, _createClass3.default)(AudioTimeEngine, [{
    key: 'connect',
    value: function connect(target) {
      this.outputNode.connect(target);
      return this;
    }

    /**
     * Disconnect from an audio node (e.g. audioContext.destination). If undefined
     * disconnect from all target nodes.
     *
     * @param {AudioNode} target - Target audio node.
     */

  }, {
    key: 'disconnect',
    value: function disconnect(connection) {
      this.outputNode.disconnect(connection);
      return this;
    }
  }]);
  return AudioTimeEngine;
}(_timeEngine2.default);

exports.default = AudioTimeEngine;

},{"./audio-context":313,"./time-engine":317,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],315:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// works by reference
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

// https://jsperf.com/js-for-loop-vs-array-indexof/346
function indexOf(arr, el) {
  var l = arr.length;
  // ignore first element as it can't be a entry
  for (var i = 1; i < l; i++) {
    if (arr[i] === el) {
      return i;
    }
  }

  return -1;
}

/**
 * Define if `time1` should be lower in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isLowerMaxHeap = function _isLowerMaxHeap(time1, time2) {
  return time1 < time2;
};

var _isLowerMinHeap = function _isLowerMinHeap(time1, time2) {
  return time1 > time2;
};

/**
 * Define if `time1` should be higher in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isHigherMaxHeap = function _isHigherMaxHeap(time1, time2) {
  return time1 > time2;
};

var _isHigherMinHeap = function _isHigherMinHeap(time1, time2) {
  return time1 < time2;
};

var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

/**
 * Priority queue implementing a binary heap.
 * Acts as a min heap by default, can be dynamically changed to a max heap
 * by setting `reverse` to true.
 *
 * _note_: the queue creates and maintains a new property (i.e. `queueTime`)
 * to each object added.
 *
 * @param {Number} [heapLength=100] - Default size of the array used to create the heap.
 */

var PriorityQueue = function () {
  function PriorityQueue() {
    var heapLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    (0, _classCallCheck3.default)(this, PriorityQueue);

    /**
     * Pointer to the first empty index of the heap.
     * @type {Number}
     * @memberof PriorityQueue
     * @name _currentLength
     * @private
     */
    this._currentLength = 1;

    /**
     * Array of the sorted indexes of the entries, the actual heap. Ignore the index 0.
     * @type {Array}
     * @memberof PriorityQueue
     * @name _heap
     * @private
     */
    this._heap = new Array(heapLength + 1);

    /**
     * Type of the queue: `min` heap if `false`, `max` heap if `true`
     * @type {Boolean}
     * @memberof PriorityQueue
     * @name _reverse
     * @private
     */
    this._reverse = null;

    // initialize compare functions
    this.reverse = false;
  }

  /**
   * Time of the first element in the binary heap.
   * @returns {Number}
   */


  (0, _createClass3.default)(PriorityQueue, [{
    key: "_bubbleUp",


    /**
     * Fix the heap by moving an entry to a new upper position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */
    value: function _bubbleUp(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var parentIndex = Math.floor(index / 2);
      var parent = this._heap[parentIndex];

      while (parent && this._isHigher(entry.queueTime, parent.queueTime)) {
        swap(this._heap, index, parentIndex);

        index = parentIndex;
        parentIndex = Math.floor(index / 2);
        parent = this._heap[parentIndex];
      }
    }

    /**
     * Fix the heap by moving an entry to a new lower position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */

  }, {
    key: "_bubbleDown",
    value: function _bubbleDown(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var c1index = index * 2;
      var c2index = c1index + 1;
      var child1 = this._heap[c1index];
      var child2 = this._heap[c2index];

      while (child1 && this._isLower(entry.queueTime, child1.queueTime) || child2 && this._isLower(entry.queueTime, child2.queueTime)) {
        // swap with the minimum child
        var targetIndex = void 0;

        if (child2) targetIndex = this._isHigher(child1.queueTime, child2.queueTime) ? c1index : c2index;else targetIndex = c1index;

        swap(this._heap, index, targetIndex);

        // update to find next children
        index = targetIndex;
        c1index = index * 2;
        c2index = c1index + 1;
        child1 = this._heap[c1index];
        child2 = this._heap[c2index];
      }
    }

    /**
     * Build the heap (from bottom up).
     */

  }, {
    key: "buildHeap",
    value: function buildHeap() {
      // find the index of the last internal node
      // @todo - make sure that's the right way to do.
      var maxIndex = Math.floor((this._currentLength - 1) / 2);

      for (var i = maxIndex; i > 0; i--) {
        this._bubbleDown(i);
      }
    }

    /**
     * Insert a new object in the binary heap and sort it.
     *
     * @param {Object} entry - Entry to insert.
     * @param {Number} time - Time at which the entry should be orderer.
     * @returns {Number} - Time of the first entry in the heap.
     */

  }, {
    key: "insert",
    value: function insert(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        entry.queueTime = time;
        // add the new entry at the end of the heap
        this._heap[this._currentLength] = entry;
        // bubble it up
        this._bubbleUp(this._currentLength);
        this._currentLength += 1;

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Move a given entry to a new position.
     *
     * @param {Object} entry - Entry to move.
     * @param {Number} time - Time at which the entry should be orderer.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "move",
    value: function move(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        var index = indexOf(this._heap, entry);

        if (index !== -1) {
          entry.queueTime = time;
          // define if the entry should be bubbled up or down
          var parent = this._heap[Math.floor(index / 2)];

          if (parent && this._isHigher(time, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
        }

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Remove an entry from the heap and fix the heap.
     *
     * @param {Object} entry - Entry to remove.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "remove",
    value: function remove(entry) {
      // find the index of the entry
      var index = indexOf(this._heap, entry);

      if (index !== -1) {
        var lastIndex = this._currentLength - 1;

        // if the entry is the last one
        if (index === lastIndex) {
          // remove the element from heap
          this._heap[lastIndex] = undefined;
          // update current length
          this._currentLength = lastIndex;

          return this.time;
        } else {
          // swap with the last element of the heap
          swap(this._heap, index, lastIndex);
          // remove the element from heap
          this._heap[lastIndex] = undefined;

          if (index === 1) {
            this._bubbleDown(1);
          } else {
            // bubble the (ex last) element up or down according to its new context
            var _entry = this._heap[index];
            var parent = this._heap[Math.floor(index / 2)];

            if (parent && this._isHigher(_entry.queueTime, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
          }
        }

        // update current length
        this._currentLength = lastIndex;
      }

      return this.time;
    }

    /**
     * Clear the queue.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._currentLength = 1;
      this._heap = new Array(this._heap.length);
    }

    /**
     * Defines if the queue contains the given `entry`.
     *
     * @param {Object} entry - Entry to be checked
     * @return {Boolean}
     */

  }, {
    key: "has",
    value: function has(entry) {
      return this._heap.indexOf(entry) !== -1;
    }
  }, {
    key: "time",
    get: function get() {
      if (this._currentLength > 1) return this._heap[1].queueTime;

      return Infinity;
    }

    /**
     * First element in the binary heap.
     * @returns {Number}
     * @readonly
     */

  }, {
    key: "head",
    get: function get() {
      return this._heap[1];
    }

    /**
     * Change the order of the queue (max heap if true, min heap if false),
     * rebuild the heap with the existing entries.
     *
     * @type {Boolean}
     */

  }, {
    key: "reverse",
    set: function set(value) {
      if (value !== this._reverse) {
        this._reverse = value;

        if (this._reverse === true) {
          this._isLower = _isLowerMaxHeap;
          this._isHigher = _isHigherMaxHeap;
        } else {
          this._isLower = _isLowerMinHeap;
          this._isHigher = _isHigherMinHeap;
        }

        this.buildHeap();
      }
    },
    get: function get() {
      return this._reverse;
    }
  }]);
  return PriorityQueue;
}();

exports.default = PriorityQueue;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],316:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _priorityQueue = require('./priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class SchedulingQueue
 * @extends TimeEngine
 */
/**
 * SchedulingQueue base class
 * http://wavesjs.github.io/audio/#audio-scheduling-queue
 *
 * Norbert.Schnell@ircam.fr
 * Copyright 2014, 2015 IRCAM – Centre Pompidou
 */

var SchedulingQueue = function (_TimeEngine) {
  (0, _inherits3.default)(SchedulingQueue, _TimeEngine);

  function SchedulingQueue() {
    (0, _classCallCheck3.default)(this, SchedulingQueue);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(SchedulingQueue)).call(this));

    _this.__queue = new _priorityQueue2.default();
    _this.__engines = new _set2.default();
    return _this;
  }

  // TimeEngine 'scheduled' interface


  (0, _createClass3.default)(SchedulingQueue, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var engine = this.__queue.head;
      var nextEngineTime = engine.advanceTime(time);

      if (!nextEngineTime) {
        engine.master = null;
        this.__engines.delete(engine);
        this.__queue.remove(engine);
      } else {
        this.__queue.move(engine, nextEngineTime);
      }

      return this.__queue.time;
    }

    // TimeEngine master method to be implemented by derived class

  }, {
    key: 'defer',


    // call a function at a given time
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    // add a time engine to the scheduler

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      engine.master = this;

      // add to engines and queue
      this.__engines.add(engine);
      var nextTime = this.__queue.insert(engine, time);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // remove a time engine from the queue

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      engine.master = null;

      // remove from array and queue
      this.__engines.delete(engine);
      var nextTime = this.__queue.remove(engine);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // reset next engine time

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      var nextTime = void 0;

      if (this.__queue.has(engine)) nextTime = this.__queue.move(engine, time);else nextTime = this.__queue.insert(engine, time);

      this.resetTime(nextTime);
    }

    // check whether a given engine is scheduled

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    // clear queue

  }, {
    key: 'clear',
    value: function clear() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__engines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var engine = _step.value;

          engine.master = null;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.__queue.clear();
      this.__engines.clear();
      this.resetTime(Infinity);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return 0;
    }
  }]);
  return SchedulingQueue;
}(_timeEngine2.default);

exports.default = SchedulingQueue;

},{"./priority-queue":315,"./time-engine":317,"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],317:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for time engines
 *
 * A time engine generates more or less regular events and/or plays back a
 * media stream. It implements one or multiple interfaces to be driven by a
 * master (i.e. a Scheduler, a Transport or a PlayControl) in synchronization
 * with other engines. The provided interfaces are scheduled, transported,
 * and play-controlled.
 *
 *
 * #### The `scheduled` interface
 *
 * The scheduled interface allows for synchronizing an engine to a monotonous time
 * as it is provided by the Scheduler master.
 *
 * ###### `advanceTime(time :Number) -> {Number}`
 *
 * The `advanceTime` method has to be implemented by an `TimeEngine` as part of the
 * scheduled interface. The method is called by the master (e.g. the scheduler).
 * It generates an event and to returns the time of the next event (i.e. the next
 * call of advanceTime). The returned time has to be greater than the time
 * received as argument of the method. In case that a TimeEngine has to generate
 * multiple events at the same time, the engine has to implement its own loop
 * while(event.time <= time) and return the time of the next event (if any).
 *
 * ###### `resetTime(time=undefined :Number)`
 *
 * The `resetTime` method is provided by the `TimeEngine` base class. An engine may
 * call this method to reset its next event time (e.g. when a parameter is
 * changed that influences the engine's temporal behavior). When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from the
 * master.
 *
 *
 * #### The `transported` interface
 *
 * The transported interface allows for synchronizing an engine to a position
 * (i.e. media playback time) that can run forward and backward and jump as it
 * is provided by the Transport master.
 *
 * ###### `syncPosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `syncPositon` method has to be implemented by a `TimeEngine` as part of the
 * transported interface. The method syncPositon is called whenever the master
 * of a transported engine has to (re-)synchronize the engine's position. This
 * is for example required when the master (re-)starts playback, jumps to an
 * arbitrary position, and when reversing playback direction. The method returns
 * the next position of the engine in the given playback direction
 * (i.e. `speed < 0` or `speed > 0`).
 *
 * ###### `advancePosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `advancePosition` method has to be implemented by a `TimeEngine` as part
 * of the transported interface. The master calls the advancePositon method when
 * the engine's event position is reached. The method generates an event and
 * returns the next position in the given playback direction (i.e. speed < 0 or
 * speed > 0). The returned position has to be greater (i.e. when speed > 0)
 * or less (i.e. when speed < 0) than the position received as argument of the
 * method.
 *
 * ###### `resetPosition(position=undefined :Number)`
 *
 * The resetPosition method is provided by the TimeEngine base class. An engine
 * may call this method to reset its next event position. When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from
 * the master.
 *
 *
 * #### The speed-controlled interface
 *
 * The "speed-controlled" interface allows for syncronizing an engine that is
 * neither driven through the scheduled nor the transported interface. The
 * interface allows in particular to synchronize engines that assure their own
 * scheduling (i.e. audio player or an oscillator) to the event-based scheduled
 * and transported engines.
 *
 * ###### `syncSpeed(time :Number, position :Number, speed :Number, seek=false :Boolean)`
 *
 * The syncSpeed method has to be implemented by a TimeEngine as part of the
 * speed-controlled interface. The method is called by the master whenever the
 * playback speed changes or the position jumps arbitarily (i.e. on a seek).
 *
 *
 * <hr />
 *
 * Example that shows a `TimeEngine` running in a `Scheduler` that counts up
 * at a given frequency:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/time-engine.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 *
 * class MyEngine extends audio.TimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 *
 */
var TimeEngine = function () {
  function TimeEngine() {
    (0, _classCallCheck3.default)(this, TimeEngine);

    /**
     * The engine's master.
     *
     * @type {Mixed}
     * @name master
     * @memberof TimeEngine
     */
    this.master = null;
  }

  /**
   * The time engine's current (master) time.
   *
   * @type {Number}
   * @memberof TimeEngine
   * @readonly
   */


  (0, _createClass3.default)(TimeEngine, [{
    key: "resetTime",
    value: function resetTime() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEngineTime(this, time);
    }

    /**
     * Transported interface
     *   - syncPosition(time, position, speed), called to reposition TimeEngine, returns next position
     *   - advancePosition(time, position, speed), called to generate next event at given time and position, returns next position
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "resetPosition",
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEnginePosition(this, position);
    }

    /**
     * Speed-controlled interface
     *   - syncSpeed(time, position, speed, ), called to
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "currentTime",
    get: function get() {
      if (this.master) return this.master.currentTime;

      return undefined;
    }

    /**
     * The time engine's current (master) position.
     *
     * @type {Number}
     * @memberof TimeEngine
     * @readonly
     */

  }, {
    key: "currentPosition",
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    /**
     * Scheduled interface
     *   - advanceTime(time), called to generate next event at given time, returns next time
     *
     * @static
     * @memberof TimeEngine
     */

  }], [{
    key: "implementsScheduled",
    value: function implementsScheduled(engine) {
      return engine.advanceTime && engine.advanceTime instanceof Function;
    }
  }, {
    key: "implementsTransported",
    value: function implementsTransported(engine) {
      return engine.syncPosition && engine.syncPosition instanceof Function && engine.advancePosition && engine.advancePosition instanceof Function;
    }
  }, {
    key: "implementsSpeedControlled",
    value: function implementsSpeedControlled(engine) {
      return engine.syncSpeed && engine.syncSpeed instanceof Function;
    }
  }]);
  return TimeEngine;
}();

exports.default = TimeEngine;

},{"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],318:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Granular synthesis TimeEngine implementing the scheduled interface.
 * The grain position (grain onset or center time in the audio buffer) is
 * optionally determined by the engine's currentPosition attribute.
 *
 * Example that shows a `GranularEngine` (with a few parameter controls) driven
 * by a `Scheduler` and a `PlayControl`:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/granular-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const granularEngine = new audio.GranularEngine();
 *
 * scheduler.add(granularEngine);
 *
 *
 * @param {Object} options={} - Parameters
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0.01] - Absolute grain period in sec
 * @param {Number} [options.periodRel=0] - Grain period relative to absolute
 *  duration
 * @param {Number} [options.periodVar=0] - Amout of random grain period
 *  variation relative to grain period
 * @param {Number} [options.periodMin=0.001] - Minimum grain period
 * @param {Number} [options.position=0] - Grain position (onset time in audio
 *  buffer) in sec
 * @param {Number} [options.positionVar=0.003] - Amout of random grain position
 *  variation in sec
 * @param {Number} [options.durationAbs=0.1] - Absolute grain duration in sec
 * @param {Number} [options.durationRel=0] - Grain duration relative to grain
 *  period (overlap)
 * @param {Number} [options.attackAbs=0] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0.5] - Attack time relative to grain duration
 * @param {String} [options.attackShape='lin'] - Shape of attack
 * @param {Number} [options.releaseAbs=0] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0.5] - Release time relative to grain duration
 * @param {Number} [options.releaseShape='lin'] - Shape of release
 * @param {String} [options.expRampOffset=0.0001] - Offset (start/end value)
 *  for exponential attack/release
 * @param {Number} [options.resampling=0] - Grain resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Boolean} [options.centered=true] - Whether the grain position refers
 *  to the center of the grain (or the beginning)
 * @param {Boolean} [options.cyclic=false] - Whether the audio buffer and grain
 *  position are considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the
 *  audio buffer that has been copied from the beginning to assure cyclic behavior
 */

var GranularEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(GranularEngine, _AudioTimeEngine);

  function GranularEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, GranularEngine);

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @default null
     * @memberof GranularEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (GranularEngine.__proto__ || (0, _getPrototypeOf2.default)(GranularEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute grain period in sec
     *
     * @type {Number}
     * @name periodAbs
     * @default 0.01
     * @memberof GranularEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0.01);

    /**
     * Grain period relative to absolute duration
     *
     * @type {Number}
     * @name periodRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 0);

    /**
     * Amout of random grain period variation relative to grain period
     *
     * @type {Number}
     * @name periodVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum grain period
     *
     * @type {Number}
     * @name periodMin
     * @default 0.001
     * @memberof GranularEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Grain position (onset time in audio buffer) in sec
     *
     * @type {Number}
     * @name position
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.position = optOrDef(options.position, 0);

    /**
     * Amout of random grain position variation in sec
     *
     * @type {Number}
     * @name positionVar
     * @default 0.003
     * @memberof GranularEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0.003);

    /**
     * Absolute grain duration in sec
     *
     * @type {Number}
     * @name durationAbs
     * @default 0.1
     * @memberof GranularEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0.1); // absolute grain duration

    /**
     * Grain duration relative to grain period (overlap)
     *
     * @type {Number}
     * @name durationRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 0);

    /**
     * Absolute attack time in sec
     *
     * @type {Number}
     * @name attackAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0);

    /**
     * Attack time relative to grain duration
     *
     * @type {Number}
     * @name attackRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0.5);

    /**
     * Shape of attack ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name attackShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.attackShape = optOrDef(options.attackShape, 'lin');

    /**
     * Absolute release time in sec
     *
     * @type {Number}
     * @name releaseAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0);

    /**
     * Release time relative to grain duration
     *
     * @type {Number}
     * @name releaseRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0.5);

    /**
     * Shape of release ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name releaseShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseShape = optOrDef(options.releaseShape, 'lin');

    /**
     * Offset (start/end value) for exponential attack/release
     *
     * @type {Number}
     * @name expRampOffset
     * @default 0.0001
     * @memberof GranularEngine
     * @instance
     */
    _this.expRampOffset = optOrDef(options.expRampOffset, 0.0001);

    /**
     * Grain resampling in cent
     *
     * @type {Number}
     * @name resampling
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     *
     * @type {Number}
     * @name resamplingVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     *
     * @type {Number}
     * @name gain
     * @default 1
     * @memberof GranularEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Whether the grain position refers to the center of the grain (or the beginning)
     *
     * @type {Boolean}
     * @name centered
     * @default true
     * @memberof GranularEngine
     * @instance
     */
    _this.centered = optOrDef(options.centered, true);

    /**
     * Whether the audio buffer and grain position are considered as cyclic
     *
     * @type {Boolean}
     * @name cyclic
     * @default false
     * @memberof GranularEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);

    /**
     * Portion at the end of the audio buffer that has been copied from the
     * beginning to assure cyclic behavior
     *
     * @type {Number}
     * @name wrapAroundExtension
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @name bufferDuration
   * @memberof GranularEngine
   * @instance
   * @readonly
   */


  (0, _createClass3.default)(GranularEngine, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    /**
     * Trigger a grain. This function can be called at any time (whether the
     * engine is scheduled or not) to generate a single grain according to the
     * current grain parameters.
     *
     * @param {Number} time - grain synthesis audio time
     * @return {Number} - period to next grain
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var grainTime = time || audioContext.currentTime;
      var grainPeriod = this.periodAbs;
      var grainPosition = this.currentPosition;
      var grainDuration = this.durationAbs;

      if (this.buffer) {
        var resamplingRate = 1.0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        grainPeriod += this.periodRel * grainDuration;
        grainDuration += this.durationRel * grainPeriod;

        // grain period randon variation
        if (this.periodVar > 0.0) grainPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

        // center grain
        if (this.centered) grainPosition -= 0.5 * grainDuration;

        // randomize grain position
        if (this.positionVar > 0) grainPosition += (2.0 * Math.random() - 1) * this.positionVar;

        var bufferDuration = this.bufferDuration;

        // wrap or clip grain position and duration into buffer duration
        if (grainPosition < 0 || grainPosition >= bufferDuration) {
          if (this.cyclic) {
            var cycles = grainPosition / bufferDuration;
            grainPosition = (cycles - Math.floor(cycles)) * bufferDuration;

            if (grainPosition + grainDuration > this.buffer.duration) grainDuration = this.buffer.duration - grainPosition;
          } else {
            if (grainPosition < 0) {
              grainTime -= grainPosition;
              grainDuration += grainPosition;
              grainPosition = 0;
            }

            if (grainPosition + grainDuration > bufferDuration) grainDuration = bufferDuration - grainPosition;
          }
        }

        // make grain
        if (this.gain > 0 && grainDuration >= 0.001) {
          // make grain envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * grainDuration;
          var release = this.releaseAbs + this.releaseRel * grainDuration;

          if (attack + release > grainDuration) {
            var factor = grainDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = grainTime + attack;
          var grainEndTime = grainTime + grainDuration / resamplingRate;
          var releaseStartTime = grainEndTime - release;

          envelope.gain.value = 0;

          if (this.attackShape === 'lin') {
            envelope.gain.setValueAtTime(0.0, grainTime);
            envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
          } else {
            envelope.gain.setValueAtTime(this.expRampOffset, grainTime);
            envelope.gain.exponentialRampToValueAtTime(this.gain, attackEndTime);
          }

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          if (this.releaseShape === 'lin') {
            envelope.gain.linearRampToValueAtTime(0.0, grainEndTime);
          } else {
            envelope.gain.exponentialRampToValueAtTime(this.expRampOffset, grainEndTime);
          }

          envelope.connect(this.outputNode);

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(grainTime, grainPosition);
          source.stop(grainEndTime);
        }
      }

      return Math.max(this.periodMin, grainPeriod);
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }

    /**
     * Current position
     *
     * @type {Number}
     * @name currentPosition
     * @memberof GranularEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.position;
    }
  }]);
  return GranularEngine;
}(_audioTimeEngine2.default);

exports.default = GranularEngine;

},{"../core/audio-time-engine":314,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],319:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Metronome audio engine. It extends Time Engine as a transported interface.
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/metronome.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const metronome = new audio.Metronome({period: 0.333});
 *
 * scheduler.add(metronome);
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.period=1] - Metronome period
 * @param {Number} [options.clickFreq=600] - Metronome click frequency
 * @param {Number} [options.clickAttack=0.002] - Metronome click attack time
 * @param {Number} [options.clickRelease=0.098] - Metronome click release time
 * @param {Number} [options.gain=1] - Gain
 */

var Metronome = function (_AudioTimeEngine) {
  (0, _inherits3.default)(Metronome, _AudioTimeEngine);

  function Metronome() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Metronome);

    /**
     * Metronome period
     * @type {Number}
     * @private
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Metronome.__proto__ || (0, _getPrototypeOf2.default)(Metronome)).call(this, options.audioContext));

    _this.__period = optOrDef(options.period, 1);

    /**
     * Metronome click frequency
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickFreq
     * @instance
     */
    _this.clickFreq = optOrDef(options.clickFreq, 600);

    /**
     * Metronome click attack time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickAttack
     * @instance
     */
    _this.clickAttack = optOrDef(options.clickAttack, 0.002);

    /**
     * Metronome click release time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickRelease
     * @instance
     */
    _this.clickRelease = optOrDef(options.clickRelease, 0.098);

    _this.__lastTime = 0;
    _this.__phase = 0;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(Metronome, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      this.trigger(time);
      this.__lastTime = time;
      return time + this.__period;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (this.__period > 0) {
        var nextPosition = (Math.floor(position / this.__period) + this.__phase) * this.__period;

        if (speed > 0 && nextPosition < position) nextPosition += this.__period;else if (speed < 0 && nextPosition > position) nextPosition -= this.__period;

        return nextPosition;
      }

      return Infinity * speed;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      this.trigger(time);

      if (speed < 0) return position - this.__period;

      return position + this.__period;
    }

    /**
     * Trigger metronome click
     * @param {Number} time metronome click synthesis audio time
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var clickAttack = this.clickAttack;
      var clickRelease = this.clickRelease;

      var env = audioContext.createGain();
      env.gain.value = 0.0;
      env.gain.setValueAtTime(0, time);
      env.gain.linearRampToValueAtTime(1.0, time + clickAttack);
      env.gain.exponentialRampToValueAtTime(0.0000001, time + clickAttack + clickRelease);
      env.gain.setValueAtTime(0, time);
      env.connect(this.outputNode);

      var osc = audioContext.createOscillator();
      osc.frequency.value = this.clickFreq;
      osc.start(time);
      osc.stop(time + clickAttack + clickRelease);
      osc.connect(env);
    }

    /**
     * linear gain factor
     *
     * @type {Number}
     * @name gain
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      this.__gainNode.gain.value = value;
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * metronome period
     *
     * @type {Number}
     * @name period
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'period',
    set: function set(period) {
      this.__period = period;

      var master = this.master;

      if (master) {
        if (master.resetEngineTime) master.resetEngineTime(this, this.__lastTime + period);else if (master.resetEnginePosition) master.resetEnginePosition(this);
      }
    },
    get: function get() {
      return this.__period;
    }

    /**
     * Set phase parameter (available only when 'transported'), should be
     * between [0, 1[
     *
     * @type {Number}
     * @name phase
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'phase',
    set: function set(phase) {
      this.__phase = phase - Math.floor(phase);

      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this);
    },
    get: function get() {
      return this.__phase;
    }
  }]);
  return Metronome;
}(_audioTimeEngine2.default);

exports.default = Metronome;

},{"../core/audio-time-engine":314,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],320:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Used with a buffer to serve audio files.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/player-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.buffer=1] - Audio buffer
 * @param {Number} [options.fadeTime=600] - Fade time for chaining segments
 * @param {Number} [options.cyclic=false] - Loop mode
 * @param {Number} [options.gain=1] - Gain
 */

var PlayerEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PlayerEngine, _AudioTimeEngine);

  function PlayerEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PlayerEngine);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PlayerEngine.__proto__ || (0, _getPrototypeOf2.default)(PlayerEngine)).call(this, options.audioContext));

    _this.transport = null; // set when added to transporter

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @memberof PlayerEngine
     * @instance
     * @default null
     */
    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Fade time for chaining segments (e.g. in start, stop, and seek)
     *
     * @type {Number}
     * @name fadeTime
     * @memberof PlayerEngine
     * @instance
     * @default 0.005
     */
    _this.fadeTime = optOrDef(options.fadeTime, 0.005);

    _this.__time = 0;
    _this.__position = 0;
    _this.__speed = 0;

    _this.__bufferSource = null;
    _this.__envNode = null;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.__cyclic = optOrDef(options.cyclic, false);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  (0, _createClass3.default)(PlayerEngine, [{
    key: '__start',
    value: function __start(time, position, speed) {
      var audioContext = this.audioContext;

      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.__cyclic && (position < 0 || position >= bufferDuration)) {
          var phase = position / bufferDuration;
          position = (phase - Math.floor(phase)) * bufferDuration;
        }

        if (position >= 0 && position < bufferDuration && speed > 0) {
          this.__envNode = audioContext.createGain();
          this.__envNode.gain.setValueAtTime(0, time);
          this.__envNode.gain.linearRampToValueAtTime(1, time + this.fadeTime);
          this.__envNode.connect(this.__gainNode);

          this.__bufferSource = audioContext.createBufferSource();
          this.__bufferSource.buffer = this.buffer;
          this.__bufferSource.playbackRate.value = speed;
          this.__bufferSource.loop = this.__cyclic;
          this.__bufferSource.loopStart = 0;
          this.__bufferSource.loopEnd = bufferDuration;
          this.__bufferSource.start(time, position);
          this.__bufferSource.connect(this.__envNode);
        }
      }
    }
  }, {
    key: '__halt',
    value: function __halt(time) {
      if (this.__bufferSource) {
        this.__envNode.gain.cancelScheduledValues(time);
        this.__envNode.gain.setValueAtTime(this.__envNode.gain.value, time);
        this.__envNode.gain.linearRampToValueAtTime(0, time + this.fadeTime);
        this.__bufferSource.stop(time + this.fadeTime);

        this.__bufferSource = null;
        this.__envNode = null;
      }
    }

    // TimeEngine method (speed-controlled interface)

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if (seek || lastSpeed * speed < 0) {
          this.__halt(time);
          this.__start(time, position, speed);
        } else if (lastSpeed === 0 || seek) {
          this.__start(time, position, speed);
        } else if (speed === 0) {
          this.__halt(time);
        } else if (this.__bufferSource) {
          this.__bufferSource.playbackRate.setValueAtTime(speed, time);
        }

        this.__speed = speed;
      }
    }

    /**
     * Set whether the audio buffer is considered as cyclic
     * @type {Bool}
     * @name cyclic
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'cyclic',
    set: function set(cyclic) {
      if (cyclic !== this.__cyclic) {
        var time = this.currentTime;
        var position = this.currentosition;

        this.__halt(time);
        this.__cyclic = cyclic;

        if (this.__speed !== 0) this.__start(time, position, this.__speed);
      }
    },
    get: function get() {
      return this.__cyclic;
    }

    /**
     * Linear gain factor
     * @type {Number}
     * @name gain
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      var time = this.currentTime;
      this.__gainNode.cancelScheduledValues(time);
      this.__gainNode.setValueAtTime(this.__gainNode.gain.value, time);
      this.__gainNode.linearRampToValueAtTime(0, time + this.fadeTime);
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * Get buffer duration
     * @type {Number}
     * @name bufferDuration
     * @memberof PlayerEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) return this.buffer.duration;

      return 0;
    }
  }]);
  return PlayerEngine;
}(_audioTimeEngine2.default);

exports.default = PlayerEngine;

},{"../core/audio-time-engine":314,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],321:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `SegmentEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/segment-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const segmentEngine = new audio.SegmentEngine();
 *
 * scheduler.add(segmentEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var SegmentEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(SegmentEngine, _AudioTimeEngine);

  function SegmentEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SegmentEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof SegmentEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentEngine.__proto__ || (0, _getPrototypeOf2.default)(SegmentEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, -0.005);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.005);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.005);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.005);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof SegmentEngine
   * @instance
   */


  (0, _createClass3.default)(SegmentEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(segmentTime, segmentPosition);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }
  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }]);
  return SegmentEngine;
}(_audioTimeEngine2.default);

exports.default = SegmentEngine;

},{"../core/audio-time-engine":314,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],322:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _audioContext = require('./core/audio-context');

Object.defineProperty(exports, 'audioContext', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioContext).default;
  }
});

var _timeEngine = require('./core/time-engine');

Object.defineProperty(exports, 'TimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_timeEngine).default;
  }
});

var _audioTimeEngine = require('./core/audio-time-engine');

Object.defineProperty(exports, 'AudioTimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioTimeEngine).default;
  }
});

var _priorityQueue = require('./core/priority-queue');

Object.defineProperty(exports, 'PriorityQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_priorityQueue).default;
  }
});

var _schedulingQueue = require('./core/scheduling-queue');

Object.defineProperty(exports, 'SchedulingQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_schedulingQueue).default;
  }
});

var _granularEngine = require('./engines/granular-engine');

Object.defineProperty(exports, 'GranularEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_granularEngine).default;
  }
});

var _metronome = require('./engines/metronome');

Object.defineProperty(exports, 'Metronome', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_metronome).default;
  }
});

var _playerEngine = require('./engines/player-engine');

Object.defineProperty(exports, 'PlayerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playerEngine).default;
  }
});

var _segmentEngine = require('./engines/segment-engine');

Object.defineProperty(exports, 'SegmentEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_segmentEngine).default;
  }
});

var _playControl = require('./masters/play-control');

Object.defineProperty(exports, 'PlayControl', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playControl).default;
  }
});

var _transport = require('./masters/transport');

Object.defineProperty(exports, 'Transport', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_transport).default;
  }
});

var _scheduler = require('./masters/scheduler');

Object.defineProperty(exports, 'Scheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scheduler).default;
  }
});

var _simpleScheduler = require('./masters/simple-scheduler');

Object.defineProperty(exports, 'SimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_simpleScheduler).default;
  }
});

var _factories = require('./masters/factories');

Object.defineProperty(exports, 'getScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getScheduler;
  }
});
Object.defineProperty(exports, 'getSimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getSimpleScheduler;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./core/audio-context":313,"./core/audio-time-engine":314,"./core/priority-queue":315,"./core/scheduling-queue":316,"./core/time-engine":317,"./engines/granular-engine":318,"./engines/metronome":319,"./engines/player-engine":320,"./engines/segment-engine":321,"./masters/factories":323,"./masters/play-control":324,"./masters/scheduler":325,"./masters/simple-scheduler":326,"./masters/transport":327}],323:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSimpleScheduler = exports.getScheduler = undefined;

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _scheduler = require('./scheduler');

var _scheduler2 = _interopRequireDefault(_scheduler);

var _simpleScheduler = require('./simple-scheduler');

var _simpleScheduler2 = _interopRequireDefault(_simpleScheduler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schedulerMap = new _weakMap2.default(); // schedulers should be singletons

var simpleSchedulerMap = new _weakMap2.default();

/**
 * Returns a unique instance of `Scheduler`
 *
 * @global
 * @function
 * @returns {Scheduler}
 * @see Scheduler
 */
var getScheduler = exports.getScheduler = function getScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var scheduler = schedulerMap.get(audioContext);

  if (!scheduler) {
    scheduler = new _scheduler2.default({ audioContext: audioContext });
    schedulerMap.set(audioContext, scheduler);
  }

  return scheduler;
};

/**
 * Returns a unique instance of `SimpleScheduler`
 *
 * @global
 * @function
 * @returns {SimpleScheduler}
 * @see SimpleScheduler
 */
var getSimpleScheduler = exports.getSimpleScheduler = function getSimpleScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var simpleScheduler = simpleSchedulerMap.get(audioContext);

  if (!simpleScheduler) {
    simpleScheduler = new _simpleScheduler2.default({ audioContext: audioContext });
    simpleSchedulerMap.set(audioContext, simpleScheduler);
  }

  return simpleScheduler;
};

},{"../core/audio-context":313,"./scheduler":325,"./simple-scheduler":326,"babel-runtime/core-js/weak-map":31}],324:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 1e-8;

var LoopControl = function (_TimeEngine) {
  (0, _inherits3.default)(LoopControl, _TimeEngine);

  function LoopControl(playControl) {
    (0, _classCallCheck3.default)(this, LoopControl);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LoopControl.__proto__ || (0, _getPrototypeOf2.default)(LoopControl)).call(this));

    _this.__playControl = playControl;
    _this.speed = 1;
    _this.lower = -Infinity;
    _this.upper = Infinity;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(LoopControl, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var speed = this.speed;
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0) time += EPSILON;else time -= EPSILON;

      if (speed > 0) {
        playControl.syncSpeed(time, lower, speed, true);
        return playControl.__getTimeAtPosition(upper) - EPSILON;
      } else if (speed < 0) {
        playControl.syncSpeed(time, upper, speed, true);
        return playControl.__getTimeAtPosition(lower) + EPSILON;
      }

      return Infinity;
    }
  }, {
    key: 'reschedule',
    value: function reschedule(speed) {
      var playControl = this.__playControl;
      var lower = Math.min(playControl.__loopStart, playControl.__loopEnd);
      var upper = Math.max(playControl.__loopStart, playControl.__loopEnd);

      this.speed = speed;
      this.lower = lower;
      this.upper = upper;

      if (lower === upper) speed = 0;

      if (speed > 0) this.resetTime(playControl.__getTimeAtPosition(upper) - EPSILON);else if (speed < 0) this.resetTime(playControl.__getTimeAtPosition(lower) + EPSILON);else this.resetTime(Infinity);
    }
  }, {
    key: 'applyLoopBoundaries',
    value: function applyLoopBoundaries(position, speed) {
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0 && position >= upper) return lower + (position - lower) % (upper - lower);else if (speed < 0 && position < lower) return upper - (upper - position) % (upper - lower);

      return position;
    }
  }]);
  return LoopControl;
}(_timeEngine2.default);

// play controlled base class


var PlayControlled = function () {
  function PlayControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlled);

    this.__playControl = playControl;

    engine.master = this;
    this.__engine = engine;
  }

  (0, _createClass3.default)(PlayControlled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      this.__engine.syncSpeed(time, position, speed, seek);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlled;
}();

// play control for engines implementing the *speed-controlled* interface


var PlayControlledSpeedControlled = function (_PlayControlled) {
  (0, _inherits3.default)(PlayControlledSpeedControlled, _PlayControlled);

  function PlayControlledSpeedControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (PlayControlledSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSpeedControlled)).call(this, playControl, engine));
  }

  return PlayControlledSpeedControlled;
}(PlayControlled);

// play control for engines implmenting the *transported* interface


var PlayControlledTransported = function (_PlayControlled2) {
  (0, _inherits3.default)(PlayControlledTransported, _PlayControlled2);

  function PlayControlledTransported(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledTransported);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledTransported.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported)).call(this, playControl, engine));

    _this3.__schedulerHook = new PlayControlledSchedulerHook(playControl, engine);
    return _this3;
  }

  (0, _createClass3.default)(PlayControlledTransported, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;

          if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, 0);
        } else if (this.__engine.syncSpeed) {
          // change speed without reversing direction
          this.__engine.syncSpeed(time, position, speed);
        }

        this.__schedulerHook.resetPosition(nextPosition);
      }
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position === undefined) {
        var playControl = this.__playControl;
        var time = playControl.__sync();

        position = this.__engine.syncPosition(time, playControl.__position, playControl.__speed);
      }

      this.__schedulerHook.resetPosition(position);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulerHook.destroy();
      this.__schedulerHook = null;

      (0, _get3.default)(PlayControlledTransported.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledTransported;
}(PlayControlled);

// play control for time engines implementing the *scheduled* interface


var PlayControlledScheduled = function (_PlayControlled3) {
  (0, _inherits3.default)(PlayControlledScheduled, _PlayControlled3);

  function PlayControlledScheduled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledScheduled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled)).call(this, playControl, engine));

    engine.master = null;
    _this4.__schedulingQueue = new PlayControlledSchedulingQueue(playControl, engine);
    return _this4;
  }

  (0, _createClass3.default)(PlayControlledScheduled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (lastSpeed === 0 && speed !== 0) // start or seek
        this.__engine.resetTime();else if (lastSpeed !== 0 && speed === 0) // stop
        this.__engine.resetTime(Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulingQueue.destroy();
      (0, _get3.default)(PlayControlledScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledScheduled;
}(PlayControlled);

// translates transported engine advancePosition into global scheduler times


var PlayControlledSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(PlayControlledSchedulerHook, _TimeEngine2);

  function PlayControlledSchedulerHook(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulerHook)).call(this));

    _this5.__playControl = playControl;
    _this5.__engine = engine;

    _this5.__nextPosition = Infinity;
    playControl.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  (0, _createClass3.default)(PlayControlledSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var engine = this.__engine;
      var position = this.__nextPosition;
      var nextPosition = engine.advancePosition(time, position, playControl.__speed);
      var nextTime = playControl.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var time = this.__playControl.__getTimeAtPosition(position);
      this.__nextPosition = position;
      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var PlayControlledSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(PlayControlledSchedulingQueue, _SchedulingQueue);

  function PlayControlledSchedulingQueue(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulingQueue)).call(this));

    _this6.__playControl = playControl;
    _this6.__engine = engine;

    _this6.add(engine, Infinity);
    playControl.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(PlayControlledSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.remove(this.__engine);

      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Extends Time Engine to provide playback control of a Time Engine instance.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/play-control.html}
 *
 * @extends TimeEngine
 * @param {TimeEngine} engine - engine to control
 *
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 */


var PlayControl = function (_TimeEngine3) {
  (0, _inherits3.default)(PlayControl, _TimeEngine3);

  function PlayControl(engine) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, PlayControl);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (PlayControl.__proto__ || (0, _getPrototypeOf2.default)(PlayControl)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;
    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);

    _this7.__playControlled = null;

    _this7.__loopControl = null;
    _this7.__loopStart = 0;
    _this7.__loopEnd = 1;

    // synchronized tie, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;

    // non-zero "user" speed
    _this7.__playingSpeed = 1;

    if (engine) _this7.__setEngine(engine);
    return _this7;
  }

  (0, _createClass3.default)(PlayControl, [{
    key: '__setEngine',
    value: function __setEngine(engine) {
      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsSpeedControlled(engine)) this.__playControlled = new PlayControlledSpeedControlled(this, engine);else if (_timeEngine2.default.implementsTransported(engine)) this.__playControlled = new PlayControlledTransported(this, engine);else if (_timeEngine2.default.implementsScheduled(engine)) this.__playControlled = new PlayControlledScheduled(this, engine);else throw new Error("object cannot be added to play control");
    }
  }, {
    key: '__resetEngine',
    value: function __resetEngine() {
      this.__playControlled.destroy();
      this.__playControlled = null;
    }

    /**
     * Calculate/extrapolate playing time for given position
     *
     * @param {Number} position position
     * @return {Number} extrapolated time
     * @private
     */

  }, {
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }

    /**
     * Calculate/extrapolate playing position for given time
     *
     * @param {Number} time time
     * @return {Number} extrapolated position
     * @private
     */

  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__sync',
    value: function __sync() {
      var now = this.currentTime;
      this.__position += (now - this.__time) * this.__speed;
      this.__time = now;
      return now;
    }

    /**
     * Get current master time.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentTime
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'set',
    value: function set() {
      var engine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var time = this.__sync();
      var speed = this.__speed;

      if (this.__playControlled !== null && this.__playControlled.__engine !== engine) {

        this.syncSpeed(time, this.__position, 0);

        if (this.__playControlled) this.__resetEngine();

        if (this.__playControlled === null && engine !== null) {
          this.__setEngine(engine);

          if (speed !== 0) this.syncSpeed(time, this.__position, speed);
        }
      }
    }

    /**
     * Sets the play control loop behavior.
     *
     * @type {Boolean}
     * @name loop
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'setLoopBoundaries',


    /**
     * Sets loop start and end time.
     *
     * @param {Number} loopStart - loop start value.
     * @param {Number} loopEnd - loop end value.
     */
    value: function setLoopBoundaries(loopStart, loopEnd) {
      this.__loopStart = loopStart;
      this.__loopEnd = loopEnd;

      this.loop = this.loop;
    }

    /**
     * Sets loop start value
     *
     * @type {Number}
     * @name loopStart
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'syncSpeed',


    // TimeEngine method (speed-controlled interface)
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if ((seek || lastSpeed === 0) && this.__loopControl) position = this.__loopControl.applyLoopBoundaries(position, speed);

        this.__time = time;
        this.__position = position;
        this.__speed = speed;

        if (this.__playControlled) this.__playControlled.syncSpeed(time, position, speed, seek, lastSpeed);

        if (this.__loopControl) this.__loopControl.reschedule(speed);
      }
    }

    /**
     * Starts playback
     */

  }, {
    key: 'start',
    value: function start() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, this.__playingSpeed);
    }

    /**
     * Pauses playback and stays at the same position.
     */

  }, {
    key: 'pause',
    value: function pause() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, 0);
    }

    /**
     * Stops playback and seeks to initial (0) position.
     */

  }, {
    key: 'stop',
    value: function stop() {
      var time = this.__sync();
      this.syncSpeed(time, 0, 0, true);
    }

    /**
     * If speed if provided, sets the playback speed. The speed value should
     * be non-zero between -16 and -1/16 or between 1/16 and 16.
     *
     * @type {Number}
     * @name speed
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'seek',


    /**
     * Set (jump to) playing position.
     *
     * @param {Number} position target position
     */
    value: function seek(position) {
      var time = this.__sync();
      this.__position = position;
      this.syncSpeed(time, position, this.__speed, true);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentPosition
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }

    /**
     * Returns if the play control is runnin g.
     *
     * @name running
     * @type {Boolean}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'running',
    get: function get() {
      return !(this.__speed === 0);
    }
  }, {
    key: 'loop',
    set: function set(enable) {
      if (enable && this.__loopStart > -Infinity && this.__loopEnd < Infinity) {
        if (!this.__loopControl) {
          this.__loopControl = new LoopControl(this);
          this.__scheduler.add(this.__loopControl, Infinity);
        }

        if (this.__speed !== 0) {
          var position = this.currentPosition;
          var lower = Math.min(this.__loopStart, this.__loopEnd);
          var upper = Math.max(this.__loopStart, this.__loopEnd);

          if (this.__speed > 0 && position > upper) this.seek(upper);else if (this.__speed < 0 && position < lower) this.seek(lower);else this.__loopControl.reschedule(this.__speed);
        }
      } else if (this.__loopControl) {
        this.__scheduler.remove(this.__loopControl);
        this.__loopControl = null;
      }
    },
    get: function get() {
      return !!this.__loopControl;
    }
  }, {
    key: 'loopStart',
    set: function set(loopStart) {
      this.setLoopBoundaries(loopStart, this.__loopEnd);
    },
    get: function get() {
      return this.__loopStart;
    }

    /**
     * Sets loop end value
     *
     * @type {Number}
     * @name loopEnd
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'loopEnd',
    set: function set(loopEnd) {
      this.setLoopBoundaries(this.__loopStart, loopEnd);
    },
    get: function get() {
      return this.__loopEnd;
    }
  }, {
    key: 'speed',
    set: function set(speed) {
      var time = this.__sync();

      if (speed >= 0) {
        if (speed < 0.01) speed = 0.01;else if (speed > 100) speed = 100;
      } else {
        if (speed < -100) speed = -100;else if (speed > -0.01) speed = -0.01;
      }

      this.__playingSpeed = speed;

      if (!this.master && this.__speed !== 0) this.syncSpeed(time, this.__position, speed);
    },
    get: function get() {
      return this.__playingSpeed;
    }
  }]);
  return PlayControl;
}(_timeEngine2.default);

exports.default = PlayControl;

},{"../core/audio-context":313,"../core/scheduling-queue":316,"../core/time-engine":317,"./factories":323,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],325:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 * The `Scheduler` class implements a master for `TimeEngine` or `AudioTimeEngine`
 * instances that implement the *scheduled* interface such as the `Metronome`
 * `GranularEngine`.
 *
 * A `Scheduler` can also schedule simple callback functions.
 * The class is based on recursive calls to `setTimeOut` and uses the
 * `audioContext.currentTime` as logical passed to the `advanceTime` methods
 * of the scheduled engines or to the scheduled callback functions.
 * It extends the `SchedulingQueue` class that itself includes a `PriorityQueue`
 * to assure the order of the scheduled engines (see `SimpleScheduler` for a
 * simplified scheduler implementation without `PriorityQueue`).
 *
 * To get a unique instance of `Scheduler` as the global scheduler of an
 * application, the `getScheduler` factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see `audioContext`) as
 * default. The factory creates a single scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a Scheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getScheduler
 * @see SimpleScheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 *
 * scheduler.add(myEngine);
 */

var Scheduler = function (_SchedulingQueue) {
  (0, _inherits3.default)(Scheduler, _SchedulingQueue);

  function Scheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Scheduler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Scheduler.__proto__ || (0, _getPrototypeOf2.default)(Scheduler)).call(this));

    _this.audioContext = options.audioContext || _audioContext2.default;

    _this.__currentTime = null;
    _this.__nextTime = Infinity;
    _this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    _this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    _this.lookahead = options.lookahead || 0.1;
    return _this;
  }

  // setTimeout scheduling loop


  (0, _createClass3.default)(Scheduler, [{
    key: '__tick',
    value: function __tick() {
      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var time = this.__nextTime;

      this.__timeout = null;

      while (time <= currentTime + this.lookahead) {
        this.__currentTime = time;
        time = this.advanceTime(time);
      }

      this.__currentTime = null;
      this.resetTime(time);
    }
  }, {
    key: 'resetTime',
    value: function resetTime() {
      var _this2 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentTime;

      if (this.master) {
        this.master.reset(this, time);
      } else {
        if (this.__timeout) {
          clearTimeout(this.__timeout);
          this.__timeout = null;
        }

        if (time !== Infinity) {
          if (this.__nextTime === Infinity) log('Scheduler Start');

          var timeOutDelay = Math.max(time - this.lookahead - this.audioContext.currentTime, this.period);

          this.__timeout = setTimeout(function () {
            _this2.__tick();
          }, Math.ceil(timeOutDelay * 1000));
        } else if (this.__nextTime !== Infinity) {
          log('Scheduler Stop');
        }

        this.__nextTime = time;
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'currentTime',
    get: function get() {
      if (this.master) return this.master.currentTime;

      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    // inherited from scheduling queue
    /**
     * Add a TimeEngine or a simple callback function to the scheduler at an
     * optionally given time. Whether the add method is called with a TimeEngine
     * or a callback function it returns a TimeEngine that can be used as argument
     * of the methods remove and resetEngineTime. A TimeEngine added to a scheduler
     * has to implement the scheduled interface. The callback function added to a
     * scheduler will be called at the given time and with the given time as
     * argument. The callback can return a new scheduling time (i.e. the next
     * time when it will be called) or it can return Infinity to suspend scheduling
     * without removing the function from the scheduler. A function that does
     * not return a value (or returns null or 0) is removed from the scheduler
     * and cannot be used as argument of the methods remove and resetEngineTime
     * anymore.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine|Function} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @name resetEngineTime
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */
    /**
     * Remove all scheduled callbacks and engines from the scheduler.
     *
     * @name clear
     * @function
     * @memberof Scheduler
     * @instance
     */

  }]);
  return Scheduler;
}(_schedulingQueue2.default);

exports.default = Scheduler;

},{"../core/audio-context":313,"../core/scheduling-queue":316,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"debug":205}],326:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 *
 *
 *
 * The SimpleScheduler class implements a simplified master for time engines
 * (see TimeEngine or AudioTimeEngine) that implement the scheduled interface
 * such as the Metronome and the GranularEngine. The API and funtionalities of
 * the SimpleScheduler class are identical to the Scheduler class. But, other
 * than the Scheduler, the SimpleScheduler class does not guarantee the order
 * of events (i.e. calls to the advanceTime method of scheduled time engines
 * and to scheduled callback functions) within a scheduling period (see period
 * attribute).
 *
 * To get a unique instance of SimpleScheduler as the global scheduler of an
 * application, the getSimpleScheduler factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see Audio Context) as default. The factory creates
 * a single (simple) scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a SimpleScheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/simple-scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getSimpleScheduler
 * @see Scheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getSimpleScheduler();
 *
 * scheduler.add(myEngine);
 */

var SimpleScheduler = function () {
  function SimpleScheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SimpleScheduler);

    this.audioContext = options.audioContext || _audioContext2.default;

    this.__engines = new _set2.default();

    this.__schedEngines = [];
    this.__schedTimes = [];

    this.__currentTime = null;
    this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    this.lookahead = options.lookahead || 0.1;
  }

  (0, _createClass3.default)(SimpleScheduler, [{
    key: '__scheduleEngine',
    value: function __scheduleEngine(engine, time) {
      this.__schedEngines.push(engine);
      this.__schedTimes.push(time);
    }
  }, {
    key: '__rescheduleEngine',
    value: function __rescheduleEngine(engine, time) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        if (time !== Infinity) {
          this.__schedTimes[index] = time;
        } else {
          this.__schedEngines.splice(index, 1);
          this.__schedTimes.splice(index, 1);
        }
      } else if (time < Infinity) {
        this.__schedEngines.push(engine);
        this.__schedTimes.push(time);
      }
    }
  }, {
    key: '__unscheduleEngine',
    value: function __unscheduleEngine(engine) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        this.__schedEngines.splice(index, 1);
        this.__schedTimes.splice(index, 1);
      }
    }
  }, {
    key: '__resetTick',
    value: function __resetTick() {
      if (this.__schedEngines.length > 0) {
        if (!this.__timeout) {
          log('SimpleScheduler Start');
          this.__tick();
        }
      } else if (this.__timeout) {
        log('SimpleScheduler Stop');
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }
    }
  }, {
    key: '__tick',
    value: function __tick() {
      var _this = this;

      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var i = 0;

      while (i < this.__schedEngines.length) {
        var engine = this.__schedEngines[i];
        var time = this.__schedTimes[i];

        while (time && time <= currentTime + this.lookahead) {
          time = Math.max(time, currentTime);
          this.__currentTime = time;
          time = engine.advanceTime(time);
        }

        if (time && time < Infinity) {
          this.__schedTimes[i++] = time;
        } else {
          this.__unscheduleEngine(engine);

          // remove engine from scheduler
          if (!time) {
            engine.master = null;
            this.__engines.delete(engine);
          }
        }
      }

      this.__currentTime = null;
      this.__timeout = null;

      if (this.__schedEngines.length > 0) {
        this.__timeout = setTimeout(function () {
          _this.__tick();
        }, this.period * 1000);
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'defer',


    // call a function at a given time
    /**
     * Defer the execution of a function at a given time.
     *
     * @param {Function} fun - Function to defer
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    /**
     * Add a TimeEngine function to the scheduler at an optionally given time.
     *
     * @param {TimeEngine} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      // set master and add to array
      engine.master = this;
      this.__engines.add(engine);

      // schedule engine
      this.__scheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (!engine.master || engine.master !== this) throw new Error("engine has not been added to this scheduler");

      // reset master and remove from array
      engine.master = null;
      this.__engines.delete(engine);

      // unschedule engine
      this.__unscheduleEngine(engine);
      this.__resetTick();
    }

    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      this.__rescheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Check whether a given engine is scheduled.
     *
     * @param {TimeEngine} engine - Engine to check
     */

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    /**
     * Remove all engines from the scheduler.
     */

  }, {
    key: 'clear',
    value: function clear() {
      if (this.__timeout) {
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }

      this.__schedEngines.length = 0;
      this.__schedTimes.length = 0;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return undefined;
    }
  }]);
  return SimpleScheduler;
}();

exports.default = SimpleScheduler;

},{"../core/audio-context":313,"../core/time-engine":317,"babel-runtime/core-js/set":28,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"debug":205}],327:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _priorityQueue = require('../core/priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addDuplet(firstArray, secondArray, firstElement, secondElement) {
  firstArray.push(firstElement);
  secondArray.push(secondElement);
}

function removeDuplet(firstArray, secondArray, firstElement) {
  var index = firstArray.indexOf(firstElement);

  if (index >= 0) {
    var secondElement = secondArray[index];

    firstArray.splice(index, 1);
    secondArray.splice(index, 1);

    return secondElement;
  }

  return null;
}

// The Transported call is the base class of the adapters between
// different types of engines (i.e. transported, scheduled, play-controlled)
// The adapters are at the same time masters for the engines added to the transport
// and transported TimeEngines inserted into the transport's position-based pritority queue.

var Transported = function (_TimeEngine) {
  (0, _inherits3.default)(Transported, _TimeEngine);

  function Transported(transport, engine, start, duration, offset) {
    var stretch = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    (0, _classCallCheck3.default)(this, Transported);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Transported.__proto__ || (0, _getPrototypeOf2.default)(Transported)).call(this));

    _this.master = transport;

    _this.__engine = engine;
    engine.master = _this;

    _this.__startPosition = start;
    _this.__endPosition = !isFinite(duration) ? Infinity : start + duration;
    _this.__offsetPosition = start + offset;
    _this.__stretchPosition = stretch;
    _this.__isRunning = false;
    return _this;
  }

  (0, _createClass3.default)(Transported, [{
    key: 'setBoundaries',
    value: function setBoundaries(start, duration) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var stretch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      this.__startPosition = start;
      this.__endPosition = start + duration;
      this.__offsetPosition = start + offset;
      this.__stretchPosition = stretch;
      this.resetPosition();
    }
  }, {
    key: 'start',
    value: function start(time, position, speed) {}
  }, {
    key: 'stop',
    value: function stop(time, position) {}
  }, {
    key: 'resetPosition',
    value: function resetPosition(position) {
      if (position !== undefined) position += this.__offsetPosition;

      this.master.resetEnginePosition(this, position);
    }
  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0) {
        if (position < this.__startPosition) {

          if (this.__isRunning) this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__startPosition;
        } else if (position < this.__endPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__endPosition;
        }
      } else {
        if (position > this.__endPosition) {
          if (this.__isRunning) // if engine is running
            this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__endPosition;
        } else if (position > this.__startPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__startPosition;
        }
      }

      if (this.__isRunning) // if engine is running
        this.stop(time, position);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      if (!this.__isRunning) {
        this.start(time, position - this.__offsetPosition, speed);
        this.__isRunning = true;

        if (speed > 0) return this.__endPosition;

        return this.__startPosition;
      }

      // stop engine
      this.stop(time, position - this.__offsetPosition);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (speed === 0) // stop
        this.stop(time, position - this.__offsetPosition);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.master.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.master.currentPosition - this.__offsetPosition;
    }
  }]);
  return Transported;
}(_timeEngine2.default);

// TransportedTransported
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedTransported = function (_Transported) {
  (0, _inherits3.default)(TransportedTransported, _Transported);

  function TransportedTransported(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedTransported);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedTransported.__proto__ || (0, _getPrototypeOf2.default)(TransportedTransported)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedTransported, [{
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0 && position < this.__endPosition) position = Math.max(position, this.__startPosition);else if (speed < 0 && position >= this.__startPosition) position = Math.min(position, this.__endPosition);

      return this.__offsetPosition + this.__engine.syncPosition(time, position - this.__offsetPosition, speed);
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      position = this.__offsetPosition + this.__engine.advancePosition(time, position - this.__offsetPosition, speed);

      if (speed > 0 && position < this.__endPosition || speed < 0 && position >= this.__startPosition) return position;

      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position !== undefined) position += this.__offsetPosition;

      this.resetPosition(position);
    }
  }]);
  return TransportedTransported;
}(Transported);

// TransportedSpeedControlled
// has to start and stop the speed-controlled engines when the transport hits the engine's start and end position


var TransportedSpeedControlled = function (_Transported2) {
  (0, _inherits3.default)(TransportedSpeedControlled, _Transported2);

  function TransportedSpeedControlled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedSpeedControlled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.__engine.syncSpeed(time, position, speed, true);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.__engine.syncSpeed(time, position, 0);
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__isRunning) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__engine.syncSpeed(this.master.currentTime, this.master.currentPosition - this.__offsetPosition, 0);
      (0, _get3.default)(TransportedSpeedControlled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedSpeedControlled;
}(Transported);

// TransportedScheduled
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedScheduled = function (_Transported3) {
  (0, _inherits3.default)(TransportedScheduled, _Transported3);

  function TransportedScheduled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (TransportedScheduled.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));

    engine.master = null;
    transport.__schedulingQueue.add(engine, Infinity);
    return _this4;
  }

  (0, _createClass3.default)(TransportedScheduled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, time);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master.__schedulingQueue.remove(this.__engine);
      (0, _get3.default)(TransportedScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedScheduled;
}(Transported);

// translates advancePosition of *transported* engines into global scheduler times


var TransportSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(TransportSchedulerHook, _TimeEngine2);

  function TransportSchedulerHook(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulerHook)).call(this));

    _this5.__transport = transport;

    _this5.__nextPosition = Infinity;
    _this5.__nextTime = Infinity;
    transport.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(TransportSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var transport = this.__transport;
      var position = this.__nextPosition;
      var speed = transport.__speed;
      var nextPosition = transport.advancePosition(time, position, speed);
      var nextTime = transport.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      this.__nextTime = nextTime;

      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var transport = this.__transport;
      var time = transport.__getTimeAtPosition(position);

      this.__nextPosition = position;
      this.__nextTime = time;

      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }]);
  return TransportSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var TransportSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(TransportSchedulingQueue, _SchedulingQueue);

  function TransportSchedulingQueue(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulingQueue)).call(this));

    _this6.__transport = transport;
    transport.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(TransportSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__transport.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__transport.currentPosition;
    }
  }]);
  return TransportSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Provides synchronized scheduling of Time Engine instances.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/transport.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 * const transport = audio.Transport();
 * const playControl = new audio.PlayControl(transport);
 * const myEngine = new MyEngine();
 * const yourEngine = new yourEngine();
 *
 * transport.add(myEngine);
 * transport.add(yourEngine);
 *
 * playControl.start();
 */


var Transport = function (_TimeEngine3) {
  (0, _inherits3.default)(Transport, _TimeEngine3);

  function Transport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Transport);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (Transport.__proto__ || (0, _getPrototypeOf2.default)(Transport)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;

    _this7.__engines = [];
    _this7.__transported = [];

    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);
    _this7.__schedulerHook = new TransportSchedulerHook(_this7);
    _this7.__transportedQueue = new _priorityQueue2.default();
    _this7.__schedulingQueue = new TransportSchedulingQueue(_this7);

    // syncronized time, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;
    return _this7;
  }

  (0, _createClass3.default)(Transport, [{
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }
  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__syncTransportedPosition',
    value: function __syncTransportedPosition(time, position, speed) {
      var numTransportedEngines = this.__transported.length;
      var nextPosition = Infinity * speed;

      if (numTransportedEngines > 0) {
        this.__transportedQueue.clear();
        this.__transportedQueue.reverse = speed < 0;

        for (var i = 0; i < numTransportedEngines; i++) {
          var engine = this.__transported[i];
          var nextEnginePosition = engine.syncPosition(time, position, speed);
          this.__transportedQueue.insert(engine, nextEnginePosition);
        }

        nextPosition = this.__transportedQueue.time;
      }

      return nextPosition;
    }
  }, {
    key: '__syncTransportedSpeed',
    value: function __syncTransportedSpeed(time, position, speed) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__transported), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transported = _step.value;

          transported.syncSpeed(time, position, speed);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Get current master time. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentTime
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'resetPosition',


    /**
     * Reset next transport position
     *
     * @param {Number} next - transport position
     */
    value: function resetPosition(position) {
      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this, position);else this.__schedulerHook.resetPosition(position);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      return this.__syncTransportedPosition(time, position, speed);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var engine = this.__transportedQueue.head;
      var nextEnginePosition = engine.advancePosition(time, position, speed);
      return this.__transportedQueue.move(engine, nextEnginePosition);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     * @param {Boolean} [seek=false]
     */

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition = void 0;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;
          this.__syncTransportedSpeed(time, position, 0);
        } else {
          // change speed without reversing direction
          this.__syncTransportedSpeed(time, position, speed);
        }

        this.resetPosition(nextPosition);
      }
    }

    /**
     * Add a time engine to the transport.
     *
     * @param {Object} engine - engine to be added to the transport
     * @param {Number} position - start position
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var endPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
      var offsetPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var transported = null;

      if (offsetPosition === -Infinity) offsetPosition = 0;

      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsTransported(engine)) transported = new TransportedTransported(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsSpeedControlled(engine)) transported = new TransportedSpeedControlled(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsScheduled(engine)) transported = new TransportedScheduled(this, engine, startPosition, endPosition, offsetPosition);else throw new Error("object cannot be added to a transport");

      if (transported) {
        var speed = this.__speed;

        addDuplet(this.__engines, this.__transported, engine, transported);

        if (speed !== 0) {
          // sync and start
          var nextEnginePosition = transported.syncPosition(this.currentTime, this.currentPosition, speed);
          var nextPosition = this.__transportedQueue.insert(transported, nextEnginePosition);

          this.resetPosition(nextPosition);
        }
      }

      return transported;
    }

    /**
     * Remove a time engine from the transport.
     *
     * @param {object} engineOrTransported - engine or transported to be removed from the transport
     */

  }, {
    key: 'remove',
    value: function remove(engineOrTransported) {
      var engine = engineOrTransported;
      var transported = removeDuplet(this.__engines, this.__transported, engineOrTransported);

      if (!transported) {
        engine = removeDuplet(this.__transported, this.__engines, engineOrTransported);
        transported = engineOrTransported;
      }

      if (engine && transported) {
        var nextPosition = this.__transportedQueue.remove(transported);

        transported.destroy();

        if (this.__speed !== 0) this.resetPosition(nextPosition);
      } else {
        throw new Error("object has not been added to this transport");
      }
    }

    /**
     * Reset position of the given engine.
     *
     * @param {TimeEngine} transported - Engine to reset
     * @param {Number} position - New position
     */

  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(transported) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      var speed = this.__speed;

      if (speed !== 0) {
        if (position === undefined) position = transported.syncPosition(this.currentTime, this.currentPosition, speed);

        var nextPosition = this.__transportedQueue.move(transported, position);
        this.resetPosition(nextPosition);
      }
    }

    /**
     * Remove all time engines from the transport.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.syncSpeed(this.currentTime, this.currentPosition, 0);

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.__transported), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var transported = _step2.value;

          transported.destroy();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentPosition
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }
  }]);
  return Transport;
}(_timeEngine2.default);

exports.default = Transport;

},{"../core/audio-context":313,"../core/priority-queue":315,"../core/scheduling-queue":316,"../core/time-engine":317,"./factories":323,"babel-runtime/core-js/get-iterator":16,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],328:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _loader = require('./loader');

var _loader2 = _interopRequireDefault(_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets called if a parameter is missing and the expression
 * specifying the default value is evaluated.
 * @function
 */
function throwIfMissing() {
  throw new Error('Missing parameter');
}

var audioContext = void 0;

window.AudioContext = window.AudioContext || window.webkitAudioContext;

try {
  audioContext = new window.AudioContext();
} catch (e) {}

/**
 * AudioBufferLoader
 * Promise based implementation of XMLHttpRequest Level 2 for GET method and decode audio data for arraybuffer.
 */

var AudioBufferLoader = function (_Loader) {
  (0, _inherits3.default)(AudioBufferLoader, _Loader);

  /**
   * Set the responseType to 'arraybuffer' and initialize options.
   * @param {string} [responseType="arraybuffer"]
   */

  function AudioBufferLoader() {
    var responseType = arguments.length <= 0 || arguments[0] === undefined ? 'arraybuffer' : arguments[0];
    (0, _classCallCheck3.default)(this, AudioBufferLoader);

    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AudioBufferLoader).call(this, responseType));

    _this.options = {
      "wrapAroundExtension": 0
    };
    _this.responseType = responseType;
    _this.audioContext = audioContext;
    return _this;
  }

  /**
   * Allow to set the audio context that should be used in order to decode
   * the file and create the AudioBuffer.
   * @param {AudioContext} audioContext
   */


  (0, _createClass3.default)(AudioBufferLoader, [{
    key: 'setAudioContext',
    value: function setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }

    /**
     * Method for promise audio file loading and decoding.
     * @param {(string|string[])} fileURLs - The URL(s) of the audio files to load. Accepts a URL pointing to the file location or an array of URLs.
     * @param {{wrapAroundExtension: number}} [options] - Object with a wrapAroundExtension key which set the length, in seconds to be copied from the begining at the end of the returned AudioBuffer
     * @returns {Promise}
     */

  }, {
    key: 'load',
    value: function load() {
      var fileURLs = arguments.length <= 0 || arguments[0] === undefined ? throwIfMissing() : arguments[0];
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.options = options;
      this.options.wrapAroundExtension = this.options.wrapAroundExtension || 0;
      return (0, _get3.default)((0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'load', this).call(this, fileURLs);
    }

    /**
     * Load a single audio file, decode it in an AudioBuffer, return a Promise
     * @private
     * @param {string} fileURL - The URL of the audio file location to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadOne',
    value: function loadOne(fileURL) {
      return (0, _get3.default)((0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'loadOne', this).call(this, fileURL).then(this.decodeAudioData.bind(this), function (error) {
        throw error;
      });
    }

    /**
     * Load all audio files at once in a single array, decode them in an array of AudioBuffers, and return a Promise.
     * @private
     * @param {string[]} fileURLs - The URLs array of the audio files to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadAll',
    value: function loadAll(fileURLs) {
      var _this2 = this;

      return (0, _get3.default)((0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'loadAll', this).call(this, fileURLs).then(function (arraybuffers) {
        return _promise2.default.all(arraybuffers.map(function (arraybuffer) {
          return _this2.decodeAudioData.bind(_this2)(arraybuffer);
        }));
      }, function (error) {
        throw error; // TODO: better error handler
      });
    }

    /**
     * Decode Audio Data, return a Promise
     * @private
     * @param {arraybuffer} - The arraybuffer of the loaded audio file to be decoded.
     * @returns {Promise}
     */

  }, {
    key: 'decodeAudioData',
    value: function decodeAudioData(arraybuffer) {
      var _this3 = this;

      if (arraybuffer instanceof ArrayBuffer) {
        return new _promise2.default(function (resolve, reject) {
          _this3.audioContext.decodeAudioData(arraybuffer, // returned audio data array
          function (buffer) {
            if (_this3.options.wrapAroundExtension === 0) resolve(buffer);else resolve(_this3.__wrapAround(buffer));
          }, function (error) {
            reject(new Error("DecodeAudioData error"));
          });
        });
      } else {
        return new _promise2.default(function (resolve, reject) {
          resolve(arraybuffer);
        });
      }
    }

    /**
     * WrapAround, copy the begining input buffer to the end of an output buffer
     * @private
     * @param {arraybuffer} inBuffer {arraybuffer} - The input buffer
     * @returns {arraybuffer} - The processed buffer (with frame copied from the begining to the end)
     */

  }, {
    key: '__wrapAround',
    value: function __wrapAround(inBuffer) {
      var length = inBuffer.length + this.options.wrapAroundExtension * inBuffer.sampleRate;

      var outBuffer = this.audioContext.createBuffer(inBuffer.numberOfChannels, length, inBuffer.sampleRate);
      var arrayChData, arrayOutChData;

      for (var channel = 0; channel < inBuffer.numberOfChannels; channel++) {
        arrayChData = inBuffer.getChannelData(channel);
        arrayOutChData = outBuffer.getChannelData(channel);

        arrayOutChData.forEach(function (sample, index) {
          if (index < inBuffer.length) arrayOutChData[index] = arrayChData[index];else arrayOutChData[index] = arrayChData[index - inBuffer.length];
        });
      }

      return outBuffer;
    }
  }]);
  return AudioBufferLoader;
}(_loader2.default);

exports.default = AudioBufferLoader;

},{"./loader":330,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/core-js/promise":27,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],329:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loader = require('./loader');

Object.defineProperty(exports, 'Loader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_loader).default;
  }
});

var _audioBufferLoader = require('./audio-buffer-loader');

Object.defineProperty(exports, 'AudioBufferLoader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioBufferLoader).default;
  }
});

var _superLoader = require('./super-loader');

Object.defineProperty(exports, 'SuperLoader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_superLoader).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./audio-buffer-loader":328,"./loader":330,"./super-loader":331}],330:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets called if a parameter is missing and the expression
 * specifying the default value is evaluated.
 * @function
 */
function throwIfMissing() {
  throw new Error('Missing parameter');
}

/**
 * Promise based implementation of XMLHttpRequest Level 2 for GET method.
 */

var Loader = function () {
  /**
   * @constructs
   * @param {string} [responseType=""] - responseType's value, "text" (equal to ""), "arraybuffer", "blob", "document" or "json"
   */

  function Loader() {
    var responseType = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];
    (0, _classCallCheck3.default)(this, Loader);

    /**
     * @type {string}
     */
    this.responseType = responseType;
    // rename to `onProgress` ?
    /**
     * @type {function}
     */
    this.progressCb = undefined;
  }

  /**
   * Method for a promise based file loading.
   * Internally switch between loadOne and loadAll.
   * @public
   * @param {(string|string[])} fileURLs - The URL(s) of the files to load. Accepts a URL pointing to the file location or an array of URLs.
   * @returns {Promise}
   */


  (0, _createClass3.default)(Loader, [{
    key: 'load',
    value: function load() {
      var fileURLs = arguments.length <= 0 || arguments[0] === undefined ? throwIfMissing() : arguments[0];

      if (fileURLs === undefined) throw new Error('load needs at least a url to load');
      if (Array.isArray(fileURLs)) {
        return this.loadAll(fileURLs);
      } else {
        return this.loadOne(fileURLs);
      }
    }

    /**
     * Load a single file
     * @private
     * @param {string} fileURL - The URL of the file to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadOne',
    value: function loadOne(fileURL) {
      return this.fileLoadingRequest(fileURL);
    }

    /**
     * Load all files at once in a single array and return a Promise
     * @private
     * @param {string[]} fileURLs - The URLs array of the files to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadAll',
    value: function loadAll(fileURLs) {
      var urlsCount = fileURLs.length,
          promises = [];

      for (var i = 0; i < urlsCount; ++i) {
        promises.push(this.fileLoadingRequest(fileURLs[i], i));
      }

      return _promise2.default.all(promises);
    }

    /**
     * Load a file asynchronously, return a Promise.
     * @private
     * @param {string} url - The URL of the file to load
     * @param {string} [index] - The index of the file in the array of files to load
     * @returns {Promise}
     */

  }, {
    key: 'fileLoadingRequest',
    value: function fileLoadingRequest(url, index) {
      var _this = this;

      var promise = new _promise2.default(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.index = index;
        if (_this.responseType) {
          request.responseType = _this.responseType;
        } else {
          var suffix = '.json';
          if (url.indexOf(suffix, _this.length - suffix.length) !== -1) {
            request.responseType = 'json';
          } else {
            request.responseType = 'arraybuffer';
          }
        }
        request.addEventListener('load', function () {
          // Test request.status value, as 404 will also get there
          // Test request.status === 0 for cordova internal ajax calls
          if (request.status === 200 || request.status === 304 || request.status === 0) {
            // Hack for iOS 7, to remove as soon as possible
            if (this.responseType === 'json' && typeof request.response === 'string') {
              request.response = JSON.parse(request.response);
            }
            resolve(request.response);
          } else {
            reject(new Error(request.statusText));
          }
        });
        request.addEventListener('progress', function (evt) {
          if (_this.progressCallback) {
            if (index !== undefined) {
              _this.progressCallback({
                index: index,
                value: evt.loaded / evt.total,
                loaded: evt.loaded,
                total: evt.total
              });
            } else {
              _this.progressCallback({
                value: evt.loaded / evt.total,
                loaded: evt.loaded,
                total: evt.total
              });
            }
          }
        });
        // Manage network errors
        request.addEventListener('error', function () {
          reject(new Error('Network Error'));
        });

        request.send();
      });
      return promise;
    }

    /**
     * Get the callback function to get the progress of file loading process.
     * This is only for the file loading progress as decodeAudioData doesn't
     * expose a decode progress value.
     * @type {function}
     */

  }, {
    key: 'progressCallback',
    get: function get() {
      return this.progressCb;
    }

    /**
     * Set the callback function to get the progress of file loading process.
     * This is only for the file loading progress as decodeAudioData doesn't
     * expose a decode progress value.
     * @type {function} callback - The callback that handles the response.
     */
    ,
    set: function set(callback) {
      this.progressCb = callback;
    }
  }]);
  return Loader;
}();

exports.default = Loader;

},{"babel-runtime/core-js/promise":27,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/createClass":33}],331:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioBufferLoader = require('./audio-buffer-loader');

var _audioBufferLoader2 = _interopRequireDefault(_audioBufferLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SuperLoader
 * Helper to load multiple type of files, and get them in their useful type, json for json files, AudioBuffer for audio files.
 */

var SuperLoader = function (_AudioBufferLoader) {
  (0, _inherits3.default)(SuperLoader, _AudioBufferLoader);

  /**
   * Use composition to setup appropriate file loaders
   */

  function SuperLoader() {
    (0, _classCallCheck3.default)(this, SuperLoader);
    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SuperLoader).call(this, null));
    // bypass AudioBufferLoader constructor. This is bad but it works.
  }

  return SuperLoader;
}(_audioBufferLoader2.default);

exports.default = SuperLoader;

},{"./audio-buffer-loader":328,"babel-runtime/core-js/object/get-prototype-of":24,"babel-runtime/helpers/classCallCheck":32,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],332:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2NsaWVudC9iYXJyZWwvQmFycmVsRXhwZXJpZW5jZS5qcyIsImRpc3QvY2xpZW50L2JhcnJlbC9pbmRleC5qcyIsImRpc3QvY2xpZW50L2JhcnJlbC9zY2VuZXMvUGxhY2VyLmpzIiwiZGlzdC9jbGllbnQvYmFycmVsL3NjZW5lcy9jby05MDkuanMiLCJkaXN0L2NsaWVudC9iYXJyZWwvc2NlbmVzL2NvLW1peC5qcyIsImRpc3QvY2xpZW50L2JhcnJlbC9zY2VuZXMvY29sbGVjdGl2ZS1sb29wcy5qcyIsImRpc3QvY2xpZW50L2JhcnJlbC9zY2VuZXMvb2ZmLmpzIiwiZGlzdC9jbGllbnQvYmFycmVsL3NjZW5lcy93d3J5LXIuanMiLCJkaXN0L2NsaWVudC9zaGFyZWQvTG9vcFBsYXllci5qcyIsImRpc3QvY2xpZW50L3NoYXJlZC9RdWVlblBsYXllci5qcyIsImRpc3QvY2xpZW50L3NoYXJlZC9zZXJ2aWNlVmlld3MuanMiLCJkaXN0L3NoYXJlZC9zY2VuZXMtY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy93ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9CYXNlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9EcmFnQW5kRHJvcC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvR3JvdXAuanMiLCJub2RlX21vZHVsZXMvYmFzaWMtY29udHJvbGxlcnMvZGlzdC9jb21wb25lbnRzL051bWJlckJveC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvU2VsZWN0QnV0dG9ucy5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvU2VsZWN0TGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvU2xpZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9UZXh0LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9UaXRsZS5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvVG9nZ2xlLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9UcmlnZ2VyQnV0dG9ucy5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L2ZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvYmFzaWMtY29udHJvbGxlcnMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L21peGlucy9jb250YWluZXIuanMiLCJub2RlX21vZHVsZXMvYmFzaWMtY29udHJvbGxlcnMvZGlzdC9taXhpbnMvZGlzcGxheS5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L3V0aWxzL2VsZW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvdXRpbHMvc3R5bGVzLWRlY2xhcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9kaXN0L3V0aWxzL3N0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYXNpYy1jb250cm9sbGVycy9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi93ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wZXJmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvZG9tLWRlbGVnYXRlL2xpYi9kZWxlZ2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kb20tZGVsZWdhdGUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi91dGY4LmpzIiwibm9kZV9tb2R1bGVzL2d1aS1jb21wb25lbnRzL2Rpc3QvU2xpZGVyLmpzIiwibm9kZV9tb2R1bGVzL2d1aS1jb21wb25lbnRzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLWJpbmFyeTIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLWJpbmFyeTIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLWNvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5fcmVpbnRlcnBvbGF0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gudGVtcGxhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLnRlbXBsYXRlc2V0dGluZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9iaWxlLWRldGVjdC9tb2JpbGUtZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdGlvbi1pbnB1dC9kaXN0L0RPTUV2ZW50U3VibW9kdWxlLmpzIiwibm9kZV9tb2R1bGVzL21vdGlvbi1pbnB1dC9kaXN0L0RldmljZU1vdGlvbk1vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3Rpb24taW5wdXQvZGlzdC9EZXZpY2VPcmllbnRhdGlvbk1vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3Rpb24taW5wdXQvZGlzdC9FbmVyZ3lNb2R1bGUuanMiLCJub2RlX21vZHVsZXMvbW90aW9uLWlucHV0L2Rpc3QvSW5wdXRNb2R1bGUuanMiLCJub2RlX21vZHVsZXMvbW90aW9uLWlucHV0L2Rpc3QvTW90aW9uSW5wdXQuanMiLCJub2RlX21vZHVsZXMvbW90aW9uLWlucHV0L2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbm9zbGVlcC5qcy9kaXN0L05vU2xlZXAubWluLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlcXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BsYXRmb3JtL3BsYXRmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zY3JlZW5mdWxsL2Rpc3Qvc2NyZWVuZnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9jb3JlL0FjdGl2aXR5LmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L2NvcmUvRXhwZXJpZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9jb3JlL1Byb2Nlc3MuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvY29yZS9TZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L2NvcmUvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L2NvcmUvc2VydmljZU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvY29yZS9zb2NrZXQuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvY29yZS92aWV3TWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9wcmVmYWJzL0NvbnRyb2xsZXJFeHBlcmllbmNlLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3ByZWZhYnMvQ29udHJvbGxlclNjZW5lLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3ByZWZhYnMvU2VsZWN0Vmlldy5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9wcmVmYWJzL1NwYWNlVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9wcmVmYWJzL1NxdWFyZWRWaWV3LmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3NlcnZpY2VzL0F1ZGlvQnVmZmVyTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9BdWRpb1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9BdWRpb1N0cmVhbU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvc2VydmljZXMvQXV0aC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9DaGVja2luLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3NlcnZpY2VzL0Vycm9yUmVwb3J0ZXIuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvc2VydmljZXMvRmlsZVN5c3RlbS5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9HZW9sb2NhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9MYW5ndWFnZS5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9Mb2NhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3NlcnZpY2VzL01ldHJpY1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9Nb3Rpb25JbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9OZXR3b3JrLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3NlcnZpY2VzL1BsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9QbGF0Zm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9SYXdTb2NrZXQuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvc2VydmljZXMvU2hhcmVkQ29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3NlcnZpY2VzL1NoYXJlZFBhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9TaGFyZWRSZWNvcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC9zZXJ2aWNlcy9TeW5jLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3NlcnZpY2VzL1N5bmNTY2hlZHVsZXIuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvdmlld3MvQ2FudmFzMmRSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC92aWV3cy9DYW52YXNSZW5kZXJpbmdHcm91cC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL2NsaWVudC92aWV3cy9DYW52YXNWaWV3LmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3ZpZXdzL1NlZ21lbnRlZFZpZXcuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvdmlld3MvVG91Y2hTdXJmYWNlLmpzIiwibm9kZV9tb2R1bGVzL3NvdW5kd29ya3MvY2xpZW50L3ZpZXdzL1ZpZXcuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9jbGllbnQvdmlld3Mvdmlld3BvcnQuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc291bmR3b3Jrcy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL3V0aWxzL0V2ZW50RW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL3V0aWxzL1NpZ25hbC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL3V0aWxzL1NpZ25hbEFsbC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VuZHdvcmtzL3V0aWxzL21hdGguanMiLCJub2RlX21vZHVsZXMvc3luYy9jbGllbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9jb3JlL2F1ZGlvLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvY29yZS9wcmlvcml0eS1xdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L2NvcmUvc2NoZWR1bGluZy1xdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L2NvcmUvdGltZS1lbmdpbmUuanMiLCJub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9lbmdpbmVzL2dyYW51bGFyLWVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L2VuZ2luZXMvbWV0cm9ub21lLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvZW5naW5lcy9wbGF5ZXItZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvZW5naW5lcy9zZWdtZW50LWVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvbWFzdGVycy9mYWN0b3JpZXMuanMiLCJub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9tYXN0ZXJzL3BsYXktY29udHJvbC5qcyIsIm5vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L21hc3RlcnMvc2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvbWFzdGVycy9zaW1wbGUtc2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvbWFzdGVycy90cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvd2F2ZXMtbG9hZGVycy9kaXN0L2F1ZGlvLWJ1ZmZlci1sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvd2F2ZXMtbG9hZGVycy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWxvYWRlcnMvZGlzdC9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvd2F2ZXMtbG9hZGVycy9kaXN0L3N1cGVyLWxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7O0lBQVksVTs7QUFDWjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0FBQ0EsSUFBTSxlQUFlLFdBQVcsWUFBaEM7O0FBRUEsSUFBTSxhQUFhO0FBQ2pCLFNBQU8sYUFEVTtBQUVqQixZQUFVLFlBRk87QUFHakIsc0JBQW9CLHlCQUhIO0FBSWpCLFlBQVUsZUFKTztBQUtqQixZQUFVO0FBTE8sQ0FBbkI7O0FBUUEsSUFBTSx5S0FBTjs7QUFTQSxJQUFNLG9CQUFvQixDQUExQixDLENBQTZCO0FBQzdCLElBQU0sOEJBQThCLGFBQWEsV0FBYixDQUF5QixlQUE3RDtBQUNBLElBQU0sa0JBQWtCLDhCQUE4QixLQUFLLEdBQUwsQ0FBUyxpQkFBVCxFQUE0QiwyQkFBNUIsQ0FBOUIsR0FBeUYsQ0FBakgsQyxDQUFvSDs7SUFFL0YsZ0I7OztBQUNuQiw0QkFBWSxZQUFaLEVBQTBCO0FBQUE7O0FBQUE7O0FBR3hCLFVBQUssUUFBTCxHQUFnQixNQUFLLE9BQUwsQ0FBYSxVQUFiLEVBQXlCLEVBQUUsVUFBVSxDQUFDLFdBQUQsQ0FBWixFQUEyQixZQUFZLElBQXZDLEVBQXpCLENBQWhCO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE1BQUssT0FBTCxDQUFhLGVBQWIsQ0FBcEI7QUFDQSxVQUFLLGtCQUFMLEdBQTBCLE1BQUssT0FBTCxDQUFhLHNCQUFiLEVBQXFDLEVBQUUsY0FBYyxZQUFoQixFQUFyQyxDQUExQjtBQUNBLFVBQUssZUFBTCxHQUF1QixNQUFLLE9BQUwsQ0FBYSxrQkFBYixDQUF2Qjs7QUFFQSxVQUFLLE1BQUwsR0FBYyxFQUFkO0FB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QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzErQkE7Ozs7Ozs7Ozs7OztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25NQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUdBOzs7Ozs7O0lBT00sUTs7O0FBQ0o7Ozs7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDN0IsV0FBSyxVQUFMLEdBQWtCLFFBQWxCLENBRDZCOzs7U0E1SVo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNickI7Ozs7Ozs7Ozs7O0lBT3FCOzs7Ozs7O0FBSW5CLFdBSm1CLFdBSW5CLEdBQWM7d0NBSkssYUFJTDt3RkFKSyx3QkFLWDs7QUFETSxHQUFkOztTQUptQjs7Ozs7O0FDUHJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImltcG9ydCAqIGFzIHNvdW5kd29ya3MgZnJvbSAnc291bmR3b3Jrcy9jbGllbnQnO1xuaW1wb3J0IHsgZGVjaWJlbFRvTGluZWFyIH0gZnJvbSAnc291bmR3b3Jrcy91dGlscy9tYXRoJztcbmltcG9ydCBzY2VuZUNvbmZpZyBmcm9tICcuLi8uLi9zaGFyZWQvc2NlbmVzLWNvbmZpZyc7XG5pbXBvcnQgU2NlbmVPZmYgZnJvbSAnLi9zY2VuZXMvb2ZmJztcbmltcG9ydCBTY2VuZUNvOTA5IGZyb20gJy4vc2NlbmVzL2NvLTkwOSc7XG5pbXBvcnQgU2NlbmVDb2xsZWN0aXZlTG9vcHMgZnJvbSAnLi9zY2VuZXMvY29sbGVjdGl2ZS1sb29wcyc7XG5pbXBvcnQgU2NlbmVDb01peCBmcm9tICcuL3NjZW5lcy9jby1taXgnO1xuaW1wb3J0IFNjZW5lV3dyeVIgZnJvbSAnLi9zY2VuZXMvd3dyeS1yJztcbmNvbnN0IGF1ZGlvQ29udGV4dCA9IHNvdW5kd29ya3MuYXVkaW9Db250ZXh0O1xuXG5jb25zdCBzY2VuZUN0b3JzID0ge1xuICAnb2ZmJzogU2NlbmVPZmYsXG4gICdjby05MDknOiBTY2VuZUNvOTA5LFxuICAnY29sbGVjdGl2ZS1sb29wcyc6IFNjZW5lQ29sbGVjdGl2ZUxvb3BzLFxuICAnY28tbWl4JzogU2NlbmVDb01peCxcbiAgJ3d3cnktcic6IFNjZW5lV3dyeVIsXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IGBcbiAgPGNhbnZhcyBjbGFzcz1cImJhY2tncm91bmRcIj48L2NhbnZhcz5cbiAgPGRpdiBjbGFzcz1cImZvcmVncm91bmRcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleC1taWRkbGVcIj5cbiAgICAgIDxwIGNsYXNzPVwiYmlnXCI+QmFycmVsPC9wPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbmA7XG5cbmNvbnN0IG51bU91dHB1dENoYW5uZWxzID0gODsgLy8gXCJ2aXJ0dWFsXCIgb3V0cHV0IGNoYW5uZWxzXG5jb25zdCBtYXhBdWRpb0Rlc3RpbmF0aW9uQ2hhbm5lbHMgPSBhdWRpb0NvbnRleHQuZGVzdGluYXRpb24ubWF4Q2hhbm5lbENvdW50O1xuY29uc3QgbnVtQXVkaW9PdXRwdXRzID0gbWF4QXVkaW9EZXN0aW5hdGlvbkNoYW5uZWxzID8gTWF0aC5taW4obnVtT3V0cHV0Q2hhbm5lbHMsIG1heEF1ZGlvRGVzdGluYXRpb25DaGFubmVscykgOiAyOyAvLyBcInBoeXNpY2FsXCIgYXVkaW8gb3V0cHV0c1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJyZWxFeHBlcmllbmNlIGV4dGVuZHMgc291bmR3b3Jrcy5FeHBlcmllbmNlIHtcbiAgY29uc3RydWN0b3IoYXNzZXRzRG9tYWluKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucGxhdGZvcm0gPSB0aGlzLnJlcXVpcmUoJ3BsYXRmb3JtJywgeyBmZWF0dXJlczogWyd3ZWItYXVkaW8nXSwgc2hvd0RpYWxvZzogdHJ1ZSB9KTtcbiAgICB0aGlzLnNoYXJlZFBhcmFtcyA9IHRoaXMucmVxdWlyZSgnc2hhcmVkLXBhcmFtcycpO1xuICAgIHRoaXMuYXVkaW9CdWZmZXJNYW5hZ2VyID0gdGhpcy5yZXF1aXJlKCdhdWRpby1idWZmZXItbWFuYWdlcicsIHsgYXNzZXRzRG9tYWluOiBhc3NldHNEb21haW4gfSk7XG4gICAgdGhpcy5tZXRyaWNTY2hlZHVsZXIgPSB0aGlzLnJlcXVpcmUoJ21ldHJpYy1zY2hlZHVsZXInKTtcblxuICAgIHRoaXMuc2NlbmVzID0ge307XG4gICAgdGhpcy5jdXJyZW50U2NlbmUgPSBudWxsO1xuXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy5vdXRwdXRCdXNzZXMgPSBuZXcgQXJyYXkobnVtT3V0cHV0Q2hhbm5lbHMpOyAvLyBvdXRwdXQgY2hhbm5lbHMgKGFycmF5IG9mIGdhaW4gbm9kZXMpXG4gICAgdGhpcy5jcm9zc0ZpbHRlcnMgPSBuZXcgQXJyYXkobnVtT3V0cHV0Q2hhbm5lbHMpOyAvLyBjaGFubmVsIGNyb3NzLW92ZXIgZmlsdGVycyAoYXJyYXkgb2YgYmlxdWFkIGZpbHRlciBub2RlcylcbiAgICB0aGlzLndvb2ZlckJ1c3MgPSBudWxsOyAvLyBiYXNzIHdvb2ZlciBnYWluIG5vZGVcbiAgICB0aGlzLndvb2ZlckdhaW4gPSAxOyAvLyBiYXNzIHdvb2ZlciBnYWluIChsaW5lYXIgYW1wbGl0dWRlIGZhY3RvcilcbiAgICB0aGlzLmRlbGF5ID0gMC4wMjtcblxuICAgIHRoaXMub25TY2VuZUNoYW5nZSA9IHRoaXMub25TY2VuZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Db25uZWN0Q2xpZW50ID0gdGhpcy5vbkNvbm5lY3RDbGllbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRGlzY29ubmVjdENsaWVudCA9IHRoaXMub25EaXNjb25uZWN0Q2xpZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNsZWFyID0gdGhpcy5vbkNsZWFyLmJpbmQodGhpcyk7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgdGhpcy52aWV3ID0gbmV3IHNvdW5kd29ya3MuVmlldyh0ZW1wbGF0ZSwge30sIHt9LCB7IGlkOiAnYmFycmVsJyB9KTtcbiAgICB0aGlzLnNob3coKTtcblxuICAgIHRoaXMuaW5pdFNjZW5lcygpO1xuXG4gICAgdGhpcy5pbml0QXVkaW8obnVtQXVkaW9PdXRwdXRzKTsgLy8gaW5pdCBhdWRpbyBvdXRwdXRzIGZvciBhbiBpbnRlcmZhY2Ugb2YgdGhlIGdpdmVuIG51bWJlciBvZiBjaGFubmVsc1xuICAgIHRoaXMuaW5pdFBhcmFtcygpO1xuXG4gICAgdGhpcy5yZWNlaXZlKCdjb25uZWN0Q2xpZW50JywgdGhpcy5vbkNvbm5lY3RDbGllbnQpO1xuICAgIHRoaXMucmVjZWl2ZSgnZGlzY29ubmVjdENsaWVudCcsIHRoaXMub25EaXNjb25uZWN0Q2xpZW50KTtcbiAgICB0aGlzLnNoYXJlZFBhcmFtcy5hZGRQYXJhbUxpc3RlbmVyKCdjbGVhcicsIHRoaXMub25DbGVhcik7XG4gIH1cblxuICBpbml0QXVkaW8obnVtQXVkaW9PdXRwdXRzID0gMikge1xuICAgIGNvbnN0IGNoYW5uZWxNZXJnZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcihudW1PdXRwdXRDaGFubmVscyk7XG4gICAgY29uc3QgYmFzc1dvb2ZlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU91dHB1dENoYW5uZWxzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgY29uc3QgbG93cGFzcyA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgIGNvbnN0IGludmVydGVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAgICAgbG93cGFzcy50eXBlID0gJ2xvd3Bhc3MnO1xuICAgICAgbG93cGFzcy5mcmVxdWVuY3kudmFsdWUgPSAyNTA7IC8vIHNldCBkZWZhdWx0IHdvb2ZlciBjdXRvZmYgZnJlcXVlbmN5IHRvIDI1MCBIelxuICAgICAgaW52ZXJ0ZXIuZ2Fpbi52YWx1ZSA9IC0xO1xuXG4gICAgICAvLyBjb25uZWN0XG4gICAgICBjaGFubmVsLmNvbm5lY3QobG93cGFzcyk7XG5cbiAgICAgIC8vIGNvbm5lY3QgaGlnaCBwYXNzIHRvIHNpbmdsZSBvdXRwdXQgY2hhbm5lbCxcbiAgICAgIC8vIGhpZ2hwYXNzID0gY2hhbm5lbCAtIGxvd3Bhc3MoY2hhbm5lbCkgPSBjaGFubmVsICsgaW52ZXJ0ZXIobG93cGFzcyhjaGFubmVsKSlcbiAgICAgIGNoYW5uZWwuY29ubmVjdChjaGFubmVsTWVyZ2VyLCAwLCBpKTtcbiAgICAgIGxvd3Bhc3MuY29ubmVjdChpbnZlcnRlcik7XG4gICAgICBpbnZlcnRlci5jb25uZWN0KGNoYW5uZWxNZXJnZXIsIDAsIGkpO1xuXG4gICAgICAvLyBjb25uZWN0IGxvdyBwYXNzICh2aXJ0dWFsKSB0byBiYXNzIHdvb2ZlclxuICAgICAgbG93cGFzcy5jb25uZWN0KGJhc3NXb29mZXIpO1xuXG4gICAgICB0aGlzLm91dHB1dEJ1c3Nlc1tpXSA9IGNoYW5uZWw7XG4gICAgICB0aGlzLmNyb3NzRmlsdGVyc1tpXSA9IGxvd3Bhc3M7XG4gICAgfVxuXG4gICAgLy8gY29ubmVjdCBiYXNzIHdvb2ZlciB0byBhbGwgb3V0cHV0IGNoYW5uZWxzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PdXRwdXRDaGFubmVsczsgaSsrKVxuICAgICAgYmFzc1dvb2Zlci5jb25uZWN0KGNoYW5uZWxNZXJnZXIsIDAsIGkpO1xuXG4gICAgdGhpcy53b29mZXJCdXNzID0gYmFzc1dvb2ZlcjtcbiAgICB0aGlzLnNldFdvb2ZlckdhaW4oMCk7IC8vIHNldCBkZWZhdWx0IHdvb2ZlciBnYWluIHRvIDAgZEJcblxuICAgIGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbi5jaGFubmVsQ291bnQgPSBudW1BdWRpb091dHB1dHM7XG4gICAgbGV0IGNoYW5uZWxEZXN0aW5hdGlvbiA9IGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbjtcblxuICAgIGlmIChudW1BdWRpb091dHB1dHMgPCBudW1PdXRwdXRDaGFubmVscykge1xuICAgICAgY29uc3Qgc3BsaXR0ZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKG51bU91dHB1dENoYW5uZWxzKTtcbiAgICAgIGNvbnN0IG91dHB1dE1lcmdlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKG51bUF1ZGlvT3V0cHV0cyk7XG5cbiAgICAgIGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbi5jaGFubmVsQ291bnQgPSBudW1BdWRpb091dHB1dHM7XG4gICAgICBvdXRwdXRNZXJnZXIuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgY2hhbm5lbE1lcmdlci5jb25uZWN0KHNwbGl0dGVyKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PdXRwdXRDaGFubmVsczsgaSsrKVxuICAgICAgICBzcGxpdHRlci5jb25uZWN0KG91dHB1dE1lcmdlciwgaSwgaSAlIG51bUF1ZGlvT3V0cHV0cyk7XG5cbiAgICAgIGNoYW5uZWxEZXN0aW5hdGlvbiA9IHNwbGl0dGVyO1xuICAgIH1cblxuICAgIGNoYW5uZWxNZXJnZXIuY29ubmVjdChjaGFubmVsRGVzdGluYXRpb24pO1xuICB9XG5cbiAgaW5pdFBhcmFtcygpIHtcbiAgICB0aGlzLnNoYXJlZFBhcmFtcy5hZGRQYXJhbUxpc3RlbmVyKCdzY2VuZScsIHRoaXMub25TY2VuZUNoYW5nZSk7XG4gICAgdGhpcy5zaGFyZWRQYXJhbXMuYWRkUGFyYW1MaXN0ZW5lcignb3V0cHV0R2FpbjAnLCAodmFsdWUpID0+IHRoaXMuc2V0T3V0cHV0R2FpbigwLCB2YWx1ZSkpO1xuICAgIHRoaXMuc2hhcmVkUGFyYW1zLmFkZFBhcmFtTGlzdGVuZXIoJ291dHB1dEdhaW4xJywgKHZhbHVlKSA9PiB0aGlzLnNldE91dHB1dEdhaW4oMSwgdmFsdWUpKTtcbiAgICB0aGlzLnNoYXJlZFBhcmFtcy5hZGRQYXJhbUxpc3RlbmVyKCdvdXRwdXRHYWluMicsICh2YWx1ZSkgPT4gdGhpcy5zZXRPdXRwdXRHYWluKDIsIHZhbHVlKSk7XG4gICAgdGhpcy5zaGFyZWRQYXJhbXMuYWRkUGFyYW1MaXN0ZW5lcignb3V0cHV0R2FpbjMnLCAodmFsdWUpID0+IHRoaXMuc2V0T3V0cHV0R2FpbigzLCB2YWx1ZSkpO1xuICAgIHRoaXMuc2hhcmVkUGFyYW1zLmFkZFBhcmFtTGlzdGVuZXIoJ291dHB1dEdhaW40JywgKHZhbHVlKSA9PiB0aGlzLnNldE91dHB1dEdhaW4oNCwgdmFsdWUpKTtcbiAgICB0aGlzLnNoYXJlZFBhcmFtcy5hZGRQYXJhbUxpc3RlbmVyKCdvdXRwdXRHYWluNScsICh2YWx1ZSkgPT4gdGhpcy5zZXRPdXRwdXRHYWluKDUsIHZhbHVlKSk7XG4gICAgdGhpcy5zaGFyZWRQYXJhbXMuYWRkUGFyYW1MaXN0ZW5lcignb3V0cHV0R2FpbjYnLCAodmFsdWUpID0+IHRoaXMuc2V0T3V0cHV0R2Fpbig2LCB2YWx1ZSkpO1xuICAgIHRoaXMuc2hhcmVkUGFyYW1zLmFkZFBhcmFtTGlzdGVuZXIoJ291dHB1dEdhaW43JywgKHZhbHVlKSA9PiB0aGlzLnNldE91dHB1dEdhaW4oNywgdmFsdWUpKTtcbiAgICB0aGlzLnNoYXJlZFBhcmFtcy5hZGRQYXJhbUxpc3RlbmVyKCd3b29mZXJHYWluJywgKHZhbHVlKSA9PiB0aGlzLnNldFdvb2ZlckdhaW4odmFsdWUpKTtcbiAgICB0aGlzLnNoYXJlZFBhcmFtcy5hZGRQYXJhbUxpc3RlbmVyKCd3b29mZXJDdXRvZmYnLCAodmFsdWUpID0+IHRoaXMuc2V0V29vZmVyQ3V0b2ZmKHZhbHVlKSk7XG4gICAgdGhpcy5zaGFyZWRQYXJhbXMuYWRkUGFyYW1MaXN0ZW5lcignYmFycmVsRGVsYXknLCAodmFsdWUpID0+IHRoaXMuc2V0RGVsYXkodmFsdWUpKTtcbiAgfVxuXG4gIGluaXRTY2VuZXMoKSB7XG4gICAgZm9yIChsZXQgc2NlbmUgaW4gc2NlbmVDdG9ycykge1xuICAgICAgY29uc3QgY3RvciA9IHNjZW5lQ3RvcnNbc2NlbmVdO1xuICAgICAgY29uc3QgY29uZmlnID0gc2NlbmVDb25maWdbc2NlbmVdO1xuXG4gICAgICBpZiAoY29uZmlnKVxuICAgICAgICB0aGlzLnNjZW5lc1tzY2VuZV0gPSBuZXcgY3Rvcih0aGlzLCBjb25maWcpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGNvbmZpZyBmb3Igc2NlbmUgJyR7c2NlbmV9J2ApO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFNjZW5lID0gdGhpcy5zY2VuZXMub2ZmO1xuICAgIHRoaXMuZW50ZXJDdXJyZW50U2NlbmUoKTtcbiAgfVxuXG4gIHNldE91dHB1dEdhaW4oaW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5vdXRwdXRCdXNzZXNbaW5kZXhdLmdhaW4udmFsdWUgPSBkZWNpYmVsVG9MaW5lYXIodmFsdWUpO1xuICB9XG5cbiAgc2V0V29vZmVyR2Fpbih2YWx1ZSkge1xuICAgIHRoaXMud29vZmVyQnVzcy5nYWluLnZhbHVlID0gZGVjaWJlbFRvTGluZWFyKHZhbHVlKSAvIG51bU91dHB1dENoYW5uZWxzO1xuICB9XG5cbiAgc2V0V29vZmVyQ3V0b2ZmKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PdXRwdXRDaGFubmVsczsgaSsrKVxuICAgICAgdGhpcy5jcm9zc0ZpbHRlcnNbaV0uZnJlcXVlbmN5LnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBzZXREZWxheSh2YWx1ZSkge1xuICAgIHRoaXMuZGVsYXkgPSB2YWx1ZTtcbiAgfVxuXG4gIGVudGVyQ3VycmVudFNjZW5lKCkge1xuICAgIHRoaXMuY3VycmVudFNjZW5lLmVudGVyKCk7XG5cbiAgICBmb3IgKGxldCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKVxuICAgICAgdGhpcy5jdXJyZW50U2NlbmUuY2xpZW50RW50ZXIoY2xpZW50KTtcbiAgfVxuXG4gIGV4aXRDdXJyZW50U2NlbmUoKSB7XG4gICAgdGhpcy5jdXJyZW50U2NlbmUuZXhpdCgpO1xuXG4gICAgZm9yIChsZXQgY2xpZW50IG9mIHRoaXMuY2xpZW50cylcbiAgICAgIHRoaXMuY3VycmVudFNjZW5lLmNsaWVudEV4aXQoY2xpZW50KTtcbiAgfVxuXG4gIG9uU2NlbmVDaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmV4aXRDdXJyZW50U2NlbmUoKTtcbiAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IHRoaXMuc2NlbmVzW3ZhbHVlXTtcbiAgICB0aGlzLmVudGVyQ3VycmVudFNjZW5lKCk7XG4gIH1cblxuICBvbkNvbm5lY3RDbGllbnQoaW5kZXgpIHtcbiAgICB0aGlzLmNsaWVudHMuYWRkKGluZGV4KTtcbiAgICB0aGlzLmN1cnJlbnRTY2VuZS5jbGllbnRFbnRlcihpbmRleCk7XG4gIH1cblxuICBvbkRpc2Nvbm5lY3RDbGllbnQoaW5kZXgpIHtcbiAgICB0aGlzLmNsaWVudHMuZGVsZXRlKGluZGV4KTtcbiAgICB0aGlzLmN1cnJlbnRTY2VuZS5jbGllbnRFeGl0KGluZGV4KTtcbiAgfVxuXG4gIG9uQ2xlYXIoaW5kZXgpIHtcbiAgICBpZih0aGlzLmN1cnJlbnRTY2VuZS5jbGVhcilcbiAgICAgIHRoaXMuY3VycmVudFNjZW5lLmNsZWFyKGluZGV4KTtcbiAgfVxufVxuIiwiLy8gaW1wb3J0IGNsaWVudCBzaWRlIHNvdW5kd29ya3MgYW5kIHBsYXllciBleHBlcmllbmNlXG5pbXBvcnQgKiBhcyBzb3VuZHdvcmtzIGZyb20gJ3NvdW5kd29ya3MvY2xpZW50JztcbmltcG9ydCBCYXJyZWxFeHBlcmllbmNlIGZyb20gJy4vQmFycmVsRXhwZXJpZW5jZSc7XG5pbXBvcnQgc2VydmljZVZpZXdzIGZyb20gJy4uL3NoYXJlZC9zZXJ2aWNlVmlld3MnO1xuXG5mdW5jdGlvbiBib290c3RyYXAoKSB7XG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBhcHBDb250YWluZXI6ICcjY29udGFpbmVyJyB9LCB3aW5kb3cuc291bmR3b3Jrc0NvbmZpZyk7XG4gIHNvdW5kd29ya3MuY2xpZW50LmluaXQoY29uZmlnLmNsaWVudFR5cGUsIGNvbmZpZyk7XG5cbiAgc291bmR3b3Jrcy5jbGllbnQuc2V0U2VydmljZUluc3RhbmNpYXRpb25Ib29rKChpZCwgaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoc2VydmljZVZpZXdzLmhhcyhpZCkpXG4gICAgICBpbnN0YW5jZS52aWV3ID0gc2VydmljZVZpZXdzLmdldChpZCwgY29uZmlnKTtcbiAgfSk7XG5cbiAgY29uc3QgZXhwZXJpZW5jZSA9IG5ldyBCYXJyZWxFeHBlcmllbmNlKGNvbmZpZy5hc3NldHNEb21haW4pO1xuICBzb3VuZHdvcmtzLmNsaWVudC5zdGFydCgpO1xufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGJvb3RzdHJhcCk7XG4iLCJpbXBvcnQgKiBhcyBzb3VuZHdvcmtzIGZyb20gJ3NvdW5kd29ya3MvY2xpZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxhY2VyIHtcbiAgY29uc3RydWN0b3IoZXhwZXJpZW5jZSkge1xuICAgIHRoaXMuZXhwZXJpZW5jZSA9IGV4cGVyaWVuY2U7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcblxuICAgIHRoaXMub25Eb25lID0gdGhpcy5vbkRvbmUuYmluZCh0aGlzKTtcbiAgICBleHBlcmllbmNlLnJlY2VpdmUoJ3BsYWNlckRvbmUnLCB0aGlzLm9uRG9uZSk7XG4gIH1cblxuICBzdGFydChpbmRleCwgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHt9KSB7XG4gICAgdGhpcy5jYWxsYmFja3NbaW5kZXhdID0gY2FsbGJhY2s7XG4gIH1cblxuICBzdG9wKGluZGV4KSB7XG4gICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2luZGV4XTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIH1cblxuICBvbkRvbmUoaW5kZXgpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2luZGV4XTtcblxuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIGNhbGxiYWNrKGluZGV4KTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgc291bmR3b3JrcyBmcm9tICdzb3VuZHdvcmtzL2NsaWVudCc7XG5pbXBvcnQgeyBkZWNpYmVsVG9MaW5lYXIgfSBmcm9tICdzb3VuZHdvcmtzL3V0aWxzL21hdGgnO1xuY29uc3QgYXVkaW9Db250ZXh0ID0gc291bmR3b3Jrcy5hdWRpb0NvbnRleHQ7XG5jb25zdCBhdWRpb1NjaGVkdWxlciA9IHNvdW5kd29ya3MuYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lQ285MDkge1xuICBjb25zdHJ1Y3RvcihleHBlcmllbmNlLCBjb25maWcpIHtcbiAgICB0aGlzLmV4cGVyaWVuY2UgPSBleHBlcmllbmNlO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuaW5zdHJ1bWVudHMgPSBudWxsO1xuXG4gICAgY29uc3QgbnVtU3RlcHMgPSBjb25maWcubnVtU3RlcHM7XG4gICAgY29uc3QgbnVtSW5zdHJ1bWVudHMgPSBjb25maWcuaW5zdHJ1bWVudHMubGVuZ3RoO1xuXG4gICAgdGhpcy5pbnN0cnVtZW50U2VxdWVuY2VzID0gbmV3IEFycmF5KG51bUluc3RydW1lbnRzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5zdHJ1bWVudHM7IGkrKykge1xuICAgICAgdGhpcy5pbnN0cnVtZW50U2VxdWVuY2VzW2ldID0gbmV3IEFycmF5KG51bVN0ZXBzKTtcbiAgICAgIHRoaXMucmVzZXRJbnN0cnVtZW50U2VxdWVuY2UoaSk7XG4gICAgfVxuXG4gICAgdGhpcy5vdXRwdXRCdXNzZXMgPSBleHBlcmllbmNlLm91dHB1dEJ1c3NlcztcblxuICAgIHRoaXMub25NZXRyb0JlYXQgPSB0aGlzLm9uTWV0cm9CZWF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblN3aXRjaE5vdGUgPSB0aGlzLm9uU3dpdGNoTm90ZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY2xpZW50RW50ZXIoaW5kZXgpIHt9XG5cbiAgY2xpZW50RXhpdChpbmRleCkge1xuICAgIHRoaXMucmVzZXRJbnN0cnVtZW50U2VxdWVuY2UoaW5kZXgpO1xuICB9XG5cbiAgZW50ZXJTY2VuZSgpIHtcbiAgICBjb25zdCBleHBlcmllbmNlID0gdGhpcy5leHBlcmllbmNlO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gdGhpcy5jb25maWcubnVtU3RlcHM7XG4gICAgZXhwZXJpZW5jZS5tZXRyaWNTY2hlZHVsZXIuYWRkTWV0cm9ub21lKHRoaXMub25NZXRyb0JlYXQsIG51bVN0ZXBzLCBudW1TdGVwcywgMSwgMCwgdHJ1ZSk7XG4gICAgZXhwZXJpZW5jZS5yZWNlaXZlKCdzd2l0Y2hOb3RlJywgdGhpcy5vblN3aXRjaE5vdGUpO1xuICB9XG5cbiAgZW50ZXIoKSB7XG4gICAgY29uc3QgZXhwZXJpZW5jZSA9IHRoaXMuZXhwZXJpZW5jZTtcblxuICAgIGlmICh0aGlzLmluc3RydW1lbnRzKSB7XG4gICAgICB0aGlzLmVudGVyU2NlbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5zdHJ1bWVudENvbmZpZyA9IHRoaXMuY29uZmlnLmluc3RydW1lbnRzO1xuICAgICAgZXhwZXJpZW5jZS5hdWRpb0J1ZmZlck1hbmFnZXIubG9hZEZpbGVzKGluc3RydW1lbnRDb25maWcpLnRoZW4oKGluc3RydW1lbnRzKSA9PiB7XG4gICAgICAgIHRoaXMuaW5zdHJ1bWVudHMgPSBpbnN0cnVtZW50cztcbiAgICAgICAgdGhpcy5lbnRlclNjZW5lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBleGl0KCkge1xuICAgIGNvbnN0IGV4cGVyaWVuY2UgPSB0aGlzLmV4cGVyaWVuY2U7XG4gICAgZXhwZXJpZW5jZS5tZXRyaWNTY2hlZHVsZXIucmVtb3ZlTWV0cm9ub21lKHRoaXMub25NZXRyb0JlYXQpO1xuICAgIGV4cGVyaWVuY2Uuc3RvcFJlY2VpdmluZygnc3dpdGNoTm90ZScsIHRoaXMub25Td2l0Y2hOb3RlKTtcbiAgfVxuXG4gIHJlc2V0SW5zdHJ1bWVudFNlcXVlbmNlKGluc3RydW1lbnQpIHtcbiAgICBjb25zdCBzZXF1ZW5jZSA9IHRoaXMuaW5zdHJ1bWVudFNlcXVlbmNlc1tpbnN0cnVtZW50XTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlcXVlbmNlW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5zdHJ1bWVudFNlcXVlbmNlcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMucmVzZXRJbnN0cnVtZW50U2VxdWVuY2UoaSk7XG4gIH1cblxuICBvbk1ldHJvQmVhdChtZWFzdXJlLCBiZWF0KSB7XG4gICAgY29uc3QgdGltZSA9IGF1ZGlvU2NoZWR1bGVyLmN1cnJlbnRUaW1lO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydW1lbnRTZXF1ZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RydW1lbnQgPSB0aGlzLmluc3RydW1lbnRzW2ldO1xuICAgICAgY29uc3Qgc2VxdWVuY2UgPSB0aGlzLmluc3RydW1lbnRTZXF1ZW5jZXNbaV07XG4gICAgICBjb25zdCBzdGF0ZSA9IHNlcXVlbmNlW2JlYXRdO1xuXG4gICAgICBpZiAoc3RhdGUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gaW5zdHJ1bWVudC5sYXllcnNbc3RhdGUgLSAxXTtcblxuICAgICAgICBjb25zdCBnYWluID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTsgXG4gICAgICAgIGdhaW4uY29ubmVjdCh0aGlzLm91dHB1dEJ1c3Nlc1tpXSk7XG4gICAgICAgIGdhaW4uZ2Fpbi52YWx1ZSA9IGRlY2liZWxUb0xpbmVhcihsYXllci5nYWluKTtcblxuICAgICAgICBjb25zdCBzcmMgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIHNyYy5jb25uZWN0KGdhaW4pO1xuICAgICAgICBzcmMuYnVmZmVyID0gbGF5ZXIuYnVmZmVyO1xuICAgICAgICBzcmMuc3RhcnQodGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Td2l0Y2hOb3RlKGluc3RydW1lbnQsIGJlYXQsIHN0YXRlKSB7XG4gICAgY29uc3Qgc2VxdWVuY2UgPSB0aGlzLmluc3RydW1lbnRTZXF1ZW5jZXNbaW5zdHJ1bWVudF07XG4gICAgc2VxdWVuY2VbYmVhdF0gPSBzdGF0ZTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgc291bmR3b3JrcyBmcm9tICdzb3VuZHdvcmtzL2NsaWVudCc7XG5pbXBvcnQgUGxhY2VyIGZyb20gJy4vUGxhY2VyJztcbmltcG9ydCBMb29wUGxheWVyIGZyb20gJy4uLy4uL3NoYXJlZC9Mb29wUGxheWVyJztcbmNvbnN0IGF1ZGlvQ29udGV4dCA9IHNvdW5kd29ya3MuYXVkaW9Db250ZXh0O1xuY29uc3QgYXVkaW9TY2hlZHVsZXIgPSBzb3VuZHdvcmtzLmF1ZGlvLmdldFNjaGVkdWxlcigpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZUNvTWl4IHtcbiAgY29uc3RydWN0b3IoZXhwZXJpZW5jZSwgY29uZmlnKSB7XG4gICAgdGhpcy5leHBlcmllbmNlID0gZXhwZXJpZW5jZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm5vdGVzID0gbnVsbDtcblxuICAgIGNvbnN0IG51bVRyYWNrcyA9IGNvbmZpZy50cmFja3MubGVuZ3RoO1xuICAgIHRoaXMub3V0cHV0QnVzc2VzID0gZXhwZXJpZW5jZS5vdXRwdXRCdXNzZXM7XG5cbiAgICB0aGlzLnBsYWNlciA9IG5ldyBQbGFjZXIoZXhwZXJpZW5jZSk7XG4gICAgdGhpcy5sb29wUGxheWVyID0gbnVsbDtcblxuICAgIHRoaXMub25UcmFja0N1dG9mZiA9IHRoaXMub25UcmFja0N1dG9mZi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Td2l0Y2hMYXllciA9IHRoaXMub25Td2l0Y2hMYXllci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY2xpZW50RW50ZXIoaW5kZXgpIHtcbiAgICBjb25zdCBleHBlcmllbmNlID0gdGhpcy5leHBlcmllbmNlO1xuXG4gICAgdGhpcy5wbGFjZXIuc3RhcnQoaW5kZXgsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvb3BQbGF5ZXIgPSB0aGlzLmxvb3BQbGF5ZXI7XG5cbiAgICAgIGlmIChsb29wUGxheWVyKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbaW5kZXhdO1xuICAgICAgICBsb29wUGxheWVyLmFkZExvb3BUcmFjayhpbmRleCwgdHJhY2subGF5ZXJzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNsaWVudEV4aXQoaW5kZXgpIHtcbiAgICBjb25zdCBsb29wUGxheWVyID0gdGhpcy5sb29wUGxheWVyO1xuXG4gICAgaWYgKGxvb3BQbGF5ZXIpXG4gICAgICBsb29wUGxheWVyLnJlbW92ZUxvb3BUcmFjayhpbmRleCk7XG4gIH1cblxuICBlbnRlclNjZW5lKCkge1xuICAgIGNvbnN0IGV4cGVyaWVuY2UgPSB0aGlzLmV4cGVyaWVuY2U7XG4gICAgZXhwZXJpZW5jZS5yZWNlaXZlKCd0cmFja0N1dG9mZicsIHRoaXMub25UcmFja0N1dG9mZik7XG4gICAgZXhwZXJpZW5jZS5yZWNlaXZlKCdzd2l0Y2hMYXllcicsIHRoaXMub25Td2l0Y2hMYXllcik7XG5cbiAgICBpZiAoIXRoaXMubG9vcFBsYXllcikge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICB0aGlzLmxvb3BQbGF5ZXIgPSBuZXcgTG9vcFBsYXllcihleHBlcmllbmNlLm1ldHJpY1NjaGVkdWxlciwgdGhpcy5vdXRwdXRCdXNzZXMsIDEsIGNvbmZpZy50ZW1wbywgY29uZmlnLnRlbXBvVW5pdCwgMC4wNSk7XG4gICAgfVxuICB9XG5cbiAgZW50ZXIoKSB7XG4gICAgY29uc3QgZXhwZXJpZW5jZSA9IHRoaXMuZXhwZXJpZW5jZTtcblxuICAgIGlmICh0aGlzLm5vdGVzKSB7XG4gICAgICB0aGlzLmVudGVyU2NlbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhY2tDb25maWcgPSB0aGlzLmNvbmZpZy50cmFja3M7XG4gICAgICBleHBlcmllbmNlLmF1ZGlvQnVmZmVyTWFuYWdlci5sb2FkRmlsZXModHJhY2tDb25maWcpLnRoZW4oKHRyYWNrcykgPT4ge1xuICAgICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICAgICAgdGhpcy5lbnRlclNjZW5lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBleGl0KCkge1xuICAgIGNvbnN0IGV4cGVyaWVuY2UgPSB0aGlzLmV4cGVyaWVuY2U7XG4gICAgZXhwZXJpZW5jZS5zdG9wUmVjZWl2aW5nKCd0cmFja0N1dG9mZicsIHRoaXMub25UcmFja0N1dG9mZik7XG4gICAgZXhwZXJpZW5jZS5zdG9wUmVjZWl2aW5nKCdzd2l0Y2hMYXllcicsIHRoaXMub25Td2l0Y2hMYXllcik7XG5cbiAgICB0aGlzLnBsYWNlci5jbGVhcigpO1xuICAgIHRoaXMubG9vcFBsYXllci5zdG9wQWxsVHJhY2tzKCk7XG4gIH1cblxuICBvblRyYWNrQ3V0b2ZmKGluZGV4LCB2YWx1ZSkge1xuICAgIGNvbnN0IGxvb3BQbGF5ZXIgPSB0aGlzLmxvb3BQbGF5ZXI7XG5cbiAgICBpZiAobG9vcFBsYXllcilcbiAgICAgIGxvb3BQbGF5ZXIuc2V0Q3V0b2ZmKGluZGV4LCB2YWx1ZSk7XG4gIH1cblxuICBvblN3aXRjaExheWVyKGluZGV4LCB2YWx1ZSkge1xuICAgIGNvbnN0IGxvb3BQbGF5ZXIgPSB0aGlzLmxvb3BQbGF5ZXI7XG5cbiAgICBpZiAobG9vcFBsYXllcilcbiAgICAgIGxvb3BQbGF5ZXIuc2V0TGF5ZXIoaW5kZXgsIHZhbHVlKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgc291bmR3b3JrcyBmcm9tICdzb3VuZHdvcmtzL2NsaWVudCc7XG5pbXBvcnQgeyBkZWNpYmVsVG9MaW5lYXIgfSBmcm9tICdzb3VuZHdvcmtzL3V0aWxzL21hdGgnO1xuY29uc3QgYXVkaW9Db250ZXh0ID0gc291bmR3b3Jrcy5hdWRpb0NvbnRleHQ7XG5jb25zdCBhdWRpb1NjaGVkdWxlciA9IHNvdW5kd29ya3MuYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lQ29sbGVjdGl2ZUxvb3BzIHtcbiAgY29uc3RydWN0b3IoZXhwZXJpZW5jZSwgY29uZmlnKSB7XG4gICAgdGhpcy5leHBlcmllbmNlID0gZXhwZXJpZW5jZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm5vdGVzID0gbnVsbDtcblxuICAgIGNvbnN0IG51bVN0ZXBzID0gY29uZmlnLm51bVN0ZXBzO1xuICAgIGNvbnN0IG51bU5vdGVzID0gY29uZmlnLm5vdGVzLmxlbmd0aDtcblxuICAgIHRoaXMuc3RlcFN0YXRlcyA9IG5ldyBBcnJheShudW1TdGVwcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVN0ZXBzOyBpKyspIHtcbiAgICAgIHRoaXMuc3RlcFN0YXRlc1tpXSA9IG5ldyBBcnJheShudW1Ob3Rlcyk7XG4gICAgICB0aGlzLnJlc2V0U3RlcFN0YXRlcyhpKTtcbiAgICB9XG5cbiAgICB0aGlzLm91dHB1dEJ1c3NlcyA9IGV4cGVyaWVuY2Uub3V0cHV0QnVzc2VzO1xuXG4gICAgdGhpcy5vbk1ldHJvQmVhdCA9IHRoaXMub25NZXRyb0JlYXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uU3dpdGNoTm90ZSA9IHRoaXMub25Td2l0Y2hOb3RlLmJpbmQodGhpcyk7XG4gIH1cblxuICBjbGllbnRFbnRlcihpbmRleCkge31cblxuICBjbGllbnRFeGl0KGluZGV4KSB7XG4gICAgdGhpcy5yZXNldFN0ZXBTdGF0ZXMoaW5kZXgpO1xuICB9XG5cbiAgZW50ZXJTY2VuZSgpIHtcbiAgICBjb25zdCBleHBlcmllbmNlID0gdGhpcy5leHBlcmllbmNlO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gdGhpcy5zdGVwU3RhdGVzLmxlbmd0aDtcbiAgICBleHBlcmllbmNlLm1ldHJpY1NjaGVkdWxlci5hZGRNZXRyb25vbWUodGhpcy5vbk1ldHJvQmVhdCwgbnVtU3RlcHMsIG51bVN0ZXBzLCAxLCAwLCB0cnVlKTtcbiAgICBleHBlcmllbmNlLnJlY2VpdmUoJ3N3aXRjaE5vdGUnLCB0aGlzLm9uU3dpdGNoTm90ZSk7XG4gIH1cblxuICBlbnRlcigpIHtcbiAgICBjb25zdCBleHBlcmllbmNlID0gdGhpcy5leHBlcmllbmNlO1xuXG4gICAgaWYgKHRoaXMubm90ZXMpIHtcbiAgICAgIHRoaXMuZW50ZXJTY2VuZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub3RlQ29uZmlnID0gdGhpcy5jb25maWcubm90ZXM7XG4gICAgICBleHBlcmllbmNlLmF1ZGlvQnVmZmVyTWFuYWdlci5sb2FkRmlsZXMobm90ZUNvbmZpZykudGhlbigobm90ZXMpID0+IHtcbiAgICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgICB0aGlzLmVudGVyU2NlbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgY29uc3QgZXhwZXJpZW5jZSA9IHRoaXMuZXhwZXJpZW5jZTtcbiAgICBleHBlcmllbmNlLm1ldHJpY1NjaGVkdWxlci5yZW1vdmVNZXRyb25vbWUodGhpcy5vbk1ldHJvQmVhdCk7XG4gICAgZXhwZXJpZW5jZS5zdG9wUmVjZWl2aW5nKCdzd2l0Y2hOb3RlJywgdGhpcy5vblN3aXRjaE5vdGUpO1xuICB9XG5cbiAgcmVzZXRTdGVwU3RhdGVzKHN0ZXApIHtcbiAgICBjb25zdCBzdGF0ZXMgPSB0aGlzLnN0ZXBTdGF0ZXNbc3RlcF07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhdGVzW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RlcFN0YXRlcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMucmVzZXRTdGVwU3RhdGVzKGkpO1xuICB9XG5cbiAgb25NZXRyb0JlYXQobWVhc3VyZSwgYmVhdCkge1xuICAgIGNvbnN0IHRpbWUgPSBhdWRpb1NjaGVkdWxlci5jdXJyZW50VGltZTtcbiAgICBjb25zdCBub3RlcyA9IHRoaXMubm90ZXM7XG4gICAgY29uc3Qgc3RhdGVzID0gdGhpcy5zdGVwU3RhdGVzW2JlYXRdO1xuICAgIGNvbnN0IG91dHB1dCA9IHRoaXMub3V0cHV0QnVzc2VzW2JlYXRdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vdGUgPSBub3Rlc1tpXTtcbiAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzW2ldO1xuXG4gICAgICBpZiAoc3RhdGUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGdhaW4gPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICBnYWluLmNvbm5lY3Qob3V0cHV0KTtcbiAgICAgICAgZ2Fpbi5nYWluLnZhbHVlID0gZGVjaWJlbFRvTGluZWFyKG5vdGUuZ2Fpbik7XG5cbiAgICAgICAgY29uc3Qgc3JjID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICBzcmMuY29ubmVjdChnYWluKTtcbiAgICAgICAgc3JjLmJ1ZmZlciA9IG5vdGUuYnVmZmVyO1xuICAgICAgICBzcmMuc3RhcnQodGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Td2l0Y2hOb3RlKHN0ZXAsIG5vdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGVzID0gdGhpcy5zdGVwU3RhdGVzW3N0ZXBdO1xuICAgIHN0YXRlc1tub3RlXSA9IHN0YXRlO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBzb3VuZHdvcmtzIGZyb20gJ3NvdW5kd29ya3MvY2xpZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVPZmYge1xuICBjb25zdHJ1Y3RvcihleHBlcmllbmNlLCBjb25maWcpIHtcbiAgICB0aGlzLmV4cGVyaWVuY2UgPSBleHBlcmllbmNlO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgY2xpZW50RW50ZXIoY2xpZW50KSB7fVxuXG4gIGNsaWVudEV4aXQoY2xpZW50KSB7fVxuXG4gIGVudGVyKCkge31cblxuICBleGl0KCkge31cbn1cbiIsImltcG9ydCAqIGFzIHNvdW5kd29ya3MgZnJvbSAnc291bmR3b3Jrcy9jbGllbnQnO1xuaW1wb3J0IFBsYWNlciBmcm9tICcuL1BsYWNlcic7XG5pbXBvcnQgUXVlZW5QbGF5ZXIgZnJvbSAnLi4vLi4vc2hhcmVkL1F1ZWVuUGxheWVyJztcbmNvbnN0IGF1ZGlvQ29udGV4dCA9IHNvdW5kd29ya3MuYXVkaW9Db250ZXh0O1xuY29uc3QgYXVkaW9TY2hlZHVsZXIgPSBzb3VuZHdvcmtzLmF1ZGlvLmdldFNjaGVkdWxlcigpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZVd3cnlSIHtcbiAgY29uc3RydWN0b3IoZXhwZXJpZW5jZSwgY29uZmlnKSB7XG4gICAgdGhpcy5leHBlcmllbmNlID0gZXhwZXJpZW5jZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm5vdGVzID0gbnVsbDtcblxuICAgIGNvbnN0IG51bVRyYWNrcyA9IGNvbmZpZy50cmFja3MubGVuZ3RoO1xuICAgIHRoaXMub3V0cHV0QnVzc2VzID0gZXhwZXJpZW5jZS5vdXRwdXRCdXNzZXM7XG5cbiAgICB0aGlzLnBsYWNlciA9IG5ldyBQbGFjZXIoZXhwZXJpZW5jZSk7XG4gICAgdGhpcy5xdWVlblBsYXllciA9IG51bGw7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcblxuICAgIHRoaXMub25Nb3Rpb25FdmVudCA9IHRoaXMub25Nb3Rpb25FdmVudC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY2xpZW50RW50ZXIoaW5kZXgpIHtcbiAgICBjb25zdCBleHBlcmllbmNlID0gdGhpcy5leHBlcmllbmNlO1xuXG4gICAgdGhpcy5wbGFjZXIuc3RhcnQoaW5kZXgsICgpID0+IHtcbiAgICAgIGNvbnN0IHF1ZWVuUGxheWVyID0gdGhpcy5xdWVlblBsYXllcjtcblxuICAgICAgaWYgKHF1ZWVuUGxheWVyKVxuICAgICAgICBxdWVlblBsYXllci5zdGFydFRyYWNrKGluZGV4LCB0aGlzLnRyYWNrc1tpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgY2xpZW50RXhpdChpbmRleCkge1xuICAgIGNvbnN0IHF1ZWVuUGxheWVyID0gdGhpcy5xdWVlblBsYXllcjtcblxuICAgIGlmIChxdWVlblBsYXllcilcbiAgICAgIHF1ZWVuUGxheWVyLnN0b3BUcmFjayhpbmRleCk7XG4gIH1cblxuICBlbnRlclNjZW5lKCkge1xuICAgIGNvbnN0IGV4cGVyaWVuY2UgPSB0aGlzLmV4cGVyaWVuY2U7XG4gICAgZXhwZXJpZW5jZS5yZWNlaXZlKCdtb3Rpb25FdmVudCcsIHRoaXMub25Nb3Rpb25FdmVudCk7XG5cbiAgICBpZiAoIXRoaXMucXVlZW5QbGF5ZXIpXG4gICAgICB0aGlzLnF1ZWVuUGxheWVyID0gbmV3IFF1ZWVuUGxheWVyKHRoaXMub3V0cHV0QnVzc2VzKTtcbiAgfVxuXG4gIGVudGVyKCkge1xuICAgIGNvbnN0IGV4cGVyaWVuY2UgPSB0aGlzLmV4cGVyaWVuY2U7XG5cbiAgICBpZiAodGhpcy5ub3Rlcykge1xuICAgICAgdGhpcy5lbnRlclNjZW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyYWNrQ29uZmlnID0gdGhpcy5jb25maWcudHJhY2tzO1xuICAgICAgZXhwZXJpZW5jZS5hdWRpb0J1ZmZlck1hbmFnZXIubG9hZEZpbGVzKHRyYWNrQ29uZmlnKS50aGVuKCh0cmFja3MpID0+IHtcbiAgICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICAgIHRoaXMuZW50ZXJTY2VuZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZXhpdCgpIHtcbiAgICBjb25zdCBleHBlcmllbmNlID0gdGhpcy5leHBlcmllbmNlO1xuICAgIGV4cGVyaWVuY2Uuc3RvcFJlY2VpdmluZygnbW90aW9uRXZlbnQnLCB0aGlzLm9uTW90aW9uRXZlbnQpO1xuXG4gICAgdGhpcy5wbGFjZXIuY2xlYXIoKTtcbiAgfVxuXG4gIG9uTW90aW9uRXZlbnQoaW5kZXgsIGRhdGEpIHtcbiAgICBjb25zdCBxdWVlblBsYXllciA9IHRoaXMucXVlZW5QbGF5ZXI7XG5cbiAgICBpZiAocXVlZW5QbGF5ZXIpXG4gICAgICBxdWVlblBsYXllci5vbk1vdGlvbkV2ZW50KGluZGV4LCBkYXRhKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgc291bmR3b3JrcyBmcm9tICdzb3VuZHdvcmtzL2NsaWVudCc7XG5pbXBvcnQgeyBkZWNpYmVsVG9MaW5lYXIgfSBmcm9tICdzb3VuZHdvcmtzL3V0aWxzL21hdGgnO1xuXG5jb25zdCBhdWRpbyA9IHNvdW5kd29ya3MuYXVkaW87XG5jb25zdCBhdWRpb0NvbnRleHQgPSBzb3VuZHdvcmtzLmF1ZGlvQ29udGV4dDtcbmNvbnN0IGF1ZGlvU2NoZWR1bGVyID0gc291bmR3b3Jrcy5hdWRpby5nZXRTY2hlZHVsZXIoKTtcblxuZnVuY3Rpb24gYXBwZW5kU2VnbWVudHMoc2VnbWVudHMsIGxvb3BTZWdtZW50LCBtZWFzdXJlRHVyYXRpb24pIHtcbiAgY29uc3QgYnVmZmVyID0gbG9vcFNlZ21lbnQuYnVmZmVyO1xuICBjb25zdCBidWZmZXJEdXJhdGlvbiA9IGJ1ZmZlciA/IGJ1ZmZlci5kdXJhdGlvbiA6IDA7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbG9vcFNlZ21lbnQuc3RhcnRPZmZzZXQgfHwgMDtcbiAgY29uc3QgZ2FpbiA9IGxvb3BTZWdtZW50LmdhaW47XG4gIGNvbnN0IHJlcGVhdCA9IGxvb3BTZWdtZW50LnJlcGVhdCB8fCAxO1xuXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgcmVwZWF0OyBuKyspIHtcbiAgICBsZXQgY29udCA9ICEhbG9vcFNlZ21lbnQuY29udGludWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb3BTZWdtZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBzdGFydE9mZnNldCArIGkgKiBtZWFzdXJlRHVyYXRpb247XG5cbiAgICAgIGlmIChvZmZzZXQgPCBidWZmZXJEdXJhdGlvbikge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gbmV3IFNlZ21lbnQoYnVmZmVyLCBvZmZzZXQsIEluZmluaXR5LCAwLCBnYWluLCBjb250KTtcbiAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgIH1cblxuICAgICAgY29udCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFNlZ21lbnQge1xuICBjb25zdHJ1Y3RvcihidWZmZXIsIG9mZnNldEluQnVmZmVyID0gMCwgZHVyYXRpb25JbkJ1ZmZlciA9IEluZmluaXR5LCBvZmZzZXRJbk1lYXN1cmUgPSAwLCBnYWluID0gMCwgY29udCA9IGZhbHNlKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5vZmZzZXRJbkJ1ZmZlciA9IG9mZnNldEluQnVmZmVyO1xuICAgIHRoaXMuZHVyYXRpb25JbkJ1ZmZlciA9IGR1cmF0aW9uSW5CdWZmZXI7IC8vIDA6IGNvbnRpbnVlIHVudGlsbCBuZXh0IHNlZ21lbnQgc3RhcnRzXG4gICAgdGhpcy5vZmZzZXRJbk1lYXN1cmUgPSBvZmZzZXRJbk1lYXN1cmU7XG4gICAgdGhpcy5nYWluID0gZ2FpbjtcbiAgICB0aGlzLmNvbnRpbnVlID0gY29udDsgLy8gc2VnbWVudCBjb250aW51ZXMgcHJldmlvdXMgc2VnbWVudFxuICB9XG59XG5cbmNsYXNzIFNlZ21lbnRUcmFjayB7XG4gIGNvbnN0cnVjdG9yKG91dHB1dCwgc2VnbWVudExheWVycywgdHJhbnNpdGlvblRpbWUgPSAwLjA1KSB7XG4gICAgdGhpcy5zcmMgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cbiAgICB0aGlzLnNlZ21lbnRMYXllcnMgPSBzZWdtZW50TGF5ZXJzO1xuICAgIHRoaXMudHJhbnNpdGlvblRpbWUgPSB0cmFuc2l0aW9uVGltZTtcblxuICAgIHRoaXMubWluQ3V0b2ZmRnJlcSA9IDU7XG4gICAgdGhpcy5tYXhDdXRvZmZGcmVxID0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgLyAyO1xuICAgIHRoaXMubG9nQ3V0b2ZmUmF0aW8gPSBNYXRoLmxvZyh0aGlzLm1heEN1dG9mZkZyZXEgLyB0aGlzLm1pbkN1dG9mZkZyZXEpO1xuXG4gICAgdGhpcy5sYXllckluZGV4ID0gMDtcbiAgICB0aGlzLmRpc2NvbnRpbnVlID0gdHJ1ZTtcblxuICAgIGNvbnN0IGN1dG9mZiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICBjdXRvZmYuY29ubmVjdChvdXRwdXQpO1xuICAgIGN1dG9mZi50eXBlID0gJ2xvd3Bhc3MnO1xuICAgIGN1dG9mZi5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLm1heEN1dG9mZkZyZXE7XG5cbiAgICB0aGlzLnNyYyA9IG51bGw7XG4gICAgdGhpcy5lbnYgPSBudWxsO1xuICAgIHRoaXMuY3V0b2ZmID0gY3V0b2ZmO1xuICAgIHRoaXMuZW5kVGltZSA9IDA7XG4gIH1cblxuICBzdGFydFNlZ21lbnQoYXVkaW9UaW1lLCBzZWdtZW50KSB7XG4gICAgY29uc3QgYnVmZmVyID0gc2VnbWVudC5idWZmZXI7XG4gICAgY29uc3QgYnVmZmVyRHVyYXRpb24gPSBidWZmZXIuZHVyYXRpb247XG4gICAgY29uc3Qgb2Zmc2V0SW5CdWZmZXIgPSBzZWdtZW50Lm9mZnNldEluQnVmZmVyO1xuICAgIGNvbnN0IGR1cmF0aW9uSW5CdWZmZXIgPSBNYXRoLm1pbigoc2VnbWVudC5kdXJhdGlvbkluQnVmZmVyIHx8IEluZmluaXR5KSwgYnVmZmVyRHVyYXRpb24gLSBvZmZzZXRJbkJ1ZmZlcik7XG4gICAgbGV0IHRyYW5zaXRpb25UaW1lID0gdGhpcy50cmFuc2l0aW9uVGltZTtcblxuICAgIGlmIChhdWRpb1RpbWUgPCB0aGlzLmVuZFRpbWUgLSB0cmFuc2l0aW9uVGltZSkge1xuICAgICAgY29uc3Qgc3JjID0gdGhpcy5zcmM7XG4gICAgICBjb25zdCBlbmRUaW1lID0gTWF0aC5taW4oYXVkaW9UaW1lICsgdHJhbnNpdGlvblRpbWUsIHRoaXMuZW5kVGltZSk7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uVGltZSA+IDApIHtcbiAgICAgICAgY29uc3QgZW52ID0gdGhpcy5lbnY7XG4gICAgICAgIC8vIGVudi5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhdWRpb1RpbWUpO1xuICAgICAgICBlbnYuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCBhdWRpb1RpbWUpO1xuICAgICAgICBlbnYuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBlbmRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgc3JjLnN0b3AoZW5kVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldEluQnVmZmVyIDwgYnVmZmVyRHVyYXRpb24pIHtcbiAgICAgIGxldCBkZWxheSA9IDA7XG5cbiAgICAgIGlmIChvZmZzZXRJbkJ1ZmZlciA8IHRyYW5zaXRpb25UaW1lKSB7XG4gICAgICAgIGRlbGF5ID0gdHJhbnNpdGlvblRpbWUgLSBvZmZzZXRJbkJ1ZmZlcjtcbiAgICAgICAgdHJhbnNpdGlvblRpbWUgPSBvZmZzZXRJbkJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ2FpbiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICBnYWluLmNvbm5lY3QodGhpcy5jdXRvZmYpO1xuICAgICAgZ2Fpbi5nYWluLnZhbHVlID0gZGVjaWJlbFRvTGluZWFyKHNlZ21lbnQuZ2Fpbik7XG5cbiAgICAgIGNvbnN0IGVudiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICBlbnYuY29ubmVjdChnYWluKTtcblxuICAgICAgaWYgKHRyYW5zaXRpb25UaW1lID4gMCkge1xuICAgICAgICBlbnYuZ2Fpbi52YWx1ZSA9IDA7XG4gICAgICAgIGVudi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIGF1ZGlvVGltZSArIGRlbGF5KTtcbiAgICAgICAgZW52LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgYXVkaW9UaW1lICsgZGVsYXkgKyB0cmFuc2l0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNyYyA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIHNyYy5jb25uZWN0KGVudik7XG4gICAgICBzcmMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgc3JjLnN0YXJ0KGF1ZGlvVGltZSArIGRlbGF5LCBvZmZzZXRJbkJ1ZmZlciAtIHRyYW5zaXRpb25UaW1lKTtcblxuICAgICAgYXVkaW9UaW1lICs9IHRyYW5zaXRpb25UaW1lO1xuXG4gICAgICBjb25zdCBlbmRJbkJ1ZmZlciA9IG9mZnNldEluQnVmZmVyICsgZHVyYXRpb25JbkJ1ZmZlcjtcbiAgICAgIGxldCBlbmRUaW1lID0gYXVkaW9UaW1lICsgZHVyYXRpb25JbkJ1ZmZlcjtcblxuICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICB0aGlzLmVudiA9IGVudjtcbiAgICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgfVxuICB9XG5cbiAgc3RvcFNlZ21lbnQoYXVkaW9UaW1lID0gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSB7XG4gICAgY29uc3Qgc3JjID0gdGhpcy5zcmM7XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uVGltZSA9IHRoaXMudHJhbnNpdGlvblRpbWU7XG4gICAgICBjb25zdCBlbnYgPSB0aGlzLmVudjtcblxuICAgICAgZW52LmdhaW4uc2V0VmFsdWVBdFRpbWUoMSwgYXVkaW9UaW1lKTtcbiAgICAgIGVudi5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIGF1ZGlvVGltZSArIHRyYW5zaXRpb25UaW1lKTtcblxuICAgICAgc3JjLnN0b3AoYXVkaW9UaW1lICsgdHJhbnNpdGlvblRpbWUpO1xuXG4gICAgICB0aGlzLnNyYyA9IG51bGw7XG4gICAgICB0aGlzLmVudiA9IG51bGw7XG4gICAgICB0aGlzLmVuZFRpbWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0TWVhc3VyZShhdWRpb1RpbWUsIG1lYXN1cmVJbmRleCwgY2FuQ29udGludWUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50TGF5ZXJzW3RoaXMubGF5ZXJJbmRleF07XG4gICAgY29uc3QgbWVhc3VyZUluZGV4SW5QYXR0ZXJuID0gbWVhc3VyZUluZGV4ICUgc2VnbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1ttZWFzdXJlSW5kZXhJblBhdHRlcm5dO1xuXG4gICAgaWYgKHNlZ21lbnQgJiYgKHRoaXMuZGlzY29udGludWUgfHwgIShzZWdtZW50LmNvbnRpbnVlICYmIGNhbkNvbnRpbnVlKSkpIHtcbiAgICAgIGNvbnN0IGRlbGF5ID0gc2VnbWVudC5vZmZzZXRJbk1lYXN1cmUgfHwgMDtcbiAgICAgIHRoaXMuc3RhcnRTZWdtZW50KGF1ZGlvVGltZSArIGRlbGF5LCBzZWdtZW50KTtcbiAgICAgIHRoaXMuZGlzY29udGludWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzZXRDdXRvZmYodmFsdWUpIHtcbiAgICBjb25zdCBjdXRvZmZGcmVxID0gdGhpcy5taW5DdXRvZmZGcmVxICogTWF0aC5leHAodGhpcy5sb2dDdXRvZmZSYXRpbyAqIHZhbHVlKTtcbiAgICB0aGlzLmN1dG9mZi5mcmVxdWVuY3kudmFsdWUgPSBjdXRvZmZGcmVxO1xuICB9XG5cbiAgc2V0TGF5ZXIodmFsdWUpIHtcbiAgICB0aGlzLmxheWVySW5kZXggPSB2YWx1ZTtcbiAgICB0aGlzLmRpc2NvbnRpbnVlID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb29wUGxheWVyIGV4dGVuZHMgYXVkaW8uVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKG1ldHJpY1NjaGVkdWxlciwgYXVkaW9PdXRwdXRzLCBtZWFzdXJlTGVuZ3RoID0gMSwgdGVtcG8gPSAxMjAsIHRlbXBvVW5pdCA9IDEgLyA0LCB0cmFuc2l0aW9uVGltZSA9IDAuMDUsIG1lYXN1cmVDYWxsYmFjayA9IGZ1bmN0aW9uKG1lYXN1cmVDb3VudCkge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5tZXRyaWNTY2hlZHVsZXIgPSBtZXRyaWNTY2hlZHVsZXI7XG4gICAgdGhpcy5hdWRpb091dHB1dHMgPSBhdWRpb091dHB1dHM7XG4gICAgdGhpcy5tZWFzdXJlTGVuZ3RoID0gbWVhc3VyZUxlbmd0aDtcbiAgICB0aGlzLnRlbXBvID0gdGVtcG87XG4gICAgdGhpcy50ZW1wb1VuaXQgPSB0ZW1wb1VuaXQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVGltZSA9IHRyYW5zaXRpb25UaW1lO1xuICAgIHRoaXMubWVhc3VyZUNhbGxiYWNrID0gbWVhc3VyZUNhbGxiYWNrO1xuXG4gICAgdGhpcy5tZWFzdXJlRHVyYXRpb24gPSA2MCAvICh0ZW1wbyAqIHRlbXBvVW5pdCk7XG4gICAgdGhpcy5tZWFzdXJlSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWdtZW50VHJhY2tzID0gbmV3IE1hcCgpO1xuXG4gICAgdGhpcy5tZXRyaWNTY2hlZHVsZXIuYWRkKHRoaXMpO1xuICB9XG5cbiAgc3RvcEFsbFRyYWNrcygpIHtcbiAgICBmb3IgKGxldCBbaW5kZXgsIHNlZ21lbnRUcmFja10gb2YgdGhpcy5zZWdtZW50VHJhY2tzKVxuICAgICAgc2VnbWVudFRyYWNrLnN0b3BTZWdtZW50KCk7XG4gIH1cblxuICBzeW5jU3BlZWQoc3luY1RpbWUsIG1ldHJpY1Bvc2l0aW9uLCBtZXRyaWNTcGVlZCkge1xuICAgIGlmIChtZXRyaWNTcGVlZCA9PT0gMClcbiAgICAgIHRoaXMuc3RvcEFsbFRyYWNrcygpO1xuICB9XG5cbiAgc3luY1Bvc2l0aW9uKHN5bmNUaW1lLCBtZXRyaWNQb3NpdGlvbiwgbWV0cmljU3BlZWQpIHtcbiAgICBjb25zdCBhdWRpb1RpbWUgPSBhdWRpb1NjaGVkdWxlci5jdXJyZW50VGltZTtcbiAgICBjb25zdCBmbG9hdE1lYXN1cmVzID0gbWV0cmljUG9zaXRpb24gLyB0aGlzLm1lYXN1cmVMZW5ndGg7XG4gICAgY29uc3QgbnVtTWVhc3VyZXMgPSBNYXRoLmNlaWwoZmxvYXRNZWFzdXJlcyk7XG4gICAgY29uc3QgbmV4dE1lYXN1cmVQb3NpdGlvbiA9IG51bU1lYXN1cmVzICogdGhpcy5tZWFzdXJlTGVuZ3RoO1xuXG4gICAgdGhpcy5tZWFzdXJlSW5kZXggPSBudW1NZWFzdXJlcyAtIDE7XG4gICAgdGhpcy5uZXh0TWVhc3VyZVRpbWUgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gbmV4dE1lYXN1cmVQb3NpdGlvbjtcbiAgfVxuXG4gIGFkdmFuY2VQb3NpdGlvbihzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIG1ldHJpY1NwZWVkKSB7XG4gICAgY29uc3QgYXVkaW9UaW1lID0gYXVkaW9TY2hlZHVsZXIuY3VycmVudFRpbWU7XG5cbiAgICB0aGlzLm1lYXN1cmVJbmRleCsrO1xuXG4gICAgY29uc3QgY2FuQ29udGludWUgPSAodGhpcy5uZXh0TWVhc3VyZVRpbWUgJiYgTWF0aC5hYnMoYXVkaW9UaW1lIC0gdGhpcy5uZXh0TWVhc3VyZVRpbWUpIDwgMC4wMSk7XG5cbiAgICBmb3IgKGxldCBbaW5kZXgsIHNlZ21lbnRUcmFja10gb2YgdGhpcy5zZWdtZW50VHJhY2tzKVxuICAgICAgc2VnbWVudFRyYWNrLnN0YXJ0TWVhc3VyZShhdWRpb1RpbWUsIHRoaXMubWVhc3VyZUluZGV4LCBjYW5Db250aW51ZSk7XG5cbiAgICB0aGlzLm1lYXN1cmVDYWxsYmFjayhhdWRpb1RpbWUsIHRoaXMubWVhc3VyZUluZGV4KTtcblxuICAgIHRoaXMubmV4dE1lYXN1cmVUaW1lID0gYXVkaW9UaW1lICsgdGhpcy5tZWFzdXJlRHVyYXRpb247XG5cbiAgICByZXR1cm4gbWV0cmljUG9zaXRpb24gKyB0aGlzLm1lYXN1cmVMZW5ndGg7XG4gIH1cblxuICBnZXRMb29wVHJhY2soaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWdtZW50VHJhY2tzLmdldChpbmRleCk7XG4gIH1cblxuICByZW1vdmVMb29wVHJhY2soaW5kZXgpIHtcbiAgICBjb25zdCBzZWdtZW50VHJhY2sgPSB0aGlzLnNlZ21lbnRUcmFja3MuZ2V0KGluZGV4KTtcblxuICAgIGlmIChzZWdtZW50VHJhY2spIHtcbiAgICAgIHNlZ21lbnRUcmFjay5zdG9wU2VnbWVudCgpO1xuICAgICAgdGhpcy5zZWdtZW50VHJhY2tzLmRlbGV0ZShpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgYWRkTG9vcFRyYWNrKGluZGV4LCBsb29wTGF5ZXJzKSB7XG4gICAgbGV0IHNlZ21lbnRUcmFjayA9IHRoaXMuc2VnbWVudFRyYWNrcy5nZXQoaW5kZXgpO1xuXG4gICAgaWYgKHNlZ21lbnRUcmFjaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFkZCBzZWdtZW50IHRyYWNrIHR3aWNlIChpbmRleDogJHtpbmRleH0pYCk7XG5cbiAgICBjb25zdCBzZWdtZW50TGF5ZXJzID0gW107XG5cbiAgICBmb3IgKGxldCBsYXllciBvZiBsb29wTGF5ZXJzKSB7XG4gICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXllcikpXG4gICAgICAgIGxheWVyLmZvckVhY2goKHNlZykgPT4gYXBwZW5kU2VnbWVudHMoc2VnbWVudHMsIHNlZywgdGhpcy5tZWFzdXJlRHVyYXRpb24pKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYXBwZW5kU2VnbWVudHMoc2VnbWVudHMsIGxheWVyLCB0aGlzLm1lYXN1cmVEdXJhdGlvbik7XG5cbiAgICAgIHNlZ21lbnRMYXllcnMucHVzaChzZWdtZW50cyk7XG4gICAgfVxuXG4gICAgc2VnbWVudFRyYWNrID0gbmV3IFNlZ21lbnRUcmFjayh0aGlzLmF1ZGlvT3V0cHV0c1tpbmRleF0sIHNlZ21lbnRMYXllcnMsIHRoaXMudHJhbnNpdGlvblRpbWUpO1xuICAgIHRoaXMuc2VnbWVudFRyYWNrcy5zZXQoaW5kZXgsIHNlZ21lbnRUcmFjayk7XG4gIH1cblxuICBzZXRDdXRvZmYoaW5kZXgsIHZhbHVlKSB7XG4gICAgY29uc3Qgc2VnbWVudFRyYWNrID0gdGhpcy5zZWdtZW50VHJhY2tzLmdldChpbmRleCk7XG5cbiAgICBpZiAoc2VnbWVudFRyYWNrKVxuICAgICAgc2VnbWVudFRyYWNrLnNldEN1dG9mZih2YWx1ZSk7XG4gIH1cblxuICBzZXRMYXllcihpbmRleCwgdmFsdWUpIHtcbiAgICBjb25zdCBzZWdtZW50VHJhY2sgPSB0aGlzLnNlZ21lbnRUcmFja3MuZ2V0KGluZGV4KTtcblxuICAgIGlmIChzZWdtZW50VHJhY2spXG4gICAgICBzZWdtZW50VHJhY2suc2V0TGF5ZXIodmFsdWUpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BBbGxUcmFja3MoKTtcbiAgICB0aGlzLm1ldHJpY1NjaGVkdWxlci5yZW1vdmUodGhpcyk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHNvdW5kd29ya3MgZnJvbSAnc291bmR3b3Jrcy9jbGllbnQnO1xuY29uc3QgYXVkaW8gPSBzb3VuZHdvcmtzLmF1ZGlvO1xuY29uc3QgYXVkaW9Db250ZXh0ID0gc291bmR3b3Jrcy5hdWRpb0NvbnRleHQ7XG5jb25zdCBhdWRpb1NjaGVkdWxlciA9IHNvdW5kd29ya3MuYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XG5cbmNsYXNzIEhpdEVuZ2luZSBleHRlbmRzIGF1ZGlvLlNlZ21lbnRFbmdpbmUge1xuICBjb25zdHJ1Y3Rvcih0cmFjaywgb3V0cHV0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYnVmZmVyID0gdHJhY2suYnVmZmVyO1xuICAgIHRoaXMucG9zaXRpb25BcnJheSA9IHRyYWNrLm1hcmtlcnMudGltZTtcbiAgICB0aGlzLm9mZnNldEFycmF5ID0gdHJhY2subWFya2Vycy5vZmZzZXQ7XG5cbiAgICB0aGlzLnJlbGVhc2VSZWwgPSAwLjI1O1xuXG4gICAgdGhpcy5jb25uZWN0KG91dHB1dCk7XG4gIH1cblxuICBzdGFydCgpIHt9XG5cbiAgc3RvcCgpIHt9XG5cbiAgb25Nb3Rpb25FdmVudChkYXRhKSB7XG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBkYXRhO1xuICAgIHRoaXMudHJpZ2dlcigpO1xuICB9XG59XG5cbmNsYXNzIFBvd2VyQ2hvcmRFbmdpbmUgZXh0ZW5kcyBhdWRpby5HcmFudWxhckVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKHRyYWNrLCBvdXRwdXQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5idWZmZXIgPSB0cmFjay5idWZmZXI7XG4gICAgdGhpcy5wZXJpb2RBYnMgPSAwLjAxO1xuICAgIHRoaXMucGVyaW9kUmVsID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uQWJzID0gMC4wODtcbiAgICB0aGlzLmR1cmF0aW9uUmVsID0gMDtcbiAgICB0aGlzLmdhaW4gPSAyICogdGhpcy5wZXJpb2RBYnMgLyB0aGlzLmR1cmF0aW9uQWJzO1xuXG4gICAgdGhpcy5jb25uZWN0KG91dHB1dCk7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMubWFzdGVyKVxuICAgICAgYXVkaW9TY2hlZHVsZXIuYWRkKHRoaXMpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5tYXN0ZXIpXG4gICAgICBhdWRpb1NjaGVkdWxlci5yZW1vdmUodGhpcyk7XG4gIH1cblxuICBvbk1vdGlvbkV2ZW50KGRhdGEpIHtcbiAgICB2YXIgbWFyZ2luID0gMC41ICogdGhpcy5kdXJhdGlvbkFicyArIHRoaXMucG9zaXRpb25WYXI7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5idWZmZXIuZHVyYXRpb24gLSAyICogbWFyZ2luO1xuICAgIHRoaXMucG9zaXRpb24gPSBtYXJnaW4gKyBkYXRhICogcmFuZ2U7XG4gIH1cbn1cblxuY2xhc3MgR3VpdGFyUmlmZkVuZ2luZSBleHRlbmRzIGF1ZGlvLkdyYW51bGFyRW5naW5lIHtcbiAgY29uc3RydWN0b3IodHJhY2ssIG91dHB1dCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnNlZ21lbnRzID0gdHJhY2subWFya2VycztcblxuICAgIHRoaXMuYnVmZmVyID0gdHJhY2suYnVmZmVyO1xuICAgIHRoaXMucGVyaW9kQWJzID0gMC4wMTA7XG4gICAgdGhpcy5wZXJpb2RSZWwgPSAwO1xuICAgIHRoaXMuZHVyYXRpb25BYnMgPSAwLjA4MDtcbiAgICB0aGlzLmR1cmF0aW9uUmVsID0gMDtcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnBvc2l0aW9uVmFyID0gMC4wMjtcbiAgICB0aGlzLmdhaW4gPSAwO1xuXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSAxNTtcbiAgICB0aGlzLnBsYXlpbmdQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5wbGF5aW5nU3BlZWQgPSAwO1xuICAgIHRoaXMuZ2FpbkZhY3RvciA9IDIgKiB0aGlzLnBlcmlvZEFicyAvIHRoaXMuZHVyYXRpb25BYnM7XG5cbiAgICB0aGlzLmNvbm5lY3Qob3V0cHV0KTtcbiAgfVxuXG4gIHRyaWdnZXIodGltZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcblxuICAgIGlmICh0aGlzLnBsYXlpbmdTcGVlZCA+IDAgJiYgdGhpcy5wbGF5aW5nUG9zaXRpb24gPCBzZWdtZW50c1t0aGlzLnNlZ21lbnRJbmRleF0uZW5kKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wbGF5aW5nUG9zaXRpb247XG4gICAgICB0aGlzLnBvc2l0aW9uVmFyID0gMDtcbiAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuZ2FpbkZhY3RvciAqIDAuNzA3O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gc2VnbWVudHNbdGhpcy5zZWdtZW50SW5kZXhdLmVuZDtcbiAgICAgIHRoaXMucG9zaXRpb25WYXIgPSAwLjAyO1xuXG4gICAgICBpZiAodGhpcy5wbGF5aW5nU3BlZWQgIT09IDApIHtcbiAgICAgICAgdGhpcy5wbGF5aW5nU3BlZWQgPSAwO1xuICAgICAgICB0aGlzLmdhaW4gPSB0aGlzLmdhaW5GYWN0b3IgKiAxLjA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdhaW4gKj0gc2VnbWVudHNbdGhpcy5zZWdtZW50SW5kZXhdLnN1c3RhaW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5aW5nUG9zaXRpb24gKz0gdGhpcy5wZXJpb2RBYnMgKiB0aGlzLnBsYXlpbmdTcGVlZDtcblxuICAgIHJldHVybiBzdXBlci50cmlnZ2VyKHRpbWUpO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLm1hc3Rlcikge1xuICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuXG4gICAgICB0aGlzLnNlZ21lbnRJbmRleCA9IDE1O1xuICAgICAgdGhpcy5wbGF5aW5nUG9zaXRpb24gPSBzZWdtZW50c1t0aGlzLnNlZ21lbnRJbmRleF0uc3RhcnQ7XG4gICAgICB0aGlzLnBsYXlpbmdTcGVlZCA9IHNlZ21lbnRzW3RoaXMuc2VnbWVudEluZGV4XS5zcGVlZDtcbiAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuZ2FpbkZhY3RvciAqIDAuNzA3O1xuXG4gICAgICBhdWRpb1NjaGVkdWxlci5hZGQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5tYXN0ZXIpXG4gICAgICBhdWRpb1NjaGVkdWxlci5yZW1vdmUodGhpcyk7XG4gIH1cblxuICBvbk1vdGlvbkV2ZW50KGRhdGEpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG5cbiAgICB0aGlzLnBsYXlpbmdQb3NpdGlvbiA9IHNlZ21lbnRzW2RhdGFdLnN0YXJ0O1xuICAgIHRoaXMucGxheWluZ1NwZWVkID0gc2VnbWVudHNbZGF0YV0uc3BlZWQ7XG5cbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVlZW5QbGF5ZXIge1xuICBjb25zdHJ1Y3RvcihvdXRwdXRzKSB7XG4gICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcblxuICAgIHRoaXMuZW5naW5lcyA9IFtdO1xuXG4gICAgdGhpcy5vbk1vdGlvbkV2ZW50ID0gdGhpcy5vbk1vdGlvbkV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICBzdGFydFRyYWNrKGluZGV4LCB0cmFjaykge1xuICAgIGxldCBlbmdpbmUgPSB0aGlzLmVuZ2luZXNbaW5kZXhdO1xuXG4gICAgaWYgKCFlbmdpbmUpIHtcbiAgICAgIHN3aXRjaCAodHJhY2submFtZSkge1xuICAgICAgICBjYXNlICdkcnVtcyc6XG4gICAgICAgIGNhc2UgJ3ZlcnNlJzpcbiAgICAgICAgY2FzZSAnY2hvcnVzJzpcbiAgICAgICAgY2FzZSAnZnJlZGR5JzpcbiAgICAgICAgICBlbmdpbmUgPSBuZXcgSGl0RW5naW5lKHRyYWNrLCB0aGlzLm91dHB1dHNbaW5kZXhdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwb3dlciBjaG9yZCc6XG4gICAgICAgICAgZW5naW5lID0gbmV3IFBvd2VyQ2hvcmRFbmdpbmUodHJhY2ssIHRoaXMub3V0cHV0c1tpbmRleF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2d1aXRhciByaWZmJzpcbiAgICAgICAgICBlbmdpbmUgPSBuZXcgR3VpdGFyUmlmZkVuZ2luZSh0cmFjaywgdGhpcy5vdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW5naW5lc1tpbmRleF0gPSBlbmdpbmU7XG4gICAgfVxuXG4gICAgZW5naW5lLnN0YXJ0KCk7XG4gIH1cblxuICBzdG9wVHJhY2soaW5kZXgpIHtcbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLmVuZ2luZXNbaW5kZXhdO1xuXG4gICAgaWYgKGVuZ2luZSlcbiAgICAgIGVuZ2luZS5zdG9wKCk7XG4gIH1cblxuICBvbk1vdGlvbkV2ZW50KGluZGV4LCBkYXRhKSB7XG4gICAgY29uc3QgZW5naW5lID0gdGhpcy5lbmdpbmVzW2luZGV4XTtcblxuICAgIGlmIChlbmdpbmUpXG4gICAgICBlbmdpbmUub25Nb3Rpb25FdmVudChkYXRhKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgU2VnbWVudGVkVmlldyxcbiAgU2VsZWN0VmlldyxcbiAgU3BhY2VWaWV3LFxuICBTcXVhcmVkVmlldyxcbiAgVG91Y2hTdXJmYWNlLFxufSBmcm9tICdzb3VuZHdvcmtzL2NsaWVudCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBleGFtcGxlXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIHZpZXcgb2YgdGhlIGBhdWRpby1idWZmZXItbWFuYWdlcmAgc2VydmljZS5cbiAqXG4gKiBAaW50ZXJmYWNlIEFic3RyYWN0QXVkaW9CdWZmZXJNYW5hZ2VyVmlld1xuICogQGV4dGVuZHMgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXdcbiAqL1xuLyoqXG4gKiBNZXRob2QgY2FsbGVkIHdoZW4gYSBuZXcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRseSBsb2FkZWQgYXNzZXRzXG4gKiBpcyByZWNlaXZlZC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBuYW1lIEFic3RyYWN0QXVkaW9CdWZmZXJNYW5hZ2VyVmlldy5vblByb2dyZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gcGVyY2VudCAtIFRoZSBwdXJjZW50YWdlIG9mIGxvYWRlZCBhc3NldHMuXG4gKi9cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbmNvbnN0IHNlcnZpY2VWaWV3cyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEF1ZGlvQnVmZmVyTWFuYWdlclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgJ3NlcnZpY2U6YXVkaW8tYnVmZmVyLW1hbmFnZXInOiBjbGFzcyBBdWRpb0J1ZmZlck1hbmFnZXJWaWV3IGV4dGVuZHMgU2VnbWVudGVkVmlldyB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoKTtcblxuICAgICAgdGhpcy50ZW1wbGF0ZSA9IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdG9wIGZsZXgtbWlkZGxlXCI+XG4gICAgICAgICAgPHA+PCU9IG1zZ1tzdGF0dXNdICU+PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tY2VudGVyIGZsZXgtY2VudGVyXCI+XG4gICAgICAgICAgPCUgaWYgKHNob3dQcm9ncmVzcykgeyAlPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy13cmFwXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCI+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPCUgfSAlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tYm90dG9tXCI+PC9kaXY+XG4gICAgICBgO1xuXG4gICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICBzdGF0dXM6ICdsb2FkaW5nJyxcbiAgICAgICAgc2hvd1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICBtc2c6IHtcbiAgICAgICAgICBsb2FkaW5nOiAnTG9hZGluZyBzb3VuZHMuLi4nLFxuICAgICAgICAgIGRlY29kaW5nOiAnRGVjb2Rpbmcgc291bmRzLi4uJyxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvblJlbmRlcigpIHtcbiAgICAgIHN1cGVyLm9uUmVuZGVyKCk7XG4gICAgICB0aGlzLiRwcm9ncmVzc0JhciA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9ncmVzcy1iYXInKTtcbiAgICB9XG5cbiAgICBvblByb2dyZXNzKHJhdGlvKSB7XG4gICAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5yb3VuZChyYXRpbyAqIDEwMCk7XG5cbiAgICAgIGlmIChwZXJjZW50ID09PSAxMDApIHtcbiAgICAgICAgdGhpcy5tb2RlbC5zdGF0dXMgPSAnZGVjb2RpbmcnO1xuICAgICAgICB0aGlzLnJlbmRlcignLnNlY3Rpb24tdG9wJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1vZGVsLnNob3dQcm9ncmVzcylcbiAgICAgICAgdGhpcy4kcHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSBgJHtwZXJjZW50fSVgO1xuICAgIH1cbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQXV0aFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgJ3NlcnZpY2U6YXV0aCc6IGNsYXNzIEF1dGhWaWV3IGV4dGVuZHMgU2VnbWVudGVkVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlID0gYFxuICAgICAgICA8JSBpZiAoIXJlamVjdGVkKSB7ICU+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdG9wIGZsZXgtbWlkZGxlXCI+XG4gICAgICAgICAgICA8cD48JT0gaW5zdHJ1Y3Rpb25zICU+PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWNlbnRlciBmbGV4LWNlbnRlclwiPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGlkPVwicGFzc3dvcmRcIiAvPlxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuXCIgaWQ9XCJzZW5kXCI+PCU9IHNlbmQgJT48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWJvdHRvbSBmbGV4LW1pZGRsZVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInJlc2V0XCIgY2xhc3M9XCJidG5cIj48JT0gcmVzZXQgJT48L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPCUgfSBlbHNlIHsgJT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi10b3BcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1jZW50ZXIgZmxleC1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxwPjwlPSByZWplY3RNZXNzYWdlICU+PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWJvdHRvbSBmbGV4LW1pZGRsZVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInJlc2V0XCIgY2xhc3M9XCJidG5cIj48JT0gcmVzZXQgJT48L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPCUgfSAlPlxuICAgICAgYDtcblxuICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiAnTG9naW4nLFxuICAgICAgICBzZW5kOiAnU2VuZCcsXG4gICAgICAgIHJlc2V0OiAnUmVzZXQnLFxuICAgICAgICByZWplY3RNZXNzYWdlOiBgU29ycnksIHlvdSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGlzIGNsaWVudGAsXG4gICAgICAgIHJlamVjdGVkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NlbmRQYXNzd29yZENhbGxiYWNrID0gbm9vcDtcbiAgICAgIHRoaXMuX3Jlc2V0Q2FsbGJhY2sgPSBub29wO1xuICAgIH1cblxuICAgIG9uUmVuZGVyKCkge1xuICAgICAgc3VwZXIub25SZW5kZXIoKTtcblxuICAgICAgdGhpcy5pbnN0YWxsRXZlbnRzKHtcbiAgICAgICAgJ2NsaWNrICNzZW5kJzogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3Bhc3N3b3JkJykudmFsdWU7XG5cbiAgICAgICAgICBpZiAocGFzc3dvcmQgIT09ICcnKVxuICAgICAgICAgICAgdGhpcy5fc2VuZFBhc3N3b3JkQ2FsbGJhY2socGFzc3dvcmQpO1xuICAgICAgICB9LFxuICAgICAgICAnY2xpY2sgI3Jlc2V0JzogKCkgPT4gdGhpcy5fcmVzZXRDYWxsYmFjaygpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0U2VuZFBhc3N3b3JkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3NlbmRQYXNzd29yZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgc2V0UmVzZXRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgdGhpcy5fcmVzZXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHVwZGF0ZVJlamVjdGVkU3RhdHVzKHZhbHVlKSB7XG4gICAgICB0aGlzLm1vZGVsLnJlamVjdGVkID0gdmFsdWU7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQ2hlY2tpblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgJ3NlcnZpY2U6Y2hlY2tpbic6IGNsYXNzIENoZWNraW5WaWV3IGV4dGVuZHMgU2VnbWVudGVkVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlID0gYFxuICAgICAgICA8JSBpZiAobGFiZWwpIHsgJT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi10b3AgZmxleC1taWRkbGVcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzPVwiYmlnXCI+PCU9IGxhYmVsUHJlZml4ICU+PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWNlbnRlciBmbGV4LWNlbnRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoZWNraW4tbGFiZWxcIj5cbiAgICAgICAgICAgICAgPHAgY2xhc3M9XCJodWdlIGJvbGRcIj48JT0gbGFiZWwgJT48L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1ib3R0b20gZmxleC1taWRkbGVcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzPVwic21hbGxcIj48JT0gbGFiZWxQb3N0Zml4ICU+PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8JSB9IGVsc2UgeyAlPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLXRvcFwiPjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWNlbnRlciBmbGV4LWNlbnRlclwiPlxuICAgICAgICAgICAgPHA+PCU9IGVycm9yID8gZXJyb3JNZXNzYWdlIDogd2FpdCAlPjwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1ib3R0b21cIj48L2Rpdj5cbiAgICAgICAgPCUgfSAlPlxuICAgICAgYDtcblxuICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAgbGFiZWxQcmVmaXg6ICdHbyB0bycsXG4gICAgICAgIGxhYmVsUG9zdGZpeDogJ1RvdWNoIHRoZSBzY3JlZW48YnIgY2xhc3M9XCJwb3J0cmFpdC1vbmx5XCIgLz53aGVuIHlvdSBhcmUgcmVhZHkuJyxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBlcnJvck1lc3NhZ2U6ICdTb3JyeSw8YnIvPm5vIHBsYWNlIGF2YWlsYWJsZScsXG4gICAgICAgIHdhaXQ6ICdQbGVhc2Ugd2FpdC4uLicsXG4gICAgICAgIGxhYmVsOiAnJyxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgIH1cblxuICAgIG9uUmVuZGVyKCkge1xuICAgICAgc3VwZXIub25SZW5kZXIoKTtcblxuICAgICAgY29uc3QgZXZlbnROYW1lID0gdGhpcy5vcHRpb25zLmludGVyYWN0aW9uID09PSAnbW91c2UnID8gJ2NsaWNrJyA6ICd0b3VjaHN0YXJ0JztcblxuICAgICAgdGhpcy5pbnN0YWxsRXZlbnRzKHtcbiAgICAgICAgW2V2ZW50TmFtZV06ICgpID0+IHRoaXMuX3JlYWR5Q2FsbGJhY2soKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFJlYWR5Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3JlYWR5Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB1cGRhdGVMYWJlbCh2YWx1ZSkge1xuICAgICAgdGhpcy5tb2RlbC5sYWJlbCA9IHZhbHVlO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFcnJvclN0YXR1cyh2YWx1ZSkge1xuICAgICAgdGhpcy5tb2RlbC5lcnJvciA9IHZhbHVlO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgJ3NlcnZpY2U6bGFuZ3VhZ2UnOiBjbGFzcyBMYW5ndWFnZVZpZXcgZXh0ZW5kcyBTZWdtZW50ZWRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIHRoaXMudGVtcGxhdGUgPSBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLXRvcFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1jZW50ZXJcIj5cbiAgICAgICAgICA8JSBmb3IgKGxldCBrZXkgaW4gb3B0aW9ucykgeyAlPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0blwiIGRhdGEtaWQ9XCI8JT0ga2V5ICU+XCI+PCU9IG9wdGlvbnNba2V5XSAlPjwvYnV0dG9uPlxuICAgICAgICAgIDwlIH0gJT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWJvdHRvbVwiPjwvZGl2PlxuICAgICAgYDtcblxuICAgICAgdGhpcy5tb2RlbCA9IHt9O1xuXG4gICAgICB0aGlzLl9zZWxlY3Rpb25DYWxsYmFjayA9IG5vb3A7XG4gICAgfVxuXG4gICAgb25SZW5kZXIoKSB7XG4gICAgICBzdXBlci5vblJlbmRlcigpO1xuXG4gICAgICBjb25zdCBldmVudE5hbWUgPSB0aGlzLm9wdGlvbnMuaW50ZXJhY3Rpb24gPT09ICdtb3VzZScgPyAnY2xpY2snIDogJ3RvdWNoc3RhcnQnO1xuICAgICAgdGhpcy5pbnN0YWxsRXZlbnRzKHtcbiAgICAgICAgW2Ake2V2ZW50TmFtZX0gLmJ0bmBdOiAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgIGNvbnN0IGlkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpO1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkNhbGxiYWNrKGlkKTtcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc2V0U2VsZWN0aW9uQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBMb2NhdG9yXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAnc2VydmljZTpsb2NhdG9yJzogY2xhc3MgTG9jYXRvclZpZXcgZXh0ZW5kcyBTcXVhcmVkVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlID0gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1zcXVhcmVcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tZmxvYXQgZmxleC1taWRkbGVcIj5cbiAgICAgICAgICA8JSBpZiAoIXNob3dCdG4pIHsgJT5cbiAgICAgICAgICAgIDxwIGNsYXNzPVwic21hbGxcIj48JT0gaW5zdHJ1Y3Rpb25zICU+PC9wPlxuICAgICAgICAgIDwlIH0gZWxzZSB7ICU+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuXCI+PCU9IHNlbmQgJT48L2J1dHRvbj5cbiAgICAgICAgICA8JSB9ICU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcblxuICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiAnRGVmaW5lIHlvdXIgcG9zaXRpb24gaW4gdGhlIGFyZWEnLFxuICAgICAgICBzZW5kOiAnU2VuZCcsXG4gICAgICAgIHNob3dCdG46IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcmVhID0gbnVsbDtcbiAgICAgIHRoaXMuX3NlbGVjdENhbGxiYWNrID0gbm9vcDtcblxuICAgICAgdGhpcy5fb25BcmVhVG91Y2hTdGFydCA9IHRoaXMuX29uQXJlYVRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uQXJlYVRvdWNoTW92ZSA9IHRoaXMuX29uQXJlYVRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICBzdXBlci5zaG93KCk7XG4gICAgICB0aGlzLnNlbGVjdG9yLnNob3coKTtcbiAgICB9XG5cbiAgICBvblJlbmRlcigpIHtcbiAgICAgIHN1cGVyLm9uUmVuZGVyKCk7XG4gICAgICB0aGlzLiRhcmVhQ29udGFpbmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnNlY3Rpb24tc3F1YXJlJyk7XG4gICAgfVxuXG4gICAgc2V0QXJlYShhcmVhKSB7XG4gICAgICB0aGlzLl9hcmVhID0gYXJlYTtcbiAgICAgIHRoaXMuX3JlbmRlckFyZWEoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3RDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgdGhpcy5fc2VsZWN0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICByZW1vdmUoKSB7XG4gICAgICBzdXBlci5yZW1vdmUoKTtcblxuICAgICAgdGhpcy5zdXJmYWNlLnJlbW92ZUxpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25BcmVhVG91Y2hTdGFydCk7XG4gICAgICB0aGlzLnN1cmZhY2UucmVtb3ZlTGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uQXJlYVRvdWNoTW92ZSk7XG4gICAgfVxuXG4gICAgb25SZXNpemUodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIG9yaWVudGF0aW9uKSB7XG4gICAgICBzdXBlci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RvcilcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuICAgIH1cblxuICAgIF9yZW5kZXJBcmVhKCkge1xuICAgICAgdGhpcy5zZWxlY3RvciA9IG5ldyBTcGFjZVZpZXcoKTtcbiAgICAgIHRoaXMuc2VsZWN0b3Iuc2V0QXJlYSh0aGlzLl9hcmVhKTtcblxuICAgICAgdGhpcy5zZWxlY3Rvci5yZW5kZXIoKTtcbiAgICAgIHRoaXMuc2VsZWN0b3IuYXBwZW5kVG8odGhpcy4kYXJlYUNvbnRhaW5lcik7XG4gICAgICB0aGlzLnNlbGVjdG9yLm9uUmVuZGVyKCk7XG5cbiAgICAgIHRoaXMuc3VyZmFjZSA9IG5ldyBUb3VjaFN1cmZhY2UodGhpcy5zZWxlY3Rvci4kc3ZnQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuc3VyZmFjZS5hZGRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uQXJlYVRvdWNoU3RhcnQpO1xuICAgICAgdGhpcy5zdXJmYWNlLmFkZExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkFyZWFUb3VjaE1vdmUpO1xuICAgIH1cblxuICAgIF9vbkFyZWFUb3VjaFN0YXJ0KGlkLCBub3JtWCwgbm9ybVkpIHtcbiAgICAgIGlmICghdGhpcy5wb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3NpdGlvbihub3JtWCwgbm9ybVkpO1xuXG4gICAgICAgIHRoaXMubW9kZWwuc2hvd0J0biA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyKCcuc2VjdGlvbi1mbG9hdCcpO1xuICAgICAgICB0aGlzLmluc3RhbGxFdmVudHMoe1xuICAgICAgICAgICdjbGljayAuYnRuJzogKGUpID0+IHRoaXMuX3NlbGVjdENhbGxiYWNrKHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihub3JtWCwgbm9ybVkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9vbkFyZWFUb3VjaE1vdmUoaWQsIG5vcm1YLCBub3JtWSkge1xuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24obm9ybVgsIG5vcm1ZKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlUG9zaXRpb24obm9ybVgsIG5vcm1ZKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICBpZDogJ2xvY2F0b3InLFxuICAgICAgICB4OiBub3JtWCAqIHRoaXMuX2FyZWEud2lkdGgsXG4gICAgICAgIHk6IG5vcm1ZICogdGhpcy5fYXJlYS5oZWlnaHQsXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNlbGVjdG9yLmFkZFBvaW50KHRoaXMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIF91cGRhdGVQb3NpdGlvbihub3JtWCwgbm9ybVkpIHtcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IG5vcm1YICogdGhpcy5fYXJlYS53aWR0aDtcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IG5vcm1ZICogdGhpcy5fYXJlYS5oZWlnaHQ7XG5cbiAgICAgIHRoaXMuc2VsZWN0b3IudXBkYXRlUG9pbnQodGhpcy5wb3NpdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQbGFjZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICdzZXJ2aWNlOnBsYWNlcic6IGNsYXNzIFBsYWNlclZpZXdMaXN0IGV4dGVuZHMgU3F1YXJlZFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcblxuICAgICAgdGhpcy50ZW1wbGF0ZSA9IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tc3F1YXJlIGZsZXgtbWlkZGxlXCI+XG4gICAgICAgICAgPCUgaWYgKHJlamVjdGVkKSB7ICU+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZpdC1jb250YWluZXIgZmxleC1taWRkbGVcIj5cbiAgICAgICAgICAgIDxwPjwlPSByZWplY3QgJT48L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPCUgfSAlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tZmxvYXQgZmxleC1taWRkbGVcIj5cbiAgICAgICAgICA8JSBpZiAoIXJlamVjdGVkKSB7ICU+XG4gICAgICAgICAgICA8JSBpZiAoc2hvd0J0bikgeyAlPlxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuXCI+PCU9IHNlbmQgJT48L2J1dHRvbj5cbiAgICAgICAgICAgIDwlIH0gJT5cbiAgICAgICAgICA8JSB9ICU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcblxuICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiAnU2VsZWN0IHlvdXIgcG9zaXRpb24nLFxuICAgICAgICBzZW5kOiAnU2VuZCcsXG4gICAgICAgIHJlamVjdDogJ1NvcnJ5LCBubyBwbGFjZSBpcyBhdmFpbGFibGUnLFxuICAgICAgICBzaG93QnRuOiBmYWxzZSxcbiAgICAgICAgcmVqZWN0ZWQ6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fb25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLl9vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICBzdXBlci5zaG93KCk7XG4gICAgICB0aGlzLnNlbGVjdG9yLnNob3coKTtcbiAgICB9XG5cbiAgICBfb25TZWxlY3Rpb25DaGFuZ2UoZSkge1xuICAgICAgdGhpcy5tb2RlbC5zaG93QnRuID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVuZGVyKCcuc2VjdGlvbi1mbG9hdCcpO1xuXG4gICAgICB0aGlzLmluc3RhbGxFdmVudHMoe1xuICAgICAgICAnY2xpY2sgLmJ0bic6IChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnNlbGVjdG9yLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHBvc2l0aW9uKVxuICAgICAgICAgICAgdGhpcy5fb25TZWxlY3QocG9zaXRpb24uaW5kZXgsIHBvc2l0aW9uLmxhYmVsLCBwb3NpdGlvbi5jb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldEFyZWEoYXJlYSkgeyAvKiBubyBuZWVkIGZvciBhcmVhICovIH1cblxuICAgIG9uUmVuZGVyKCkge1xuICAgICAgc3VwZXIub25SZW5kZXIoKTtcbiAgICAgIHRoaXMuJHNlbGVjdG9yQ29udGFpbmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnNlY3Rpb24tc3F1YXJlJyk7XG4gICAgfVxuXG4gICAgb25SZXNpemUodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIG9yaWVudGF0aW9uKSB7XG4gICAgICBzdXBlci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RvcilcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuICAgIH1cblxuICAgIGRpc3BsYXlQb3NpdGlvbnMoY2FwYWNpdHksIGxhYmVscyA9IG51bGwsIGNvb3JkaW5hdGVzID0gbnVsbCwgbWF4Q2xpZW50c1BlclBvc2l0aW9uID0gMSkge1xuICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMubnVtYmVyUG9zaXRpb25zID0gY2FwYWNpdHkgLyBtYXhDbGllbnRzUGVyUG9zaXRpb247XG5cbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLm51bWJlclBvc2l0aW9uczsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGxhYmVscyAhPT0gbnVsbCA/IGxhYmVsc1tpbmRleF0gOiAoaW5kZXggKyAxKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgaW5kZXg6IGluZGV4LCBsYWJlbDogbGFiZWwgfTtcblxuICAgICAgICBpZiAoY29vcmRpbmF0ZXMpXG4gICAgICAgICAgcG9zaXRpb24uY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlc1tpbmRleF07XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBuZXcgU2VsZWN0Vmlldyh7XG4gICAgICAgIGluc3RydWN0aW9uczogdGhpcy5tb2RlbC5pbnN0cnVjdGlvbnMsXG4gICAgICAgIGVudHJpZXM6IHRoaXMucG9zaXRpb25zLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2VsZWN0b3IucmVuZGVyKCk7XG4gICAgICB0aGlzLnNlbGVjdG9yLmFwcGVuZFRvKHRoaXMuJHNlbGVjdG9yQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuc2VsZWN0b3Iub25SZW5kZXIoKTtcblxuICAgICAgdGhpcy5zZWxlY3Rvci5pbnN0YWxsRXZlbnRzKHtcbiAgICAgICAgJ2NoYW5nZSc6IHRoaXMuX29uU2VsZWN0aW9uQ2hhbmdlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRGlzYWJsZWRQb3NpdGlvbnMoaW5kZXhlcykge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubnVtYmVyUG9zaXRpb25zOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChpbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSlcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yLmVuYWJsZUluZGV4KGluZGV4KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuc2VsZWN0b3IuZGlzYWJsZUluZGV4KGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTZWxlY3RDYWxsYWNrKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9vblNlbGVjdCA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHJlamVjdChkaXNhYmxlZFBvc2l0aW9ucykge1xuICAgICAgdGhpcy5tb2RlbC5yZWplY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICAvLyBncmFwaGljIHBsYWNlciBmbGF2b3IgZm9yIHByZWRldGVybWluZWQgY29vcmRpbmF0ZXNcbiAgLy8gJ3NlcnZpY2U6cGxhY2VyJzogY2xhc3MgUGxhY2VyVmlld0dyYXBoaWMgZXh0ZW5kcyBTcXVhcmVkVmlldyB7XG4gIC8vICAgY29uc3RydWN0b3IoKSB7XG4gIC8vICAgICBzdXBlcigpO1xuXG4gIC8vICAgICB0aGlzLnRlbXBsYXRlID0gYFxuICAvLyAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1zcXVhcmUgZmxleC1taWRkbGVcIj5cbiAgLy8gICAgICAgICA8JSBpZiAocmVqZWN0ZWQpIHsgJT5cbiAgLy8gICAgICAgICA8ZGl2IGNsYXNzPVwiZml0LWNvbnRhaW5lciBmbGV4LW1pZGRsZVwiPlxuICAvLyAgICAgICAgICAgPHA+PCU9IHJlamVjdCAlPjwvcD5cbiAgLy8gICAgICAgICA8L2Rpdj5cbiAgLy8gICAgICAgICA8JSB9ICU+XG4gIC8vICAgICAgIDwvZGl2PlxuICAvLyAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1mbG9hdCBmbGV4LW1pZGRsZVwiPlxuICAvLyAgICAgICAgIDwlIGlmICghcmVqZWN0ZWQpIHsgJT5cbiAgLy8gICAgICAgICAgIDwlIGlmIChzaG93QnRuKSB7ICU+XG4gIC8vICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG5cIj48JT0gc2VuZCAlPjwvYnV0dG9uPlxuICAvLyAgICAgICAgICAgPCUgfSAlPlxuICAvLyAgICAgICAgIDwlIH0gJT5cbiAgLy8gICAgICAgPC9kaXY+XG4gIC8vICAgICBgO1xuXG4gIC8vICAgICB0aGlzLm1vZGVsID0ge1xuICAvLyAgICAgICBpbnN0cnVjdGlvbnM6ICdTZWxlY3QgeW91ciBwb3NpdGlvbicsXG4gIC8vICAgICAgIHNlbmQ6ICdTZW5kJyxcbiAgLy8gICAgICAgcmVqZWN0OiAnU29ycnksIG5vIHBsYWNlIGlzIGF2YWlsYWJsZScsXG4gIC8vICAgICAgIHNob3dCdG46IGZhbHNlLFxuICAvLyAgICAgICByZWplY3RlZDogZmFsc2UsXG4gIC8vICAgICB9O1xuXG4gIC8vICAgICB0aGlzLl9hcmVhID0gbnVsbDtcbiAgLy8gICAgIHRoaXMuX2Rpc2FibGVkUG9zaXRpb25zID0gW107XG4gIC8vICAgICB0aGlzLl9vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMuX29uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gIC8vICAgfVxuXG4gIC8vICAgc2hvdygpIHtcbiAgLy8gICAgIHN1cGVyLnNob3coKTtcbiAgLy8gICAgIHRoaXMuc2VsZWN0b3Iuc2hvdygpO1xuICAvLyAgIH1cblxuICAvLyAgIG9uUmVuZGVyKCkge1xuICAvLyAgICAgc3VwZXIub25SZW5kZXIoKTtcbiAgLy8gICAgIHRoaXMuJHNlbGVjdG9yQ29udGFpbmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnNlY3Rpb24tc3F1YXJlJyk7XG4gIC8vICAgfVxuXG4gIC8vICAgb25SZXNpemUodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIG9yaWVudGF0aW9uKSB7XG4gIC8vICAgICBzdXBlci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuXG4gIC8vICAgICBpZiAodGhpcy5zZWxlY3RvcilcbiAgLy8gICAgICAgdGhpcy5zZWxlY3Rvci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuICAvLyAgIH1cblxuICAvLyAgIF9vblNlbGVjdGlvbkNoYW5nZShlKSB7XG4gIC8vICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuc2VsZWN0b3Iuc2hhcGVQb2ludE1hcC5nZXQoZS50YXJnZXQpO1xuICAvLyAgICAgY29uc3QgZGlzYWJsZWRJbmRleCA9IHRoaXMuX2Rpc2FibGVkUG9zaXRpb25zLmluZGV4T2YocG9zaXRpb24uaW5kZXgpO1xuXG4gIC8vICAgICBpZiAoZGlzYWJsZWRJbmRleCA9PT0gLTEpXG4gIC8vICAgICAgIHRoaXMuX29uU2VsZWN0KHBvc2l0aW9uLmlkLCBwb3NpdGlvbi5sYWJlbCwgW3Bvc2l0aW9uLngsIHBvc2l0aW9uLnldKTtcbiAgLy8gICB9XG5cbiAgLy8gICBzZXRBcmVhKGFyZWEpIHtcbiAgLy8gICAgIHRoaXMuX2FyZWEgPSBhcmVhO1xuICAvLyAgIH1cblxuICAvLyAgIGRpc3BsYXlQb3NpdGlvbnMoY2FwYWNpdHksIGxhYmVscyA9IG51bGwsIGNvb3JkaW5hdGVzID0gbnVsbCwgbWF4Q2xpZW50c1BlclBvc2l0aW9uID0gMSkge1xuICAvLyAgICAgdGhpcy5udW1iZXJQb3NpdGlvbnMgPSBjYXBhY2l0eSAvIG1heENsaWVudHNQZXJQb3NpdGlvbjtcbiAgLy8gICAgIHRoaXMucG9zaXRpb25zID0gW107XG5cbiAgLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1iZXJQb3NpdGlvbnM7IGkrKykge1xuICAvLyAgICAgICBjb25zdCBsYWJlbCA9IGxhYmVscyAhPT0gbnVsbCA/IGxhYmVsc1tpXSA6IChpICsgMSkudG9TdHJpbmcoKTtcbiAgLy8gICAgICAgY29uc3QgcG9zaXRpb24gPSB7IGlkOiBpLCBsYWJlbDogbGFiZWwgfTtcbiAgLy8gICAgICAgY29uc3QgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gIC8vICAgICAgIHBvc2l0aW9uLnggPSBjb29yZHNbMF07XG4gIC8vICAgICAgIHBvc2l0aW9uLnkgPSBjb29yZHNbMV07XG5cbiAgLy8gICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIHRoaXMuc2VsZWN0b3IgPSBuZXcgU3BhY2VWaWV3KCk7XG4gIC8vICAgICB0aGlzLnNlbGVjdG9yLnNldEFyZWEodGhpcy5fYXJlYSk7XG4gIC8vICAgICB0aGlzLnNlbGVjdG9yLnJlbmRlcigpO1xuICAvLyAgICAgdGhpcy5zZWxlY3Rvci5hcHBlbmRUbyh0aGlzLiRzZWxlY3RvckNvbnRhaW5lcik7XG4gIC8vICAgICB0aGlzLnNlbGVjdG9yLm9uUmVuZGVyKCk7XG4gIC8vICAgICB0aGlzLnNlbGVjdG9yLnNldFBvaW50cyh0aGlzLnBvc2l0aW9ucyk7XG5cbiAgLy8gICAgIHRoaXMuc2VsZWN0b3IuaW5zdGFsbEV2ZW50cyh7XG4gIC8vICAgICAgICdjbGljayAucG9pbnQnOiB0aGlzLl9vblNlbGVjdGlvbkNoYW5nZVxuICAvLyAgICAgfSk7XG4gIC8vICAgfVxuXG4gIC8vICAgdXBkYXRlRGlzYWJsZWRQb3NpdGlvbnMoaW5kZXhlcykge1xuICAvLyAgICAgdGhpcy5fZGlzYWJsZWRQb3NpdGlvbnMgPSBpbmRleGVzO1xuXG4gIC8vICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5udW1iZXJQb3NpdGlvbnM7IGluZGV4KyspIHtcbiAgLy8gICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uc1tpbmRleF07XG4gIC8vICAgICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBpbmRleGVzLmluZGV4T2YoaW5kZXgpICE9PSAtMTtcbiAgLy8gICAgICAgcG9zaXRpb24uc2VsZWN0ZWQgPSBpc0Rpc2FibGVkID8gdHJ1ZSA6IGZhbHNlO1xuICAvLyAgICAgICB0aGlzLnNlbGVjdG9yLnVwZGF0ZVBvaW50KHBvc2l0aW9uKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG5cbiAgLy8gICBzZXRTZWxlY3RDYWxsYWNrKGNhbGxiYWNrKSB7XG4gIC8vICAgICB0aGlzLl9vblNlbGVjdCA9IGNhbGxiYWNrO1xuICAvLyAgIH1cblxuICAvLyAgIHJlamVjdChkaXNhYmxlZFBvc2l0aW9ucykge1xuICAvLyAgICAgdGhpcy5tb2RlbC5yZWplY3RlZCA9IHRydWU7XG4gIC8vICAgICB0aGlzLnJlbmRlcigpO1xuICAvLyAgIH1cbiAgLy8gfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUGxhdGZvcm1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICdzZXJ2aWNlOnBsYXRmb3JtJzogY2xhc3MgUGxhdGZvcm1WaWV3IGV4dGVuZHMgU2VnbWVudGVkVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlID0gYFxuICAgICAgICA8JSBpZiAoaXNDb21wYXRpYmxlID09PSBmYWxzZSkgeyAlPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLXRvcFwiPjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWNlbnRlciBmbGV4LWNlbnRlclwiPlxuICAgICAgICAgICAgPHA+PCU9IGVycm9yQ29tcGF0aWJsZU1lc3NhZ2UgJT48L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tYm90dG9tXCI+PC9kaXY+XG4gICAgICAgIDwlIH0gZWxzZSBpZiAoaGFzQXV0aG9yaXphdGlvbnMgPT09IGZhbHNlKSB7ICU+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdG9wXCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tY2VudGVyIGZsZXgtY2VudGVyXCI+XG4gICAgICAgICAgICA8cD48JT0gZXJyb3JIb29rc01lc3NhZ2UgJT48L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tYm90dG9tXCI+PC9kaXY+XG4gICAgICAgIDwlIH0gZWxzZSB7ICU+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdG9wIGZsZXgtbWlkZGxlXCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tY2VudGVyIGZsZXgtY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxwIGNsYXNzPVwiYmlnXCI+XG4gICAgICAgICAgICAgICAgPCU9IGludHJvICU+XG4gICAgICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICAgICAgPGI+PCU9IGdsb2JhbHMuYXBwTmFtZSAlPjwvYj5cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWJvdHRvbSBmbGV4LW1pZGRsZVwiPlxuICAgICAgICAgICAgPCUgaWYgKGNoZWNraW5nID09PSB0cnVlKSB7ICU+XG4gICAgICAgICAgICA8cCBjbGFzcz1cInNtYWxsIHNvZnQtYmxpbmtcIj48JT0gY2hlY2tpbmdNZXNzYWdlICU+PC9wPlxuICAgICAgICAgICAgPCUgfSBlbHNlIGlmIChoYXNBdXRob3JpemF0aW9ucyA9PT0gdHJ1ZSkgeyAlPlxuICAgICAgICAgICAgPHAgY2xhc3M9XCJzbWFsbCBzb2Z0LWJsaW5rXCI+PCU9IGluc3RydWN0aW9ucyAlPjwvcD5cbiAgICAgICAgICAgIDwlIH0gJT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPCUgfSAlPlxuICAgICAgYDtcblxuICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAgaXNDb21wYXRpYmxlOiBudWxsLFxuICAgICAgICBoYXNBdXRob3JpemF0aW9uczogbnVsbCxcbiAgICAgICAgY2hlY2tpbmc6IGZhbHNlLFxuICAgICAgICBpbnRybzogJ1dlbGNvbWUgdG8nLFxuICAgICAgICBpbnN0cnVjdGlvbnM6ICdUb3VjaCB0aGUgc2NyZWVuIHRvIGpvaW4hJyxcbiAgICAgICAgY2hlY2tpbmdNZXNzYWdlOiAnUGxlYXNlIHdhaXQgd2hpbGUgY2hlY2tpbmcgY29tcGF0aWJsaXR5JyxcbiAgICAgICAgZXJyb3JDb21wYXRpYmxlTWVzc2FnZTogJ1NvcnJ5LDxiciAvPllvdXIgZGV2aWNlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGFwcGxpY2F0aW9uLicsXG4gICAgICAgIGVycm9ySG9va3NNZXNzYWdlOiBgU29ycnksPGJyIC8+VGhlIGFwcGxpY2F0aW9uIGRpZG4ndCBvYnRhaW4gdGhlIG5lY2Vzc2FyeSBhdXRob3JpemF0aW9ucy5gLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fdG91Y2hzdGFydENhbGxiYWNrID0gbm9vcDtcbiAgICAgIHRoaXMuX21vdXNlZG93bkNhbGxiYWNrID0gbm9vcDtcbiAgICB9XG5cbiAgICBvblJlbmRlcigpIHtcbiAgICAgIHN1cGVyLm9uUmVuZGVyKCk7XG5cbiAgICAgIHRoaXMuaW5zdGFsbEV2ZW50cyh7XG4gICAgICAgICdtb3VzZWRvd24nOiAoZSkgPT4gdGhpcy5fbW91c2Vkb3duQ2FsbGJhY2soZSksXG4gICAgICAgICd0b3VjaHN0YXJ0JzogKGUpID0+IHRoaXMuX3RvdWNoc3RhcnRDYWxsYmFjayhlKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFRvdWNoU3RhcnRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgdGhpcy5fdG91Y2hzdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgc2V0TW91c2VEb3duQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX21vdXNlZG93bkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgdXBkYXRlQ2hlY2tpbmdTdGF0dXModmFsdWUpIHtcbiAgICAgIHRoaXMubW9kZWwuY2hlY2tpbmcgPSB2YWx1ZTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlSXNDb21wYXRpYmxlU3RhdHVzKHZhbHVlKSB7XG4gICAgICB0aGlzLm1vZGVsLmlzQ29tcGF0aWJsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVIYXNBdXRob3JpemF0aW9uc1N0YXR1cyh2YWx1ZSkge1xuICAgICAgdGhpcy5tb2RlbC5oYXNBdXRob3JpemF0aW9ucyA9IHZhbHVlO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFJhdy1Tb2NrZXRcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICdzZXJ2aWNlOnJhdy1zb2NrZXQnOiBjbGFzcyBSYXdTb2NrZXRWaWV3IGV4dGVuZHMgU2VnbWVudGVkVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlID0gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi10b3BcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tY2VudGVyIGZsZXgtY2VudGVyXCI+XG4gICAgICAgICAgPHAgY2xhc3M9XCJzb2Z0LWJsaW5rXCI+PCU9IHdhaXQgJT48L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1ib3R0b21cIj48L2Rpdj5cbiAgICAgIGA7XG5cbiAgICAgIHRoaXMubW9kZWwgPSB7XG4gICAgICAgIHdhaXQ6IGBPcGVuaW5nIHNvY2tldCw8YnIgLz5zdGFuZCBieSZoZWxsaXA7YCxcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTeW5jXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAnc2VydmljZTpzeW5jJzogY2xhc3MgUmF3U29ja2V0VmlldyBleHRlbmRzIFNlZ21lbnRlZFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcblxuICAgICAgdGhpcy50ZW1wbGF0ZSA9IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdG9wXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWNlbnRlciBmbGV4LWNlbnRlclwiPlxuICAgICAgICAgIDxwIGNsYXNzPVwic29mdC1ibGlua1wiPjwlPSB3YWl0ICU+PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tYm90dG9tXCI+PC9kaXY+XG4gICAgICBgO1xuXG4gICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICB3YWl0OiBgQ2xvY2sgc3luY2luZyw8YnIgLz5zdGFuZCBieSZoZWxsaXA7YCxcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gcHVibGljIEFQSVxuICBoYXMoaWQpIHtcbiAgICByZXR1cm4gISF0aGlzW2lkXTtcbiAgfSxcblxuICBnZXQoaWQsIGNvbmZpZykge1xuICAgIGNvbnN0IGN0b3IgPSB0aGlzW2lkXTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IGN0b3IoKTtcbiAgICAvLyBhZGRpdGlvbm5hbCBjb25maWd1cmF0aW9uXG4gICAgdmlldy5tb2RlbC5nbG9iYWxzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcbiAgICB2aWV3Lm9wdGlvbnMuaWQgPSBpZC5yZXBsYWNlKC9cXDovZywgJy0nKTtcblxuICAgIHJldHVybiB2aWV3O1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VydmljZVZpZXdzO1xuIiwiZXhwb3J0IGRlZmF1bHQge1xuICAnb2ZmJzoge30sXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKlxuICAgKiAgQ08tOTA5XG4gICAqXG4gICAqL1xuICAnY28tOTA5Jzoge1xuICAgIG51bVN0ZXBzOiAxNixcbiAgICBpbnN0cnVtZW50czogW3tcbiAgICAgIG5hbWU6ICdiYXNzIGRydW0nLFxuICAgICAgbGF5ZXJzOiBbe1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tOTA5LzkwOS1CRC1sb3cud2F2JyxcbiAgICAgICAgZ2FpbjogNSxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLTkwOS85MDktQkQtaGlnaC53YXYnLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwgXSxcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc25hcmUgZHJ1bScsXG4gICAgICBsYXllcnM6IFt7XG4gICAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jby05MDkvOTA5LVNELWxvdy53YXYnLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwge1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tOTA5LzkwOS1TRC1oaWdoLndhdicsXG4gICAgICAgIGdhaW46IDAsXG4gICAgICB9LCBdLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdoaSBoYXQnLFxuICAgICAgbGF5ZXJzOiBbe1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tOTA5LzkwOS1ISC1jbG9zZWQud2F2JyxcbiAgICAgICAgZ2FpbjogMCxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLTkwOS85MDktSEgtb3Blbi53YXYnLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwgXSxcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWlkIHRvbScsXG4gICAgICBsYXllcnM6IFt7XG4gICAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jby05MDkvOTA5LU1ULWxvdy53YXYnLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwge1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tOTA5LzkwOS1NVC1oaWdoLndhdicsXG4gICAgICAgIGdhaW46IDAsXG4gICAgICB9LCBdLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdyaW0gc2hvdCAvIGhhbmQgY2xhcCcsXG4gICAgICBsYXllcnM6IFt7XG4gICAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jby05MDkvOTA5LVBDLXJpbXNob3Qud2F2JyxcbiAgICAgICAgZ2FpbjogMyxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLTkwOS85MDktUEMtY2xhcC53YXYnLFxuICAgICAgICBnYWluOiAtNCxcbiAgICAgIH0sIF0sXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2hpZ2ggdG9tJyxcbiAgICAgIGxheWVyczogW3tcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLTkwOS85MDktSFQtbG93LndhdicsXG4gICAgICAgIGdhaW46IDAsXG4gICAgICB9LCB7XG4gICAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jby05MDkvOTA5LUhULWhpZ2gud2F2JyxcbiAgICAgICAgZ2FpbjogMCxcbiAgICAgIH0sIF0sXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xvdyB0b20nLFxuICAgICAgbGF5ZXJzOiBbe1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tOTA5LzkwOS1MVC1sb3cud2F2JyxcbiAgICAgICAgZ2FpbjogMCxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLTkwOS85MDktTFQtaGlnaC53YXYnLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwgXSxcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY3ltYmFsJyxcbiAgICAgIGxheWVyczogW3tcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLTkwOS85MDktQ1ktcmlkZS53YXYnLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwge1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tOTA5LzkwOS1DWS1jcmFzaC53YXYnLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwgXSxcbiAgICB9LCBdLFxuICB9LFxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICpcbiAgICogIENvbGxlY3RpdmUgTG9vcHNcbiAgICpcbiAgICovXG4gICdjb2xsZWN0aXZlLWxvb3BzJzoge1xuICAgIG51bVN0ZXBzOiA4LFxuICAgIG5vdGVzOiBbe1xuICAgICAgY2xhc3M6ICdwZXJjJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jb2xsZWN0aXZlLWxvb3BzL3BlcmMtMDEubXAzJyxcbiAgICAgIGdhaW46IC01LFxuICAgIH0sIHtcbiAgICAgIGNsYXNzOiAncGVyYycsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvY29sbGVjdGl2ZS1sb29wcy9wZXJjLTAyLm1wMycsXG4gICAgICBnYWluOiAtNSxcbiAgICB9LCB7XG4gICAgICBjbGFzczogJ3BlcmMnLFxuICAgICAgYnVmZmVyOiAnc291bmRzL2NvbGxlY3RpdmUtbG9vcHMvcGVyYy0wMy5tcDMnLFxuICAgICAgZ2FpbjogLTVcbiAgICB9LCB7XG4gICAgICBjbGFzczogJ2Jhc3MnLFxuICAgICAgYnVmZmVyOiAnc291bmRzL2NvbGxlY3RpdmUtbG9vcHMvYmFzcy0wMS5tcDMnLFxuICAgICAgZ2FpbjogMFxuICAgIH0sIHtcbiAgICAgIGNsYXNzOiAnYmFzcycsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvY29sbGVjdGl2ZS1sb29wcy9iYXNzLTAyLm1wMycsXG4gICAgICBnYWluOiAwXG4gICAgfSwge1xuICAgICAgY2xhc3M6ICdiYXNzJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jb2xsZWN0aXZlLWxvb3BzL2Jhc3MtMDMubXAzJyxcbiAgICAgIGdhaW46IC0yLFxuICAgIH0sIHtcbiAgICAgIGNsYXNzOiAnYmFzcycsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvY29sbGVjdGl2ZS1sb29wcy9iYXNzLTA0Lm1wMycsXG4gICAgICBnYWluOiAtMixcbiAgICB9LCB7XG4gICAgICBjbGFzczogJ2Jhc3MnLFxuICAgICAgYnVmZmVyOiAnc291bmRzL2NvbGxlY3RpdmUtbG9vcHMvYmFzcy0wNS5tcDMnLFxuICAgICAgZ2FpbjogLTIsXG4gICAgfSwge1xuICAgICAgY2xhc3M6ICdiYXNzJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jb2xsZWN0aXZlLWxvb3BzL2Jhc3MtMDYubXAzJyxcbiAgICAgIGdhaW46IC0yLFxuICAgIH0sIHtcbiAgICAgIGNsYXNzOiAnbWVsb2R5JyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jb2xsZWN0aXZlLWxvb3BzL21hcmltYmEtMDEubXAzJyxcbiAgICAgIGdhaW46IC0xMCxcbiAgICB9LCB7XG4gICAgICBjbGFzczogJ21lbG9keScsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvY29sbGVjdGl2ZS1sb29wcy9tYXJpbWJhLTAyLm1wMycsXG4gICAgICBnYWluOiAtMTAsXG4gICAgfSwge1xuICAgICAgY2xhc3M6ICdtZWxvZHknLFxuICAgICAgYnVmZmVyOiAnc291bmRzL2NvbGxlY3RpdmUtbG9vcHMvbWFyaW1iYS0wMy5tcDMnLFxuICAgICAgZ2FpbjogLTEwLFxuICAgIH0sIHtcbiAgICAgIGNsYXNzOiAnbWVsb2R5JyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jb2xsZWN0aXZlLWxvb3BzL21hcmltYmEtMDQubXAzJyxcbiAgICAgIGdhaW46IC0xMCxcbiAgICB9LCB7XG4gICAgICBjbGFzczogJ21lbG9keScsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvY29sbGVjdGl2ZS1sb29wcy9tYXJpbWJhLTA1Lm1wMycsXG4gICAgICBnYWluOiAtMTAsXG4gICAgfSwge1xuICAgICAgY2xhc3M6ICdtZWxvZHknLFxuICAgICAgYnVmZmVyOiAnc291bmRzL2NvbGxlY3RpdmUtbG9vcHMvbWFyaW1iYS0wNi5tcDMnLFxuICAgICAgZ2FpbjogLTEwLFxuICAgIH0sIHtcbiAgICAgIGNsYXNzOiAnbWVsb2R5JyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jb2xsZWN0aXZlLWxvb3BzL21hcmltYmEtMDcubXAzJyxcbiAgICAgIGdhaW46IC0xMCxcbiAgICB9LCB7XG4gICAgICBjbGFzczogJ21lbG9keScsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvY29sbGVjdGl2ZS1sb29wcy9tYXJpbWJhLTA4Lm1wMycsXG4gICAgICBnYWluOiAtMTAsXG4gICAgfSwge1xuICAgICAgY2xhc3M6ICdtZWxvZHknLFxuICAgICAgYnVmZmVyOiAnc291bmRzL2NvbGxlY3RpdmUtbG9vcHMvbWFyaW1iYS0wOS5tcDMnLFxuICAgICAgZ2FpbjogLTEwLFxuICAgIH0sIHtcbiAgICAgIGNsYXNzOiAnbWVsb2R5JyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jb2xsZWN0aXZlLWxvb3BzL21hcmltYmEtMTAubXAzJyxcbiAgICAgIGdhaW46IC0xMCxcbiAgICB9LCB7XG4gICAgICBjbGFzczogJ21lbG9keScsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvY29sbGVjdGl2ZS1sb29wcy9tYXJpbWJhLTExLm1wMycsXG4gICAgICBnYWluOiAtMTAsXG4gICAgfSwge1xuICAgICAgY2xhc3M6ICdtZWxvZHknLFxuICAgICAgYnVmZmVyOiAnc291bmRzL2NvbGxlY3RpdmUtbG9vcHMvbWFyaW1iYS0xMi5tcDMnLFxuICAgICAgZ2FpbjogLTEwLFxuICAgIH0sIF0sXG4gIH0sXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKlxuICAgKiAgQ28tTWl4XG4gICAqXG4gICAqL1xuICAnY28tbWl4Jzoge1xuICAgIHRlbXBvOiAxMjIsXG4gICAgdGVtcG9Vbml0OiAxIC8gNCxcbiAgICB0cmFja3M6IFt7XG4gICAgICBuYW1lOiAnc2hha2VyJyxcbiAgICAgIGxheWVyczogW3tcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9ndWl0cGVyY19zaGFrZXJzX21vZGVfMS53YXYnLFxuICAgICAgICBzdGFydE9mZnNldDogMC41ICogNjAgLyAxMjIsXG4gICAgICAgIGxlbmd0aDogNSxcbiAgICAgICAgaW50ZW5zaXR5OiBbLTg2LjIyMzgsIC04Ny4yOTY0LCAtODYuNjIzMSwgLTUwLjAyMjcsIC0yMy4yMjc1LCAtMzMuNjU2MywgLTQwLjA2MzIsIC00My45NDM2LCAtNDcuMzQ4MiwgLTQ5LjA0MzEsIC01MC4zMjk4LCAtNTAuNTc4NSwgLTUxLjQzNDEsIC01MS4xMzEyLCAtNTEuODQzNCwgLTUyLjE1MTcsIC01Ni40Nzk1LCAtNTUuNTUyMiwgLTU2LjEzMjMsIC01My4zNjUxLCAtMzcuNTk3NiwgLTQ4LjI1NDMsIC01My41NDU3LCAtNTcuNDc4NSwgLTU4LjgyNDEsIC01OS42NDYwLCAtNjAuOTk3OSwgLTYxLjk5NTUsIC02MS44Nzk3LCAtNjYuMDg2OCwgLTY1LjEyODksIC02MS45OTU0LCAtNjMuNDQwMSwgLTY0LjkzMjQsIC02Ny4yODMyLCAtNDIuNDQ1OCwgLTI1LjA4ODIsIC0zNC4xNjEyLCAtNDIuMzgyNywgLTQ1LjE3ODYsIC00OS45NDYyLCAtMzQuNDM2MiwgLTM0LjE1OTIsIC00Ni4xODM4LCAtNTAuMzMzNywgLTUwLjgyNzIsIC00MC44ODcyLCAtNDEuNDA4MCwgLTUxLjU2OTEsIC01NC42NDM5LCAtNTUuMTQzNywgLTU1LjIyOTMsIC0zOS41MzY0LCAtNDUuNzU0MiwgLTU1Ljk5OTAsIC01OS45MTc2LCAtNTAuNzA3NiwgLTI5LjMxNzcsIC0zOS42NjMxLCAtNDUuMDI0OCwgLTUxLjAzODEsIC01My4zOTc2LCAtNDQuNTc0MSwgLTQwLjM1MDEsIC01MS42OTA0LCAtNTcuMjUwNSwgLTU5LjQ1NjAsIC00OS44ODQ3LCAtNDUuMjM5NywgLTU1LjkzMDcsIC02MS40NjM2LCAtNjMuMzk0MiwgLTYyLjYwMzksIC0zOS4zOTU4LCAtNDMuNDA2NCwgLTU2Ljg2MzksIC02MC45MDQ5LCAtNTkuNTk5NywgLTIxLjQwNDksIC0yOS45NTM4LCAtMzguOTgxNywgLTQxLjkwNDEsIC00NS4zOTAwLCAtNDQuODAyNCwgLTM4LjUzMzcsIC00NS4yNjk5LCAtNDguNDkyMCwgLTUwLjQ1ODAsIC00OS41ODg1LCAtNDIuNzg4MiwgLTUxLjY4MjcsIC01NC4xNTgwLCAtNTMuNTU0NywgLTU1LjQ1NjcsIC00MC44NDM2LCAtNDEuNzUxNSwgLTU0LjI0MTQsIC01Ni45Mzg5LCAtNTcuMjIwNiwgLTMxLjI5MTksIC0zMi45MTEzLCAtNDQuNTMxMiwgLTQ5LjEwNjQsIC01Mi41OTg0LCAtNTIuNTUzOSwgLTM5LjE2MTUsIC00Ni41MjA1LCAtNTcuMDI3MCwgLTU4LjExNjksIC01OC4xNzkxLCAtNDMuNDYxMiwgLTUyLjc0MTAsIC01OS4wMzgwLCAtNjIuNjE5MCwgLTY0LjEzMzEsIC00My44Njk4LCAtNDAuNjk4MywgLTUzLjEyNTYsIC01OS42NDc4LCAtNjEuMzkzMywgLTM0Ljc4OTcsIC0yNy42OTU4LCAtMzguMDE4NywgLTQ1LjAxODAsIC00Ni45NDk2LCAtNDkuNzMzMCwgLTM4LjYxMTYsIC00My4yOTMwLCAtNTAuNzE0NywgLTUyLjc3NDEsIC01My41MzMwLCAtNDMuNjI1OCwgLTQ5LjYxMTMsIC01NS42OTEwLCAtNTUuOTQ1MywgLTU4LjAxNDgsIC00My40NTEwLCAtNDQuMTA0MCwgLTU0LjY1OTMsIC01OC40OTQwLCAtNjAuNjkzOSwgLTU5LjAwNDQsIC00NS4zNDY2LCAtNTEuNTk4OCwgLTYwLjA3MTcsIC02Mi45Mjk2LCAtNjMuNTY5MCwgLTQxLjM5NTYsIC00Ni43NjQ2LCAtNTcuMjY3NywgLTYwLjgxNTIsIC02My4xMDI4LCAtNTguNjMxNCwgLTYxLjMzNzksIC02NS43MTE0LCAtNjcuMjU5OCwgLTY4Ljg4NjMsIC02NC4xMDI4LCAtNDkuOTg2MywgLTU3LjY0OTIsIC02OC4wNTc2LCAtNzAuNDk5MiwgLTM5LjQxNDcsIC0yMy45ODcwLCAtMzUuMjExMiwgLTQxLjE4NTYsIC00NC41ODAzLCAtNDcuOTEyNSwgLTQwLjM0NDQsIC0zOC42NzYxLCAtNDguMTc1MywgLTUxLjUyOTgsIC01MC41MzAwLCAtMzQuMTM1NCwgLTMyLjQwOTUsIC00NC4yNjM2LCAtNDguNjI3MSwgLTUxLjg0NjYsIC01Mi45MTg0LCAtNTMuODc4NCwgLTU2LjM2NjEsIC01OC4wMTAxLCAtNTkuMTM5OSwgLTYwLjc4MzAsIC02MC43ODQ0LCAtNjIuMjYyNSwgLTYxLjc4NjUsIC02My4wMjE5LCAtNjUuNzAzMywgLTY0LjUzNzcsIC02Mi42ODkxLCAtNjMuODA3MSwgLTY0Ljg3NjgsIC02Ny40MzEyLCAtNjYuMTk2MSwgLTY4LjQ3NzcsIC02Ny4xMzk2LCAtNjguNjY2NCwgLTY4LjcwNjYsIC03MC40NTI1LCAtNzIuODU1OCwgLTY5LjA4NjcsIC03MC44NzE3LCAtNzMuNDI0NCwgLTcyLjUyNDMsIC0zMi4wNzA2LCAtMzEuMDU1MCwgLTQwLjQ3NzUsIC00Ni4zODkxLCAtNDguODA5MCwgLTUyLjE0MTAsIC01MC4yNDA4LCAtNTMuNDQxOSwgLTUyLjA5MTgsIC01NC45ODEzLCAtNTUuMjQxNiwgLTU1LjIzMTksIC01Ny4xNTY2LCAtNTYuOTk0NCwgLTU2Ljk4NjQsIC02MC4wNTE1LCAtMzQuOTUxMSwgLTM0LjA5ODksIC00Ni41NDIyLCAtNTIuMDU1OCwgLTU0LjQxOTksIC01NC4xNTUzLCAtNTguOTgwOCwgLTYwLjc0MDEsIC02MC41MDY2LCAtNjEuMjk5NywgLTMxLjE4MzQsIC0yNC43NDE1LCAtMzUuODk1NiwgLTQxLjQ3MzYsIC00My41NTIxLCAtNDUuNjE0OCwgLTI5LjA1NzEsIC0zNi40NDg2LCAtNDQuMjIyNiwgLTQ3LjA1MjIsIC00OS43NjI2LCAtNDguOTQxNSwgLTUwLjU3MTIsIC01My45NzA2LCAtNTMuMTY3NSwgLTU1LjExMjAsIC01NS43NTY2LCAtNTQuNzY2MSwgLTU1LjM4MjAsIC02MC4wNjc5LCAtNTkuNzI0MCwgLTU2LjYyNDYsIC0zMi40ODcxLCAtMzUuNzA3NSwgLTQ5LjI1MzAsIC01Mi40OTgzLCAtNTMuNTg2MiwgLTM4LjI5OTEsIC00Ni4yODEzLCAtNTIuNTI5OSwgLTU1LjkwMjYsIC02MC40MDkzLCAtNjEuNDY5OCwgLTYzLjEyOTAsIC02Mi41ODY5LCAtNjMuOTQ5MSwgLTY1LjM5OTEsIC01MC4zNzA2LCAtMjcuMjQ3MiwgLTM1Ljk5MDUsIC00My45OTY2LCAtNDYuOTUwNCwgLTUxLjE4NDEsIC0zNC4wNDgwLCAtMzQuMjU0NSwgLTQ2LjQxNjAsIC01MC4xMDQ1LCAtNTAuNjY5MiwgLTUyLjM1NDcsIC01Mi44OTQwLCAtNTYuNTUyNCwgLTU2LjQ3MzcsIC01Ni41NjkyLCAtNTguMTY5OCwgLTU5LjYwMjcsIC01Ny42NDA2LCAtNjAuMTU1NSwgLTYyLjM2NDAsIC00MS4wNzk5LCAtMjEuNjgwOSwgLTMyLjg1NjQsIC0zOS44MzgxLCAtNDIuNTI2MiwgLTQ1LjI0MjgsIC00Ni4xOTk2LCAtNDcuNTA2NCwgLTQ3Ljk1OTAsIC00OC45MDI5LCAtNTEuMjIxNSwgLTQzLjQyNjYsIC0zOS40MTk5LCAtNTAuMTc1MCwgLTUyLjYzODIsIC01My4yNjUzLCAtNTQuNjIzNywgLTM5Ljg1MjYsIC00My44MDU4LCAtNTUuOTc1NiwgLTU3LjA0MDcsIC01Ny4wODQwLCAtMjkuNDA1NCwgLTM3Ljc1MjksIC00NC4xMjUwLCAtNDkuODM2MSwgLTUzLjc4NTUsIC00OC4wNjg3LCAtMzkuNDQ2OCwgLTQ5LjE0NzMsIC01NS42MzAxLCAtNTguNjEyOSwgLTQ3LjUxMzEsIC0yNy4xMzYzLCAtMzYuMzgyOCwgLTQ0LjI1ODIsIC00Ny4wNTIxLCAtNTEuNDY4OCwgLTQwLjIxODEsIC00MS40OTIzLCAtNTAuNTUzMCwgLTUyLjEyMjgsIC01My4xNzUwLCAtMzIuOTc4OCwgLTM1LjM1MjksIC00Ny4yMjY4LCAtNTAuNDM4NSwgLTUyLjYwNTksIC01Mi4yNjEyLCAtMzguODUzOSwgLTQ2LjA5OTUsIC01NS4yMjE2LCAtNTguNDc5OCwgLTQxLjQ2NzYsIC0yNC4xNDUzLCAtMzQuOTc2NCwgLTQwLjc5MDMsIC00NC4zMzM3LCAtNDcuNDkzNiwgLTQ4Ljk1MzgsIC01MC4zODM3LCAtNTAuNzQ0MCwgLTUxLjc0NDYsIC01MS4xMDM4LCAtMzMuODY3MCwgLTMxLjIxODksIC00My4xNDM2LCAtNDcuNzk2NCwgLTUxLjA5MDMsIC01MS45OTY1LCAtNTMuMzQ0OCwgLTU1Ljc2MDgsIC01Ni45MTA1LCAtNTguNDc0NSwgLTYwLjMxMjUsIC02MC40OTMxLCAtNjEuNTE0MCwgLTYxLjUzNDUsIC02Mi43MDM1LCAtNjUuMTgwOSwgLTQwLjY2MzUsIC0zMi41NDYzLCAtNDIuNjAxMywgLTUxLjkzOTEsIC01My44MDE5LCAtNDUuODU5NywgLTI3LjM0MjksIC0zNi45NTk3LCAtNDQuMTg5NiwgLTQ2Ljg2OTUsIC01MC45MDE0LCAtNTAuNDE0NywgLTUyLjM5NTMsIC01Mi4xMTA1LCAtNTIuNzE2MywgLTU0LjI3MDYsIC0zMC41MDIyLCAtMzMuNzIzMywgLTQ0Ljg0MDEsIC00OS4wMDM0LCAtNTIuMDMzMSwgLTQwLjM4OTMsIC0zNS43OTEzLCAtNDguMjIyNSwgLTUxLjcwMTcsIC01NS4yODAyLCAtNTUuOTM5NCwgLTM0LjA4MTgsIC0zOC4wMDI5LCAtNTAuOTY3OCwgLTU1LjI5MzUsIC01Ni45MTUzLCAtMzYuOTA4MCwgLTQ1LjY5ODAsIC01Mi4xNTQ5LCAtNTYuNTA4NywgLTYwLjM1MjYsIC0yOS40NTU4LCAtMjkuODUxOCwgLTQwLjA4MjMsIC00NC44NDI0LCAtNDguOTkxNywgLTQ2LjA0MDQsIC0zNi41MDY4LCAtNDYuOTExNCwgLTUwLjY3NTAsIC01Mi40NjU5LCAtNDcuNzcyNSwgLTIyLjYzMTIsIC0zMi40NzYyLCAtNDAuMzQ5MSwgLTQyLjAxNzcsIC00NS43MjgwLCAtNDAuMDQ3MSwgLTQ0LjIxNzAsIC00Ni42ODEzLCAtNDguMjgyMywgLTUwLjg0ODRdLFxuICAgICAgICBnYWluOiAxLFxuICAgICAgfSwge1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tbWl4L2d1aXRwZXJjX3NoYWtlcnNfbW9kZV8yLndhdicsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiAwLjUgKiA2MCAvIDEyMixcbiAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICBpbnRlbnNpdHk6IFstMjYuNzY4NiwgLTQwLjcxODAsIC00OC4wMjg5LCAtNTQuNjkwOSwgLTMwLjM2NjUsIC0xOS4zNjk1LCAtMzUuNjAwMiwgLTQzLjc1MzcsIC00My4zMjMzLCAtNDcuMDEwOCwgLTI3LjM2ODYsIC0zMS42Mjk2LCAtNDEuOTk0NCwgLTQ1LjUzMzQsIC01Mi4yMTU1LCAtMjkuNjEzNSwgLTMyLjcwODYsIC00Ni4xNjk4LCAtNTAuODcyMiwgLTU1LjM5OTAsIC0zNy40NTg4LCAtMjUuNzk5MywgLTM5LjI1NjEsIC00Ny4wNTMzLCAtNTQuMjYxOCwgLTMyLjY0ODgsIC0xNy42OTM5LCAtMzMuNDkyMCwgLTQyLjQyMTUsIC00Mi4wOTUwLCAtNDguMDM5NCwgLTI5LjMyNjksIC0yOC42NjYxLCAtNDAuNjY3MiwgLTQyLjg0NTAsIC01MC43MjI0LCAtMzMuMDI4NywgLTI5LjMyMzQsIC00NC42MjY1LCAtNTEuMzE1NiwgLTUzLjA1MDMsIC00My4xNTk5LCAtMjUuOTc2OSwgLTM2LjQ3MzcsIC00NS44MjYwLCAtNTMuNDQ1NywgLTQwLjYyMDgsIC0xOS4yNDA1LCAtMzAuNzc5OSwgLTQxLjA1NzEsIC00Mi40OTc1LCAtNDkuNDI4MiwgLTMyLjE2MTIsIC0yNi44MTcxLCAtNDAuMjM3MywgLTQyLjUzMDcsIC01MS43MjQ0LCAtMzcuNzU5OSwgLTI3LjI4ODAsIC00My4zNTUyLCAtNTEuMDc2NSwgLTUxLjE1MDksIC00OS4xMDg5LCAtMjYuOTYwMCwgLTMyLjY1MDUsIC00NC4xNzA1LCAtNTEuNzg2NSwgLTQ0LjMyNTgsIC0xOS4yNTQyLCAtMjUuOTQzNywgLTM5LjIxMTAsIC00Mi44MDM3LCAtNDcuODMwNywgLTM1LjkzMTksIC0yNS44Njc1LCAtMzkuMTE2OCwgLTQxLjUxMDUsIC00Ni44MDY2LCAtNDIuNTU2OSwgLTI2LjQxNTIsIC00MS43MTc2LCAtNDkuNzAzNCwgLTUwLjAzNjIsIC01My40NTkyLCAtMjguNzM0OCwgLTI5LjQxNzEsIC00Mi40ODg2LCAtNDkuOTExOSwgLTUxLjg0MjMsIC0yMy43MjM0LCAtMjIuNjk3MywgLTM3Ljg0NzgsIC00NC4wNjMyLCAtNDYuMzgwNCwgLTQwLjg0MDcsIC0yNS44NDE3LCAtMzcuMjgxMywgLTQyLjMzNTUsIC00OC44MzI5LCAtNDcuMDc2MSwgLTI2Ljc1NzAsIC0zOS4yNTQ1LCAtNDguNTA3MywgLTQ5Ljg2ODEsIC01NS44NjkxLCAtMzEuMzE4NSwgLTI3LjI0ODMsIC00MS4xMzIwLCAtNDguNDk5NiwgLTU0LjE1MDAsIC0yNS4yNTQ0LCAtMTkuNDc4MSwgLTM2LjEwNzksIC00My45ODg5LCAtNDMuODQyNiwgLTQ0Ljg5NzIsIC0yNi41NjU2LCAtMzMuNDk3NiwgLTQxLjM2MjYsIC00NC43NTI3LCAtNDkuODc0NywgLTI4LjIxNzMsIC0zNS4wMDM2LCAtNDYuOTY1MiwgLTUwLjM5MzUsIC01Ni4yMjQ2LCAtMzQuOTMwNiwgLTI2LjA2MTAsIC00MC4wNDI0LCAtNDcuNTQzNiwgLTU0LjQ3NjYsIC0zMi42MzU1LCAtMTguOTUxOSwgLTM0Ljg5MzYsIC00My4yODc2LCAtNDIuODM3MCwgLTQ3LjkzOTEsIC0yOC4xNjA5LCAtMzAuMTgyNiwgLTQxLjY0MDEsIC00NC41OTA3LCAtNTIuOTM3MSwgLTMxLjAyMTUsIC0zMS4wNDE4LCAtNDUuNTExNCwgLTUxLjIwNDYsIC01NC4zOTAyLCAtMzkuODY1OSwgLTI1Ljc3NjEsIC0zOC4yNDg4LCAtNDYuNTY0MSwgLTUzLjk5NTksIC0zNS4wNTk3LCAtMTcuNjY5NiwgLTMyLjMyNzAsIC00MS43NTk2LCAtNDEuOTgyNywgLTQ4LjM1NjYsIC0zMC40NDg5LCAtMjcuNjYyOCwgLTQwLjEzMzYsIC00Mi4yMDU2LCAtNDkuNzU0OSwgLTM0Ljk2NDUsIC0yOC4yNTEzLCAtNDQuMTQyNSwgLTUxLjI1OTMsIC01Mi4xMjQwLCAtNDUuOTM4NywgLTI2LjMyMzUsIC0zNC43NTY1LCAtNDUuMTE1OSwgLTUyLjc3NTAsIC00My4wMjMwLCAtMTkuODMzMCwgLTI4Ljg0MDEsIC00MC4zMTMxLCAtNDIuNzQ3MSwgLTQ5LjI3NTQsIC0zMy43NDMyLCAtMjYuMjg3MSwgLTM5Ljg3MzYsIC00Mi4zMDg1LCAtNTEuMDI0OSwgLTQwLjAzNDQsIC0yNi43NjE0LCAtNDIuNjk4OSwgLTUwLjYwNjYsIC01MC41NDUzLCAtNTEuMzA0NSwgLTI3LjY1ODUsIC0zMS4wNzQzLCAtNDMuMzkwNywgLTUwLjkwMDYsIC00Ny41MDQ1LCAtMjAuMjA5NywgLTI0LjA4OTAsIC0zOC40Njk2LCAtNDMuMjQxNywgLTQ3LjAzNjIsIC0zNy45MTYyLCAtMjUuNzE0MSwgLTM4LjMwMDMsIC00MS4zMjU2LCAtNDYuMzUxNywgLTQ0LjQyMDgsIC0yNi40MjAyLCAtNDAuODY0MywgLTQ5LjE5MTUsIC00OS44NzI1LCAtNTQuODA0OCwgLTI5Ljc5MjEsIC0yOC4zMDkyLCAtNDEuODM0NiwgLTQ5LjE5OTcsIC01My40NTYyLCAtMjUuMTk4NywgLTIxLjM3MjMsIC0zNy4xNzI0LCAtNDQuMjM2NywgLTQ1LjMxMzksIC00My4wNDkzLCAtMjYuMDg3NywgLTM1LjcyOTAsIC00Mi4zMTUwLCAtNDcuNzM2NiwgLTQ4LjczMjEsIC0yNy4yODE2LCAtMzcuNDY1MSwgLTQ3Ljc5NjMsIC01MC4wNDIwLCAtNTYuMzU0MiwgLTMyLjc5MzEsIC0yNi41OTk1LCAtNDAuNjQxOSwgLTQ4LjAyNTEsIC01NC40MTM1LCAtMjcuMjMzMiwgLTE4LjY3MDksIC0zNS4zODQzLCAtNDMuNzI3NSwgLTQzLjEwNDEsIC00Ni4zMTc2LCAtMjcuMjAwOSwgLTMxLjkwNjksIC00MS4zNzkyLCAtNDQuMjI5MCwgLTUwLjk0NjUsIC0yOS4zMzk2LCAtMzMuMDg3NywgLTQ2LjA3MzQsIC01MC43MzI0LCAtNTUuNTkxOSwgLTM2Ljk3NTgsIC0yNS44MjcxLCAtMzkuNDIxNSwgLTQ3LjE1MTEsIC01NC4zMTY2LCAtMzQuNjg4MSwgLTE4LjY3NDAsIC0zNC4wNjI2LCAtNDIuNjk1MCwgLTQyLjQ5MTcsIC00OC41ODMwLCAtMjkuMTE0MCwgLTI4Ljk0NDUsIC00MS4xOTM0LCAtNDMuNzI3OSwgLTUyLjg1MTUsIC0zMi42OTU3LCAtMjkuNjMzMywgLTQ0Ljg3MzksIC01MS40MTEwLCAtNTMuMzM4NiwgLTQyLjUyNTUsIC0yNS45MjExLCAtMzYuODQyNywgLTQ1Ljk3NTYsIC01My41ODIzLCAtMzcuNTY2NCwgLTE3Ljg2ODQsIC0zMC43MDk5LCAtNDEuMDE5OCwgLTQyLjA0OTMsIC00OC41NDkyLCAtMzEuODI1MSwgLTI2LjkyMzgsIC0zOS45ODM2LCAtNDEuOTY3MSwgLTQ4LjcxNzcsIC0zNy4yMDA3LCAtMjcuNDM0NSwgLTQzLjQzMTEsIC01MC44MjEzLCAtNTEuMjgyMSwgLTQ4LjU3NzEsIC0yNi44Mjg2LCAtMzMuMDE1MywgLTQ0LjM0MTYsIC01MS45NjU1LCAtNDUuNDI1NCwgLTIwLjUyNzMsIC0yNi44MTIzLCAtMzkuNTU1OSwgLTQzLjA3NjYsIC00OC42OTU1LCAtMzUuNTUxNywgLTI1Ljk0MzAsIC0zOS40NDU4LCAtNDIuMTY1MywgLTUwLjA0NzAsIC00Mi4yNDc2LCAtMjYuNDc0OSwgLTQxLjk3ODMsIC01MC4wMTY4LCAtNTAuMTMzMCwgLTUzLjA5MjIsIC0yOC41MTYxLCAtMjkuNzAxMiwgLTQyLjY1MjksIC01MC4wOTAyLCAtNTAuNTE0MiwgLTIxLjQxOTYsIC0yMi40MjU1LCAtMzcuNzIwMywgLTQzLjY4MDIsIC00Ni4wNzkyLCAtNDAuMjMzOSwgLTI1Ljc4OTAsIC0zNy40MTcwLCAtNDEuNTM3NF0sXG4gICAgICAgIGdhaW46IDEsXG4gICAgICB9LCBdLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYXNzJyxcbiAgICAgIGxheWVyczogW3tcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9wZXJjc19iYXNzX21vZGVfMS53YXYnLFxuICAgICAgICBzdGFydE9mZnNldDogMC41ICogNjAgLyAxMjIsXG4gICAgICAgIGxlbmd0aDogMTYsXG4gICAgICAgIGludGVuc2l0eTogWy04Ni4zMDU1LCAtODYuMTMyNywgLTg2LjUwOTcsIC04Ni44NjczLCAtMzkuODcxNywgLTQxLjEyNzksIC01OC41NTA4LCAtNjEuNDkxMCwgLTYzLjU3MjgsIC02NS4yMjAwLCAtNjYuNjU0OSwgLTY4LjI3MzAsIC02OS42MzQ0LCAtNzAuNzIyNSwgLTcxLjQ4MTMsIC03Mi4wMzQ5LCAtNzMuMTU4NSwgLTczLjk0NDQsIC03NC45ODAxLCAtNTYuMTE5NywgLTM0LjY1NDMsIC00Mi44NjgxLCAtNDkuODg4MywgLTU0LjUwMzcsIC01Ni4yMTg2LCAtNTguMDUzMiwgLTU4LjA0MzgsIC01OC4xNDQ2LCAtNjAuMjk4OSwgLTU5LjU5OTMsIC02MC4wNTc2LCAtMjkuMzkyOSwgLTI1LjU4OTUsIC0zNy4zODQxLCAtMzcuMDYzMiwgLTM2Ljk4MDQsIC00MC45MTc3LCAtNDMuNTMwMSwgLTQ0LjQ0NTEsIC00OC4xMzQwLCAtNDguMzA3OCwgLTQ5Ljg4MDYsIC01NC44MzY0LCAtNTYuMzM1NywgLTU2Ljg3MDYsIC01OS4xNjI3LCAtNDguNzk4OSwgLTQyLjIzNTQsIC00OC43OTU0LCAtNTIuMDQ5OSwgLTU0Ljg4ODQsIC0zMC44ODIzLCAtMTMuNDIxOSwgLTE3LjI5NDgsIC0yNS42MzExLCAtMzAuMjY2MiwgLTMyLjk5NzEsIC0zNS45MzI3LCAtMzYuNDk1OSwgLTM4Ljk4MjAsIC0zOC41MjYxLCAtMzkuNjE4NywgLTQwLjE3NzAsIC00MS4yMDk2LCAtNDIuODMyNSwgLTQzLjIxNDMsIC00My4xMTUwLCAtNDQuNzU0OCwgLTQzLjkxMzMsIC00My43NDY2LCAtNDYuNTg1OCwgLTQ1Ljk5NDcsIC00NC43OTkzLCAtNDUuMjM4OSwgLTQ1Ljc5NjYsIC00NS4zMDQwLCAtNDQuMzQ2NCwgLTQyLjQxNTQsIC00MS4yNDk0LCAtNDIuOTkxNCwgLTQ0LjY0ODUsIC00Ny42MzMyLCAtNTAuMTkyMywgLTUxLjQzNzQsIC01MS4xNTMyLCAtNTIuMjk5OCwgLTU0LjU0NTAsIC01NS4xMjU0LCAtNTYuOTIwNCwgLTU2Ljg3NzAsIC01Ni43NzY1LCAtNTcuODk4NiwgLTU5LjI5NTYsIC01OC43MTc5LCAtNTcuNTI2MiwgLTU3LjU0NjgsIC01OS4yMDgxLCAtNjIuNTYwMCwgLTYyLjc1MTMsIC02My42MzI2LCAtNjQuODk1NCwgLTYzLjk3MjQsIC02Mi40NzA3LCAtNjUuNDg3MCwgLTQyLjMxNzcsIC0zOC4wODk2LCAtNTAuMzIyNCwgLTU1LjMzMzAsIC01Ny4wNzcwLCAtNTcuNTMyNSwgLTYwLjIyNjEsIC01OS44MDM5LCAtNjEuODA1MiwgLTYxLjI3NjAsIC02MS40MzcxLCAtNjEuNzA4OSwgLTYzLjk0OTksIC02NC4zNDE0LCAtNjMuNzA3MCwgLTY0LjgxMDMsIC0zMC45Nzk4LCAtMzMuNTk4MywgLTQ0LjUyODQsIC01MC41NDQxLCAtNTAuNDIwMCwgLTQ5LjQwNTcsIC00OS40ODM5LCAtNTIuMzE2MywgLTUyLjQyMTUsIC01NC41MjA2LCAtNTguNTQxNCwgLTU5LjA5MzksIC01OC4zNTU0LCAtNTkuOTYxNSwgLTU2LjA0MDcsIC01NS41MTkxLCAtMjEuMjY5OCwgLTEzLjQ1MjIsIC0xOC4zNDU4LCAtMjEuMjcxNiwgLTI2LjM3NTcsIC0yOS4xMjAxLCAtMzAuMTczNSwgLTM0LjMzNzQsIC0zNy4yOTc2LCAtMzYuMzQ3NiwgLTM3LjY1ODIsIC0yNS44MDY3LCAtMjUuMDI0NywgLTI4LjA5MzMsIC0zMC45MTI1LCAtMzIuNDk4NywgLTM1LjYxNTcsIC0zNi4zMzQ4LCAtMzYuNjcwMiwgLTM2LjExNzcsIC0zOC4zOTMzLCAtMzkuMjI5OSwgLTM4LjU5ODEsIC00MC4zNDMwLCAtNDAuMDQ0OSwgLTQwLjUzMzgsIC00MS4xMjM5LCAtNDAuNzI1OCwgLTQxLjg0OTMsIC00Mi41MTk4LCAtNDQuNjkyNiwgLTQ2LjE0MDYsIC00Ny44NjgwLCAtNDguNjg0NCwgLTQ4LjMzODgsIC00OS4xNjUzLCAtNDYuMzk1MiwgLTQ1LjM2MTMsIC0zNy4wODQzLCAtNDcuNzE1MywgLTUyLjEzMTksIC01Ni4xNDI3LCAtNTYuNDA4NiwgLTU2Ljc1ODMsIC01NS43Mjk3LCAtNTguODY0OCwgLTYxLjAzODQsIC01OS45NDY1LCAtNjIuODU2MywgLTYzLjMzMjcsIC02Mi44NjczLCAtNjIuOTY0NiwgLTY0LjYzNjUsIC0zNi45MDMzLCAtMzQuMjEwMiwgLTQ2LjY5NTEsIC01MS45Njg0LCAtNTQuODU0NiwgLTU2LjI3MTgsIC01Ny41MTYzLCAtNTYuNjU1NCwgLTU3LjU2NDQsIC01Ny45OTE2LCAtNTguOTc0OCwgLTUyLjgyNDAsIC0yMy40NjA2LCAtMzIuODQ0NywgLTM3LjI1NjcsIC0zNy4zNDY4LCAtMzcuNzkwNSwgLTQxLjU1NzAsIC00NC4xNDA4LCAtNDUuODY2OSwgLTQ4LjE5MTcsIC01MC42MTgxLCAtNTEuOTc0OSwgLTU1LjUyMDUsIC01Ni42NDAyLCAtNTcuMjU5MSwgLTU3Ljk4NjgsIC00MS4yODMyLCAtNDYuMzE3MCwgLTUwLjExMTYsIC01My41ODIzLCAtNTUuODcyMCwgLTE2LjcxMTYsIC0xNS40MjE0LCAtMjEuOTQ5NywgLTMwLjg4ODEsIC0zMi4yMDY0LCAtMzIuNTY4OCwgLTM3LjAyOTAsIC0zOC42Nzk2LCAtMzcuODY1NCwgLTM4Ljc4ODcsIC00MC41OTY3LCAtMzguMjcyNSwgLTQzLjY4MDAsIC00NS4yNjI2LCAtNDEuNzIwMiwgLTQxLjcxNjMsIC00MS4xODA1LCAtNDAuNzc2MiwgLTM5LjEzMzIsIC00MC43MDU1LCAtNDIuMjE5MSwgLTQzLjA0MjksIC00My42Mzk2LCAtNDUuNjEwMSwgLTQ1Ljg0MTAsIC00NS4zMDA2LCAtNDguMDgyMCwgLTQ3LjI3ODksIC00OC42MTIwLCAtNDkuMzA0OCwgLTUwLjAzNDUsIC01MS41MDUwLCAtNTAuNjg5NSwgLTUxLjQ3ODQsIC00OS43MTEwLCAtNDguOTc5OSwgLTUyLjcwNzIsIC01NC42NDE2LCAtNTcuMjYxNSwgLTU3LjczMDQsIC01Ni42NTYwLCAtNTYuNzc4MywgLTU3LjY1NzMsIC01NS4yMzE3LCAtNTkuNjUxNywgLTYyLjc1NjgsIC02NC4wMzg0LCAtNjUuMzA4OSwgLTY1LjQ3MDQsIC02My4yODgwLCAtNjIuOTY3NiwgLTYzLjMxMzQsIC02My4zODgwLCAtMzQuMTEwMCwgLTM0Ljg4OTgsIC00Ni41MTkzLCAtNTEuNDI4NSwgLTUyLjU2NTQsIC01My4zOTY0LCAtNTUuMjczNSwgLTU1LjQzMjQsIC01Ni44MDI3LCAtNTcuMDY3MSwgLTU3LjU5MzUsIC01OC44OTAwLCAtNjAuNTcxMywgLTYwLjcyMDAsIC02MC4zNDA4LCAtNDIuMzMyMiwgLTI4LjgxNjMsIC00MS4wNDUyLCAtNDguOTc5OCwgLTUyLjUyMjYsIC01MC43MTQzLCAtNTEuNzIzNywgLTUyLjM1ODUsIC01MS4zMjgxLCAtNTEuNjYxNiwgLTUxLjgyMjIsIC01Ni44MjY0LCAtNTUuNjQ0NSwgLTU4LjkxNDIsIC01OC41MDk4LCAtNTguMzkyMiwgLTQxLjE1NDQsIC0xMy43Mjk1LCAtMTAuNDYxMywgLTE4LjIwNzMsIC0yMy43OTAxLCAtMjYuODc1NywgLTI3LjIxNTYsIC0zMC45MTM0LCAtMzYuNjE3MywgLTM0Ljc1ODMsIC0zNS4xMDM2LCAtMjguMzQ4NiwgLTI1LjI5MTMsIC0yNS45MzE0LCAtMzAuNTMzOSwgLTMxLjM0NzUsIC0zMi4wMjExLCAtMzMuMjk1NywgLTMyLjMwMjEsIC0zMC44OTY1LCAtMzAuODA2MywgLTMzLjA5MTEsIC0zNi4zNzk3LCAtMzguNTg1NywgLTM5LjYxNjQsIC0zOS40MTE5LCAtMzguNzk3MSwgLTM4LjI0MzIsIC0zOS44Mzg2LCAtNDEuMjk2MCwgLTQzLjc0NDEsIC00NC41ODE0LCAtNDYuMjA0MSwgLTQ1LjQ2ODgsIC00NC45NzEyLCAtNDMuNzgwMiwgLTQyLjY3MjgsIC00MS43MDI2LCAtMzcuMjUxMiwgLTQ0Ljk4ODQsIC01MC4xNzk2LCAtNTAuOTM3OCwgLTQ5Ljc0MzEsIC00OS44NzYxLCAtNDguODQ5NCwgLTUxLjE2MzcsIC01NS4xMDY1LCAtNTguODY0MiwgLTU5Ljk2NzksIC02MS45MDY4LCAtNTguOTkxMCwgLTU3LjE2NTgsIC01Ni42OTg4LCAtNDguMjcwMiwgLTM0Ljc4OTIsIC00NS4wMjY5LCAtNTAuMDgzNSwgLTU0LjA0NDgsIC01NS44ODM0LCAtNTUuMTE2MSwgLTU0LjkzODIsIC01Ni4xNTMzLCAtNTcuODQ2NSwgLTU4LjY5ODAsIC01Mi44MTU0LCAtMjMuNDYxNCwgLTMyLjg0NDEsIC0zNy4yMjI4LCAtMzcuMzIyOCwgLTM3Ljc5MDUsIC00MS41NDEzLCAtNDQuMTc0NCwgLTQ1Ljg5NDcsIC00OC4xODY4LCAtNTAuNTkxMiwgLTUxLjk2NDIsIC01NS42MDU1LCAtNTYuNTU0MCwgLTU2Ljk4ODgsIC01OC4wODY3LCAtNDEuMzAxMSwgLTQ2LjI3OTYsIC01MC4yMzM0LCAtNTMuNjI1MCwgLTU1LjkyNzYsIC0yNS43MDg1LCAtMTMuMDQ1NSwgLTE4LjQ3MzUsIC0yNi4xODE0LCAtMzAuMjkzMCwgLTMzLjE5MzEsIC0zNS4yNjk1LCAtMzYuNDM0MSwgLTM5LjU0MTgsIC0zOC42NTM4LCAtMzkuNDU3MywgLTQwLjI4NjAsIC00MS4yMDEyLCAtNDMuNTg2NiwgLTQyLjg3NTEsIC00My4yNjk1LCAtNDQuNzk0OCwgLTQzLjc3NTAsIC00My44MzU2LCAtNDYuOTUwOSwgLTQ1LjYzMjcsIC00NS4xNDcyLCAtNDcuMDM3NywgLTQ0LjkzMDcsIC00My45NjIxLCAtNDQuNzA4MiwgLTQzLjI2NDMsIC00MS44NjU1LCAtNDMuNTI2NSwgLTQ1LjYyMDAsIC00Ny4wMTc1LCAtNTAuOTQ1MCwgLTUyLjMwMTAsIC01Mi42Njk2LCAtNTMuNzk0MCwgLTUzLjQ2OTcsIC01NC45NjU2LCAtNTguMDc4MywgLTU3LjU5NzAsIC01Ni4zNjExLCAtNTcuNTU3NSwgLTU4Ljk2OTYsIC01OC45NjY0LCAtNTguODY1NywgLTU2LjQwMzQsIC02MC40NTI3LCAtNjIuOTAwMywgLTYzLjE0NTQsIC02My40MTQ1LCAtNjQuODI3MSwgLTYzLjIyNTIsIC02My4wNjE0LCAtNjYuNDE5MSwgLTM5LjUxMTgsIC0zOS44NjI5LCAtNTAuNzAxOSwgLTU1LjM3MTAsIC01Ny42NTc0LCAtNTcuNzE5MSwgLTU5LjgwMDAsIC01OC45OTk1LCAtNjEuNDA3MCwgLTYxLjA1MjIsIC02MS44NjIzLCAtNjIuNTAzOCwgLTYzLjQ1MzIsIC02NC44NDQ5LCAtNjQuMzg2NywgLTY0LjAzNjAsIC0yOS4wNjkwLCAtMzQuOTU1MSwgLTQ0Ljg4NzYsIC00OS42NjIzLCAtNDkuODE2NSwgLTUxLjU3MDUsIC01Mi45ODcxLCAtNTQuMTkxMCwgLTU0LjU4ODksIC01NC4xNzEzLCAtNTguMTcyOCwgLTU0LjUzNjEsIC01NC4wOTI4LCAtNTUuNjIwNSwgLTU1Ljc1MDIsIC01OC4zNDkwLCAtMTkuMDc4MSwgLTEzLjQ3MzEsIC0xOS4xNDgyLCAtMjEuNjA5MywgLTI3LjIyMzQsIC0yOS42MTM4LCAtMzAuMzk5NSwgLTM0Ljk3MDQsIC0zNy42NTY1LCAtMzYuMzQ4OSwgLTM2LjY3MDMsIC0yNS40NTE4LCAtMjUuMzM2OSwgLTI4Ljg5MDYsIC0zMC45MTk3LCAtMzIuNjc0MSwgLTM1Ljg3NzksIC0zNS45ODYwLCAtMzcuMjExNywgLTM2LjAzMzUsIC0zOC41NjE2LCAtMzkuNTE5NiwgLTM4LjkxNTAsIC0zOS40NDkyLCAtMzkuNzQwMSwgLTQwLjY0NjcsIC0zOS44OTk3LCAtNDAuNjcyMiwgLTQxLjc3NzcsIC00Mi41ODE4LCAtNDQuMjIwOSwgLTQ3LjA4MDQsIC00OC4zNTcxLCAtNDkuNzUxNCwgLTQ4LjM1MzQsIC00OC44MjczLCAtNDYuMDc4MiwgLTM4Ljg2MTcsIC0zOS4zMTk1LCAtNDkuNTAyOSwgLTUyLjgzODQsIC01Ni43MjM4LCAtNTYuMzA2OSwgLTU3LjAyNzAsIC01NS41NjE3LCAtNTkuMzgwNiwgLTYxLjcwMzEsIC02MC4yMTk0LCAtNjMuMDIyMSwgLTYzLjgxMjcsIC02MS45MTk2LCAtNjIuNTczNSwgLTY0LjczNzEsIC0zNS43MzQ1LCAtMzQuNjY4NCwgLTQ3LjQyMDcsIC01Mi41MTYwLCAtNTUuMjM5MiwgLTU2LjM0MzYsIC01Ny41MjE4LCAtNTYuNjg3MCwgLTU3LjY5MzMsIC01OC4xMDU2LCAtNTguNzQ1MywgLTI5LjM4MDUsIC0yNS41NzgwLCAtMzcuMzU5OSwgLTM3LjA2MjUsIC0zNi45ODAyLCAtNDAuOTA5NSwgLTQzLjQ5NTgsIC00NC4zOTEyLCAtNDguMDQ2NCwgLTQ4LjI4MDYsIC00OS44NzA5LCAtNTQuNzIwMSwgLTU2LjAzMjYsIC01Ni43ODMyLCAtNTkuMDIxOCwgLTQ4Ljc4MDEsIC00Mi4yMTc1LCAtNDguODUzOSwgLTUyLjExNjEsIC01NC44MzA2LCAtNTYuNzU0MSwgLTE1LjcyNDMsIC0xNS43ODc4LCAtMjIuODgwMiwgLTMxLjQ3ODcsIC0zMi40MDAyLCAtMzIuODY0OSwgLTM3LjgxNjQsIC0zOC43NDExLCAtMzcuNzQyMSwgLTM4LjkwNTEsIC00MC42NTE1LCAtMzguNTIyNywgLTQ0LjEyNjAsIC00NS4zNzk0LCAtNDEuNjY5MiwgLTQxLjYxMDksIC00MS4xNTcxLCAtNDAuNTc1NCwgLTM5LjA1MjAsIC00MC42MDEwLCAtNDIuMzM3NSwgLTQzLjYyNzksIC00Mi45MDA5LCAtNDQuNzg2NSwgLTQ0Ljc4OTgsIC00NS4zNTgxLCAtNDYuMjU2MywgLTQ2Ljg1MzYsIC00Ni43NzIyLCAtNDguNzA0NiwgLTUwLjc0NDcsIC01Mi41ODk4LCAtNTEuODU3MywgLTUxLjU5ODgsIC00OS45MjczLCAtNDkuMzA5OCwgLTUyLjgzODIsIC01NS4yNTU3LCAtNTcuODk1MywgLTU4LjAyMTcsIC01Ny4xMzAzLCAtNTYuODM2NiwgLTU3LjU2MzAsIC01NS41MzAzLCAtNTkuMTk1MSwgLTYzLjE1NDQsIC02My42OTYxLCAtNjUuNzM0MiwgLTY1LjczMTQsIC02My4xMTU1LCAtNjIuNDk1MywgLTYzLjIwMjQsIC01OS43MzI3LCAtMzMuMjY0OCwgLTM3LjA0MzAsIC00Ni42MTQxLCAtNTEuNzg3OCwgLTUzLjEzMjAsIC01My41NDU2LCAtNTUuNDI5MSwgLTU1LjYxMTgsIC01Ny4xNjExLCAtNTcuMzA1MiwgLTU3LjU0NjEsIC01OC45OTcwLCAtNjAuNjAzNiwgLTYxLjAxNzcsIC02MC4yNTI5LCAtMzguMzIxMywgLTMwLjA1MTEsIC00MS45ODM4LCAtNDguODg4MywgLTUxLjQ4NjgsIC00OS4wMDYyLCAtNDkuNTI3OCwgLTUwLjk5OTQsIC01MS4xMTE5LCAtNTQuMjYwMCwgLTU1LjE3NjIsIC01OS45MjUxLCAtNTguMzQxNywgLTU5LjE3NjgsIC01Ni42MjIwLCAtNTUuMzgyNSwgLTM0LjMwOTMsIC0xMi44NzYyLCAtMTAuODA4MCwgLTE4LjgyNDIsIC0yMy42Njk5LCAtMjcuMTI3NiwgLTI2Ljk1MDgsIC0zMS44MDk4LCAtMzYuNTY3MSwgLTM0LjMzNDgsIC0zNS4zNDcxLCAtMjguMDEyNywgLTI1LjE1MTMsIC0yNi42MTUzLCAtMzAuMDQ3OSwgLTMxLjIxNDQsIC0zMi4wNTQzLCAtMzIuNTkxNiwgLTMxLjc2MzMsIC0zMC44ODU2LCAtMzEuMDI2NCwgLTMzLjQ1MzAsIC0zNi44NjA3LCAtMzguNDIyNiwgLTM5LjYwMzEsIC0zOS4wOTAyLCAtMzkuMjU3NywgLTM4LjMyMDAsIC0zOS44NjcyLCAtNDEuNjAwOSwgLTQ0LjQyMDksIC00NC44OTgzLCAtNDYuNTkxMiwgLTQ1LjI5OTAsIC00NC43NDE0LCAtNDMuNDczMCwgLTQyLjUzNjIsIC00MS44MjY1LCAtMzcuMDg1MCwgLTQ0LjYzNDgsIC01MC4zOTkxLCAtNTAuNzM5OSwgLTQ5LjYxMTksIC00OS42OTA5LCAtNDguOTI0MiwgLTUxLjQ5NTcsIC01NS42MjAyLCAtNTguNjUzNSwgLTYwLjUwMTIsIC02MS43MjY5LCAtNTkuMDg4MSwgLTU2Ljk5NTMsIC01Ni41NjI1LCAtNTMuMDc0NCwgLTM0LjUyODQsIC00Mi43NjEyLCAtNDkuNzMyMiwgLTU0LjIxMjIsIC01NC41NTcwLCAtNTUuNTEzMywgLTU1LjI1MDksIC01NS44MTM0LCAtNTcuMDcwMSwgLTU4LjQzMjQsIC01Mi44NjI5LCAtMjMuNDU3NywgLTMyLjg1MzksIC0zNy4yMzgwLCAtMzcuMzI3NSwgLTM3Ljc4MzksIC00MS41NjE3LCAtNDQuMTc0MiwgLTQ1LjkwNzUsIC00OC4xOTUwLCAtNTAuNTgwOSwgLTUxLjkzNTIsIC01NS40ODM3LCAtNTYuNTA0OSwgLTU3LjAyMTIsIC01OC4wNTMwLCAtNDEuMzA1MCwgLTQ2LjMzMzYsIC01MC4xOTM5LCAtNTMuNjg4OSwgLTU2LjAwMDcsIC0zMC44ODkxLCAtMTMuNDIwNiwgLTE3LjI0MjIsIC0yNS41MDU5LCAtMzAuMTQ1MCwgLTMyLjg4NTYsIC0zNS41MTY4LCAtMzYuMzU2NSwgLTM5LjAyNDYsIC0zOC42OTMyLCAtMzkuNTEyMCwgLTQwLjE0ODMsIC00MS4yNTAwLCAtNDMuMDI3NCwgLTQzLjAyNjEsIC00Mi45NDA0LCAtNDQuNzI3OCwgLTQzLjg2NjMsIC00My43MzYwLCAtNDYuNDAxMiwgLTQ1Ljk2MjQsIC00NC43ODExLCAtNDUuMTI0NiwgLTQ1Ljc1MDYsIC00NS4yNzI3LCAtNDQuMjYxNiwgLTQyLjI4MTAsIC00MS4xNTQ0LCAtNDMuMDQ1NywgLTQ0LjYzOTEsIC00Ny41NTkzLCAtNTAuMzE1OSwgLTUxLjY4MzEsIC01MS4xNzgyLCAtNTIuMjQwNiwgLTU0LjM4MDQsIC01NS4yNDQ5LCAtNTYuOTQzOSwgLTU2Ljg1ODMsIC01Ni43MDI3LCAtNTcuNzAzMywgLTU5LjMyNzQsIC01OC43ODM3LCAtNTcuNTAxMiwgLTU3LjQ5MTgsIC01OS4yOTQ0LCAtNjIuNDA5MCwgLTYyLjY3NDMsIC02My40ODEzLCAtNjQuODk1MiwgLTY0LjA3MzgsIC02Mi42MTYyLCAtNjUuNDE0MiwgLTQyLjMxNjAsIC0zOC4wODk1LCAtNTAuMzQ4NiwgLTU1LjM0MDIsIC01Ny4wNTM5LCAtNTcuNTQ1MywgLTYwLjIxNDIsIC01OS43ODQ5LCAtNjEuNzMzOSwgLTYxLjIyMjMsIC02MS4zOTAwLCAtNjEuNzU4MywgLTYzLjkzNDMsIC02NC4zMTYyLCAtNjMuNjU3NSwgLTY0LjAzMzUsIC0yOC40Mjc2LCAtMzYuNzc5MCwgLTQ2LjM4NTUsIC01Mi4zODYzLCAtNTAuNjQxMywgLTUxLjk1NTEsIC01MS42Mjc2LCAtNTMuMTMwMSwgLTUxLjUzMzgsIC01MC44MTA1LCAtNTYuMTk0NCwgLTU1LjAzODUsIC01Ny4wNzIyLCAtNTkuNzQ3NSwgLTU4LjQzMDksIC01OS45MjgzLCAtMjEuMjczNSwgLTEzLjQzODMsIC0xOC4yNDk5LCAtMjEuMjE4OSwgLTI2LjMxNTksIC0yOC45MTQwLCAtMzAuMjU4NSwgLTM0LjIxNTMsIC0zNy4yNzI5LCAtMzYuMTcyMywgLTM0LjE0NzgsIC0yNS4yODA2LCAtMjUuNDgwMCwgLTI5LjQzNDMsIC0zMS4xMzc4LCAtMzIuMzg3NywgLTM2LjA5NTcsIC0zNS44NjgwLCAtMzcuMTYwNywgLTM2LjAzMTQsIC0zOC41NjkyLCAtMzkuNzU4OSwgLTM5LjAwODYsIC0zOS45MjgwLCAtMzkuOTk2MSwgLTQwLjY0NTAsIC00MC4zMzg4LCAtNDEuMjE0MiwgLTQxLjU2NDcsIC00My4wMzgwLCAtNDQuMTgyMywgLTQ2LjgxNjksIC00Ny44MTI3LCAtNDguNjg3NiwgLTQ4LjUyODYsIC00OC45ODI3LCAtNDUuODMyMiwgLTM5LjEyNDMsIC0zOS45MzAzLCAtNDguNzQ4NCwgLTU0LjA2NDksIC01Ni4wNjUyLCAtNTYuMzYxNiwgLTU2LjU4NTIsIC01NS42ODIzLCAtNTguODI5MiwgLTYxLjE0NTIsIC01OS45NDA1LCAtNjIuNjQ2OCwgLTYzLjUzMDksIC02Mi43OTYwLCAtNjMuMDQ0NSwgLTY0LjUxMjMsIC0zNi45MDYwLCAtMzQuMjA3OCwgLTQ2LjczMzQsIC01MS45MDc3LCAtNTQuODM3MywgLTU2LjI2NTIsIC01Ny40MzIzLCAtNTYuNjQxMywgLTU3LjY2NjQsIC01Ny44Nzc0LCAtNTkuMDAzMSwgLTI5LjM4NjcsIC0yNS41ODMxLCAtMzcuMjg1MCwgLTM3LjA4OTMsIC0zNi45NjY5LCAtNDAuOTAxNywgLTQzLjQ5OTgsIC00NC4zODY4LCAtNDguMDMyMiwgLTQ4LjI1NjEsIC00OS44NjQwLCAtNTQuNzEwNCwgLTU2LjAwMDAsIC01Ni43Njc3LCAtNTkuMDAyMSwgLTQ4Ljc2OTIsIC00Mi4yMjI0LCAtNDguNzcxOSwgLTUyLjA4MjksIC01NC44MDQ4LCAtNTcuNDEwOCwgLTE2LjY5OTksIC0xNS40MjE5LCAtMjEuOTYxMSwgLTMwLjkyOTAsIC0zMi4zNTk2LCAtMzIuNjM2NywgLTM3LjE0NjYsIC0zOC42ODEwLCAtMzcuODUxMSwgLTM4LjgyNTQsIC00MC42NTIwLCAtMzguMjYyNywgLTQzLjgxNjMsIC00NS4yNTkzLCAtNDEuODA2NywgLTQxLjY5OTAsIC00MS4xNDE4LCAtNDAuNzI1MSwgLTM5LjAzODksIC00MC41NjkzLCAtNDIuMTE2NCwgLTQzLjAyNjAsIC00My42OTI2LCAtNDUuNTY0NSwgLTQ1Ljk0NDcsIC00NS4zNDU1LCAtNDcuOTc3OSwgLTQ3LjI1NTUsIC00OS4xMTg4LCAtNDguOTYxMCwgLTQ5LjcxOTgsIC01MC43ODA2LCAtNTAuNTY3MywgLTUxLjQ0NjMsIC00OS4zNzU3LCAtNDkuMjU5NCwgLTUyLjM4NjUsIC01NC4yNTE1LCAtNTYuODE1MiwgLTU3Ljc4ODIsIC01Ni42MDQ4LCAtNTYuODMyNywgLTU3LjYxODMsIC01NS4yMDA0LCAtNTkuNTEwNiwgLTYyLjUzMjIsIC02My40Nzg3LCAtNjQuNjU4MCwgLTY0Ljk4MTgsIC02My4wNzc0LCAtNjIuOTAzNiwgLTYzLjIxNjcsIC02My4wNTM0LCAtMzQuMTEyMSwgLTM0Ljg5MTMsIC00Ni40OTY2LCAtNTEuNTU3MywgLTUyLjczMDEsIC01My41MzQyLCAtNTUuMzEyMywgLTU1LjQ3NDgsIC01Ni44NjM2LCAtNTcuMTI0OCwgLTU3LjYxODEsIC01OC44MzY1LCAtNjAuNDUxNCwgLTYwLjYxNDMsIC02MC4yNjM2LCAtMzQuMjEyNywgLTMwLjcxMTQsIC00Mi4zODIwLCAtNDguMjMzOCwgLTQ5Ljg1MDUsIC01MC41MzczLCAtNTEuNDU0MSwgLTU0LjcwODksIC01Mi44NTA4LCAtNTUuMzYwMSwgLTU2LjYxOTMsIC01Ni4wNTA0LCAtNTMuOTE1OSwgLTU1Ljc2NTMsIC01NS4xMzY5LCAtNTYuNzQ2NCwgLTQxLjEyMDgsIC0xMy43MTY2LCAtMTAuNDExNCwgLTE4LjE4OTAsIC0yMy43NDYwLCAtMjYuODExMSwgLTI3LjE1MTksIC0zMC44NzE2LCAtMzYuNTU5NSwgLTM0LjU5MjIsIC0zNS4xMDMwLCAtMjYuNDMxOCwgLTI1LjE5MTAsIC0yNy4wMTg1LCAtMzAuNjY0OCwgLTMxLjYzOTcsIC0zMi4zODk1LCAtMzMuNDY5MSwgLTMyLjMxNjAsIC0zMC43Nzg5LCAtMzEuMDQ1NSwgLTMyLjk0NDgsIC0zNi4zMDY4LCAtMzguNzU0NSwgLTM5LjgyMDcsIC0zOS40Njg4LCAtMzguODMwMiwgLTM4LjQ1OTksIC00MC4wMTEyLCAtNDEuNjI0NCwgLTQ0LjAxMTQsIC00NS4yNDE4LCAtNDYuMzcyMywgLTQ1LjY3NzAsIC00NC42NjA0LCAtNDMuNzI5MiwgLTQyLjQwMzcsIC00MS42OTE1LCAtMzcuNjQ5NCwgLTQ0LjQ1MjMsIC00OS44NTA3LCAtNTEuNjAwNywgLTQ5LjcxNTIsIC00OS45MDI1LCAtNDguOTIzMSwgLTUxLjA5MTQsIC01NS4xMDUyLCAtNTguOTMyMCwgLTYwLjEwNjAsIC02MS44MDAzLCAtNTguOTQ1OSwgLTU3LjE3NjYsIC01Ni42Mjg2LCAtNDguMjUzMiwgLTM0Ljc3NzEsIC00NS4wNDU1LCAtNTAuMDUzMiwgLTU0LjAyMDgsIC01NS44MTUyLCAtNTUuMDc2MCwgLTU1LjA4NTAsIC01Ni4wNTMwLCAtNTcuNzYyNywgLTU4LjU4NDcsIC01Mi44MDA5LCAtMjMuNDYwOCwgLTMyLjg0NTMsIC0zNy4yMjI5LCAtMzcuMzIzMywgLTM3Ljc5MDUsIC00MS41NDAwLCAtNDQuMTczMCwgLTQ1Ljg5NDEsIC00OC4xODcyLCAtNTAuNTkwNCwgLTUxLjk2NDksIC01NS41OTYzLCAtNTYuNTQ4NCwgLTU2Ljk3NDIsIC01OC4wNzkzLCAtNDEuMzAwOSwgLTQ2LjI3ODMsIC01MC4yMzAxLCAtNTMuNjIxMywgLTU1LjkzMDUsIC0yNS43MDA4LCAtMTMuMDY2MywgLTE4LjYzMzksIC0yNi41MDg0LCAtMzAuNjM4MiwgLTMzLjQ5MjAsIC0zNi4wMDM4LCAtMzYuNjAwNywgLTM5LjMzODAsIC0zOC4zNjE2LCAtMzkuODkxMCwgLTQwLjIxODAsIC00MS4yMzA1LCAtNDMuMTczMCwgLTQyLjg3NjUsIC00My4zODc4LCAtNDQuNjYyNiwgLTQzLjc1NDUsIC00My44MTMwLCAtNDcuMDk5MSwgLTQ1LjU3NDgsIC00NS4wNzMyLCAtNDcuMDU2MywgLTQ0LjkyNzMsIC00NC4wNDY1LCAtNDQuNzQzOCwgLTQzLjA2MzQsIC00MS42NTUwLCAtNDMuNjQwMSwgLTQ1LjI4NTAsIC00Ny4wMjA2LCAtNTEuMjU0NCwgLTUyLjE2MzEsIC01MS43MjQ0LCAtNTMuMTU3MCwgLTUzLjY0MzAsIC01NS4xNjQ5LCAtNTcuODM4MiwgLTU3LjQzNTcsIC01Ni40ODA3LCAtNTcuNTg3NCwgLTU4Ljk4MjgsIC01OS4xNTEyLCAtNTguODE5NCwgLTU2LjQ2NzYsIC02MC40NTcyLCAtNjIuODQ0NSwgLTYzLjIwMjIsIC02My44NTAyLCAtNjQuODcxNywgLTYzLjM0OTQsIC02My4wMjg5LCAtNjYuNzYyNywgLTM5LjUxMjUsIC0zOS44NjA4LCAtNTAuNjgzMCwgLTU1LjM3MzIsIC01Ny42MzI0LCAtNTcuODE3MSwgLTU5Ljg0MTAsIC01OS4xMTI2LCAtNjEuMzY5MCwgLTYxLjA4ODcsIC02MS44ODI3LCAtNjIuNTc5MCwgLTYzLjM5NDEsIC02NS4wMTIzLCAtNjQuNDA0NCwgLTU2LjQyNTAsIC0yOC42NTMwLCAtMzguMDIzOCwgLTQ2LjY5NTMsIC01MS42NDI0LCAtNDkuNDU4NSwgLTUwLjEwMzgsIC01MC4yNDk1LCAtNTEuNzc1NSwgLTUzLjQxMDIsIC01My41OTI2LCAtNTkuNzE3MCwgLTU4LjA4NjEsIC01OC42MDY4LCAtNTguNjk2OCwgLTU2LjEwOTMsIC01Ni4wNzU1LCAtMTkuMDc5MCwgLTEzLjQ2NzYsIC0xOS4wMzQ3LCAtMjEuNTI1MywgLTI3LjE2MDgsIC0yOS40Njc0LCAtMzAuNDAyMSwgLTM0LjkwNTgsIC0zNy41OTg5LCAtMzYuMjM5NiwgLTMyLjQ4OTYsIC0yNS4xOTg2LCAtMjUuNzY0MywgLTI5Ljg1ODIsIC0zMS4yODAyLCAtMzIuNDc4NCwgLTM2LjM2MjAsIC0zNS40NTYxLCAtMzcuNzA1NiwgLTM2LjU1OTcsIC0zOC43NjY1LCAtNDAuMDAxNSwgLTM5LjQ1MzYsIC0zOS4xODUwLCAtMzkuNjg4OSwgLTQwLjk0MjMsIC0zOS4yNTYyLCAtNDEuMDMyNywgLTQxLjQ1OTcsIC00My4wNTM1LCAtNDQuMDI0NywgLTQ3LjY0MjQsIC00OC4zMzc5LCAtNDkuNTMxNiwgLTQ4Ljc1NDAsIC00OC41Njc4LCAtNDUuODE5MCwgLTM5LjM1MzQsIC00MC44OTA5LCAtNDkuMjg2MywgLTUzLjkzMjksIC01Ni43MTI2LCAtNTYuMDc3MSwgLTU2LjgyNzUsIC01NS4zODUzLCAtNTkuMjkzNiwgLTYxLjU5NjMsIC02MC4xMzQ1LCAtNjIuNzU1MCwgLTYzLjY1MjQsIC02MS44ODk2LCAtNjIuNTA4NCwgLTY0LjU0MjUsIC0zNS43MzQ0LCAtMzQuNjYzNSwgLTQ3LjQyNDEsIC01Mi40NTY0LCAtNTUuMjQwMiwgLTU2LjM5NzksIC01Ny41MTMxLCAtNTYuNjYxMCwgLTU3LjY3NzQsIC01OC4wMTQwLCAtNTguNzY4MSwgLTI5LjM3OTgsIC0yNS41Nzc3LCAtMzcuMzYxMywgLTM3LjA2MjYsIC0zNi45NzkyLCAtNDAuOTA5NSwgLTQzLjQ5NjMsIC00NC4zOTI2LCAtNDguMDQ3NywgLTQ4LjI4MDYsIC00OS44NzIyLCAtNTQuNzIwMSwgLTU2LjAzODgsIC01Ni43ODYxLCAtNTkuMDI3NSwgLTQ4Ljc4OTksIC00Mi4yMTk0LCAtNDguODU1NywgLTUyLjExOTMsIC01NC44MzM4LCAtNTYuNzU5NiwgLTE1LjcyNjQsIC0xNS43OTAxLCAtMjIuODYxNywgLTMxLjQzNjgsIC0zMi4yMzMwLCAtMzIuNzY3OSwgLTM3LjY5ODgsIC0zOC43MjM4LCAtMzcuODAwOSwgLTM4Ljg0NzgsIC00MC42MDU2LCAtMzguNDYwMSwgLTQ0LjAzMjYsIC00NS40MzYxLCAtNDEuNTY0NCwgLTQxLjYzMjksIC00MS4xODc5LCAtNDAuNjU1NSwgLTM5LjE3OTQsIC00MC44MDEyLCAtNDIuNDcxMCwgLTQzLjY4MjEsIC00Mi45MTAwLCAtNDQuNzE1NywgLTQ0LjcxNzgsIC00NS4zNDM5LCAtNDYuMjA3OSwgLTQ2Ljg5NzksIC00Ni44NDAyLCAtNDguNjY1OCwgLTUwLjgxMDMsIC01Mi41Nzg5LCAtNTIuMDk1NSwgLTUxLjYyMDEsIC00OS45MDQ0LCAtNDkuNDg1OSwgLTUzLjAyNzUsIC01NS4zOTM0LCAtNTcuOTI2NywgLTU3Ljk3NzMsIC01Ny4xNzU0LCAtNTYuOTU0OCwgLTU3LjU5NzYsIC01NS41MzczLCAtNTkuMjExOSwgLTYzLjEyNTksIC02My40NzIxLCAtNjUuNTE1OSwgLTY1LjcyMjgsIC02My4wNTk3LCAtNjIuNTMwNCwgLTYzLjM0MTksIC01OS43NDAzLCAtMzMuMjY1MSwgLTM3LjAzNTQsIC00Ni42MjMzLCAtNTEuNzI5MCwgLTUzLjA1NzQsIC01My40NzU1LCAtNTUuNDExMywgLTU1LjU1NjgsIC01Ny4xMzIxLCAtNTcuMjg0MywgLTU3LjU5MDgsIC01OS4wMzUwLCAtNjAuNjYyMywgLTYxLjAxMTYsIC02MC4yNDQ3LCAtMzEuNzQ2MiwgLTMyLjI3MDMsIC00My44MTU4LCAtNTAuNzEyMiwgLTUxLjM2NjgsIC01MS4zNDYzLCAtNTEuMTU0NSwgLTUzLjA4MTQsIC01MC45MDc0LCAtNTEuMzY5MywgLTU0Ljc0MjUsIC01NS40ODkxLCAtNTUuNzg2MiwgLTU5LjkyMTEsIC01Ny44OTUzLCAtNTguNTA4OCwgLTM0LjMzMzgsIC0xMi44ODk3LCAtMTAuODc4NCwgLTE5LjA0MzksIC0yMy44NTA5LCAtMjcuMjYyMiwgLTI3LjEwNjUsIC0zMS44ODEzLCAtMzYuNjE3MSwgLTM0LjQ1ODcsIC0zNS4zODkxLCAtMjUuNTk4OCwgLTI1LjE0MDMsIC0yNy42MTEyLCAtMzAuNTM1MywgLTMxLjg5ODcsIC0zMy4yNDQ1LCAtMzIuOTE4MywgLTMyLjQxMzEsIC0zMC41MTIwLCAtMzEuMTIxOCwgLTMzLjM4OTUsIC0zNi41MjU0LCAtMzguMzY2MywgLTM5Ljg2NzgsIC0zOS4yNjA1LCAtMzkuMjg4MSwgLTM4LjY1MzksIC0zOS45NzMzLCAtNDIuMjA4MywgLTQ0LjI1MTUsIC00NS42MTkxLCAtNDYuNzkxNSwgLTQ1LjU5NDAsIC00NC43MjU1LCAtNDMuNDg0OCwgLTQyLjIzODNdLFxuICAgICAgICBnYWluOiAwLFxuICAgICAgfSwge1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tbWl4L3BlcmNzX2Jhc3NfbW9kZV8yLndhdicsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiAwLjUgKiA2MCAvIDEyMixcbiAgICAgICAgbGVuZ3RoOiA4LFxuICAgICAgICBpbnRlbnNpdHk6IFstODYuNzk4NywgLTg2LjUyOTQsIC04Ny4wODk0LCAtNDIuMDk0MCwgLTE4LjYyMDIsIC0xOC4wMDU5LCAtMTkuMDc1MSwgLTE2LjkxOTcsIC0xNS44NjkxLCAtMTQuMDIwMSwgLTE1LjM3ODUsIC0yMC41MDI4LCAtMTguMjYxNSwgLTE2Ljk5MTQsIC0xNy43MzYyLCAtMjIuMTYwNiwgLTIyLjc4MTUsIC0yMi4xNjY0LCAtMjQuNDMzMCwgLTI1Ljg4MzgsIC0yMy40NjAwLCAtMjMuOTM2MiwgLTIwLjk4NzMsIC0xOS42ODAyLCAtMjEuMzIyOCwgLTIzLjQzNDcsIC0yNC45NDk5LCAtMjMuMTA4NiwgLTIzLjI4NjEsIC0yMi43OTY2LCAtMjMuNTczMiwgLTIyLjk3MzYsIC0yNC40MjQ2LCAtMjUuMTQ2NSwgLTI1Ljg0NzIsIC0yNi4wNDYzLCAtMjYuNjE3MiwgLTI0LjI0NDUsIC0yMy44NjIyLCAtMjAuMjgyOCwgLTIyLjk0MTcsIC0yMi42MTE4LCAtMjYuNDk0MSwgLTI3LjQwOTEsIC0yMy42MzQwLCAtMjIuMjQ3OSwgLTI0LjEyNDIsIC0yNS41NzE5LCAtMjYuODY5NywgLTI5LjY0MDMsIC0zMC42NDQxLCAtMzIuMTMxMCwgLTMwLjI2NDgsIC0yOS45MDAwLCAtMjAuMjg3MSwgLTIwLjEzNjAsIC0yMy4zMjMyLCAtMjYuMDMzNywgLTI5LjgwMjksIC0yOS4wODkxLCAtMjguODE5OSwgLTI4LjEyNjEsIC0yNy43ODA2LCAtMzEuNTk2NywgLTI4LjIyNjUsIC0zMC40OTM5LCAtMzAuNTk0NywgLTI4LjI2MDEsIC0yOC4yMzIxLCAtMzEuMzAyOCwgLTI5LjE1ODIsIC0zMS4wNTYwLCAtMjkuMDkxNywgLTI0LjQ3NzAsIC0yNy42ODc2LCAtMzMuMTU0MCwgLTMyLjcxMDUsIC0zNy45OTk2LCAtMzYuMjA0MiwgLTM1LjE1MjAsIC0zNC42NTM1LCAtMzguMjYyNCwgLTM4LjI0OTYsIC00MS45MDUzLCAtMzcuNDkzMiwgLTM1LjUzMTEsIC0yNy41MDQ4LCAtMzMuOTc5NiwgLTM3Ljg3NjIsIC0zNS45NzY5LCAtNDEuNzc5NSwgLTQxLjkxNjEsIC0zNi4zNTExLCAtMzMuNjYwNSwgLTIwLjM0ODMsIC0zMi43MjQxLCAtNDIuODIzNywgLTQ2LjI4ODMsIC00My41ODQ2LCAtNDQuMDQxNCwgLTQ2LjI1ODYsIC00OS4wMDI5LCAtNDIuNDc2MCwgLTQ2LjM0NzAsIC00Ny43ODEyLCAtMzcuNDU3NSwgLTQ0LjY2MTgsIC01My45MjUzLCAtNTUuMDUyNCwgLTU4LjM4NzUsIC0zNy44MDE4LCAtNDIuNzY4MiwgLTU0Ljg3MjksIC02MS42NTU5LCAtNjAuMTYwOSwgLTIxLjI2NjAsIC0yNS40NjYyLCAtNTIuMzQ3MCwgLTU1LjE0MDAsIC01OC43NjU4LCAtMzQuNTg0NCwgLTI2LjcwODksIC01NS4xNjIzLCAtNTguNjk0OCwgLTU3LjI3NDIsIC01Ny42ODI5LCAtMzMuNDUwNiwgLTQyLjI2ODQsIC01Ni45MDg2LCAtNTkuNDM1NSwgLTU5LjA4NTcsIC0zOC40NjcwLCAtNDUuMjQ0OCwgLTU3LjE4NjcsIC01Mi41MDQ0LCAtNTcuNjczMSwgLTI5LjE1ODIsIC0yNS42OTE2LCAtNTQuMTk5OSwgLTU5LjYwMTcsIC02MS42MTg5LCAtNTQuOTM2OSwgLTM4LjU0MzMsIC01MC42MDczLCAtNjQuMDgwNiwgLTYzLjQ3ODEsIC02NS45NTIxLCAtMzUuMzYyNSwgLTQzLjMyNDQsIC01NS4xNjIwLCAtNTcuNTczOCwgLTU5LjcyMTMsIC00NS4wNjk2LCAtNDYuODgyNiwgLTY1Ljk0MzksIC02Ny4zNTU4LCAtNjUuMjY3OCwgLTU5LjA4NDksIC00Ni40MTE4LCAtNTcuMzY0MCwgLTczLjUwMTIsIC03My4xNTM5LCAtNzMuOTQ0NCwgLTUwLjc5MjAsIC02MS4zNTkzLCAtNzUuODAzMywgLTc1LjgwMTksIC03Ny4zOTg3LCAtNDIuMTQ3MiwgLTQ2Ljc0NDYsIC02OC45MjEzLCAtNzguMTcwMCwgLTc5LjYzMTUsIC01Ni40MjkwLCAtNTEuODU4NCwgLTY3LjcyNzEsIC03Ny43MDM4LCAtNzcuNzE4MCwgLTcyLjAxODMsIC00Ny43OTU5LCAtNTguNDQzNCwgLTczLjMwNTIsIC03Ny40NTg3LCAtODAuNDMxNiwgLTU0Ljc1NDgsIC02NC4xMDM0LCAtODIuMzM0NywgLTgzLjg5MjgsIC04NC43NjE4LCAtNjMuMzk2MywgLTU4Ljc5MjgsIC03MC45MTQ1LCAtODQuNDg0NSwgLTgzLjYzOTIsIC03Ni43NzgzLCAtNjEuODk0MywgLTc1LjE1NTEsIC04Mi4zNzc2LCAtODMuNDE2NSwgLTg0Ljk0NTUsIC01My4wODM0LCAtNjMuODMwOSwgLTgwLjk5ODMsIC04NC4wMTI3LCAtODQuODM5MCwgLTYxLjkyMzUsIC02NS42NzQ5LCAtODAuNjE5OSwgLTg0Ljc0OTQsIC04NS4xMzk3LCAtNzAuNjUzNywgLTYwLjI1MjYsIC03Mi4yMTQxLCAtODIuODIwMywgLTg1LjEzMTcsIC04Ni4xNDY3LCAtNjUuNDEwNCwgLTc5LjQyODgsIC04Ni4yMzQ5LCAtODYuMjA5NiwgLTg2LjkxOTgsIC02OS42NjE1LCAtNzEuMTg5MSwgLTgyLjgzNTAsIC04Ni4wMDcwLCAtODYuMTY4OCwgLTc4LjY3NDQsIC03My43NjAxLCAtODUuMDk3NCwgLTg2LjIwODMsIC04Ni4wMzU1LCAtODQuOTQ2NywgLTY0LjI0NjgsIC03OS4wOTcyLCAtODYuMTUwMiwgLTg2LjI5MjAsIC04Ni4xNTA0LCAtNjkuOTA2NiwgLTc4LjgxMDgsIC04Ni4yNDY1LCAtODYuNDA4NSwgLTg2LjU1NDIsIC03NC43NzU4LCAtNzIuOTIzOCwgLTgzLjE3NjYsIC04Ni4yNzI2LCAtODYuNTg2OSwgLTg1Ljg0NTksIC03Ni43NTQwLCAtODYuMjI2OSwgLTg2LjMyOTUsIC04Ni42NTUyLCAtODYuODk5MSwgLTc3LjYwOTcsIC04MS45MzE3LCAtODUuOTIzOSwgLTg2Ljc5NzQsIC04Ni4zMzA3LCAtODIuODI1NCwgLTgzLjg2MDIsIC04Ni44NTM2LCAtODYuNjg3MSwgLTg2Ljc0MTgsIC0zNC4wMzEwLCAtMjQuNTI3NiwgLTU0Ljg1MjAsIC02Ni40MjUzLCAtNjguODY3MSwgLTY5Ljg0NTEsIC03Mi44MzgwLCAtNzYuMTM4NCwgLTc3LjM2ODcsIC03OC44NjU3LCAtODIuNjUwMywgLTM0Ljg1OTIsIC0zOC4xNDI1LCAtMzkuNjE5NiwgLTQwLjE2MTUsIC00MS42NjI0LCAtNDEuNzQ0NCwgLTQyLjYzOTksIC00Ni41ODM0LCAtNDguMjE3OSwgLTUyLjAxNzQsIC00My4wNzYwLCAtMjAuODU3NSwgLTQ2Ljg1ODksIC02MC45NjAwLCAtNjEuMTExMCwgLTY1LjI4MDMsIC0yOS4wNjAzLCAtMzguNjU4OCwgLTQxLjM4NDIsIC00Mi4xNDY4LCAtNDIuODMwNSwgLTM5LjI5NTMsIC0zOS43NjMzLCAtNDYuMzU0OSwgLTQ4LjM5MDQsIC01MC4zMTIwLCAtNDkuNzg0MSwgLTQxLjQyODcsIC01My4wNTM5LCAtNTcuODM2MSwgLTU5Ljc5MjUsIC00Ni40MzAxLCAtMjYuNTA0MywgLTQxLjEzMjAsIC00My4zODQ1LCAtNDMuOTkxOCwgLTQ0LjU5MTUsIC0zOC42ODAyLCAtNDQuNDM2MSwgLTQ4LjA0MTAsIC00OS4yODM5LCAtNTAuODIxOSwgLTQ0Ljg0NzUsIC0zOC43OTI1LCAtNTMuMDkyOSwgLTU4LjIwODMsIC01OC42OTMwLCAtNjAuNTc0MiwgLTQzLjUxNzMsIC02Mi40NzA1LCAtNjYuODI5NSwgLTY4LjY4OTQsIC03MC44NzE4LCAtMjguMjY2NiwgLTQxLjU0OTYsIC02NS4zOTQ5LCAtNjQuNzk1OSwgLTY4LjIxOTIsIC0zMS41Njc3LCAtMzAuOTU1MSwgLTQ5LjQ4ODYsIC01NC43Njc2LCAtNTkuMTM4NSwgLTU4LjcxMjMsIC00Mi43MjcyLCAtNjMuMDI1MywgLTY2LjQyODcsIC02Ny44ODIwLCAtNjkuNDczOSwgLTUzLjEwOTgsIC02NS40NjkwLCAtNzMuMTA2OCwgLTcyLjczMjMsIC03Ni4xMjY4LCAtNTIuNjExNCwgLTU1LjMwODYsIC03MS45MDExLCAtNzUuODgyNCwgLTc3LjY2NzAsIC02OS44ODg1LCAtNTUuODQ2OSwgLTgwLjI2ODUsIC04My4yMDU4LCAtODMuNzU3MiwgLTgwLjI1MDQsIC00My4wMTc3LCAtNjIuNzY2MCwgLTc2Ljg5ODUsIC03OS4zNzU3LCAtODAuODU5MiwgLTQ0LjE2MTgsIC01MS43Nzc0LCAtNzcuNDcwMywgLTc3Ljc1MjksIC04MS40NTcwLCAtNjMuNTIxMSwgLTU2Ljg3OTcsIC04MC4wNTc3LCAtODQuNzIwNCwgLTg1LjExNjQsIC04MC44ODExLCAtNjQuMTU2NiwgLTgwLjQ0MDEsIC04NC41NDMwLCAtODMuOTMyNiwgLTg2LjI0MjIsIC02MS4zMTUwLCAtNzEuMDI0MSwgLTgyLjM3NjUsIC04NC41NDQ2LCAtODUuMTIxNSwgLTcyLjczNTYsIC02OS4zODMwLCAtODUuMzg2OSwgLTg1LjcxMDAsIC04Ni40ODUwLCAtNzIuMjIwMiwgLTU1LjkxMzcsIC03OS40NTk2LCAtODQuNTQ0OCwgLTg1LjMwODQsIC04NS4zNjE2LCAtNTQuNTI1OSwgLTY4Ljk2MTAsIC04NC43OTE5LCAtODQuNTgyOSwgLTg2LjI3MzQsIC02OS41NDQxLCAtNzEuOTc1MCwgLTg2LjE4NjksIC04Ni41OTg5LCAtODYuNjI5NywgLTgwLjg0NTcsIC03Ni4zOTA4LCAtODUuOTY5OCwgLTg2LjE2MjksIC04Ni44MzQzLCAtODUuOTY1MCwgLTcxLjUxMjIsIC04My43ODQ4LCAtODUuOTgxNywgLTg2LjI3MzIsIC04Ni4zOTU1LCAtNzguNDIxMiwgLTgyLjcyOTgsIC04Ni4xMDI1LCAtODYuMTg2MCwgLTg2LjkwODUsIC03NC45MDk0LCAtNjkuNDA3NiwgLTg1Ljg1OTMsIC04Ni42NjUzLCAtODYuNzQ1NywgLTg0LjMzNTEsIC02Ni4wMjMzLCAtODIuODYyNiwgLTg2LjI2ODYsIC04Ni42MzQ2LCAtMzIuNTg1NSwgLTIxLjQxOTYsIC00OC40Njc5LCAtNjUuMjI3MiwgLTY4LjIwMDEsIC03Mi4wODY0LCAtNzMuNTgzMCwgLTc2LjUzNjgsIC03Ny4zNzI2LCAtODAuODkxMCwgLTgyLjMzMDcsIC0zOC44NjI4LCAtNDEuMDI0NiwgLTUyLjYwOTMsIC02NC43NzMxLCAtNjYuNjY5MCwgLTQ0LjUyNjAsIC0zOC43MzY0LCAtNDguNjk4OCwgLTYyLjQ1MzksIC02NS4xNDk2LCAtNDAuNzQ0NywgLTE3LjcyNTgsIC0zOS44NDc0LCAtNjMuNTM4MCwgLTY3LjM5ODEsIC03MC4yMDA0LCAtMjMuOTg5OCwgLTM4LjE5MjQsIC02NC42NjIwLCAtNzAuMjczMiwgLTY4LjY2ODIsIC0zOS4xODU2LCAtMzYuNTU5NywgLTQ4Ljg3MzMsIC02My41MTAzLCAtNjAuNjE5OSwgLTUwLjMwNDYsIC0zNy43NzM5LCAtNTQuMDgxNywgLTYyLjA1MzksIC02NC4xMjE1LCAtNjUuNjQ0MiwgLTIxLjQ2NTQsIC00MC45Njc2LCAtNjQuNTg4MCwgLTYzLjQ1NjMsIC02OS4yODQxLCAtNDIuNDQxOCwgLTQ0LjY3NjYsIC01Ny44OTk3LCAtNjIuOTc5OSwgLTYzLjkxNzYsIC00NC40Njg4LCAtMzUuODM3MiwgLTQ5LjcwNzQsIC02NC44NjA2LCAtNjYuMzc3NCwgLTY1LjYwMTYsIC0zOS42OTMwLCAtNTguMjI5OCwgLTc0LjgzMzAsIC03OC4zNDI0LCAtNzguNjAxOCwgLTIzLjg3NzksIC0zNC45ODc2LCAtNjEuMzI4OCwgLTY3LjA1MjcsIC02Ny45MTU0LCAtMjcuMzQzMCwgLTI1LjY2ODQsIC01NS4zNTgwLCAtNjMuMzYyMCwgLTY2LjEzMzEsIC01My40NDEwLCAtMzUuMDQ2NywgLTQ1LjkzMDgsIC02MS40MTQ0LCAtNjYuMjE3NiwgLTY4Ljg1MjYsIC00MC4zOTAzLCAtNDMuNTk0NCwgLTU3LjE0NjUsIC02Ni43MDkyLCAtNjcuMTkzMSwgLTI1LjE4MTEsIC0yOS4yNTg0LCAtNTkuMTMzNCwgLTY1LjU3MDYsIC02OS43MDI5LCAtNjQuOTg1NSwgLTUyLjkwMTMsIC03MC42NzIyLCAtNzguMjQyMiwgLTgxLjUwMzAsIC03Ny4yMDc5LCAtMzMuNjMwMSwgLTM5LjAyMDMsIC00MC4wMDkzLCAtNDAuNjIyMCwgLTQxLjMyNTMsIC0zOC42OTk2LCAtNDIuODc4OCwgLTQ3LjE5NzYsIC00OS4zOTg3LCAtNTEuNzQzNywgLTUxLjc3NzYsIC00OC42NzI1LCAtNTYuODg1NSwgLTYwLjYwNzEsIC02Mi45Nzc4LCAtNjQuMDgxMCwgLTM2LjI1MDYsIC0zOS43NDE1LCAtNDEuNDQ5NywgLTQyLjEwOTksIC00Mi45NDAxLCAtMzcuOTc4NiwgLTQ0LjEwNTIsIC00Ni44OTQwLCAtNDguNjY0MCwgLTUwLjU1NjAsIC01Mi4zMjEwLCAtNTQuMTY0OSwgLTU2LjIzODIsIC01OC4xNTExLCAtNjAuMTE5NSwgLTYxLjI3OTUsIC0zNi40OTAwLCAtNDAuMjg3NiwgLTQyLjg0MTMsIC00My41NTQxLCAtNDQuMzI1OSwgLTQ0LjM2NjAsIC00NS45MTQyLCAtNDcuMTE5MSwgLTQ4LjY4NzIsIC01MC4zNzQ3LCAtNDYuMDA5MiwgLTM3LjM5NzcsIC00NC4wNTQ5LCAtNDQuNTYxNCwgLTQ1LjY0NzcsIC00Ni42MDYzLCAtNDcuMzE0NSwgLTQ4LjM4MjcsIC00OS40NTQyLCAtNTAuOTI4OSwgLTUyLjU2MjUsIC0zNy4zNjkzLCAtNDIuNzM3MywgLTQ2Ljg1MjcsIC00OC4xNzk0LCAtNDkuOTQyNiwgLTUxLjQ3ODcsIC01Mi45MDUwLCAtNTQuMzE4MSwgLTU1LjUwNzEsIC01Ni44Nzg4LCAtNDguNTMzMSwgLTM4LjY5ODYsIC00NS41MTc5LCAtNTIuNjc1OSwgLTU4LjAwNzIsIC02MC45NTMwLCAtMjMuNTA3MiwgLTM3LjkyNTgsIC02Mi41NjM1LCAtNjMuMjExNCwgLTU5Ljk4NTgsIC01Ny4xMDEzLCAtNTEuNDE4NCwgLTQ3LjY4NzgsIC00OS4yMzA3LCAtNDQuNzY5MywgLTQzLjA4OTAsIC00MC4wNTAwLCAtNDUuMTY4MSwgLTQzLjkyNjgsIC00NC44NDY0LCAtNDMuMzI4MSwgLTM2LjkwOTIsIC0zNy42NjE4LCAtMzguNjAyMywgLTM5LjMwNDYsIC0zOC44NDg4LCAtMjMuOTIzNywgLTI4LjY5NjQsIC0zNC4wMTE4LCAtMzQuMDQ5MiwgLTM2LjQyNDgsIC0zNC40NTg1LCAtMzAuMTgyMywgLTM4LjgwMTEsIC0zOC41MDY2LCAtMzQuMjUxOCwgLTMwLjU2OTgsIC0yOS45OTc0LCAtMjguNzUyNCwgLTMwLjEyNjksIC0yOS4zMTAzLCAtMjcuOTA3NywgLTI4LjM2NDIsIC0yOC45OTU0LCAtMjkuNzYxMywgLTI5LjA3NDMsIC0yNy43ODc1LCAtMjguMzY4NywgLTI3LjEwNDYsIC0zMS4wNTAxLCAtMzQuMDQ0MCwgLTM1LjY1MDgsIC0zMi42NjU3LCAtMzEuNzk1MywgLTI5Ljk5ODgsIC0yNC44MTg5LCAtMjUuMjE2MCwgLTI0Ljc1ODcsIC0yNC4xNjI4LCAtMjYuOTAxMiwgLTI1LjQxNTYsIC0yNi43OTI3LCAtMjIuMTc3MywgLTI0LjEzMzgsIC0yNS43MjUzLCAtMjYuMTA5MSwgLTIzLjgzNDgsIC0xNi40NDAzLCAtMTguNDY4NywgLTIxLjM4MTQsIC0yNC45NTA4LCAtMTkuOTU0MCwgLTIzLjgwNTYsIC0yNy40OTE0LCAtMjIuMDk4NSwgLTI0LjAyOTIsIC0yNS45OTI3LCAtMjQuODEwOCwgLTIzLjM0NzMsIC0yNC42NDIyLCAtMjguNDkwOCwgLTIzLjIwNDgsIC0yMy45Njc3LCAtMjIuNDU1NywgLTE5LjUwNzYsIC0xNi43NjI3LCAtMTYuNDI0MiwgLTIxLjc0MjEsIC0yMC44NDE0XSxcbiAgICAgICAgZ2FpbjogMCxcbiAgICAgIH0sIF0sXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2Jhc3MgZHJ1bScsXG4gICAgICBsYXllcnM6IFt7XG4gICAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jby1taXgva2lja190b21fbW9kZV8xLndhdicsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiAwLjUgKiA2MCAvIDEyMixcbiAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICBpbnRlbnNpdHk6IFstODUuOTE2MiwgLTg2LjM1MjQsIC04NS45NzI3LCAtMzkuMDE4OSwgLTIyLjgyMDUsIC0zMi4yNDg2LCAtMzIuNTA3MiwgLTMzLjc4MzAsIC0zNy43MDY1LCAtNDguMDE0MSwgLTQ3LjA5ODksIC00Mi4yMDA0LCAtNDEuOTkxOSwgLTQ0LjM5MjMsIC00OC41NjE5LCAtNTAuOTg2NCwgLTUwLjI2ODYsIC01MC40MTIyLCAtNTIuMDA5NCwgLTU0LjIxMjgsIC01NS43NjY4LCAtNTYuNjY3MiwgLTU3Ljc5NzQsIC01OS40MDUyLCAtNjEuMjQ3NCwgLTYyLjg5MTQsIC02NC45MzA0LCAtNjYuODMzMSwgLTY4LjUyMjQsIC03MC4zMjA3LCAtNzIuNTY3NSwgLTg1LjAxODcsIC04Ni40MDU5LCAtODYuMDgzNSwgLTg2LjYxNTMsIC0zMC4zOTA0LCAtMjMuOTk4NCwgLTMzLjk4NjksIC0zMi42OTU0LCAtMzQuMzY1MywgLTM5LjI3NTIsIC01MS4yMzUwLCAtNDUuMjA4OSwgLTQxLjg4OTMsIC00Mi4zNjg0LCAtNDUuMjc2MywgLTQ5LjUxMzEsIC01MC45MTc3LCAtNTAuMTYyNywgLTUwLjY2NzEsIC01Mi41MDUwLCAtMjMuNzA4MCwgLTIyLjM3NDEsIC0yNS4zNDE4LCAtMzAuMDk0OSwgLTMzLjkxMzAsIC0zNi4yMDY3LCAtMzYuNjIwMCwgLTQwLjUwMzYsIC00My41OTA0LCAtNDYuMTU4MywgLTQ3LjcwNDIsIC01MC4wNDAyLCAtNTIuMDYyMCwgLTUzLjUxMjgsIC01NS40MTMzLCAtNTcuMjE3NSwgLTYwLjA1NDEsIC02MS42NjM1LCAtNjMuNzEzMiwgLTY2LjYzNTksIC02OC4zOTE1LCAtNzAuMzY2NiwgLTcyLjMwODMsIC03NC43NjI2LCAtNzUuMzM5MywgLTc3LjkzMTgsIC00Ny41MjA4LCAtMjIuNjg0MCwgLTMwLjYyNTMsIC0zMi41NDc0LCAtMzMuNTQ4NSwgLTM2Ljk2MDgsIC00Ni4xMDY3LCAtNDguNDgzMywgLTQyLjQ2ODcsIC00MS44MzQwLCAtNDMuOTI3MSwgLTQ3Ljk2MzAsIC01MC45MzE3LCAtNTAuMzYyNCwgLTUwLjMwMzAsIC01MS43MzUxLCAtNTMuOTMwMiwgLTU1LjYxODQsIC01Ni41NTg5LCAtNTcuNjIzMSwgLTU5LjE4NTEsIC02MC45OTE2LCAtMjMuNTg0MCwgLTI3LjkzNzgsIC0zMi45NDY4LCAtMzMuMjY4MCwgLTM1LjkyOTMsIC00My4zMTc3LCAtNTAuOTgxNCwgLTQzLjA3NTcsIC00MS42OTAyLCAtNDMuMjY3NywgLTQ2Ljk4MzksIC01MC42NTMxLCAtNTAuNTQxNCwgLTUwLjE3MDIsIC01MS4zMDc0LCAtNTMuNDMyNywgLTU1LjMzMTEsIC01Ni4zNjE2LCAtNTcuMzQ2NSwgLTU4LjgwOTgsIC02MC41NTUxLCAtNjIuMzc4MCwgLTY0LjE5OTgsIC02Ni4xOTg2LCAtNjcuOTAwMSwgLTY5LjY1OTksIC03MS41NTQ3LCAtNzkuMjAxMiwgLTg2LjcxNTEsIC04Ni43NjE0LCAtODYuNjY3OCwgLTg2Ljg2NzMsIC04Ni43OTgzLCAtODYuMDgyNywgLTg2LjQ5NTMsIC04Ni43NDE1LCAtODYuNTUyNiwgLTg2LjQ5NjEsIC04Ni40NDkzLCAtODYuOTk5NCwgLTg2LjUyNDcsIC04Ni4zMjA2LCAtODYuODA4NiwgLTg3LjQ0MTEsIC04Ni44Nzg1LCAtODYuNjgzMywgLTg1LjgzOTcsIC04Ni4xMTUyLCAtODYuMzUyNywgLTg2LjQ5MDMsIC04Ni4wODYxLCAtODYuMzA3OCwgLTg2LjQ4NzIsIC04Ni43Mjk3LCAtODYuNTIzNSwgLTg2LjM5MDMsIC04Ni41Mjg4LCAtODYuMzIzNiwgLTg2LjQ1NDUsIC04Ni4zNzc5LCAtODYuNTU5MSwgLTg2LjM1OTYsIC04Ni43MzE5LCAtODYuMTA3NSwgLTg2LjU4ODUsIC04Ni41MzIyLCAtODYuNjMwOSwgLTg2LjE3NDQsIC04Ni4zODg2LCAtODYuMTAyOSwgLTg2LjEzMzMsIC04Ni41NDQ4LCAtODYuNjQxMCwgLTg2Ljc2MDYsIC0yNC4zOTE2LCAtMjYuOTg4MSwgLTMzLjIyNzgsIC0zMy4xNTg2LCAtMzUuNTU3OCwgLTQyLjMzMDksIC01MS44NTczLCAtNDMuNDA4MywgLTQxLjY4NTYsIC00My4wNDcxLCAtNDYuNjEyNywgLTUwLjQ3OTYsIC01MC42MjQxLCAtNTAuMTQzNiwgLTUxLjE1MjYsIC01My4yMzI1LCAtNTUuMjA0OSwgLTU2LjI4OTYsIC01Ny4yNDI4LCAtNTguNjYwMSwgLTYwLjM3ODYsIC02Mi4yNDM3LCAtNjQuMDE2MCwgLTY2LjAyNjksIC02Ny43NjM2LCAtNjkuNTA2NSwgLTM3LjA4NTksIC0yMi45NDE3LCAtMzIuNzAzMiwgLTMyLjUyMjgsIC0zMy44NTIwLCAtMzcuODk5NCwgLTIyLjkxMDgsIC0yOS4xNDQxLCAtMzIuNzgzMCwgLTMzLjM0NjksIC0zNi4zNDczLCAtNDQuNDk1MywgLTQ5Ljg2MjksIC00Mi43Njk1LCAtNDEuNzMxNSwgLTQzLjU0MDYsIC00Ny40MTMxLCAtNTAuODA0MiwgLTUwLjQ1NjEsIC01MC4yMTc2LCAtNTEuNDkwNiwgLTQzLjE2NDQsIC0xOS4yMTg3LCAtMjQuNTA1NCwgLTI3LjQxNzksIC0zMi41OTkxLCAtMzQuNTc3MywgLTM3LjAwNDUsIC0zOC44MDA3LCAtNDEuMzEyMiwgLTQ0LjE5NzMsIC00Ni43NzU5LCAtNDguNjQyMiwgLTUwLjkyNzAsIC01MS40OTg1LCAtNTMuNjk3MiwgLTU2LjMwMjIsIC01OC4xMjEzLCAtNjAuNjA2MCwgLTYyLjg1ODQsIC02NS4yMzQwLCAtNjcuMTk1MCwgLTY4LjgzNzcsIC03MS4wNzA5LCAtNzMuMjU1NCwgLTc1LjQyMjcsIC03Ny4yNjUyLCAtNzkuMDQwOSwgLTgwLjU5NDgsIC04Mi4wNzY3LCAtODMuNDU4OCwgLTg0LjMxNDgsIC04NC42MjUxLCAtODUuNDY5MSwgLTg1Ljk4MDYsIC04Ni4wMzIzLCAtODUuNzcwNSwgLTg2LjIwMTksIC04Ni4xNzIzLCAtODUuOTU0MiwgLTg2LjgzNzksIC04Ni41NDMxLCAtODYuNDQxMywgLTg2LjM1NjUsIC04Ni4xNzE4LCAtODYuODI1NywgLTg1Ljk2NTgsIC04NS44Nzc2LCAtODYuNTY0MywgLTg2LjAxOTYsIC04Ni43ODM5LCAtODYuNzUyMSwgLTg2LjE3NzcsIC04Ni40NzY2LCAtODYuNzIwMCwgLTg2LjUyMDUsIC04Ni4yMjM2LCAtODYuNzIzMiwgLTg2Ljk5MTgsIC04NS43NjAyLCAtMjMuNTA1MSwgLTI4LjA1ODQsIC0zMi45MTY5LCAtMzMuMjgwNywgLTM1Ljk3NTgsIC00My40NDI4LCAtNTAuODYxNCwgLTQzLjAzOTAsIC00MS42OTI3LCAtNDMuMjk1MiwgLTQ3LjAzMTAsIC01MC42NzE3LCAtNTAuNTMyOCwgLTUwLjE3NDMsIC01MS4zMjYxLCAtNTMuNDU1OSwgLTU1LjM0NjksIC01Ni4zNzUxLCAtNTcuMzU2MiwgLTU4LjgyNzcsIC02MC41NjkxLCAtNjIuMzk1MiwgLTY0LjIzNzksIC02Ni4yMjM5LCAtNjcuOTE2NywgLTY5LjY3NTgsIC03MS41OTg4LCAtNzkuMzY2NCwgLTg2LjIzNjksIC04Ni44NjQ1LCAtODYuNzM3MSwgLTg2LjI4NjUsIC04Ni42MDkwLCAtODYuNzIxOCwgLTg2LjEzNDcsIC04Ni4xNTI3LCAtODYuMzc0MSwgLTg2LjY2NTAsIC04Ni40MzI3LCAtODYuOTkzOSwgLTg2LjYwNjcsIC04Ni4xNjUzLCAtODYuMjYzMywgLTg2LjMwOTQsIC04Ni4zNzA3LCAtODYuMzM5NywgLTg2LjI3MjcsIC04Ni4zMjUzLCAtODYuMTM3MiwgLTg2LjA5MjQsIC04Ni4wNDUwLCAtODYuMjQ1NSwgLTg2Ljg1MDYsIC04Ni4yMDQ4LCAtODYuMzczNywgLTg2LjM0MTgsIC04Ni42MDUxLCAtODYuMTMwOCwgLTg2LjI1NjEsIC04Ni44NTk5LCAtODYuMDc3MCwgLTg2LjI5MDYsIC04Ni40NTcyXSxcbiAgICAgICAgZ2FpbjogLTMsXG4gICAgICB9LCB7XG4gICAgICAgIGJ1ZmZlcjogJ3NvdW5kcy9jby1taXgva2lja190b21fbW9kZV8yLndhdicsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiAwLjUgKiA2MCAvIDEyMixcbiAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICBpbnRlbnNpdHk6IFstODYuNTc0NCwgLTg2LjY0MjcsIC04Ni44MjY3LCAtNDAuNjM4NiwgLTI0LjQ0MDQsIC0zMy44Njg1LCAtMzQuMTI3MiwgLTM1LjQwMzEsIC0zOS4zMjY2LCAtNDkuNjMzMywgLTQ4LjcxODQsIC00My44MjAyLCAtNDMuNjExOCwgLTQ2LjAxMTksIC0yOS44ODQ0LCAtMjcuODIxMCwgLTM2LjU3NjgsIC0zNS41OTUwLCAtMzcuNTQ0MCwgLTQzLjE4MjYsIC01NS4xODI2LCAtNDcuMDQ2MywgLTQ0LjQ5MTMsIC00NS4zNTg4LCAtNDguMTYxMiwgLTI0LjQ4OTUsIC0zMS4wODUwLCAtMzQuMjY5NywgLTM1LjA2MjAsIC0zOC4xNjMyLCAtNDYuNTk0NywgLTUxLjAyODAsIC00NC4yNzU1LCAtNDMuMzY1NiwgLTQ1LjI2MjMsIC00OS4xOTAyLCAtNTIuNDYzNiwgLTUyLjAzNzcsIC01MS44NTE0LCAtNTMuMTczOCwgLTU1LjM0OTQsIC01Ny4xMjM4LCAtNTguMDg5OCwgLTU5LjEyMDIsIC02MC42NDM0LCAtNjIuNDMxMCwgLTI1LjYyNzgsIC0yOS4wMTUzLCAtMzQuNzA2NCwgLTM0LjgzNTIsIC0zNy4zNTk0LCAtNDQuNDI1MSwgLTUzLjAzMjYsIC00NC44NDM2LCAtNDMuMjk0MCwgLTQ0Ljc2MzYsIC00OC40MDY5LCAtNTIuMTgzNywgLTUyLjE5NjMsIC01MS43NjY4LCAtNTIuODM3NSwgLTU0Ljk0MDEsIC01Ni44NzgxLCAtNTcuOTM2MSwgLTU4LjkwNDcsIC02MC4zMzkwLCAtNjIuMDU5NywgLTI3Ljk0NTUsIC0yNy4yMDM2LCAtMzUuMzYwNCwgLTM0LjU4NTAsIC0zNi42MzUyLCAtNDIuNTQwMywgLTU0LjExNjAsIC00NS42NjEyLCAtNDMuMzQ3MiwgLTQ0LjM1NDIsIC00Ny42NTc3LCAtNTEuNzUyNywgLTUyLjM3NDMsIC01MS43NDUwLCAtNTIuNTQ1OCwgLTU0LjUzODAsIC01Ni42MDU1LCAtNTcuNzgwMiwgLTU4LjY5OTEsIC02MC4wNDg4LCAtNjEuNzMyNywgLTMxLjgyMTEsIC0yNS42NjMxLCAtMzUuNjM2MSwgLTM0LjMyMzEsIC0zNS45OTA5LCAtNDAuOTEyMSwgLTUyLjg3NDAsIC00Ni44Mjk0LCAtNDMuNTE4OCwgLTQ0LjAwMjIsIC00Ni45MTI1LCAtNTEuMTQzOCwgLTUyLjU0MTMsIC01MS43ODgxLCAtNTIuMzAwNCwgLTU0LjEzNjAsIC01Ni4yOTMxLCAtNTcuNjIyMSwgLTU4LjUwOTIsIC01OS43NjQyLCAtNjEuNDEzOCwgLTM3Ljk1NjksIC0yNC42MjQ1LCAtMzQuNDk3NSwgLTM0LjE1MTEsIC0zNS41MDgzLCAtMzkuNjQwOSwgLTUwLjM2NDAsIC00OC4yNjgxLCAtNDMuNzUzMywgLTQzLjcwMDcsIC00Ni4yMTM4LCAtNTAuNDEzMiwgLTUyLjYxMjQsIC01MS44NjY1LCAtNTIuMDk0MiwgLTUzLjc0ODQsIC01NS45NDYyLCAtNTcuNDQ0OCwgLTU4LjMzOTIsIC01OS40OTkyLCAtNjEuMTA2MCwgLTQ4LjQyOTAsIC0yNC4yOTg5LCAtMzIuMzMxOSwgLTM0LjE2MTYsIC0zNS4xNzkzLCAtMzguNjE1MiwgLTQ3LjgxOTEsIC01MC4wMzA3LCAtNDQuMDc0NiwgLTQzLjQ2MTYsIC00NS41NzAwLCAtNDkuNjE1MCwgLTUyLjU1NDMsIC01MS45Nzc4LCAtNTEuOTI2OCwgLTUzLjM3MjAsIC01NS41ODUyLCAtNDMuODc0MSwgLTM5LjYwNjcsIC0zOS44MDA2LCAtNDEuMTMzOCwgLTQyLjk0NjMsIC0yNC44MzA0LCAtMzAuMTI1MiwgLTM0LjQzNzcsIC0zNC45NDczLCAtMzcuNzY2OSwgLTQ1LjUyNDUsIC01Mi4wNDU1LCAtNDQuNTMzMSwgLTQzLjMyNjEsIC00NS4wMjEzLCAtNDguODE5MiwgLTUyLjM1NDYsIC01Mi4xMTYzLCAtNTEuODEyNiwgLTUzLjAxNjAsIC01NS4xNjQ5LCAtNTcuMDE1NCwgLTU4LjAyNTAsIC01OS4wMjY3LCAtNjAuNTAxMCwgLTYyLjI1ODUsIC0yNi41MDk2LCAtMjguMTY1MiwgLTM1LjAwNTQsIC0zNC43MjE0LCAtMzcuMDAyMCwgLTQzLjQ5MTMsIC01My44MDY5LCAtNDUuMjEzOCwgLTQzLjMxNDcsIC00NC41NjcyLCAtNDguMDUxMiwgLTUyLjAwMjQsIC01Mi4yODY5LCAtNTEuNzU3OSwgLTUyLjcwMDcsIC01NC43NTM5LCAtNTYuNzU1NywgLTU3Ljg2ODIsIC01OC44MTU0LCAtNjAuMjA1OCwgLTYxLjkxMDcsIC0yOS40NjE5LCAtMjYuNDY0NSwgLTM1LjYxMjksIC0zNC40NjA2LCAtMzYuMzIxMiwgLTQxLjc0NjIsIC01My44NTQzLCAtNDYuMTY4NywgLTQzLjQyMTAsIC00NC4xODkxLCAtNDcuMzEzNywgLTUxLjQ5NDUsIC01Mi40NTk1LCAtNTEuNzYzNCwgLTUyLjQyOTgsIC01NC4zNTYwLCAtNTYuNDY2NiwgLTU3LjcxMzEsIC01OC42MTQ4LCAtNTkuOTIwNCwgLTYxLjU3ODYsIC0zNC4yMzQzLCAtMjUuMTE5NiwgLTM1LjMxNTAsIC0zNC4yMjk1LCAtMzUuNzUzNCwgLTQwLjMwMzksIC01MS43ODg2LCAtNDcuNDQwMSwgLTQzLjYxNTgsIC00My44NjAzLCAtNDYuNTkyMCwgLTUwLjgyNTgsIC01Mi41ODc4LCAtNTEuODE5NywgLTUyLjIwMTIsIC01My45NTgzLCAtNTYuMTM4OCwgLTU3LjU0NTUsIC01OC40MzQ2LCAtNTkuNjM3NSwgLTYxLjI4MTYsIC00MS45NjExLCAtMjQuMzc1NywgLTMzLjU2OTMsIC0zNC4xMjcxLCAtMzUuMzQxNywgLTM5LjE0NzgsIC00OS4xODUzLCAtNDkuMDI3OCwgLTQzLjg4NjQsIC00My41ODE5LCAtNDUuOTExOSwgLTUwLjA1MzAsIC01Mi42MDM5LCAtNTEuOTExMiwgLTUyLjAxMDksIC01My41NzM0LCAtNTUuNzc1OCwgLTU3LjM2MjcsIC01OC4yNjY2LCAtNTkuMzg0MCwgLTYwLjk4MDUsIC01NS42NjI5LCAtMjQuNDM1MiwgLTMxLjMxMDQsIC0zNC4yNTAxLCAtMzUuMDY4MSwgLTM4LjIxNzQsIC00Ni43NTAwLCAtNTAuOTE3OCwgLTQ0LjI1OTAsIC00My4zODY0LCAtNDUuMzEwMSwgLTQ5LjI1MzQsIC01Mi40ODE0LCAtNTIuMDM1MywgLTUxLjg2ODIsIC01My4yMDY3LCAtNTUuMzg1NywgLTU3LjE0NzYsIC01OC4xMDczLCAtNTkuMTUwMiwgLTYwLjY3ODksIC02Mi40NTU3LCAtMjUuNDY3MiwgLTI5LjIwMjQsIC0zNC42NjI0LCAtMzQuODQ4OSwgLTM3LjQxMTIsIC00NC41NjgwLCAtNTIuOTQ0NSwgLTQ0LjgxMDUsIC00My4zMDUyLCAtNDQuODAzOSwgLTQ4LjQ2NjgsIC01Mi4yMTM4LCAtNTIuMTkwNSwgLTUxLjc3OTQsIC01Mi44Njg3LCAtNTQuOTc3MiwgLTU2LjkwMzYsIC01Ny45NTU3LCAtNTguOTI4MSwgLTYwLjM2ODEsIC02Mi4xMDE4LCAtMjcuNjU3OSwgLTI3LjM2NTYsIC0zNS4zMTM4LCAtMzQuNjA2MiwgLTM2LjY4MzIsIC00Mi42Njc0LCAtNTQuMTMxOSwgLTQ1LjYwODAsIC00My4zNDk5LCAtNDQuMzg4OSwgLTQ3LjcxNjcsIC01MS43OTIyLCAtNTIuMzY4OSwgLTUxLjc1MTcsIC01Mi41NzIwLCAtNTQuNTc1NCwgLTUzLjg2ODQsIC00MC4yNzIyLCAtMzkuNzkxMiwgLTQwLjY2NzUsIC00Mi4yOTAwLCAtMzEuMTA4NSwgLTI1Ljc5NzAsIC0zNS42NjI0LCAtMzQuMzQ1OSwgLTM2LjA0NjMsIC00MS4wNTIxLCAtNTMuMDgzMywgLTQ2LjcwNjEsIC00My41MDAyLCAtNDQuMDM0NCwgLTQ2Ljk4MjgsIC01MS4yMDc4LCAtNTIuNTI3MCwgLTUxLjc4MzUsIC01Mi4zMjA5LCAtNTQuMTc1MSwgLTU2LjMyMTIsIC01Ny42NDAwLCAtNTguNTM3NSwgLTU5Ljc4ODYsIC02MS40NDQzXSxcbiAgICAgICAgZ2FpbjogLTMsXG4gICAgICB9LCBdLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjbGFwJyxcbiAgICAgIGxheWVyczogW3tcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9jbGFwc19tb2RlXzEud2F2JyxcbiAgICAgICAgc3RhcnRPZmZzZXQ6IDAuNSAqIDYwIC8gMTIyLFxuICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgIGludGVuc2l0eTogWy04Ni43MTE3LCAtODYuNjI5NiwgLTg2Ljc5NjYsIC04Ni40NzUxLCAtODYuNjM2NywgLTg2LjQ1MTUsIC04Ni4zNTI3LCAtODYuMTI5MiwgLTg2LjQ3ODAsIC04Ni40MzYyLCAtODYuMjU3MiwgLTg2LjM4NzgsIC04Ni4xOTQ0LCAtODYuNTYxMSwgLTg2Ljc1ODksIC04Ni41NDAzLCAtODYuMzI1NSwgLTg2Ljg2MjAsIC04Ni41MzMxLCAtODYuODUzMSwgLTg2LjY3NTcsIC04Ni42NDA2LCAtODcuMDE3MiwgLTg2LjAxNzQsIC04Ny4wMzYxLCAtODYuMzkzNCwgLTg2LjUzNzIsIC04Ni43MTI0LCAtODYuMTA1NiwgLTg2Ljg2OTEsIC0xOS45NTY0LCAtMTYuMDIxMSwgLTIzLjQzMTgsIC00NC41NzYzLCAtODYuMTA0MSwgLTg2LjgxOTgsIC04Ni41MTMxLCAtODYuNjc1NiwgLTg2LjU5MTMsIC04NS45MzQzLCAtODYuNTM2OCwgLTg2LjcyNDcsIC04Ni4zNTMyLCAtODYuMzI2OCwgLTg2LjQ1ODMsIC03My4wNDU3LCAtNy44MzE4MCwgLTMuNzE1NzgsIC03Ljg2NzkwLCAtMTcuNDk2MCwgLTI2LjYwMjYsIC0zMy44Mzg2LCAtMzguMjg4NSwgLTM2Ljc2MjgsIC0zNS42NDg1LCAtMzMuNTM2NCwgLTMxLjU1MTgsIC0xNC41NDY1LCAtMjAuMDczNSwgLTMwLjIwMTgsIC00NC4wNTY1LCAtNDYuNjYxNCwgLTQ5LjEzMjIsIC01MC4yOTEyLCAtNTIuNzMwMCwgLTU2LjIwMjEsIC01OC43NDY1LCAtMTguMjk0MywgLTEzLjQ3NzMsIC0xOC41Nzc4LCAtMzYuNjgzNiwgLTQ5Ljk3MTIsIC0yMy4yODEwLCAtOS43MTc5OSwgLTE0LjI4NTQsIC0yNS4zNzIxLCAtNDQuODY2NiwgLTQ4LjUwOTUsIC00Ny4wMTE2LCAtNDUuNzg3NSwgLTQ5LjczOTMsIC01Mi44NzE2LCAtNTMuODgxMywgLTU1LjExOTEsIC01Ni45MDMwLCAtNTcuMjAwNSwgLTU5LjAyODEsIC02MC42Njc3LCAtNjEuMzgxMiwgLTYyLjc4NTQsIC02NC41NzYyLCAtNjYuMDE3OSwgLTY4LjE1MTksIC02OC45MTYxLCAtNjkuODE0MiwgLTcxLjA4NzksIC03Mi45NDQzLCAtNzMuNjYwOSwgLTc0LjI3OTIsIC03NS40NDEyLCAtNzUuNzcwMCwgLTc3LjMxNjIsIC03OC4yODU0LCAtNzguODY5OSwgLTc5LjYyMzIsIC04MC41MTE1LCAtODEuMjg4NywgLTgxLjA4NTIsIC04MS45NTkyLCAtODUuNjkyOCwgLTg2LjIwNTAsIC04Ni4zNjg0LCAtODYuMjEzMywgLTg2LjQ4MjgsIC04Ny4xNzk5LCAtODYuNDU4OSwgLTg2LjQwMTMsIC04Ni42OTk5LCAtODYuNjA2NCwgLTg2LjA1NTEsIC04Ni40MTAxLCAtODYuNjA0OSwgLTg2Ljk3NjksIC04Ny4wMTI5LCAtODYuMjUzOSwgLTg3LjEzMzcsIC04Ni40MjcyLCAtODYuOTA4NCwgLTg2LjUyNzgsIC04Ni41NzgwLCAtMjkuMDM2OCwgLTUuMjUxNTMsIC00LjA1ODQ4LCAtOC45OTgyMSwgLTE4LjczODUsIC0yNy41MzEzLCAtMzMuMTQ2NiwgLTM0LjM2ODgsIC0zMy41OTAwLCAtMzEuNDA0NywgLTMwLjc0NjAsIC0zMC42NDU4LCAtMzIuODg0MCwgLTMzLjQwNjYsIC0zNS41NDQ2LCAtMzYuMDYxNiwgLTM3LjY2NDMsIC0zNS44ODM0LCAtMzcuNTM4MywgLTM4LjU3NDIsIC0zNi43MjUzLCAtMzkuNDY1OSwgLTM4LjAyNjcsIC00MS41ODA5LCAtMzkuNDExNiwgLTQxLjMzMjksIC0zOS40OTE1LCAtNDIuMzE5NCwgLTQxLjg1OTcsIC00NC41NTA2LCAtNDQuMjc0MCwgLTQ0LjQyMjksIC00NS4zMDk3LCAtNDYuMDg1MywgLTQ2LjU3NjUsIC00Ni4wODcwLCAtNDcuMzMxMSwgLTQ2LjYwNTcsIC00OC4wNzk5LCAtNDcuNTE2MCwgLTQ3Ljk3NTksIC00Ny43NDg5LCAtNDguNzI0NSwgLTUxLjM5OTMsIC01MC45NzE4LCAtNTIuMDUyNCwgLTUxLjg0NzQsIC01Mi41ODQyLCAtNTEuMjE0NiwgLTUxLjk0OTYsIC01NS4xMjc5LCAtNTQuNjM5MywgLTUzLjM0NjAsIC01NC44MjMwLCAtNTYuNzIzMywgLTU0LjU0NjMsIC01NS4zMDAxLCAtNTQuNzc2MywgLTU1Ljk5MDksIC01Ni43MDExLCAtNTguMTQxMywgLTU4LjkzNjAsIC01OS4wNzg4LCAtNTguNzA2MSwgLTIzLjIzODIsIC0xNS4wODQyLCAtMjIuMjEwNywgLTM4Ljg0NjEsIC02MS42ODY3LCAtNjIuOTM1MywgLTYzLjQyMjQsIC02Mi4xNDA4LCAtNjAuNzQwOCwgLTU5LjkxMjcsIC02MC44MDk3LCAtNTkuMTYxOSwgLTU4LjgyOTMsIC01OC40MjQ5LCAtNTguOTk2NCwgLTU3LjUxODEsIC01Ny4wNDI5LCAtNTUuMzg4MSwgLTU0LjgzNTUsIC01NS4xNDMwLCAtNTUuMTg1NiwgLTE2LjM4NTUsIC00LjMzNTk5LCAtNS4yMTYxMSwgLTEzLjA4MjMsIC0yMi42MDMzLCAtMzEuMjIyNiwgLTM2Ljk0NTcsIC0zOC4wMDI1LCAtMzUuNzc5OCwgLTM0LjMyMDcsIC0zMy45ODYzLCAtMzUuMzEzMiwgLTM3LjIxMjgsIC0zOS44NzIyLCAtNDMuMjEzMSwgLTQ1LjgxMzksIC0yNi4wMjI3LCAtMTUuODE5NCwgLTIyLjc2OTQsIC0zNy43ODM5LCAtNTYuOTM1NCwgLTMzLjE1NjYsIC0xMi45MzEwLCAtMTYuNjU2NSwgLTI1LjA5OTYsIC00Ni41NjM4LCAtNTEuMzQzNywgLTExLjU2NzEsIC0xMS44MDk5LCAtMTcuNTczMSwgLTM5LjgwMDAsIC00Ny42Mjk4LCAtNDkuMDU3OSwgLTQ1LjI2NzYsIC00Ny43OTQ0LCAtNTIuNDc0MCwgLTUzLjQzNzgsIC01NC40NzM4LCAtNTYuNDU0NiwgLTU1LjkwNDAsIC01Ny42MzkyLCAtNjAuMTgzMSwgLTYxLjI5NzQsIC02Mi42MjEyLCAtNjMuNjA1NiwgLTY0Ljg3NzIsIC02Ny4xMDcyLCAtNjguMTM1NiwgLTY5LjM0NzMsIC02OS45Mzg1LCAtNzEuMzk5MCwgLTczLjU3MDAsIC03My4zMzMxLCAtNzQuOTA2NiwgLTc1Ljc5MDIsIC03Ni41MjIyLCAtNzcuMDEzMCwgLTc4LjY0OTAsIC03OS40NDk4LCAtODAuNjQ4OCwgLTgwLjI2NTUsIC04MS40NTAyLCAtODEuMjE5NCwgLTg0LjIzNjEsIC04Ni4zODkzLCAtODYuNzk2NywgLTg2LjQwOTYsIC04Ni43OTQ1LCAtODYuMzY5NCwgLTg2LjEyMTIsIC04Ni42OTI3LCAtODYuNTI2MCwgLTg2LjczNjMsIC04Ni42NTcxLCAtODYuMTQzOCwgLTg2LjU4MDMsIC04Ni40ODY5LCAtODYuNzExMiwgLTg2LjA4MzEsIC04Ni40ODcwLCAtODYuODk0NiwgLTg2LjQzMzgsIC04Ni4wOTk3LCAtODYuMTI2MSwgLTg3LjEwNDEsIC0xMC4wMzk4LCAtMy4zMjg2MiwgLTYuMzQwNTAsIC0xMy45MTUxLCAtMjMuNzg4NSwgLTMwLjY4NjYsIC0zNC44MTU3LCAtMzQuMDk2OCwgLTMyLjAzMDMsIC0zMC42NzIyLCAtMzEuMjg1NSwgLTMyLjAwNjQsIC0zMy41Mzg5LCAtMzMuOTA5NSwgLTM2LjY2NTgsIC0zNy4yOTQzLCAtMzcuNjg1MCwgLTM2LjM4MTMsIC0zOC42NTk1LCAtMzcuMTI1MywgLTM4LjUzMzksIC00MC4yODU2LCAtMzkuMDE4OCwgLTQwLjU3MDIsIC00MC40NTUxLCAtNDAuMjE1MiwgLTQyLjM0ODEsIC00MC45MTU0LCAtNDMuMjA4NywgLTQ1LjU5NDgsIC00NC4yMzAxLCAtNDQuMTE0MiwgLTQ1LjU5MTAsIC00Ni43MDA4LCAtNDUuNDUyMCwgLTQ3LjQ1NzIsIC00Ny4xNTM2LCAtNDYuOTU5NywgLTQ4LjEzMjEsIC00Ny44MTU3LCAtNDcuODQzNCwgLTQ5LjAzNzJdLFxuICAgICAgICBnYWluOiAtOCxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9jbGFwc19tb2RlXzIud2F2JyxcbiAgICAgICAgc3RhcnRPZmZzZXQ6IDAuNSAqIDYwIC8gMTIyLFxuICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgIGludGVuc2l0eTogWy04Ni40NzUwLCAtODUuOTg2NCwgLTg1Ljc3NzcsIC04Ni45NjQwLCAtODYuNDA4NCwgLTg2LjU4MjIsIC04Ni41MDQzLCAtODcuMDk2MywgLTg2LjU1MzIsIC04Ni43MDk5LCAtODYuOTA2OSwgLTg2LjUwNjQsIC04Ni43NjQ1LCAtODYuMzQ5OCwgLTg2LjE3MjQsIC04Ni40MzYzLCAtODYuMTI2NSwgLTg2LjE3MDksIC04Ni4yMjMwLCAtODYuMjE0NywgLTg2LjMxODMsIC04Ni44OTQzLCAtODYuNDAwMCwgLTg2LjU2ODgsIC00MS43NjUzLCAtMTAuNDgxMSwgLTguMjM5MTIsIC0xNS4wMTI5LCAtMjQuOTE2NywgLTMzLjkzMjcsIC0zOC43MzU2LCAtNDEuNzg1OSwgLTQxLjAzMTcsIC0zOS42ODE5LCAtMzguMjU1NCwgLTM5LjM4MTMsIC00MS40OTExLCAtNDMuNTg5OSwgLTQ2LjkzMzMsIC00OS4wOTgyLCAtNTEuMzgyNywgLTUzLjk3NzIsIC01NS40NDA0LCAtNTcuOTk1MywgLTYxLjAwMDEsIC02My42MTAzLCAtNjQuNzA5OCwgLTY2LjQ3MzcsIC02OC40MDMyLCAtNzAuNDU4NiwgLTcyLjM1OTIsIC03My44MTQ3LCAtNzUuOTk2NywgLTc3LjY0MDAsIC03OS4wNTYxLCAtNzkuOTY1MSwgLTgwLjcxNTIsIC04MS43ODQ2LCAtODIuMjc5OSwgLTgyLjkyMzQsIC04Mi42ODE2LCAtODUuNDAzNywgLTI3LjIwNjksIC0yMS42NjQ5LCAtMTkuOTkxMywgLTI2LjI2ODcsIC0zNi41NzE5LCAtMTQuMzc4NiwgLTcuNzU4NjIsIC0xMi4wMjg0LCAtMjEuMjYxMCwgLTI5LjgxNDgsIC0zMy4xMDczLCAtMzUuNTExMiwgLTM2Ljk5MDYsIC0zNi4yODg3LCAtMzUuOTMyNiwgLTM2LjcxNjQsIC0zNy4zODI5LCAtMzguNjEzMSwgLTQxLjI2NDQsIC0zOS4xNzgwLCAtNDEuNzExMSwgLTQxLjg0MDQsIC00My44NzEzLCAtNDIuNjQ1MSwgLTQ0LjUxMDgsIC00Mi40Nzg5LCAtNDUuODk1OSwgLTQ0LjQwMjgsIC00Ny4wNDUzLCAtNDcuODUxNCwgLTQ3LjYzNTUsIC00OC4wODIwLCAtNDkuMjAyNiwgLTUwLjEzODUsIC00OC45ODI3LCAtNTAuNjk4OSwgLTUwLjAzOTEsIC01MC44ODU0LCAtNTAuODc1MywgLTUxLjE0MjMsIC01MC44NjkxLCAtNTIuMTAxOCwgLTUzLjg2ODgsIC01NC4zMTEzLCAtNTUuMDE4MSwgLTU1LjE4NTcsIC01NS41NTQ4LCAtMjMuODYzNywgLTguOTY5OTQsIC05LjQ3MjkxLCAtMTguMjE4NSwgLTI2Ljk3NzgsIC0zNS4zMzE4LCAtMzguNzM4OSwgLTQyLjExNzMsIC00MC4zNDUxLCAtMzguOTAxMCwgLTM4LjQ0OTcsIC0zOS45MDI1LCAtNDEuOTA5NSwgLTQ0LjEyNzIsIC00Ny41OTIzLCAtNDkuOTkyOSwgLTUxLjcwOTAsIC01NC4xNDM2LCAtNTUuNTQyNSwgLTU3LjgyMjEsIC02MC4xMzgwLCAtNjEuMzIxNiwgLTYzLjQxMjgsIC02Mi41OTU5LCAtNjIuNjMwNywgLTYyLjE0NjQsIC02NC4wNzQ1LCAtNjIuMTk2NCwgLTYxLjg3NjgsIC02Mi4wMDQ5LCAtNjIuMjc3NSwgLTYxLjA5MzMsIC02MC4wMjYxLCAtNTkuMDE5NiwgLTU4LjAyODcsIC01OC41MDQyLCAtNTcuODg1MywgLTczLjA5NTUsIC04Ni4xOTI2LCAtODYuMzc5NywgLTg2LjM2NDEsIC04Ni4wNjMwLCAtNTMuNDM1MCwgLTExLjA2MjgsIC03LjgyMzAyLCAtMTQuNDk3NCwgLTIzLjYwNDMsIC0zMi45NDgzLCAtMzguNzE2MywgLTQxLjI0MTQsIC00MS4xODE2LCAtNDAuMDQyMywgLTM4LjA3OTMsIC0zOS4yNTgwLCAtNDEuMjQxNSwgLTQzLjI2NzcsIC00Ni42NjkyLCAtNDguNzEyMCwgLTUxLjQ3OTQsIC01NC4xNDY1LCAtNTUuNDA1MywgLTU3LjYxODMsIC02MC43ODUyLCAtNjIuODU0MCwgLTY0LjQ2MjksIC02Ni4xNjUwLCAtNjcuODk3NSwgLTcwLjE3MjcsIC03MS43MzEzLCAtNzMuODcyNywgLTc2LjMwNDAsIC03Ny4xOTIwLCAtNzguNjU5NCwgLTc5LjU4ODYsIC04MC4zNTg1LCAtODEuNTExNCwgLTgyLjQxNjksIC04Mi45MjkzLCAtODMuMjk2MSwgLTg0LjkzMDcsIC04Ni4xNTUzLCAtODYuMDU5NiwgLTg2LjMyNjMsIC04Ni40ODc4LCAtODUuOTg0OCwgLTE1Ljg1OTYsIC03Ljk0OTIzLCAtMTEuNDIxMywgLTIwLjY3NjQsIC0yOS44NTAzLCAtMzcuMTM4MSwgLTM5LjM0ODQsIC00Mi4wNDE0LCAtNDAuMjg0MCwgLTM4LjE5NTAsIC0zOC44MDE2LCAtNDAuNTE5NywgLTQyLjM5MzgsIC00NS4xMzUyLCAtNDcuOTczNiwgLTUwLjg5NTAsIC01My4xOTg3LCAtNTQuNTc3NSwgLTU2Ljk2NDgsIC01OS43NDY3LCAtNjEuNzU1OSwgLTYzLjcyNzUsIC02NS45NTEzLCAtNjYuOTY5NCwgLTY5LjQ3NjcsIC03MS43NjMxLCAtNzIuNzI4NCwgLTc1LjQ1MzIsIC03Ni4yNzM2LCAtNzguNzUzNiwgLTc5LjUwMTIsIC04MC4yNTUxLCAtODEuMTM4MCwgLTgyLjQwNjMsIC04Mi42MzY2LCAtODIuNzY3MCwgLTgzLjYwODYsIC02OC41MzAxLCAtMTguNDYwMCwgLTIzLjUzMDIsIC0yMC40ODgzLCAtMzIuNDI5OSwgLTI3LjI3OTAsIC05LjM0MTQxLCAtOC45Nzk4NCwgLTE3LjMzODcsIC0yNi4wMTI5LCAtMzIuNzYyNCwgLTM0LjQ1NDcsIC0zNi45MTk5LCAtMzUuODQ4MiwgLTM3LjAzOTEsIC0zNi4zODU3LCAtMzcuNjU4OCwgLTM4LjA1OTgsIC00MC4wNjE1LCAtNDAuMDA3OCwgLTQwLjM0MzEsIC00Mi43NDI4LCAtNDEuMjIxNywgLTQ0LjEzNDAsIC00My4wOTk3LCAtNDQuMDE1MCwgLTQ0Ljc2MjEsIC00NC4zOTM1LCAtNDYuMjI2MCwgLTQ5LjEyODYsIC00Ny40MzA0LCAtNDcuMjYxNiwgLTQ4LjY5NDcsIC00OS42NzQyLCAtNDguNzk3MCwgLTUwLjM5MzIsIC01MC41MTE3LCAtNDkuOTA3MiwgLTUxLjYxODksIC01MC45OTUzLCAtNTEuMjE0MywgLTUyLjAwNzAsIC01Mi40NjMwLCAtNTUuMzM2MSwgLTU0LjQ4MjAsIC01NS42NTg4LCAtNTUuMjU2OCwgLTU1LjgyNDYsIC0xMS44MTA0LCAtNy42ODU1NCwgLTEzLjcxNjQsIC0yMi45MTkxLCAtMzIuMzUzNiwgLTM4LjQ2NTQsIC00MC42NjUyLCAtNDEuMjQ0NSwgLTQwLjAzMzAsIC0zNy45MjMyLCAtMzkuMTQzMSwgLTQxLjA0ODksIC00My4wMTE3LCAtNDYuMjY0NSwgLTQ4LjU5MTUsIC01MS4wNzg5LCAtNTMuNTQ5NiwgLTU0LjY5OTgsIC01Ni4zMDYwLCAtNTkuNTM4NiwgLTYwLjYyNzUsIC02Mi4zMzIwLCAtNjIuMzEwMCwgLTYyLjc1OTUsIC02Mi4yMTAxLCAtNjMuNjM0MCwgLTYyLjY5OTEsIC02MS43NTUwLCAtNjIuMTY5MywgLTYxLjE2MDcsIC02MS42MDI3LCAtNTkuOTcyMCwgLTYwLjI1MDAsIC01OC4wNzY1LCAtNTguMjExNywgLTU3Ljg3NzksIC02Mi4yMDY5LCAtODYuMTQ4NiwgLTg2LjIzNjgsIC04Ni42MzMxLCAtODcuMDIxMSwgLTg2Ljc5NzMsIC0xNy42NzQxLCAtOC4xOTY3MywgLTEwLjgxOTksIC0yMC4wMDMzLCAtMjkuMDA3MywgLTM2LjYxNzgsIC0zOS4wOTIwLCAtNDIuMTgzNiwgLTQwLjMyMDcsIC0zOC4zNzI0LCAtMzguNjg2MywgLTQwLjM2NjksIC00Mi4yOTEwLCAtNDUuMDg4MSwgLTQ3Ljc4OTgsIC01MC42MzAyLCAtNTIuODY0NCwgLTU0LjY5NjMsIC01Ni45Mzg0LCAtNTkuNTA3OCwgLTYxLjU0NTddLFxuICAgICAgICBnYWluOiAtOCxcbiAgICAgIH0sIF0sXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2hhdHMnLFxuICAgICAgbGF5ZXJzOiBbe1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tbWl4L2hhdHNfcGVyY3NfbW9kZV8xLndhdicsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiAwLjUgKiA2MCAvIDEyMixcbiAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICBpbnRlbnNpdHk6IFstODcuMzg4MiwgLTg2Ljc5MDUsIC04Ni41Nzg1LCAtMjIuNjk3OSwgLTguNzgyMDgsIC0xNC44ODMzLCAtMjMuMjYxNywgLTMwLjQ3NDcsIC0zOS4yOTc1LCAtMjAuOTAzOCwgLTMxLjc5MDMsIC00MS41NjU1LCAtNDguNTAzMSwgLTU4LjUzNzYsIC0xMS44ODMwLCAtMTAuODQxNywgLTE4LjA0MTUsIC0yNS43NDI4LCAtMzIuOTc0MSwgLTIzLjkzODcsIC0xNi45MjA5LCAtMzAuMTI0OCwgLTM4LjkzMjEsIC00NS4yOTEyLCAtMzkuMTg1MiwgLTguNjY1ODQsIC0xMy4yNDQ5LCAtMjEuNzI2MiwgLTI4Ljg0MDcsIC0zNi41Njc5LCAtMjEuNDAyMiwgLTMwLjI0NTQsIC00MC41MzcwLCAtNDcuODA0OSwgLTU2LjQxNzYsIC0xNS4yOTUxLCAtOS41ODE2OSwgLTE2LjI3MDEsIC0yNC4zOTk0LCAtMzEuODIxOCwgLTI4LjQ5NTMsIC0xNS43NjIzLCAtMjguOTk4MiwgLTM4LjA1NTgsIC00NC40MzcxLCAtNTQuNTkzOSwgLTIzLjg2MDksIC0zNS41Njg1LCAtNDUuMTQ5MywgLTUxLjkxMDAsIC02Mi44NzA3LCAtMjIuNDM0NCwgLTI4LjQ3MzAsIC0zOS40Njc4LCAtNDcuMTQyNCwgLTU0Ljc5OTAsIC0yNS4wNjE5LCAtMjAuNzIxOCwgLTMzLjcyMTgsIC00Mi4zNzcwLCAtNDguODEzMCwgLTM1LjYyMTksIC0xNS4wNDcwLCAtMjcuNzkzMSwgLTM3LjA4OTAsIC00My42MTI1LCAtNTYuODE5NSwgLTI0LjA5NDIsIC0zNC4xMDk3LCAtNDQuMTA5MiwgLTUxLjE5NzIsIC02MC40ODc4LCAtMjQuMDg0NywgLTI2LjUxMzgsIC0zOC4zODc5LCAtNDYuNDgzNiwgLTUzLjQ0MDQsIC0yOC45ODgxLCAtMTkuMzQwNiwgLTMyLjYyMTUsIC00MS41NTUxLCAtNDcuOTAyMSwgLTQ2LjkxMjksIC0xNC44MDM1LCAtMjYuNDg4OCwgLTM2LjA3MjMsIC00Mi44NTM2LCAtNTMuNzgxOCwgLTEzLjU5MTEsIC0xMC40MzQxLCAtMTcuMjM3MywgLTI1LjE4NDEsIC0zMi41MDA0LCAtMjUuODg5NSwgLTguNjE4OTQsIC0xNC4zMjQ4LCAtMjIuODUxOSwgLTI5Ljk0NTQsIC0zOC40NDE5LCAtOC44NTAzNiwgLTEyLjQxMzIsIC0yMC42NTEwLCAtMjcuNzY2MywgLTM1LjIyNzEsIC0xNy40MjE5LCAtMjEuMTMzNSwgLTMyLjcwOTksIC00MC42NjA4LCAtNDcuODMxNywgLTIwLjUwNzAsIC05LjE1NDY5LCAtMTUuMjMzMCwgLTIzLjY1MTAsIC0zMC44OTkxLCAtMzguMjcyNCwgLTIxLjAzMTYsIC0zMy42ODA3LCAtNDMuMDE3NiwgLTQ5LjU1MDUsIC02Mi40NTk0LCAtMTAuMDg3NCwgLTExLjQyNzksIC0xOC45NTIyLCAtMjYuMzgwMSwgLTMzLjg3OTcsIC0xOS41NDA2LCAtMTkuMTkyMSwgLTMxLjYzMjksIC0zOS45OTEwLCAtNDYuNjU3OCwgLTM1LjU4MTcsIC0yNS4yNDQwLCAtMzguNTI1NSwgLTQ3LjQ4MzAsIC01My44Mjc2LCAtNTQuODAxNiwgLTIwLjg0NDMsIC0zMi4zNjQxLCAtNDEuOTkwOSwgLTQ4LjgxMDYsIC01OS41MTYyLCAtMTkuNjA5NSwgLTI1LjE4MTcsIC0zNi4yOTUxLCAtNDQuMDI2MiwgLTUxLjU1OTQsIC0yMi40OTgzLCAtMTcuNDkzOSwgLTMwLjU1ODEsIC0zOS4yNTIyLCAtNDUuNjc0NCwgLTQxLjQ3MTMsIC0yNC4zMzk3LCAtMzcuMzUxNywgLTQ2LjU0NjIsIC01My4wMDM1LCAtNjcuMjYxNSwgLTIxLjE0NDQsIC0zMC44ODE3LCAtNDAuOTQyNSwgLTQ4LjA3ODAsIC01Ny4xNzY1LCAtMjEuMzM3NywgLTIzLjIzMjUsIC0zNS4yMjU3LCAtNDMuMzcwNSwgLTUwLjI3NjcsIC0yNi42MDYxLCAtMTYuMTY3OSwgLTI5LjQ1MTcsIC0zOC40MTU5LCAtNDQuNzY0OSwgLTYyLjgyMTgsIC05LjUxODk4LCAtMTIuMTYwMSwgLTE5Ljg2NjgsIC0yNy4yMDY5LCAtMzQuNTk1MCwgLTI1Ljg3NTYsIC0yNS4wMTQzLCAtMzcuNTQ0MywgLTQ1LjkzMTgsIC01Mi41ODkxLCAtMjYuNTc2NywgLTguNDU1NjksIC0xNC4xNTMwLCAtMjIuNzEzNiwgLTI5Ljc3MDEsIC0zOC4yMTkzLCAtMTQuOTUwNCwgLTI1LjM1ODAsIC0zNS4yNTkxLCAtNDIuMjc0MywgLTUxLjg1NjMsIC0xMi43NDM3LCAtMTAuNzcxNiwgLTE3Ljc2MzksIC0yNS41ODEwLCAtMzIuOTQzOCwgLTI4Ljg3NDAsIC0yMy4zNTM2LCAtMzYuNDY2MiwgLTQ1LjIwODIsIC01MS42MTI1LCAtMzkuNTMxNSwgLTguMjAxMTEsIC0xMi45OTUwLCAtMjEuMzk5NywgLTI4LjQ5NjYsIC0zNi4yMzA5LCAtMTUuNTk0MiwgLTIzLjc0MTMsIC0zNC4xOTkwLCAtNDEuNTkwNSwgLTQ5LjkwMDUsIC0yNy42MjUxLCAtMjkuMDQzMCwgLTQxLjEzODUsIC00OS4zMjEzLCAtNTYuMTg5NywgLTMzLjI2ODgsIC0yMi4wNjg3LCAtMzUuMzQ2MCwgLTQ0LjM0NTEsIC01MC42OTY3LCAtNTQuMjQyMiwgLTE3LjgzNzIsIC0yOS4xNDUxLCAtMzguODI3MywgLTQ1LjY4MzQsIC01Ni4xMzM3LCAtMTYuNzg0NiwgLTIxLjkwNDAsIC0zMy4xMjk0LCAtNDAuOTIwMSwgLTQ4LjM1ODIsIC0zMC4yMjIwLCAtMjcuMjExMiwgLTQwLjA1NjYsIC00OC42MTAxLCAtNTUuMTI0NSwgLTM5LjQ0MTAsIC0yMS4yMzU1LCAtMzQuMTcxMCwgLTQzLjQwMjYsIC00OS44NzI3LCAtNjMuODQzMSwgLTE4LjIwNDIsIC0yNy42NDk2LCAtMzcuNzc5OSwgLTQ0Ljk2NTEsIC01My45MDIwLCAtMTguNjA0MSwgLTE5Ljk1MzksIC0zMi4wNjI2LCAtNDAuMjYwMiwgLTQ3LjExMDUsIC0zMy4yNDUyLCAtOC40MTczOCwgLTEzLjc2NjYsIC0yMi4xNDI4LCAtMjkuMjg5MSwgLTM3LjIwNTUsIC0xMC4yMDgyLCAtMTEuNjk2NSwgLTE5LjM1OTcsIC0yNi43NDMxLCAtMzQuMDUzMSwgLTE1LjMzODQsIC05Ljc5MzMxLCAtMTYuNDgwNywgLTI0LjYwNDQsIC0zMS43NzEwLCAtMzAuNzg2NywgLTE1LjQyNjgsIC0yOC41MzkwLCAtMzcuNjg3NiwgLTQ0LjEwNDMsIC01Ny42MDUxLCAtOS4wOTA3MCwgLTEyLjM1MDUsIC0yMC4zODk3LCAtMjcuNTkxMCwgLTM1LjA2MzksIC0yMy4wMDAxLCAtMjcuNzEzNCwgLTM5LjA0NzUsIC00Ni44NjkwLCAtNTQuMjE4MCwgLTIxLjI4MjcsIC04Ljk0NjM1LCAtMTQuODc2MCwgLTIzLjM5MTcsIC0zMC42NDI3LCAtMzYuNTAxMSwgLTE0Ljg5NDQsIC0yNy4yOTI5LCAtMzYuNjk2NiwgLTQzLjMxMzcsIC01NS41MTk1LCAtMjQuMzI0MiwgLTMzLjQ4NTYsIC00My42ODkwLCAtNTAuOTExMiwgLTU5LjcwNDUsIC0yNC45MjI1LCAtMjUuNzUwNSwgLTM3Ljk2ODcsIC00Ni4yMDc5LCAtNTMuMDAwMiwgLTMwLjk0ODYsIC0xOC45MTE5LCAtMzIuMTczOSwgLTQxLjE5NzMsIC00Ny41NzA4LCAtNTMuNzMzNywgLTE0LjgzODYsIC0yNS45MzUyLCAtMzUuNjY3NCwgLTQyLjU2MDIsIC01Mi43NzgyLCAtMjUuMjgwOSwgLTMxLjc0NDEsIC00Mi42MjQ1LCAtNTAuMjQ2OCwgLTU3Ljk4NzcsIC0yNy42MTgwLCAtMjMuOTY5NSwgLTM2Ljg5NDksIC00NS41MDE5LCAtNTEuOTcxNiwgLTM3LjQ2MjQsIC0xOC4xMzg3LCAtMzAuOTg5NiwgLTQwLjI0ODIsIC00Ni43NDkxLCAtNjAuMzUxOSwgLTE1LjI3MzEsIC0yNC40MTUzLCAtMzQuNjIxMiwgLTQxLjg1NjQsIC01MC42MjgxXSxcbiAgICAgICAgZ2FpbjogMyxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9oYXRzX3BlcmNzX21vZGVfMi53YXYnLFxuICAgICAgICBzdGFydE9mZnNldDogMC41ICogNjAgLyAxMjIsXG4gICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgaW50ZW5zaXR5OiBbLTg2LjM1MzQsIC04Ni4xMTM0LCAtODcuMzI3MywgLTI4LjkyMTUsIC0xNS45ODUxLCAtMjUuODAxOSwgLTMyLjk3MzIsIC00Mi4yODYzLCAtNTEuMzkyOCwgLTE1Ljk2NjksIC0yNC4xOTAzLCAtMzQuMTk2MiwgLTQzLjMyMzAsIC00OS45Mzc2LCAtMTEuNDQ4MSwgLTEwLjk2NDQsIC0xNi41Mjk0LCAtMjEuNjIyOCwgLTI4LjMxNTksIC0yMS4yMDIwLCAtMTIuOTY3NSwgLTIzLjk2NTgsIC0zMi4zOTQxLCAtMzkuOTU0MSwgLTQzLjU1MDgsIC0yNC4xMDU1LCAtMzYuODY3NiwgLTQ2LjE2NDEsIC01Mi42ODIyLCAtNjUuODk3NywgLTE2LjY2NjUsIC0yMi4zNDQ1LCAtMzIuMTQyMSwgLTQyLjExMjQsIC00OC40MzY1LCAtMTQuMzEzNywgLTEwLjExNDIsIC0xNi43OTE4LCAtMjMuODg1MywgLTMwLjQ0MjMsIC0yNi45OTc3LCAtMTMuMzc4MiwgLTI0Ljk3MDUsIC0zNC43MjU4LCAtNDIuMDQxNCwgLTUwLjI1ODYsIC0yMy44Mzg0LCAtMzUuNTY0MywgLTQ1LjE0NDAsIC01MS45MjQ0LCAtNjIuODgyMCwgLTE2LjYyODcsIC0xNi43NDk1LCAtMjYuMzQxNiwgLTM2LjIxNjMsIC00My4xMjIxLCAtMTkuODUwNCwgLTguOTIzNTUsIC0xNC41MDExLCAtMTguNDEwNCwgLTIyLjUxNTIsIC0yOC4zMjg1LCAtMTMuMTQxNywgLTIzLjAzOTYsIC0zMy41OTEzLCAtNDAuNzcwNCwgLTQ5LjYzMTIsIC0xNS45NzI1LCAtMTkuMDExMiwgLTI3LjY2NTcsIC0zOC43OTk4LCAtNDUuNjc5NiwgLTIyLjA3NDMsIC0xNi41ODA0LCAtMjEuOTA0MSwgLTI0LjYxMDEsIC0yOC4wNTY3LCAtMjQuODc5NSwgLTkuMDEwNzUsIC0xNC41NTQ3LCAtMTkuOTcxOCwgLTIwLjUwODAsIC0yOC4zMjg0LCAtMTEuNTA4NSwgLTE4Ljc1MDYsIC0yNi4wNTM0LCAtMzEuMDc4NiwgLTMyLjA4MTYsIC0yMy4yNzE5LCAtMjAuMjQ4OCwgLTI2LjU2NTEsIC0yNS40NTIzLCAtMjUuNzkzNywgLTI3LjUwOTMsIC0xNS42Nzc2LCAtMjYuNTU3MCwgLTM2LjM2MDUsIC00My4zMjc5LCAtNDYuODk5MywgLTguNDQ1NTAsIC0xMi4wMTIzLCAtMTcuNzcyMSwgLTIzLjUwNTcsIC0yOS40OTAwLCAtMTYuMDkyMSwgLTE4LjEzNzIsIC0yOS4zNTI2LCAtMzcuOTc3NSwgLTQ0LjE0NTQsIC0zMS40MzE0LCAtMjYuNTU1NywgLTM5LjQxODUsIC00Ni41MjI5LCAtNTAuMTU5MywgLTM5LjQ4NjAsIC0xMi43MjczLCAtMTkuNDUzNiwgLTIyLjkxOTUsIC0yNy4zOTUzLCAtMjguMTkyMSwgLTkuOTU3OTIsIC0xMi42Mzg1LCAtMTguOTcwNywgLTI0LjE5NTAsIC0yOS45MDk0LCAtMTcuOTYwNiwgLTE2LjIxOTQsIC0yNi42Mzg0LCAtMzEuMDg2MCwgLTMyLjA4NzcsIC0yOC45NDYyLCAtMTUuNDA1MCwgLTIzLjM1MjMsIC0yNS4wNDY4LCAtMjUuMTEzMywgLTI2LjY5NDAsIC0xNS42OTQ3LCAtMjMuMTc0MiwgLTMwLjc2MTYsIC0zMi40NzA0LCAtMzIuNTIwMywgLTEyLjQ4MzMsIC0xMC40NDE0LCAtMTUuOTk0NywgLTIwLjMwMDAsIC0yNC4yOTk2LCAtMTkuNzMyNywgLTEyLjA3MDEsIC0xOC44MTMyLCAtMTUuMzYzNCwgLTMwLjI5MDcsIC00MC44NDYwLCAtMjQuMzM3MCwgLTM3LjMzMzUsIC00Ni41NDY2LCAtNTIuOTk2NSwgLTY3LjIwNjYsIC0xNy40NjA1LCAtMjEuMDUwNCwgLTMxLjU4MDYsIC00MS4zNjg4LCAtNDguNjk0OCwgLTE2LjUxMTIsIC0xMC4zODUwLCAtMTYuNzE2NiwgLTIzLjM0OTIsIC0zMC4wNjI2LCAtMjYuMjI1NiwgLTE2LjE5MjEsIC0yOS40Nzc3LCAtMzguNDI0OCwgLTQ0Ljc2MjMsIC02Mi44MDAxLCAtMTYuNTg4OSwgLTIxLjQwNjEsIC0yOS4xMDI3LCAtNDAuNTE3NSwgLTQ3LjM1OTAsIC0yMS43MjMwLCAtMTguNTM3OSwgLTI5LjcwNzIsIC0zOS42OTIzLCAtNDYuNDQxNiwgLTI0LjU0MDIsIC04LjY5NjU1LCAtMTQuMTEzNSwgLTE5LjI1NDksIC0yNS42NTM0LCAtMzAuNjkwMCwgLTExLjc3NjIsIC0xOS44MDA0LCAtMjguMDcyMiwgLTM3Ljg3NTgsIC00NS4yMzc5LCAtMjUuODA1OSwgLTMwLjk4MDMsIC00Mi4yMTI5LCAtNDkuOTg3OCwgLTU3LjQzNDYsIC0yNS4yOTMxLCAtMTYuODUwOSwgLTI3Ljk0NTgsIC0zOC4xODI5LCAtNDUuNDU4MiwgLTM2LjcwODcsIC04LjIyNzc0LCAtMTMuNTk0MywgLTIwLjY3OTMsIC0yNy41NjU0LCAtMzQuMDU5OSwgLTEzLjg1OTAsIC0yMC4yNzcyLCAtMzAuMTg5OCwgLTM5LjM1MzcsIC00Ni4yMjI1LCAtMjcuNTk1NSwgLTI5LjAzNzQsIC00MS4xMzI4LCAtNDkuMzMzNywgLTU2LjE4NjgsIC0zMS4yMzYwLCAtMTMuMDEwOCwgLTIyLjkxODksIC0zMC42MzA1LCAtMzkuOTE3MywgLTQ3LjkzMDEsIC05LjEzOTQxLCAtMTEuOTQxNSwgLTE3LjQ3MzksIC0xOC44Mzk1LCAtMjYuNjA4NSwgLTE1LjkxNzcsIC0xNy43Mzc0LCAtMjguNDI0NCwgLTM3Ljk4MDQsIC00NC45NDgxLCAtMjYuNzU4NSwgLTE0LjQ5NjgsIC0yNC42NDUwLCAtMzIuNjQ1NCwgLTQxLjU2MDgsIC0zOS4xODE1LCAtMTUuNDYyMSwgLTIwLjQyMDEsIC0yMy40NTA2LCAtMjcuMjQwNywgLTI4LjE2NjMsIC0xMS4xMjQ0LCAtMTIuMTYzOCwgLTE4LjQzMjYsIC0yMy43NTc2LCAtMjkuNjI4MSwgLTE3LjQ0NjUsIC0xMy42NzA0LCAtMjMuODYyMiwgLTI5LjY3MjksIC0zMi4yODQwLCAtMzEuMTY0MCwgLTIyLjY2NjEsIC0yNy42NjYwLCAtMjYuMjg1OCwgLTI1LjMyNjksIC0yNi43ODAyLCAtMTcuMDg4OCwgLTIyLjIyNTgsIC0zMi4yNjcwLCAtNDEuMDc2NSwgLTQ1LjcyMzYsIC0xNC4xNjk0LCAtOS41NzkxNCwgLTE1LjMzNTMsIC0xOC4wMTE0LCAtMjMuOTk0NCwgLTI3LjIwNDcsIC0xMy4wMDQ5LCAtMjQuNTMzMiwgLTM0LjUyMzMsIC00MS4wODg1LCAtNDguNjQ0MywgLTE5LjA4NjgsIC0yNi4xNzU3LCAtMzUuODA3NiwgLTQ0LjAzOTEsIC00OS4wNzA1LCAtMTYuNjQwOSwgLTE1Ljg4MjcsIC0yMS40NDkxLCAtMjUuMjM1OSwgLTI3LjgwMzMsIC0xOS4wMzQzLCAtOS40OTg1NCwgLTE1Ljk3MzQsIC0yMS44MzUwLCAtMjcuNzI2NiwgLTMxLjA3OTEsIC0xMi44Mzg5LCAtMjMuMTU0NCwgLTI5LjUyNTUsIC0zMi4wNTIwLCAtMzEuNDUxNCwgLTE3LjI1NDgsIC0xOS44MzA2LCAtMjQuNTYyNiwgLTI1LjE0MTcsIC0yNS43MDIyLCAtMjEuNDc2OCwgLTE3LjQ2MjYsIC0yOC4wNTQ2LCAtMzIuNjg0MiwgLTMyLjMzMzksIC0yNi4yOTI1LCAtOC41MDI0NCwgLTEzLjQ1MDMsIC0xOC4yOTgwLCAtMjIuODg4OSwgLTI0LjgwMzAsIC0xMS4zMjQzLCAtMTcuNjg0NiwgLTE3LjQxMDcsIC0xOC40MDMxLCAtNDQuOTc3NywgLTI1LjI3MjIsIC0zMS43MzY1LCAtNDIuNjE5NSwgLTUwLjI1NzAsIC01Ny45NjY4LCAtMjYuNDY1MiwgLTE2LjM3MDIsIC0yNy4yNjI2LCAtMzcuNzYyMiwgLTQ1LjM3MjgsIC0zNy4yMTMzLCAtOS4xNTU3NywgLTEzLjY4ODIsIC0yMC42NTAxLCAtMjYuOTU3OCwgLTMzLjY1OTAsIC0xNS4yOTczLCAtMjQuNDU0OCwgLTM0LjYwNTcsIC00MS44NTE1LCAtNTAuNjI4N10sXG4gICAgICAgIGdhaW46IDEsXG4gICAgICB9LCBdLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzb3VuZHNjYXBlJyxcbiAgICAgIGxheWVyczogW3tcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9zb3VuZHNjYXBlX21vZGVfMS53YXYnLFxuICAgICAgICBzdGFydE9mZnNldDogMC41ICogNjAgLyAxMjIsXG4gICAgICAgIGxlbmd0aDogOSxcbiAgICAgICAgaW50ZW5zaXR5OiBbLTg2LjkyMDYsIC04Ni45NTYyLCAtODYuNDEzMiwgLTgyLjg2MzAsIC01MS45NzMzLCAtNDYuMTg5NiwgLTQ3LjY0NDcsIC00Ni4xMjQ2LCAtNDEuNzc0NywgLTQxLjY2OTYsIC00MC4wMTgwLCAtMzguODUzMiwgLTM3LjY0MTgsIC0zOS45MTMwLCAtNDAuOTk1MywgLTM5LjYxMDYsIC0zOS41ODI1LCAtMzcuMzgyNiwgLTM2LjMwODksIC0zNi40Njc1LCAtMzguMDU5NSwgLTM2LjAxOTIsIC0zMi4yMjg0LCAtMjkuODUxNiwgLTM0LjgzNjYsIC0zNC40NzY5LCAtMzEuODkzMSwgLTMwLjQ2NDQsIC0yOC42Mzk1LCAtMzAuNTQ0NCwgLTMwLjg4MDYsIC0yNy40OTU5LCAtMjguNzI5NCwgLTM1LjEyMTksIC0zNy41NTI2LCAtMzguMDk0NywgLTM2LjEyMDIsIC0yOC4xMzk2LCAtMjcuMzQ3MCwgLTI5Ljc0MTksIC0yOS4xNjM5LCAtMzAuOTUyNCwgLTM0Ljk0OTksIC0zOC4yMDY5LCAtMzUuNjgyMCwgLTMxLjU4MjEsIC0yOS4yMDAzLCAtMjkuODE4NCwgLTI5LjAzMDEsIC0zMC40NDY2LCAtMzQuNDA5MCwgLTM4Ljg3MjIsIC0zOS4xMTQ0LCAtMzAuMzk4MSwgLTMwLjc2MDgsIC0yOS4wMDQ0LCAtMjguNjM5OCwgLTMwLjcxNTAsIC0zMS41ODUyLCAtMzAuODg0NSwgLTI5LjU5MzMsIC0zMC4wNTU3LCAtMzAuNjIwMSwgLTMyLjM4NTMsIC0zNC4zMzUyLCAtMzYuMjAyNSwgLTQxLjY2NDYsIC00NS4wMTAzLCAtNDEuOTYyNiwgLTM0LjcwOTQsIC0zNS44MDgwLCAtMzQuNjg0NCwgLTMzLjg1ODQsIC0zNS4zOTU4LCAtMzYuNDY2NywgLTM1LjI0NzgsIC0zNS4yMjQ4LCAtMzcuNDQ3OCwgLTM5LjE0ODQsIC0zOS43NTA3LCAtNDMuMjQwNywgLTQ0LjUxMzAsIC00Ny40OTE4LCAtNTAuMDAzMywgLTQ2LjM0ODAsIC00NC4wMTU3LCAtNDMuMzEyNiwgLTQyLjg1OTMsIC00Mi45OTE4LCAtNDIuNDYzOSwgLTQzLjQ5NzQsIC00My4zNjYxLCAtNDUuNzE0NywgLTQ3LjU3NzIsIC00Ny4zMTMzLCAtNDcuNjk3NiwgLTQ5LjU3OTUsIC00OS42Njk3LCAtNTEuMzUyNCwgLTU0LjM3NDcsIC01My4xMjI4LCAtNTEuNjc2NSwgLTUwLjU5NjQsIC01Mi4wNzk0LCAtNTEuMjg2MywgLTUxLjc0NjAsIC01MC44MDI2LCAtNTEuNTYxMCwgLTUwLjk0MzQsIC01MS4yMDk3LCAtNTEuNTkzOCwgLTUyLjEzNzEsIC01NC4zOTYxLCAtNTYuOTE2MywgLTU4LjMxMTIsIC01Ny40NDgzLCAtNTQuNjgyMiwgLTU0Ljg4OTEsIC01My43MTM1LCAtNTMuMjQxNCwgLTU0LjA4NDYsIC01My4wMTkzLCAtNTQuNzMxNCwgLTU1Ljc4NjgsIC01My4zNTE0LCAtNTIuNzA4MSwgLTUyLjkwMTgsIC01NS44OTUwLCAtNjAuMjIyNywgLTYwLjU2MjksIC02Mi44NjE5LCAtNjEuMjY1MCwgLTU3LjQ3NzgsIC01Ny45MDkzLCAtNTcuMDg0MCwgLTU2LjEyNjIsIC01OC4xMzAzLCAtNTguNDQ3OCwgLTU4LjAwNDEsIC01OS43NjUwLCAtNTcuOTY1MywgLTU4LjA2NjMsIC01OS4zNzI5LCAtNjIuMTA4NywgLTYxLjEzNTcsIC02My43NTk0LCAtNjguODEwOSwgLTY2LjgyMjUsIC02NC43MjU1LCAtNjMuNDM2MSwgLTYzLjc1NDAsIC02MC4xNTUxLCAtNjIuMTk3NywgLTYxLjQ5OTcsIC02MS44ODAzLCAtNjIuODYzMiwgLTYyLjY1MDcsIC02NC40NjQyLCAtNjUuNDE3MiwgLTY3Ljg4NzcsIC02Ni45OTIwLCAtNjcuMTg0NiwgLTY4LjI2ODMsIC02OC4xMzM2LCAtNjcuMjE3OSwgLTY5LjcwMzMsIC02Ny41ODIzLCAtNjcuNzUxOCwgLTY3Ljk3NDEsIC02Ni4xMjM4LCAtNjkuMjY2MywgLTcwLjQxNzksIC03MC41Mzc5LCAtNzEuNzI1MiwgLTc0LjE4MzAsIC03MS40NjMxLCAtNzAuNTU3OCwgLTcwLjM5ODgsIC03MS44Mjc2LCAtNzQuMTEwNywgLTc0LjE1ODEsIC03NC4xMzgzLCAtNzMuMTM2MSwgLTczLjQ5MDMsIC03My42Mjg1LCAtNzQuNTkwMiwgLTc1LjA0OTUsIC03NC45NjY5LCAtNzMuNTg3OCwgLTc1LjI1NTcsIC03Ny40NzcwLCAtNzcuMTY5NSwgLTc3LjAzOTIsIC03OC4yMzU5LCAtNzcuMTg0MywgLTc3Ljk4NjksIC03OC40NjQwLCAtNzcuNzgwOCwgLTc2LjA3NTYsIC03Ny40MjY3LCAtNzguNTM4MiwgLTc3LjgyNTcsIC03OS42OTA0LCAtNzkuMjQ3NCwgLTc5LjAzMzksIC04MC44MjcxLCAtODIuMTc1NiwgLTgxLjIzNzIsIC04MC4zNjgwLCAtODEuMzc4MiwgLTgwLjU4NTksIC04Mi4xODI3LCAtODMuMzU0NSwgLTgyLjcxOTYsIC04Mi4zODA3LCAtODIuOTEzMiwgLTgyLjg4NDEsIC04My4yODcwLCAtODQuODc0NywgLTgzLjc0MjEsIC04My41NTQ3LCAtODQuMjQ1NSwgLTg0Ljk4MTYsIC04NC45MTc0LCAtODQuNjEzNCwgLTg0Ljk2MDksIC04NS4zMjUwLCAtODUuMTkwOCwgLTg1LjEyMjIsIC04NC44OTYxLCAtODUuMjkyMCwgLTg0LjY5NjMsIC04NS45NzE2LCAtODUuNjY1OCwgLTg2LjAxMTMsIC04Ni4xNzA5LCAtODUuNjk4NSwgLTg2LjA2OTgsIC04Ni4yMTQxLCAtODYuNjI1NiwgLTg1LjkyNTUsIC04Ni4yMTU4LCAtODYuMTMyNiwgLTg2LjUzNDAsIC04NS42MTI0LCAtODYuMjMxNSwgLTg2LjAzMDAsIC04NC4zMzg5LCAtNjQuNTEwNSwgLTU3LjYwNjcsIC01Ni4wOTU1LCAtNTIuMzk0NywgLTUyLjc3OTUsIC00OC4xODY1LCAtMzcuNTg4NywgLTM3LjIzNjMsIC0zNi4xNDIxLCAtMzQuNjUyOSwgLTMwLjY1MzcsIC0yOS4zNzA1LCAtMzEuOTU2MSwgLTM2LjY1MzQsIC0zMy45NTI5LCAtMzAuMTIwMiwgLTMxLjMxNjcsIC0yOS43OTA0LCAtMjguMTA3NCwgLTI5LjE3NDYsIC0zMS4xNzQ4LCAtMzMuNzQxMSwgLTM3LjY0MTUsIC00MC40MDI0LCAtNDEuNTExNCwgLTMwLjI4NDgsIC0yOS41NjU1LCAtMzMuMjcyNiwgLTMxLjkwMjMsIC0zMi4xNTQyLCAtMzAuODM5NiwgLTMxLjg3NDksIC0zMi4wMTAwLCAtMzEuNTc4MiwgLTMxLjcyNTQsIC0zMy4zNzQ0LCAtMzYuOTI0MSwgLTQyLjk2ODcsIC00My4zNzQyLCAtMzguNjQ0MywgLTM3LjA5MzgsIC0zNS43NTExLCAtMzYuMDc0NiwgLTM3LjQwNzAsIC0zNi40ODYwLCAtMzQuMzE2MywgLTM2LjAzNzcsIC0zOS42OTYyLCAtNDQuMDUyNywgLTQzLjU0MjQsIC00Mi41ODM3LCAtNDQuODc2NCwgLTQ1Ljc4MDcsIC01MC4zNzk5LCAtNDkuNzg2MiwgLTQ4LjI5ODgsIC00OS42ODM5LCAtNDcuMzg2NSwgLTQ2LjE1ODMsIC00Ny4yMTU1LCAtNDYuNjM4OCwgLTQ2LjQzMzEsIC00OC40NTA1LCAtNDkuNTk1NiwgLTUwLjEwMTcsIC00OS42MzUyLCAtNTAuMTYxMywgLTUwLjM3NTMsIC01Mi4wNDEwLCAtNTQuODc2NSwgLTU0LjY3MDEsIC01My4xNTg5LCAtNTMuMTg0NCwgLTUyLjU3NzcsIC01My4yMTg4LCAtNTEuODMzMiwgLTUwLjIzMTIsIC01MS42Mjc0LCAtNTMuODk4MSwgLTUxLjg5ODAsIC01My4yMDg1LCAtNTIuNTYwOCwgLTU1LjU5OTAsIC01Ni44MzU5LCAtNTkuMjgyMSwgLTYwLjYyNDAsIC01OC4wNzk2LCAtNTcuMjYwNCwgLTU2LjcwMjIsIC01My41MDYxLCAtNTQuNzQzMywgLTU0Ljc1NjEsIC01NC4zODA2LCAtNTUuODQ5NCwgLTU3LjkzNDgsIC01NC42OTkxLCAtNTQuNjQxNiwgLTU1Ljk3MDcsIC02MC4wNDczLCAtNjQuMDcxNCwgLTY1LjkyMjQsIC02NS43MDM1LCAtNjAuMTU0NywgLTU3Ljk2NzUsIC01Ny44MjA1LCAtNTYuMjkwNSwgLTU3LjU0OTUsIC01OS4xOTQxLCAtNTguMzA2NiwgLTYwLjYxOTUsIC01OS4xMDU5LCAtNTcuNzA2MCwgLTU3Ljg4MDIsIC02MC42MjM5LCAtNjMuNzQ5MiwgLTY0LjU1MDQsIC03MC42NTA2LCAtNjkuNjA2NywgLTYxLjczMTMsIC01Ny44MzQ1LCAtNTkuNjU3NSwgLTYwLjc1OTksIC02MS40MjIzLCAtNTkuOTA1OCwgLTU5Ljc3MDcsIC02My4yMTI5LCAtNjIuNTE1MCwgLTU2LjA4ODIsIC00OC43MjUyLCAtNDYuMDY1NiwgLTQzLjk0MTIsIC00NS4zMTQ2LCAtNDcuNzEzOSwgLTUzLjE5MzUsIC01NS45NzI5LCAtNTEuMjc3OSwgLTQ5LjIzNTAsIC00OS4yMzQ4LCAtNDkuOTEzMSwgLTUxLjg0MjYsIC01Mi4xMjQ1LCAtNTIuNjUzNiwgLTQwLjE3ODAsIC00MS4zMjg3LCAtNDAuMzAxNCwgLTM3LjUzNTIsIC0zNS45NDEwLCAtMzguMTI3MiwgLTQwLjE1NzYsIC00My4wNDk3LCAtNDAuMzY4NiwgLTM4LjcxMTksIC0zNS40Njc5LCAtMzIuMTQzMywgLTMyLjM0OTgsIC0zMS43NzUyLCAtMzAuMTI1OSwgLTI4LjEzOTAsIC0yOS40NjgzLCAtMjguNDQ1OSwgLTI3LjI5MDIsIC0zMS42OTY0LCAtMzMuOTQ1NSwgLTM0LjY1ODksIC0zMS4yODkzLCAtMzAuNTY2MiwgLTM1Ljg4OTIsIC0yOC4yNjY4LCAtMzMuMjkwMiwgLTMxLjIzOTQsIC0zMS45MTEwLCAtMzIuOTYyNywgLTI3LjU0OTAsIC0yNy44NzE0LCAtMzEuNTEzMSwgLTMxLjI3MjIsIC0zMS45NDg4LCAtMzMuOTQ2MSwgLTMzLjI1MTEsIC0zNS45NjQ4LCAtMzcuOTgxMiwgLTM5LjYyMDIsIC00NC4yMTI2LCAtNDIuMDU0MCwgLTMzLjkyOTEsIC0zNC43MjczLCAtMzYuMzkzNiwgLTM2LjU3NzMsIC0zMS42MjA4LCAtMjguNTIwMywgLTMwLjgyMjcsIC0zMi40MTg5LCAtMzMuODQyOCwgLTMyLjM0MjUsIC0zMS42ODg4LCAtMzEuNDUzOSwgLTMyLjU1MTksIC0zNC4xMzM2LCAtMzIuNzM3MywgLTM3LjAwNDgsIC0zOS4xOTkxLCAtNDEuNTQ2MywgLTQzLjkyOTAsIC00My41OTUwLCAtMzguMjA5MywgLTM1LjU5MTYsIC0zNS4zOTQ4LCAtMzkuNzQ2OSwgLTQxLjUyMzcsIC0zNy4zOTc1LCAtMzcuMDE5MiwgLTM3LjkzMjcsIC00MC4zOTE2LCAtNDAuODU2MiwgLTQwLjM0NTgsIC00NS4yMTUzLCAtNDcuMTkzNywgLTQ4Ljc1MjUsIC01MC43MjY4LCAtNTAuMzY2OCwgLTQ2LjkwNTUsIC00NS4zNzQ5LCAtNDYuNjkxOSwgLTQ4LjMzNjUsIC00OS42Mjc3LCAtNDcuNjYzNCwgLTQ5LjY1ODcsIC01MC4yNDUwLCAtNTAuMTY0MCwgLTQ4LjkwNjEsIC00NC42MjY5LCAtNDkuMDA4NiwgLTUwLjM1MTMsIC01NC4xMTE4LCAtNTYuMjg2NCwgLTU1LjA5NDIsIC01My4zMTYyLCAtNTIuMDMxMiwgLTUzLjA0NTYsIC01NS42NzgyLCAtNTUuNjI0NiwgLTU0LjM0MzMsIC01NS4yNzU0LCAtNTYuNTYwNiwgLTU1LjYyNDAsIC01NC45NDE2LCAtNTMuNjQyOSwgLTU3LjY0MTQsIC01Ny44MjI5LCAtNjEuMzc1MywgLTYxLjc1OTAsIC02MC4wOTg3LCAtNTcuODEyMSwgLTU5LjQ1ODIsIC02MC42ODA1LCAtNTkuNzE3NSwgLTYxLjQ0NzMsIC02MC41NzY0LCAtNjEuNzIzMCwgLTYxLjEzODYsIC02MC40MTU3LCAtNjAuMzUxOSwgLTU3Ljk2MzIsIC02MS44OTExLCAtNjAuNzgzNywgLTQ5LjIzMzMsIC01MS41NDMwLCAtNTEuOTMxNSwgLTU0LjcyODMsIC01OS4xMTQwLCAtNTkuOTAzNCwgLTU4Ljc5NDksIC01OC4xODQ5LCAtNTYuOTE0NywgLTU2LjIxNTQsIC01My45NzMxLCAtNTIuMTYxNywgLTU1LjQ5NDYsIC01My4wMTYwLCAtNTUuODIyNSwgLTU3LjI3NDAsIC01MS4yNzIwLCAtNTAuMzAxNywgLTUxLjYwMzMsIC01My44NTc4LCAtNjAuMTMzNiwgLTYzLjcxMDcsIC02MS45NDU5LCAtNTguMDYyNCwgLTU3LjY0MTYsIC01Ni4wNTEyLCAtNTQuNTQ3OCwgLTU1LjA5MDAsIC01NS45ODczLCAtNTcuMDI3NSwgLTU3LjM4NzAsIC01OS4zNDU3LCAtNTYuMTQyMSwgLTUyLjQyNDIsIC01MC45OTExLCAtNDguMTIwNiwgLTUwLjcyMTksIC01NC43Mzk5LCAtNTUuOTA2MSwgLTU2LjQ5NTYsIC01NC4zNzMzLCAtNTcuMjA0NSwgLTU3LjU2ODUsIC01Ni4zNTcyLCAtNTUuNjI1OCwgLTUzLjM0NDcsIC01MC4yNzQ3LCAtNDguODc3NiwgLTQ4Ljc1NzYsIC00Ni4xNjY2LCAtNDcuMTQyNywgLTQ4LjE1MTQsIC00Ny41NjQyLCAtNDkuNTg0NCwgLTUxLjAyMzcsIC01NC4wNDYwLCAtNTMuNjgxMSwgLTU1Ljk1NDMsIC01NS40NjU0LCAtNTQuNTA5MSwgLTU1Ljc2NTksIC01NC4zNTg5LCAtNTMuNDU4OCwgLTUxLjYzMTQsIC01Mi44NzI5LCAtNTIuMjMwMiwgLTUwLjMxODYsIC00Ni4zMTM1LCAtNDUuNDc1OSwgLTQyLjY3NDYsIC00MS4xMzAyLCAtMzIuMDk0NSwgLTI5LjcwNTIsIC0zMi4xNjkwLCAtMzcuOTA1MSwgLTM4LjM4NzgsIC0zOC42MTA5LCAtNDEuODc5NywgLTQyLjQ1NjMsIC0zMy43Mzc0LCAtMjcuOTIzMiwgLTMwLjM0ODksIC0zMi4yNDM5LCAtMjguNDM2OSwgLTI3LjE1NTcsIC0yNy4zMjAxLCAtMzAuNTQxNSwgLTMzLjcxMzcsIC0zNS4wNDAxLCAtMzQuNjA2NCwgLTMyLjYxOTIsIC0zMS4yMTM2LCAtMzAuODQzNCwgLTMwLjM5NTAsIC0zMy4wMjM4LCAtMzMuMTAyMiwgLTM0LjYyNTksIC0zMS43MzE3LCAtMjguNDIyOCwgLTMwLjEwNjAsIC0zMC42MDcwLCAtMjkuMjI5NCwgLTI2LjA1OTEsIC0yNi4yMDQ0LCAtMzAuOTEyMiwgLTMwLjQxNjMsIC0yOC43NjQ0LCAtMjguMDEzMiwgLTI4Ljc4NDksIC0zMC45MDA5LCAtMzEuMTUzMiwgLTMyLjkzODAsIC0zMi44NDUwLCAtMzIuMjMxNSwgLTMxLjQyODYsIC0zMy45NDEyLCAtMzUuODY2OSwgLTM2LjUzMTcsIC0zNS4zMjc3LCAtMzYuNzk5NCwgLTM3LjA2MjQsIC0zNy44OTQwLCAtMzguNjU1MywgLTM5LjE3NzAsIC00MC43NzA5LCAtNDEuMjc0MSwgLTQyLjEwNjIsIC00My41MzIwLCAtNDUuMzIzMiwgLTQzLjUxNTksIC00Mi42NTcyLCAtNDQuNTQ5MiwgLTQ1LjU5MzQsIC00My4yNDA5LCAtNDMuNzc3NSwgLTQ0LjcyNDEsIC00Ny42NDg3LCAtNDYuNjg3OCwgLTQ3LjA4MDUsIC00My45ODY3LCAtNDIuNTI0NywgLTQxLjk2MDIsIC0zOS4xMTc0LCAtMzkuMjIyNCwgLTQ0LjEzOTAsIC00Ni4wMDI4LCAtNDcuMDk4OSwgLTQ3LjMxMzAsIC00Ni41MTc2LCAtNDQuMTk2MSwgLTQzLjQ1MjIsIC00NC4yMTg4LCAtNDguODE2MSwgLTUwLjEzMzMsIC00OS45NTIxLCAtNDguNTk4NywgLTQ3LjMzNjksIC00My41NjQyLCAtNDIuNTE1NSwgLTQ1LjA4NzksIC00Ny45MDY4LCAtNDguMjM2NCwgLTQ3LjI3MzAsIC00OC4zMDkzLCAtNDguOTcwOCwgLTQ3LjIzMTYsIC00Ny45OTY0LCAtNDkuODI5OCwgLTU1LjU0MDEsIC01NS43ODQyLCAtNTIuOTc1NiwgLTUyLjU5ODksIC01MS40MTk4LCAtNTAuNzIxNiwgLTUxLjcwNTcsIC01MS4zMzE0LCAtNTEuNzU1MywgLTUxLjE3NDEsIC01MC45NDA2LCAtNTQuMjgzMCwgLTU0LjExNzksIC01My45NTkwLCAtNTMuNzMxMSwgLTU0LjUyNzUsIC01OS41MDUwLCAtNjEuMTY4NSwgLTU3Ljk2NjgsIC01Ny4wMDc1LCAtNTYuMDYyMywgLTU1LjY4OTQsIC01NS41NzMxLCAtNTYuMDExNSwgLTU2LjI1MzYsIC01Ni4yNTEzLCAtNTguNzY3NywgLTYxLjY1NTcsIC02MC4xOTA5LCAtNTkuNTc4MywgLTYyLjMyMDQsIC02Mi4wODAyLCAtNjguMDc0MywgLTY3LjAwNTQsIC02My44NzY0LCAtNjQuMzI2NywgLTYzLjI1NTAsIC02MS45ODExLCAtNjMuMzkzOCwgLTYyLjc2MzUsIC02Mi41MjY5LCAtNjMuNDAyNiwgLTYxLjk2MjIsIC02MS45MDIyLCAtNjMuODA0OSwgLTY0LjQ0MzIsIC02Ni4zNDEyLCAtNjkuNTcwOSwgLTczLjcyNzcsIC03Mi40NzE0LCAtNjkuMzYwOCwgLTY3LjgxMzcsIC02Ni45NDA5LCAtNjQuNDQxMCwgLTY1LjcwNDcsIC02NS45MjA3LCAtNzAuMTMxOSwgLTcwLjI4NTksIC02Ni42MzUyLCAtNjUuMDEyNSwgLTY2Ljg1NzMsIC03MC42MDkxLCAtNzMuNDM1MSwgLTc2LjAyODYsIC03OS42NjQyLCAtNzYuMzExMSwgLTc0Ljg0OTAsIC03My40MDA1LCAtNzMuMjU0NiwgLTcxLjI3OTEsIC03MS4zMTQyLCAtNzMuNDA4OCwgLTczLjMyNTEsIC03Ny43MDY3LCAtNzUuODUwNSwgLTc0LjQ3NDMsIC03NS43MTQ5LCAtNzguNDY4MiwgLTc4LjUzNjksIC04MC41NTYxLCAtODIuNzUwMywgLTgwLjU2MTIsIC04MC45MzE5LCAtNzguOTI5NywgLTc4LjkxMDRdLFxuICAgICAgICBnYWluOiAtMyxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9zb3VuZHNjYXBlX21vZGVfMi53YXYnLFxuICAgICAgICBzdGFydE9mZnNldDogMC41ICogNjAgLyAxMjIsXG4gICAgICAgIGxlbmd0aDogNSxcbiAgICAgICAgaW50ZW5zaXR5OiBbLTEzNC40MjQsIC0xMzQuNzIxLCAtMTM0LjYyOCwgLTEzNC44MDIsIC0xMzQuMDgwLCAtMTM0LjgxNiwgLTEzNS4wNDMsIC0xMzQuMzMyLCAtMTM0LjI2OSwgLTEzNC4yMjcsIC0xMzUuNTU4LCAtMTM1LjM0MSwgLTEzNC45NTYsIC0xMzQuNzk5LCAtMTM1LjUxMCwgLTEzNC45NTgsIC00Ny4xMzg4LCAtMzguNzc4NiwgLTM3LjA0MzQsIC0zNS4yNTk3LCAtMzMuNTQzMywgLTMxLjc4MDAsIC0yOS4yMzc4LCAtMjcuMzY3NiwgLTI3LjM0ODMsIC0yNS4zNzM5LCAtMjQuMDA4OSwgLTIyLjU2NzUsIC0yMS4zMzE2LCAtMjAuNTExMywgLTI5LjcwNjIsIC0yOC41MzcyLCAtMjcuNzQwOCwgLTI1LjQzNzMsIC0yMy41OTc4LCAtMjIuNzg3NiwgLTIxLjE3NjksIC0xOC43MzM3LCAtMTguNDI0NywgLTE3LjI4NDcsIC0xNi44ODEzLCAtMTUuODUwNSwgLTE0Ljg4ODgsIC0xMy41MTMyLCAtMTIuMTUwOCwgLTExLjUyMTMsIC0xMS4zNzE5LCAtOS45MTI4NCwgLTguMjY0NzgsIC03LjUzNzgyLCAtNy4yNzU3NCwgLTUuOTc0OTYsIC01Ljc2ODQ1LCAtMTUuNTQxMywgLTE1LjQyMTIsIC0xMy45ODcwLCAtMTIuNTA5MiwgLTEyLjEyMjEsIC05LjIwNDQ5LCAtOS41NTIxOSwgLTguNzkzMzksIC03LjkwNTY4LCAtNy4zODIwNCwgLTYuMzQzMDgsIC02LjQ2MTI0LCAtNS4wNzAxNywgLTQuNzY4ODcsIC01LjE4NDg5LCAtNC4zNjA4NCwgLTQuMDg3OTIsIC00LjA0OTM4LCAtMi45NDk2NiwgLTMuMDg4OTgsIC0yLjc5NzAwLCAtMS41OTcyNCwgLTIuMzYzMzUsIC0xMS4wMjg4LCAtMTIuNDQwMCwgLTExLjU5NTQsIC0xMC43MTM5LCAtMTAuNDA0NiwgLTEwLjE1NjksIC05LjE3NDgxLCAtOC42NTU0MywgLTcuMjgwMTEsIC02LjcxNzE4LCAtNi4zNDgyOSwgLTUuMzI0MDYsIC01LjQ2MzU4LCAtNC44MDE3MiwgLTQuODUxODAsIC0zLjY1OTEyLCAtMy40ODIyOCwgLTIuNzIyMTUsIC0zLjAwMjc3LCAtMi43NzY0MywgLTEuMzg1NTgsIC0xLjM3Mzg1LCAtMS40OTI2MywgLTkuODUwNDIsIC0xMS40OTU0LCAtMTAuNzE1OCwgLTEwLjE2OTEsIC0xMC4xMDU2LCAtOC4xNzAyNCwgLTcuMTYxOTQsIC04LjI0MTU3LCAtNi4xMzg3MCwgLTYuNzUzNTksIC02LjM1NTYxLCAtNC45NjEyNiwgLTUuMzc0NzgsIC00LjQyNDcxLCAtNC4zOTIzNSwgLTQuODc0MTIsIC0zLjY1NjM5LCAtMy43MTk4MCwgLTMuOTU2NDcsIC0yLjgzMDk2LCAtMy4zNTM0OSwgLTMuNDAwODMsIC0xLjk2MTA1LCAtMTAuMjU4OSwgLTEyLjg5OTUsIC0xMS43MzIwLCAtMTAuNzA2OCwgLTEwLjc3NjIsIC05LjI5NjM0LCAtOC43NTgxNywgLTguNTYzOTcsIC04LjU1ODM4LCAtNy4xNjAwMiwgLTcuMzc1NjcsIC02LjgxODI0LCAtNi4yNDAyNCwgLTUuMTM0NzUsIC02LjE5MzcxLCAtNS4xMzQ0MCwgLTUuNTg0OTAsIC01LjExNTIwLCAtNC44MDU3OSwgLTQuNTMxMzEsIC00LjI5MTM3LCAtMy44MDYwNywgLTMuNjU1OTAsIC0xMC4zNDExLCAtMTMuODkyOSwgLTEzLjA0MjksIC0xMy4xMjE4LCAtMTEuOTI5OSwgLTEwLjU3MTIsIC0xMC4xODU3LCAtOS42NzI3NywgLTkuNDgyNTYsIC05LjAzMzU0LCAtOC4wMDA2MSwgLTguNzYxNTAsIC03LjE1OTExLCAtNy42MDQ3MiwgLTcuMzk0MzcsIC01Ljk3MzQ5LCAtNi41MjcyMywgLTYuMzQ4MDIsIC02LjMzNTAwLCAtNS4zOTIzMSwgLTUuNTAwOTcsIC01LjAyNzkyLCAtNS4xODg5MCwgLTExLjk4MTgsIC0xNC40NTk2LCAtMTQuMjA0MywgLTEzLjExMjEsIC0xMi44MzkzLCAtMTIuMTI4MywgLTExLjY3NTcsIC0xMC45MjY5LCAtMTAuMTE3NSwgLTEwLjA2MTEsIC05Ljg3MjY4LCAtOC42ODgzNCwgLTkuODUzMDgsIC05LjI1NTI0LCAtOC4zMzYxOCwgLTguMTYxNTksIC04LjUwMzI5LCAtNy43MTE4NiwgLTcuMTY5NTEsIC03LjA0MzAyLCAtNi45OTE1MSwgLTYuMTQ4MDQsIC02LjA0MjEwLCAtMTEuNjIxNSwgLTE2LjcwNzUsIC0xNi4wNjEwLCAtMTQuMzQ3OCwgLTE0LjYwNzksIC0xNC4zNzQ4LCAtMTMuMDEzNywgLTEyLjY0MTgsIC0xMi4wNDU0LCAtMTEuMjgzNiwgLTExLjcwNDcsIC0xMS4wOTQ2LCAtMTAuNDAyNSwgLTEwLjQ3NDUsIC0xMC4xOTM0LCAtOS4xMDY4NCwgLTEwLjI4MDAsIC04Ljc1NzAzLCAtOC45MTY2MywgLTguNjI0NTIsIC04Ljg1OTc4LCAtNy4yNDUzMiwgLTcuNTEwODIsIC0xMi42MjYyLCAtMTguMjU1MiwgLTE3LjM5NzgsIC0xNi4zMzk2LCAtMTUuNzE4NSwgLTE1LjQxNzIsIC0xNC45NzkwLCAtMTQuMzA1NiwgLTEzLjgwMDksIC0xMy44MDk0LCAtMTMuMTE2OCwgLTEyLjYwMTcsIC0xMi42ODg4LCAtMTEuMTYyNywgLTExLjQwNzQsIC0xMS40OTc1LCAtMTAuOTQ5OSwgLTExLjMxNzEsIC0xMC4zNTIyLCAtMTAuMTg1MywgLTkuNjA1NDYsIC05LjU5NjM4LCAtOS4yMTg5NCwgLTEzLjA5MjQsIC0xOS4zNzI3LCAtMTguNzUzNCwgLTE4LjYwMjEsIC0xNy41MTE5LCAtMTYuNzA1OSwgLTE2LjM5NTAsIC0xNi4xMTE4LCAtMTUuMzcwMywgLTE0Ljk4ODYsIC0xNC40ODEyLCAtMTUuMzMwNSwgLTEzLjM5NzcsIC0xMy4yNDcwLCAtMTMuMTM0NiwgLTEzLjYxOTgsIC0xMS44NzQ2LCAtMTEuOTQ5NiwgLTExLjc0ODcsIC0xMi4xODM0LCAtMTEuNDk4MSwgLTExLjA3OTIsIC0xMS4yMjg4LCAtMTQuMzEwMywgLTIxLjQ1MjEsIC0yMS4wNDE2LCAtMjAuMjgxMSwgLTE5Ljg1NTUsIC0xOS41NDM2LCAtMTkuNDgzNCwgLTE4LjYyMTQsIC0xNy44ODkxLCAtMTYuNTc1NCwgLTE2LjY1MjQsIC0xNS41ODAzLCAtMTUuNzQzNiwgLTE2LjI5OTAsIC0xNC44OTUyLCAtMTUuNDYwOCwgLTE0LjY3NjgsIC0xNC40NTU3LCAtMTQuOTgzMiwgLTE0LjY0NDgsIC0xMy41ODUwLCAtMTMuNTg1NSwgLTEzLjMxODAsIC0xNS43MjM0LCAtMjQuNDg1OCwgLTIzLjI3MTEsIC0yMi44NzA4LCAtMjIuNDkzOCwgLTIxLjc1NzksIC0yMC44MTExLCAtMjAuMDY2MCwgLTE5Ljc4MjgsIC0xOS43NDYxLCAtMTguMzg2OSwgLTE4LjM4MjEsIC0xOC4xODI0LCAtMTguNDYyNywgLTE4LjU3MzksIC0xNy4xNzM5LCAtMTguMDc3OSwgLTE3LjE2ODMsIC0xNi42ODkyLCAtMTYuMzczMCwgLTE2LjU5NTEsIC0xNi4yMjEyLCAtMTcuMjgwMSwgLTE4LjA3NzIsIC0yNi42OTE4LCAtMjUuNTg1NywgLTI1LjQ2OTUsIC0yNS4xMDAwLCAtMjQuNTAyMCwgLTIzLjM2MTksIC0yMy4wNTc4LCAtMjIuMDQ3MSwgLTIyLjY3MDksIC0yMS43NzA5LCAtMjIuMjI2NSwgLTIxLjk0NDUsIC0yMS40MzMxLCAtMjEuNDkyMiwgLTIwLjgyOTQsIC0yMC42NDg4LCAtMjAuNjU1NCwgLTIwLjU2ODksIC0yMC4xMTc1LCAtMjAuMzI2NSwgLTE5Ljc1NjgsIC0yMC4xMjU5LCAtMjEuOTQ1NCwgLTMwLjcxMTUsIC0yOS45ODY1LCAtMjguNzY0MCwgLTI4Ljg1NjMsIC0yOC4yNDY3LCAtMjcuODUwMSwgLTI3Ljg0NjIsIC0yNi40ODk3LCAtMjYuNzQ5OCwgLTI2Ljk2MDYsIC0yNy40MDA0LCAtMjUuOTAwOCwgLTI2LjM5NTMsIC0yNi4xNTUxLCAtMjUuNjA1NSwgLTI2LjI2NjEsIC0yNS40NzE1LCAtMjYuMTQ3NSwgLTI1Ljk3OTksIC0yNS45ODAyLCAtMjUuOTQ0NiwgLTI1Ljc2MDgsIC0yNy45MjM3LCAtMzcuMjUxMywgLTM2LjA0MDEsIC0zNS42OTk4LCAtMzUuNDUzOSwgLTM1LjQ2NDcsIC0zNS4xNTgxLCAtMzUuNDU4OCwgLTM1LjUyMDQsIC0zNC44OTI4LCAtMzUuOTExNSwgLTM1LjIzODQsIC0zNi44NjcwLCAtMzUuOTM5OSwgLTM3LjAxNzEsIC0zNy42MDQyLCAtMzcuNjA5MiwgLTM3Ljc3NzAsIC00MC41MDc0LCAtNDEuNDc2OCwgLTQyLjM0MDMsIC00NC41OTgwLCAtNDYuMzg5MiwgLTQ3LjMwMDUsIC01MS42MzA4LCAtNTAuODY5MSwgLTUwLjM1MDUsIC00OS44NjkyLCAtNDkuOTIzOSwgLTUwLjA5MDcsIC00OS41MTc1LCAtNDkuNzQ0MCwgLTQ5LjUyNzUsIC00OS42NjY0LCAtNDkuNDcyNiwgLTUyLjc0MDYsIC01NC4zMDczLCAtNTMuNDk1NywgLTUzLjMwNTEsIC01My4xNzM3LCAtNTIuNzgyMCwgLTUyLjU0NzEsIC01Mi41NTUwLCAtNTIuMDgyOSwgLTUyLjAzMTUsIC01MS42MTExLCAtNTIuMjg3MCwgLTU2Ljk4NzEsIC01Ni42OTA5LCAtNTYuMzEzNCwgLTU2LjAxNzYsIC01Ni44MjI0LCAtNTYuMTM3NiwgLTU1LjgwMDYsIC01NS42OTAxLCAtNTUuOTI1OCwgLTU1Ljg1MzAsIC01NS41MTA2LCAtNTcuMDk4NSwgLTU5LjM1MDksIC01OC4zNDQ2LCAtNTguNDI5MSwgLTU3Ljg2NjYsIC01Ny42ODgyLCAtNTcuOTU3MSwgLTU3LjY2NTgsIC01Ny4wNzI0LCAtNTcuNzU5OSwgLTU2Ljk0MDIsIC01Ny44Mjg3LCAtNjIuMTMwMiwgLTYxLjY1NTUsIC02MS41NjEyLCAtNjEuMzg3MiwgLTYwLjUzOTEsIC02MC42MTczLCAtNjAuMTgxMiwgLTYwLjU0MjAsIC01OS44Nzg2LCAtNTkuODkxOCwgLTU5LjEzODgsIC02Mi44MTgyLCAtNjQuMjkyOCwgLTY0LjY5NTAsIC02My43NDg1LCAtNjQuNzcwOCwgLTY0LjQxMzYsIC02My42NTUxLCAtNjMuNjY3OSwgLTYzLjcwMTQsIC02My4zNTM5LCAtNjMuOTY4OSwgLTYzLjA1NzQsIC02Ny4xODExLCAtNjYuODQyNSwgLTY2LjA4MTMsIC02NS44NjI1LCAtNjUuODU1OCwgLTY1LjgzNTEsIC02NS40MzkzLCAtNjUuNzI1OSwgLTY1LjEzMTAsIC02OS40NDA0LCAtMTM0LjkxMSwgLTEzNC44MjcsIC0xMzQuODY5LCAtMTM0LjM2OCwgLTEzNS4wNzksIC0xMzUuMTcyLCAtMTM0Ljc2MCwgLTEzNC40NjcsIC0xMzQuNTM5LCAtMTM1LjE1Ml0sXG4gICAgICAgIGdhaW46IC0zLFxuICAgICAgfSwgXSxcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZmx1dGUnLFxuICAgICAgbGF5ZXJzOiBbe1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tbWl4L2ZsdXRlc19tb2RlXzEud2F2JyxcbiAgICAgICAgc3RhcnRPZmZzZXQ6IDAuNSAqIDYwIC8gMTIyLFxuICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgIGludGVuc2l0eTogWy04Ni43MTQwLCAtODYuMDExMSwgLTg2Ljc5NjgsIC04NS43NzE2LCAtNDcuMTk1MSwgLTQyLjUyODQsIC00MS44MDA2LCAtMzcuMzQzOCwgLTMzLjY3NTUsIC0zMi45MjA2LCAtMzUuNTU1MSwgLTQ0LjAwNjksIC00MC4zMzQ0LCAtMzcuOTA4OSwgLTM2LjQ5NzksIC0zNi42OTIyLCAtMzYuODg5NiwgLTQzLjI5MDMsIC0yOS4yMTM3LCAtMjQuODA4OSwgLTIyLjgwMzAsIC0yMi4yMDk3LCAtMjIuNDA0OCwgLTI3LjA1NDYsIC0yNy41OTMwLCAtMjguMDg5NywgLTMwLjU3NTgsIC0yOS4xMzEwLCAtMjguMTYzNywgLTI2LjM5NDgsIC0yNi4zMjUwLCAtMjYuNTY3NCwgLTI1LjkzNTIsIC0yNS4zNDY1LCAtMjYuMjc3MCwgLTI2Ljk5NjUsIC0yNi41NjQxLCAtMjcuNTQzMCwgLTI5LjAxMDYsIC0yOS43ODE0LCAtMzAuMjc5MiwgLTI5Ljg0NDAsIC0zMC42MDg3LCAtMzIuMTgxOCwgLTMyLjU5MzAsIC0zMS44MjU3LCAtMzIuNTU5NCwgLTM0LjkyNzMsIC0zMS40MTY3LCAtMjguMzczOSwgLTI4LjE2MjQsIC0yOC45NzE1LCAtMzYuNzI3NiwgLTQyLjA5NDgsIC0zOC45NTg3LCAtMzUuNjM2MywgLTM0LjMzMjAsIC0zNC4xNjE5LCAtMzUuNjkwMiwgLTQxLjYwMjQsIC00My4wMzQzLCAtNDIuMzIyMiwgLTQzLjE2MjAsIC00Ny4zNTc5LCAtNDguNTkwOSwgLTQ2LjQwODYsIC00NS42Mjg2LCAtMzkuMDI5MiwgLTM2Ljk1MjksIC0zOS43ODI2LCAtNDEuMjY0NywgLTM4LjUwODksIC0zNy4wODM0LCAtMzguMzU5OCwgLTI3LjM2NTUsIC0yNC4wNzk2LCAtMjQuMDk5NSwgLTI1LjMyNzYsIC0yNy4zNzYwLCAtMjYuMDExNywgLTIzLjg0OTEsIC0yMy42MTUwLCAtMjYuNzQ0MywgLTM0Ljc5MzAsIC0zMS4yNjcxLCAtMjcuNDMzOCwgLTI3Ljk0NDgsIC0yOC43NTkzLCAtMjkuODk5MywgLTMzLjg4NzIsIC0zNC44OTE2LCAtMzQuODkyOCwgLTMxLjQ5MTYsIC0yOS43MDYwLCAtMzEuMDg2OSwgLTM0LjMyOTYsIC0zNS41MDQ4LCAtMzUuMDcyNiwgLTM0LjIzODYsIC0zNS4wMzIzLCAtMzQuNzAwOCwgLTM2Ljk3NjMsIC0zOC4wNjAxLCAtMzcuNDc1NywgLTMyLjUxMzMsIC0zMC42OTM1LCAtMjguODM3NiwgLTI5LjM4ODMsIC0yOC45MTg0LCAtMjguODA0MSwgLTI4LjkyMDksIC0zMy45ODQ1LCAtMjguNjM0MywgLTI4LjEwNjcsIC0yNi44MDE0LCAtMjYuOTQ1OSwgLTI2LjcxMjgsIC0yNS44MDU0LCAtMjUuNDcwMywgLTI2LjU5NzIsIC0yNy4yMjY3LCAtMjYuOTkwMiwgLTI4LjMyNzEsIC0yOS42NDM0LCAtMzAuMDg5NCwgLTMwLjIzODQsIC0zMC41MzI0LCAtMzEuODQ0MSwgLTMzLjc0OTYsIC0zNi40MTgwLCAtMzYuNDkxMiwgLTMyLjQ2ODcsIC0yOS4xNzgxLCAtMjkuNTUwNiwgLTM0LjE5MzIsIC00MC45MDUyLCAtNDEuMzUxMSwgLTQxLjcxNjIsIC0zOS4yMjAwLCAtMzYuODM1MSwgLTM3LjYxNzksIC0zNy4zNzk2LCAtMzYuMzY5MCwgLTM2LjY0NDUsIC0zNS41MjE3LCAtMzYuODk1NiwgLTQ2Ljc0MjEsIC00NS43NDg5LCAtNDMuNjAyNSwgLTQ1LjY2MjMsIC00NS40Mzc4LCAtNDUuMjU0MywgLTQ2LjU4OTksIC00NS40NTkxLCAtNDAuODY0MSwgLTM5LjE4NDcsIC0zNy45NDk1LCAtMzkuMTg4NywgLTQ2Ljk5NTQsIC0yOS41ODAzLCAtMjQuNDYwNSwgLTIzLjkxOTksIC0yNC43ODExLCAtMzAuODE4NSwgLTI2LjA4MzksIC0yMy44NTQ2LCAtMjIuOTYzNywgLTI1LjgxMjMsIC0zMy4yODQ0LCAtMzAuNDczOSwgLTI3LjQ0MDEsIC0yNi4zODU1LCAtMjcuMzkyNSwgLTMzLjc3MzAsIC0zNC40NzYwLCAtMzMuNTg2MCwgLTMxLjkzMzcsIC0zMC44ODQzLCAtMzAuMTczMCwgLTMxLjMxMTgsIC0zMS44Nzc1LCAtMzMuNjA5MiwgLTM0LjI1NzcsIC0zMi40ODc5LCAtMzMuMzkyOCwgLTM2LjU0MTcsIC0zOS4xODkzLCAtMzYuOTgwMSwgLTMzLjA4NTksIC0zMC4xMDkxLCAtMjkuNDA4MSwgLTI5LjQxNzQsIC0yOC45MTQ0LCAtMjkuMDE5MiwgLTM0LjgzNzAsIC0zOC41NjU1LCAtMjkuMjUwNiwgLTI4LjUyMjQsIC0yNy4yMzUyLCAtMjcuMTQ3OSwgLTI3LjAyMjcsIC0yNi4wOTgxLCAtMjUuMjg4MywgLTI2LjA5ODMsIC0yNy4xNDUzLCAtMjYuNzAzMywgLTI3Ljc5OTQsIC0yOS40NTczLCAtMzAuMDU1NywgLTMwLjM2OTEsIC0zMC42Mjc0LCAtMzEuMzQwNSwgLTMyLjg3OTUsIC0zNC4yMTIwLCAtMzYuOTY3NiwgLTMyLjA1MjMsIC0zMi45MjM2LCAtMzIuNTMzOCwgLTI4Ljg3ODUsIC0zNC44Nzg1LCAtNDAuMjAxNSwgLTM5LjE3MTMsIC0zNy4wNTI2LCAtMzUuNDg4OCwgLTM2Ljk1NTksIC0zNi44MDM0LCAtMzcuOTk4NywgLTQ0LjEyODcsIC00My44MzEzLCAtNDQuNzg0MiwgLTQ3LjYwOTYsIC00OC41MzMxLCAtNDkuMDA4MCwgLTQ4LjQ1MTYsIC00Ny44ODU3LCAtNDguMjk5MCwgLTUwLjQwNjgsIC00OC42MjU2LCAtNDUuNjIyNCwgLTQwLjkzNDQsIC0zOS4wMTUzLCAtMzcuOTE3OCwgLTM4LjYwNTYsIC00My41NzEwLCAtMjcuMjU3OSwgLTI0LjAzNzcsIC0yNC4wNzMzLCAtMjUuODkxMywgLTI3Ljk3NTUsIC0yNS4zMzAyLCAtMjMuNDI5OCwgLTI0LjE5ODUsIC0zMS42NjQ3LCAtMzYuMDQ5MSwgLTMyLjU1MDAsIC0yNy40OTY3LCAtMjguMDkzMSwgLTI4Ljc5MDEsIC0zMS41OTkwLCAtMzQuMzA2OSwgLTM0LjU5NjEsIC0zNS40NDM2LCAtMzEuNDA3OSwgLTI5Ljc0NzQsIC0zMi4wMzMxLCAtMzQuMjgzNSwgLTM0Ljk1OTUsIC0zNC44OTA5LCAtMzQuOTc4NiwgLTM0Ljk3ODgsIC0zNS42NDQzLCAtMzcuMzk4NSwgLTM3LjQ3MTcsIC0zMi44NjI5LCAtMzAuNDgzMiwgLTI5LjAyNzcsIC0yOS41NzA2LCAtMjguNzk1OSwgLTI4Ljk5MzYsIC0zMy4zNTEyLCAtMjkuNTcyMSwgLTI4LjY0ODgsIC0yNy4wMTY5LCAtMjYuNDA5MywgLTI2Ljc3NjksIC0yNi4wMjgzLCAtMjUuNDc5MiwgLTI2LjA5ODQsIC0yNy4xMDYzLCAtMjYuOTQ5MCwgLTI3Ljg4NTcsIC0yOS4yMDA1LCAtMjkuOTQ4OCwgLTMwLjIwOTQsIC0zMC4zMDc2LCAtMzEuMTM4NywgLTMyLjg1MTYsIC0zMy4yODEyLCAtMzEuNzI0MCwgLTMyLjIwNjcsIC0zNS4xODkyLCAtMzguNDUyMSwgLTM3LjgxNDQsIC0zNC43NTU5LCAtMzMuMDQ3NywgLTMxLjk2MjAsIC0zMy44Njc3LCAtMzguODAwNSwgLTM2LjU5NTEsIC0zNi4wNDYxLCAtMzYuNzU1NiwgLTM1LjQxMDYsIC0zOC4yODA0LCAtNDUuOTM4MiwgLTQ1LjM5MDEsIC00My44MTM2LCAtMzkuOTI4MCwgLTM4LjA2NTMsIC0zNy45MjU1LCAtMzYuODcwMSwgLTM2LjMyNDUsIC00MC44MTcyLCAtMzguOTMyNiwgLTM3LjM4ODksIC0yOC44OTIwLCAtMjcuMzIyMiwgLTI3LjUyNTIsIC0yOC4wNDM0LCAtMjMuODY1NiwgLTIzLjUzODYsIC0yNC4zMjQ4LCAtMjUuODc1NSwgLTI1LjAyNzcsIC0yNy4xMzM1LCAtMjQuOTI0MSwgLTIzLjQ1NDYsIC0yNC45MTI2LCAtMjguMTE1MiwgLTM2LjA3ODEsIC0zMC45MzY4LCAtMjcuODkzOSwgLTI3LjQ1NTZdLFxuICAgICAgICBnYWluOiA1LFxuICAgICAgfSwge1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tbWl4L2ZsdXRlc19tb2RlXzIud2F2JyxcbiAgICAgICAgc3RhcnRPZmZzZXQ6IDAuNSAqIDYwIC8gMTIyLFxuICAgICAgICBsZW5ndGg6IDE2LFxuICAgICAgICBpbnRlbnNpdHk6IFstODYuOTIzOCwgLTg2LjU4NDIsIC04Ni4yOTI3LCAtODYuMzk2NSwgLTg2LjEzMDgsIC04Ni43ODQ2LCAtODYuMjE4OCwgLTg2LjUxMjUsIC04Ni4yODEyLCAtODYuMjk3MiwgLTg2LjQ3MDksIC04Ni4zMjk2LCAtODYuMTUzNCwgLTg2LjU3NDAsIC01NC45ODQ5LCAtMzQuOTgxOCwgLTMzLjYxODksIC0yNC43NzU1LCAtMjMuMzI2MCwgLTIzLjc3MDgsIC0yNi4zNDQ3LCAtMzEuOTM1MCwgLTMzLjg3MTcsIC0yOS4zNTA2LCAtMjkuNzg0NSwgLTMzLjYyOTYsIC0yOC4xNTQwLCAtMjMuNzM3NCwgLTIzLjg5OTUsIC0yNS45MjIxLCAtMjUuMjc2MywgLTI4Ljk5NjIsIC0zMy4xODYzLCAtMzEuMjg4MSwgLTI4LjkxNTAsIC0zMS45NzgwLCAtMzEuMTM1NywgLTI1Ljc0MTEsIC0yMy42MjE5LCAtMjMuNzM4MiwgLTI0LjczOTYsIC0yNS43NDUxLCAtMzAuOTU1MiwgLTMzLjYxOTcsIC0zMC4wNjA0LCAtMjkuNTk5MiwgLTMzLjIyMzMsIC0zMS4zNTA3LCAtMjUuODg1NSwgLTIzLjM4OTMsIC0yMy4zMTI5LCAtMjUuNDI4MSwgLTI1Ljg0NjYsIC0yNS41ODg5LCAtMjUuOTQ1MiwgLTI2LjkwMzYsIC0yOC4wMzYzLCAtMjguNTE2MCwgLTI2LjI4MDAsIC0yNy4wNjY0LCAtMjUuODIzNywgLTI1LjgxNTIsIC0yOC44MjAwLCAtMjguNzMxMywgLTI4LjIzMzksIC0yNC41NzI5LCAtMjUuMDY1NywgLTI0LjE2ODIsIC0yNC4zNjAwLCAtMjQuOTUzMiwgLTI1LjA2NzAsIC0yNS4wMjM3LCAtMjcuODM0OSwgLTI3LjYxMDMsIC0yNi45MTU2LCAtMjkuODkxNiwgLTI1LjQ5NTYsIC0yOC40MDExLCAtMjcuNjM2MSwgLTI5LjI4OTAsIC0yNy40MDMzLCAtMjUuOTc0NiwgLTI1Ljk5ODQsIC0yNS4xMTA5LCAtMjUuMTE4NSwgLTM1LjA2NzYsIC0zNy45NzI0LCAtMzUuOTY2OCwgLTM3LjQ0MDksIC0zOC41OTA0LCAtNDAuNTEzOSwgLTQxLjQ3NDMsIC00MC4zNzg1LCAtNDEuMzE4MiwgLTQwLjA3OTEsIC00MC4zNjQxLCAtNDAuNDk4MCwgLTQwLjA1NjUsIC0zOS45NjE3LCAtNDAuNDkyOCwgLTQxLjQ2NjgsIC00My4yNTUwLCAtNDMuNTA3OSwgLTQ2LjQ2ODUsIC00Ni42ODU4LCAtNDcuNjAxNiwgLTQ4LjUyODMsIC00OC4yODQyLCAtNDcuNjk2NSwgLTQ3Ljk0MDEsIC00OC43NzY4LCAtNDguODcwOCwgLTQ5LjgzMDcsIC01MS40MjM3LCAtNTIuNDk2NCwgLTU1Ljk3MTAsIC01Ni45MDI4LCAtNTcuNzY4MywgLTU5LjA0NDgsIC01Ni41MDcyLCAtNTYuMTkzNywgLTU2LjE5MDIsIC01Ny4yNDMzLCAtNjAuMTc4MSwgLTU5Ljc0NzcsIC01OC45NTYzLCAtNTguNTU2NywgLTU3LjgwMDEsIC01OS4wNDE3LCAtNjEuMjY2NSwgLTYyLjAxNzAsIC02MC41MjA4LCAtNjAuNzU0MiwgLTYyLjU3NjMsIC02My43ODA3LCAtNjUuNjI5OSwgLTY2LjA2MjEsIC02Ni42OTI4LCAtNjguMzcwNiwgLTY4LjQyNTIsIC02Ni40NDA0LCAtNjcuMDQ3MywgLTY2Ljg0NDAsIC02Ny4xNDk2LCAtNjcuMDA3NiwgLTY4LjcyNjUsIC02OS42NzMxLCAtNjkuMjM1NSwgLTY3Ljk2MTksIC02OS4xMzY1LCAtNzEuNzczNSwgLTc0LjMyNDksIC03Ny42MDgxLCAtNzYuNzc3OCwgLTc0LjU2MTcsIC03My4wNjAxLCAtNzMuNTExMywgLTczLjQ5MTQsIC03NC4zNzEyLCAtNzQuNjE0OCwgLTc2LjA3MTYsIC03OS43NTM5LCAtODAuNDE5MCwgLTc5LjkzNDQsIC03OS40NTcwLCAtODEuMDY2MywgLTgxLjc4NjQsIC03OS41MzY0LCAtODAuMTg5NiwgLTc5LjEwODIsIC03OS42MzA4LCAtODIuOTIxOSwgLTgzLjE4NzUsIC04MS43NjUzLCAtODIuMzcyOSwgLTgzLjEwNTEsIC04My4wOTQ5LCAtODMuMzI4MCwgLTg1LjMzNzgsIC04NS41NTg0LCAtODQuNjMwMCwgLTg1LjQ5MDQsIC04NS43ODcxLCAtODUuNzMyNywgLTM4LjUxMDQsIC0zNS4xOTQ2LCAtMjcuMjkwNSwgLTI0LjA0NjQsIC0yMy40NTI5LCAtMjQuNTMwMSwgLTI5Ljk0MzQsIC0zNS4wNTc3LCAtMzAuMzg1MCwgLTI4Ljc0OTcsIC0zMC45OTIyLCAtMzMuMTE3MCwgLTMwLjc3MDIsIC0yNS41MzI3LCAtMjMuNDQ2NCwgLTI0LjM2NjksIC0yNi42NDAxLCAtMzEuNjMwMSwgLTMzLjY1ODUsIC0yOS43MDkxLCAtMzEuNjk4MSwgLTI5Ljc2NTksIC0yNS4wODQyLCAtMjQuMjYwMSwgLTI0LjkyMTEsIC0yNS4zNDc0LCAtMjYuODE5NiwgLTI3LjQzNzQsIC0zMi42NjU0LCAtMzEuMTg0MywgLTI5LjU3OTIsIC0zNC4yMDIyLCAtMjkuNTg3OCwgLTI0LjA1MzIsIC0yMy42ODA5LCAtMjYuMzU4MiwgLTI0Ljc3MzQsIC0yNS44NTM5LCAtMjQuOTk5NywgLTI3LjA3NjAsIC0yOC4zMDMyLCAtMjguODk0NSwgLTI4LjI2MTcsIC0yNi40Njk1LCAtMjUuNTM4NCwgLTI2LjM0ODIsIC0yNi44MTEzLCAtMjcuMTM3NCwgLTI4LjE1MTIsIC0zMC40Mjg5LCAtMjUuNjc3NywgLTI1LjEzMDgsIC0yNC40MDAxLCAtMjQuNDg5MCwgLTI0LjIyOTUsIC0yNS4zODg5LCAtMjQuMTE0NiwgLTI3LjEzODgsIC0yNy4wMDM4LCAtMjUuNzI1NSwgLTI5Ljg2NzksIC0yNi4yNDIyLCAtMjcuMDc0MywgLTI3LjgzNDQsIC0yOC43MjY4LCAtMzAuODE2MiwgLTI5LjI5MjUsIC0yOC4zMTU3LCAtMjcuNjU3NiwgLTI3LjgxNzUsIC0zMy4wMjYzLCAtMzYuMzQwMiwgLTM2LjQ5ODgsIC0zNy42MDU3LCAtMzguMDIyNiwgLTM5LjMwNDksIC0zOS45MDk5LCAtNDAuNTUyMywgLTQxLjQzNTgsIC00My43MjY5LCAtNDIuNTY0OSwgLTQzLjcyMzAsIC00NC4xNDExLCAtNDIuNjgzMywgLTQyLjYyMjMsIC00MS44NjUzLCAtNDQuODU0NCwgLTQ0LjU5NzIsIC00Ni4xOTc5LCAtNTAuMjM5MSwgLTQ4LjcwMDMsIC00OS45MzQ2LCAtNTAuODgzNiwgLTQ4LjQxODYsIC01MC4zMTI4LCAtNTEuMjE5MSwgLTUwLjYxNjAsIC01MS43NTc5LCAtNTIuMTMzMCwgLTUyLjY1NDUsIC01Ni4yNjQ0LCAtNTguNTMzMSwgLTU5LjA0MzgsIC01Ny44ODMzLCAtNTQuODkxMiwgLTU1LjQ1NzQsIC01NS4zNzkxLCAtNTcuMzAwNCwgLTU5LjQxMTQsIC01OC41MTQ3LCAtNTUuNTg5MywgLTU2LjcwNjcsIC02MC4yMDc4LCAtNjQuNDI1NywgLTY1Ljk5NTgsIC02NS40MDQ4LCAtNjUuNTc1MywgLTY3LjgyMDgsIC02OC40MTYwLCAtNjcuMTU5MCwgLTY5LjAzNDMsIC02Ny43MDIzLCAtNjQuNDk5NywgLTY1LjU1OTksIC02NC4wNDgzLCAtNjUuNTQ3OSwgLTY1LjUwMjQsIC02Ni41NzgyLCAtNjUuMzgwNiwgLTY0Ljg1MjYsIC02Ni44NDYzLCAtNzEuMjI0OCwgLTcxLjI2ODIsIC02OS42Mzk3LCAtNzAuMjMxOCwgLTcyLjE3ODEsIC03Mi4wMTI0LCAtNzQuNTk4MiwgLTcyLjI1NjUsIC03MC42OTU2LCAtNzAuMjM1MiwgLTcwLjE4MDQsIC03Mi4wMzYwLCAtNzQuMzg5MSwgLTc2LjU1NDAsIC03OS4yODE4LCAtODEuMTMyNiwgLTc4LjU0ODIsIC03NS45NzI3LCAtNzcuODEwMiwgLTc3LjY0NTAsIC03Ni4yODI0LCAtNzcuODc4OSwgLTc5Ljk3NTUsIC04MC4wMzUwLCAtODEuMjM1NCwgLTgwLjQ1MTMsIC04MS43MjYyLCAtODMuMjE1NiwgLTgzLjQ0OTksIC04My40NTQ4LCAtODQuMzcyOSwgLTg2LjA1MjQsIC04NS43MTU5LCAtODUuMzc4NSwgLTg0LjE5NzgsIC04NC4zMTk4LCAtODQuODUyNiwgLTg2LjA2MDMsIC00OS41OTQ0LCAtMzQuODE1MywgLTMyLjM5OTAsIC0yNC41NTIzLCAtMjMuMjY0MywgLTIzLjg4NjksIC0yNy4wOTYwLCAtMzIuNTAwNCwgLTMyLjk2NTksIC0yOS45NzMyLCAtMzIuNDg4NSwgLTI2Ljc3NDYsIC0yMy40NjQ3LCAtMjQuMTY4MiwgLTI1LjE0MDAsIC0yNS40Mzg4LCAtMjUuODE3MywgLTI4LjA1NTYsIC0zNS43MDIyLCAtMzAuMjE3MiwgLTI5LjA4NTEsIC0zMi4wNjY4LCAtMzAuODU0NSwgLTI1LjI0ODMsIC0yMi45NDM0LCAtMjQuNTIyMywgLTI2LjAxMTcsIC0yNy4zNjAwLCAtMzEuMDk1MiwgLTMzLjk2MzUsIC0yOS45MzAxLCAtMzIuMTI5NCwgLTI4Ljk0NzMsIC0yMy42ODgxLCAtMjMuNDIwMSwgLTI0LjM2NTAsIC0yNC43MTc1LCAtMjUuNTU2OCwgLTI1LjM4MzcsIC0yNi40NjU2LCAtMjYuOTY0MiwgLTI4LjA2MzAsIC0yOS4zODQ1LCAtMjYuNDgxNiwgLTI3LjAyMzAsIC0yNi40ODE0LCAtMjUuNTk3MiwgLTI3LjgxNDUsIC0yNi44MjQ0LCAtMjkuNzg5NiwgLTI3Ljg0MTEsIC0yNC41OTk4LCAtMjQuOTE3NiwgLTI0LjEyOTEsIC0yNC4xOTExLCAtMjUuMTQ1MSwgLTI0LjczNzgsIC0yNS41NDY2LCAtMjcuNzExOCwgLTI3LjI0NzcsIC0yNy40ODU4LCAtMjguOTk5NSwgLTI1LjYzMDksIC0zNC40NjA1LCAtMzMuMjY2NywgLTI1LjUxNTYsIC0yNi4yNjg2LCAtMjQuNjYxMiwgLTI1LjQ2OTYsIC0yNS44NzIxLCAtMjQuODUyMiwgLTIyLjY5MzAsIC0yMy41MDEwLCAtMjYuMjgzNSwgLTM1LjMxMTUsIC0zNy44OTk0LCAtMzcuNTg3MywgLTM4LjE4OTEsIC0zOC40NzM3LCAtMzkuNDcyMywgLTQwLjEyMDksIC0zNy4yMzM4LCAtMzcuNzUxOSwgLTM4LjQ3NDQsIC0zOS4yOTg5LCAtNDAuNTcwNiwgLTQwLjE2NzcsIC00MC43NzE0LCAtNDIuMDU3OSwgLTQzLjg5OTgsIC00NC4yNTI0LCAtNDYuNjc2NywgLTQ2LjY5MjgsIC00Ni4xNzE3LCAtNDcuODkzNywgLTQ4LjM3MjAsIC00Ni42Mjc0LCAtNDUuODExNCwgLTQ2Ljk2MjYsIC00OS45MDY3LCAtNTMuMTUwMiwgLTU0LjY2MzEsIC01NC45NDQ1LCAtNTUuMjcyNSwgLTU1Ljk3NjcsIC01NS4yNDAwLCAtNTYuMjY4MCwgLTU0LjQwNzcsIC01Ny4yNTU1LCAtNTcuODMxMCwgLTU4LjA0MzAsIC01OS43NjI1LCAtNTkuMzY1OCwgLTU3LjY2NjAsIC01NC41MzIwLCAtNTUuODM5OSwgLTU5LjQwMzIsIC02MS40NTM0LCAtNTkuMjAyMiwgLTU4LjgxODEsIC02MC4xNzc4LCAtNjIuODMyNiwgLTYzLjg1MTAsIC02NS43NzU0LCAtNjguNTk2MiwgLTY3LjQ5NTUsIC02Ny41MzA2LCAtNjQuNTIzMiwgLTY1LjA0MDAsIC02NS44OTcwLCAtNjUuNzI4NSwgLTY1LjU1MDcsIC02NS42MDM3LCAtNjcuMzMxNCwgLTY5LjE4MjIsIC02OC41MTY3LCAtNjguNTY4OCwgLTY5LjY3MTAsIC03Mi4yODgxLCAtNzQuNTIwNiwgLTc0LjE0OTksIC03Mi4xNzMyLCAtNzAuODYyOSwgLTcwLjc1MjUsIC03My43NDM3LCAtNzUuNjA4OSwgLTc0Ljc0MTUsIC03NS45NDkwLCAtNzguNDQxNiwgLTc5LjQxMDIsIC03OC44ODUwLCAtNzcuMTM3OSwgLTc4LjUxNzAsIC04MS4zNTA3LCAtNzguMDE4MywgLTc4LjQxNTQsIC03OS4xMzIxLCAtNzcuOTUxMSwgLTgwLjAyODUsIC04My4xMjAxLCAtODEuODc3NCwgLTgwLjUyNTYsIC04Mi40MjI3LCAtODMuNjgzMCwgLTgyLjMxODUsIC04NC4zNzQ3LCAtODYuMDEyMSwgLTg0LjM1NDEsIC04NC45MTQ2LCAtODEuNzY0MiwgLTM3LjAxNjksIC0zNS4xNzM5LCAtMjYuMzIyOCwgLTIzLjgzMTgsIC0yMy41MjM1LCAtMjQuODQ2MCwgLTMwLjUyNjAsIC0zNS4zMzg0LCAtMzAuMDIwOSwgLTI5Ljc2NDcsIC0zMy4wMjkwLCAtMjYuNDIwNywgLTIzLjkwNjEsIC0yNC42NTA3LCAtMjUuNTA2NSwgLTI1LjYyMTYsIC0yNi42MDE1LCAtMzEuMTA4NCwgLTMyLjY3MTgsIC0yOS4yNTM1LCAtMzIuNjM0MiwgLTI3LjgyMjIsIC0yNC4xMjcwLCAtMjMuNzcxMywgLTI0Ljk3MDQsIC0yNS4wMTYwLCAtMjYuMTE5NSwgLTI4LjIxMTEsIC0zMy4yNzYwLCAtMzAuNjY4MSwgLTI4Ljk3OTEsIC0zMC44ODA4LCAtMzIuNTk3MywgLTMzLjQxNTAsIC0yNS41MzExLCAtMjMuNTA5MiwgLTIzLjgzNjcsIC0yNS42OTk5LCAtMjYuMDE1MiwgLTI1Ljg0MDcsIC0yNS43NDQ0LCAtMjcuNTQ1NSwgLTI3Ljc0OTAsIC0yOC4yODUwLCAtMjcuMzk5NSwgLTI3LjM3MTcsIC0yNS41ODIyLCAtMjYuMDg5NSwgLTMwLjA3MzYsIC0yOS4wNDA0LCAtMjUuMTA4NywgLTI1LjEwMjUsIC0yNC4yNTE3LCAtMjQuNDU0NCwgLTI0LjQwNjYsIC0yNS41NDcwLCAtMjQuMTE2MiwgLTI3LjU5ODUsIC0yNi45ODc2LCAtMjUuODQ1OSwgLTMwLjQxNTksIC0yNS43Mjc4LCAtMjcuNTc1NCwgLTI3LjY3OTksIC0yOS41ODQxLCAtMzMuMjMyOSwgLTMzLjM5MTcsIC0zMi40ODY4LCAtMzIuOTE5MSwgLTMyLjIxMDIsIC0zMi43NjcxLCAtMzIuNzU5NCwgLTMxLjY3MDEsIC0zMi43NTc4LCAtMzMuNTIzNywgLTQwLjA3NTUsIC00MS41MDcwLCAtNDAuMzE0NiwgLTQxLjAzMTYsIC00Mi45MDI2LCAtNDMuMTg5NiwgLTQ1LjM0MDcsIC00NS40Njg1LCAtNDMuOTQ4NiwgLTQzLjg0MjEsIC00My4wODE0LCAtNDUuMzAzNywgLTQ0LjUwMTMsIC00NS40MjYxLCAtNDguMTkwNCwgLTQ3LjgyODYsIC00OC43MjEyLCAtNDkuNzE0MiwgLTQ3LjM1OTIsIC00OS4xOTE1LCAtNTEuMzMzNywgLTUxLjU3NTAsIC01MS4wNTQ1LCAtNTIuMzQzNiwgLTUyLjI1MTcsIC01Ni4wMzk4LCAtNTYuNDMwNiwgLTU4LjI1ODIsIC01Ny44Njg4LCAtNTcuMDg2OSwgLTU3LjExNTQsIC01NS41MjUxLCAtNTguNjIzMSwgLTU4Ljk0MTcsIC01OC42OTYyLCAtNTguNDk4NywgLTU4Ljc3NjcsIC02MS42MDgyLCAtNjQuMDIxMSwgLTY0LjMyNzYsIC02NS4xMjI3LCAtNjYuNjk3OCwgLTY3LjQ1NjksIC02Ny4yNzIzLCAtNjcuMTMxOCwgLTY3Ljk1ODYsIC02Ni4wMTc1LCAtNjQuNzE2OSwgLTY2LjYzMzcsIC02OS4yODk2LCAtNzAuNzU5NCwgLTcxLjE3NjgsIC03MC4zNDY2LCAtNzAuNDMyMiwgLTcwLjQzMTYsIC03MC42NDc3LCAtNzEuOTcwOSwgLTc0LjA1OTEsIC03My4zNDcxLCAtNzIuOTk0MiwgLTc1LjIyMTYsIC03NC43MDgzLCAtNzYuMTM3MSwgLTc2Ljk0MDAsIC03OC4xMTAxLCAtNzguMDcwMCwgLTc4LjA1MjgsIC03Ny4wNzYzLCAtNzcuNDcwOCwgLTc5LjQ0NTcsIC03OS41MTMzLCAtNzkuOTA5MiwgLTgwLjI4ODMsIC04MC4xNzQxLCAtODAuNDg1NSwgLTgxLjE5OTIsIC04Mi4zOTYwLCAtODEuOTI2MywgLTgxLjQ5NTEsIC04Mi44MzU3LCAtODMuOTEzNSwgLTg0LjE2MjQsIC04NC43NjM1LCAtODMuMjY1NCwgLTg0LjIzNzYsIC04NC41MTk3LCAtODQuNTM5MCwgLTg1LjE3ODUsIC04NS41NzAyLCAtODUuODQwNCwgLTg1LjU2NDQsIC04NS43MDg2LCAtODUuOTE2MSwgLTg2LjEwMTUsIC00NS41NjkwLCAtMzQuODM3MCwgLTMwLjk4MjEsIC0yNC40MjMzLCAtMjMuMjcxNSwgLTI0LjAxNTAsIC0yNy44OTE3LCAtMzMuMTQzNSwgLTMyLjExMTcsIC0yOC45OTc2LCAtMzIuMDUxMiwgLTMwLjc2OTYsIC0yNS4wMTQ1LCAtMjQuMzQ4MSwgLTI1LjYyNDgsIC0yNC44MDUzLCAtMjYuODEyMSwgLTI4LjczNjgsIC0zMi44Nzc4LCAtMzAuMjg5NiwgLTMwLjY5ODIsIC0zMS4xNjA1LCAtMjYuNjA4OCwgLTIzLjYyNjEsIC0yNC40NTA1LCAtMjYuNTk2NCwgLTI2LjQwMjgsIC0yNi4zODQyLCAtMzEuMDU2NSwgLTMzLjUwMzEsIC0yOS41MjUzLCAtMzAuMTA0NiwgLTMxLjgxNTQsIC0zMy4xODg1LCAtMjYuODg5OCwgLTIzLjA5ODksIC0yMy44OTAwLCAtMjUuMDI1NSwgLTI1LjM2NjMsIC0yNS41MTc2LCAtMjUuMDgzMiwgLTI2LjY1ODYsIC0yOC4wNTAxLCAtMjguOTg5NiwgLTI3LjYwMzEsIC0yNi43MTY2LCAtMjUuNjQ4NiwgLTI2LjMxODAsIC0yOC4xODMwLCAtMjkuNzMxMSwgLTI3LjIwOTUsIC0yNC42NzQwLCAtMjQuNzA3OCwgLTI0LjE1MTUsIC0yNC4wNDg1LCAtMjUuMjcxMSwgLTI0LjU0NjAsIC0yNi4wOTE1LCAtMjcuMjUyNCwgLTI2LjY2NDYsIC0yOC4yMDA1LCAtMjcuOTI2MywgLTI2LjU5OTgsIC0zOC40NjcwLCAtMzcuNjYxNSwgLTM3Ljc4NDksIC0zNS45MTczLCAtMzQuMDQ2MCwgLTMyLjg1ODUsIC0zMi45NjYzLCAtMzMuNTEzMiwgLTM5LjU1MDAsIC00MC4xMDg4LCAtMzkuMDE3MiwgLTQxLjYzMjUsIC00Mi44NDc4LCAtNDMuNTU3NCwgLTQyLjc0MjMsIC00MS40MDU2LCAtNDQuODI0NSwgLTQ2LjQ3MzcsIC00Ny4wOTkxLCAtNDguMTg5NywgLTQ1LjM2NjEsIC00Ni4xMDYxLCAtNDYuNzc2MiwgLTQ3LjExNDEsIC00Ny45ODU3LCAtNDcuNjczNSwgLTUxLjUxNzEsIC01MC42ODc4LCAtNTQuMjU5NiwgLTUyLjYyMDYsIC01Mi44NjQ1LCAtNTIuNzY3OCwgLTUyLjI2NDcsIC01NC45MTU3LCAtNTMuMzMzMiwgLTUzLjE1NzgsIC01NS45MzQyLCAtNTguNjk3NiwgLTU5LjY2MzAsIC01OC44NTE5LCAtNTkuMzI5OCwgLTYwLjE4OTgsIC01OS44OTI5LCAtNjAuNTAxNSwgLTYxLjMyMzYsIC02My4wMTU0LCAtNjQuMjY5MywgLTYxLjM1NzQsIC02MS45ODE5LCAtNjUuNTA4MSwgLTY4LjQ1ODUsIC02Ny4yOTYxLCAtNjkuMzEwMywgLTY5LjMwNDMsIC02OS44OTg4LCAtNzAuODQxNywgLTcwLjY0MDgsIC03MC4xNTgxLCAtNjguNDQxOCwgLTY3LjQ5MzEsIC03MS40MjU4LCAtNzIuOTc4NSwgLTc0LjExMjEsIC03Ni4yMzkzLCAtNzUuNDgzNywgLTc0LjE4MTIsIC03My44ODA5LCAtNzQuODQ3MywgLTc1LjkxMDYsIC03Ny4wNTg3LCAtNzUuOTY1NiwgLTc3LjE2NTcsIC03OC4xNDYwLCAtNzguMDUxNiwgLTc3Ljk2NjAsIC04MC4xNDgwLCAtNzguNTg1NywgLTgwLjIwMTksIC04Mi44NTg4LCAtODEuMDY4NywgLTc4LjQ1MjYsIC04MS42MTMxLCAtODEuNTQ2NSwgLTgxLjQzMjYsIC04NC4yOTgxLCAtODIuNjUzOSwgLTgzLjEwNTgsIC04My43ODQwLCAtODQuMjkyMiwgLTg0LjA5NjIsIC04My45Njc2LCAtODQuMTM3NCwgLTg0LjY3NTcsIC04NS4xNjYwLCAtODUuNTA4MCwgLTg0LjQ4MjYsIC04NC40OTM1LCAtODQuOTQxOSwgLTg1LjYwNjcsIC04Ni4xODA4LCAtODYuNjg4MywgLTg2LjcyMjMsIC04Ni4yMTY5LCAtODYuMjYyNiwgLTg2LjE5ODksIC04Ni4yODcyLCAtNjkuODcxOCwgLTM1Ljk2ODMsIC0zNC45MTkzLCAtMjUuNTg0MiwgLTIzLjYxMjksIC0yMy41OTk1LCAtMjUuMjcxMCwgLTMxLjA0MTAsIC0zNS4xNDQzLCAtMjkuOTE5OCwgLTMyLjAyOTYsIC0yOC41NDIwLCAtMjMuNzM1MywgLTIzLjg5NTUsIC0yNC43NzQwLCAtMjUuMTQxMCwgLTI2LjI2MjYsIC0yNi4yMDU0LCAtMzQuNDY1NiwgLTMxLjYyNjEsIC0yOS4xMDQ4LCAtMzEuMDI1MywgLTMyLjkxNTYsIC0yNi43NTI1LCAtMjMuMTU3MSwgLTIzLjYzMDMsIC0yNi40NDUxLCAtMjYuMTMwOCwgLTI5LjMzODQsIC0zNC4yOTQ2LCAtMzAuNjI1OCwgLTMwLjQ0MDcsIC0zMS44MzY2LCAtMjQuNjQwNiwgLTIzLjIwNjEsIC0yMy41OTkxLCAtMjQuOTkwOSwgLTI1LjY0NjEsIC0yNS42MTY4LCAtMjUuNzM2MywgLTI2Ljc3NzMsIC0yNy42Mjc5LCAtMjkuMDIyNCwgLTI3LjQ1NTYsIC0yNy4xNTk3LCAtMjUuODYzOSwgLTI2LjA2MDEsIC0yNy44OTQyLCAtMjYuNDgwNSwgLTI4LjgzNDMsIC0yOS41MTk5LCAtMjQuODU2OCwgLTI1LjA2NTksIC0yNC4xMzgyLCAtMjQuMzg0NSwgLTI0LjY0NzAsIC0yNS40Mzc0LCAtMjQuMzE1NCwgLTI3LjkwOTcsIC0yNy41MTkzLCAtMjUuOTgwMSwgLTMwLjYwMjAsIC0yNS41MzcwLCAtMjguMDUyOSwgLTI3LjcxMzIsIC0yOS40MTY0LCAtMzEuNDQ3NywgLTI4LjY1MDgsIC0yOC4xNDM3LCAtMjcuNjA2NSwgLTMwLjE4MzAsIC0zNS44MDE5LCAtMzcuNDEwMSwgLTM2LjY3MTIsIC0zNy40NTIyLCAtMzguOTIxNiwgLTM5Ljg3NTksIC00MC45NTExLCAtNDAuNTE4OCwgLTQyLjg1OTIsIC00Mi44OTExLCAtNDIuMzM2MSwgLTQ0LjU5MjgsIC00My44NzI5LCAtNDIuNTQyMiwgLTQyLjA0MzgsIC00Mi45Nzk4LCAtNDUuNDExOSwgLTQ0LjgxNjMsIC00Ny4yMzIyLCAtNDkuNjA2NiwgLTQ5LjQ3NjEsIC01MC40Nzc0LCAtNTAuNTY3MCwgLTQ4LjUyNDksIC00OS43OTM1LCAtNTEuNDExNSwgLTUxLjE1MzEsIC01Mi4wMTc3LCAtNTIuODEyMiwgLTUyLjg1MTMsIC01Ny40MTEzLCAtNTguMTY5NiwgLTU4LjMzODEsIC01Ny4wOTQ4LCAtNTUuMzE3NCwgLTU2LjEwMzEsIC01NS4zOTEwLCAtNTcuNzkzNSwgLTYwLjEyODksIC01Ny40MjIyLCAtNTUuNzM0MSwgLTU4LjAwMTUsIC02MS4xNDAxLCAtNjYuNTAyOSwgLTY1LjE1NTEsIC02NS4yOTAzLCAtNjYuOTA4MSwgLTY5LjA4OTMsIC02Ni43NTQwLCAtNjguMzE2MCwgLTY4LjY1NzQsIC02NS42ODMzLCAtNjQuOTUwMCwgLTY0LjY5OTEsIC02NC41ODQ4LCAtNjUuODI1OCwgLTY2LjcxNTEsIC02Ni43NzEzLCAtNjUuNDI0MywgLTY1LjgwMDQsIC02OS41MDg5LCAtNzEuMzY3NiwgLTcxLjU4OTAsIC02OS43OTUxLCAtNzEuNDg2MCwgLTcxLjk4MzUsIC03My40Nzk1LCAtNzQuNTU5MSwgLTcyLjA4ODYsIC03MC45MzMzLCAtNzAuMjEwOCwgLTcxLjA3NTAsIC03My40Njc5LCAtNzUuNjE5NiwgLTc3Ljg2MDQsIC03OS41ODM5LCAtODAuNTE4OSwgLTc2LjY0ODcsIC03Ny4yNTIxLCAtNzguMzk0MiwgLTc2LjMwODMsIC03Ny41Mjg5LCAtNzguOTA5OSwgLTgwLjc3NTMsIC04MC45MTEzLCAtODAuOTAxMCwgLTgwLjY3MjMsIC04Mi45MDk2LCAtODMuMDU0MCwgLTgyLjkwNjUsIC04My45ODY4LCAtODUuMDMwOSwgLTg2LjA3NjMsIC04NC4yMTMxLCAtMzcuMzU4MCwgLTM1LjE5NjcsIC0yNi41NTE2LCAtMjMuODg5NSwgLTIzLjUwNTMsIC0yNC41MTIxLCAtMjUuNTk2MiwgLTI1Ljc5NjcsIC0yNS40NDcyLCAtMjUuNjQwNiwgLTI2Ljk2MzQsIC0zMC41MTY0LCAtMzUuMzQ1NywgLTMyLjI3MDUsIC0zMy4yNDU0LCAtMjcuNDEwNCwgLTIyLjk0MjgsIC0yMy41MjUxLCAtMjQuODQyNCwgLTI0LjkyMDYsIC0yNS45NjIxLCAtMjUuNDczNiwgLTMyLjY2MzksIC0zNC40NjMxLCAtMzAuMTEwOSwgLTMxLjgzODYsIC0zMC4zMjU2LCAtMjMuODg1MywgLTIzLjQ0NzMsIC0yNC44MDE1LCAtMjQuNTY0NCwgLTI2LjIzODUsIC0yNi4yNDQ1LCAtMzIuNTM4MSwgLTMyLjYzMDAsIC0yOS4xMzE1LCAtMzAuMzg2NywgLTMzLjYyNTUsIC0yOS4zNjc4LCAtMjQuNjA1MCwgLTIyLjg2MjAsIC0yNS40NjM3LCAtMjQuOTM2MCwgLTI2LjIwNTksIC0yNS41MDc1LCAtMjYuNDI1NiwgLTI3LjMxMjIsIC0yOC42ODY1LCAtMjguNzgzNSwgLTI1LjY2ODQsIC0yNS45ODA5LCAtMjUuNDc5NCwgLTI1LjYzNzAsIC0yOS4wMzIwLCAtMjkuNTIxNywgLTI2LjUzMDgsIC0yNC43NjM0LCAtMjQuMzk4MSwgLTI0LjI5NzUsIC0yNC4wNzIyLCAtMjUuNTA4MCwgLTI0LjI3NTksIC0yNi4yNTc0LCAtMjcuMTE0MiwgLTI2LjIwNDEsIC0yOC44MzU4LCAtMjcuMjUwOSwgLTI2LjI3MzcsIC0zMy4xMTQzLCAtMzAuNzg3OCwgLTI1Ljc3MzUsIC0yNi4zMjA3LCAtMjQuNzg5MSwgLTI1LjIyMzcsIC0yNS42MjU2LCAtMjQuNDU0MSwgLTIzLjA1MzEsIC0zMS40NjAzLCAtMzYuMzc2OSwgLTM4LjA2MzYsIC0zOC4xNzQ5LCAtMzguNDQwNiwgLTM4Ljk5ODQsIC0zOS40NjY5LCAtNDAuNjY3NiwgLTM5LjUxNjcsIC0zOC43NTU5LCAtMzkuNTEwNCwgLTM4Ljc0NzYsIC0zOS41Nzg2LCAtNDAuMjI0NSwgLTQwLjQwODIsIC00MS42MzAwLCAtNDIuNjI0MywgLTQ0LjkxMjMsIC00NC45NDM2LCAtNDguNTczMSwgLTQ3LjcxNDMsIC00OC4wNDQ3LCAtNDguMTgxMCwgLTQ5LjE1ODMsIC00OC4yMTU2LCAtNDcuMTE0MSwgLTQ4LjY5ODcsIC01MC43Njc0LCAtNTMuNzE2MiwgLTU1LjAyMDIsIC01NS45NDU1LCAtNTUuNDY5NywgLTU2Ljc4ODAsIC01Ni43NzE1LCAtNTUuMDQ1MiwgLTU2LjIyMDEsIC01Ny44OTY2LCAtNTguNDY1NCwgLTU5LjQ3MDEsIC01OS40MzY3LCAtNjAuNDE1MywgLTU3LjI5MTcsIC01NS43MDUxLCAtNTcuMzIxNSwgLTYwLjA3MjUsIC02MC43MDMwLCAtNTkuNDEyOSwgLTU5LjUyNjEsIC02MS43MzAxLCAtNjIuNzU1NywgLTY0LjAyMTQsIC02Ny4yMTcxLCAtNjguMzA0MywgLTY3Ljk0MTMsIC02Ni41MzQ0LCAtNjUuMjc2NywgLTY2LjQwOTgsIC02NS4wNzMyLCAtNjUuNzQ4OSwgLTY1LjU3MzQsIC02Ny40OTk0LCAtNjcuOTg4OCwgLTY4LjQ1MDIsIC02OC4xMjAwLCAtNjkuNzQ5MCwgLTcwLjU1MzEsIC03My40Mjk2LCAtNzQuNzkxNiwgLTc0LjI2MzEsIC03Mi42ODg0LCAtNzEuNTk1MiwgLTcyLjEyOTcsIC03My45ODU4LCAtNzQuNzQwOSwgLTczLjkwNDIsIC03Ni44NTgxLCAtODAuMTc2OSwgLTgwLjk2MjMsIC03OS4xNjIzLCAtNzguMTY5MiwgLTgwLjE1MDQsIC04MC4xNjQyLCAtNzkuMTExMCwgLTc5LjE0NzUsIC03OC4yNTI1LCAtNzkuNjI2MCwgLTgxLjkxNzQsIC04MS45Njk3LCAtODEuMDYxMiwgLTgxLjU1NjYsIC04Mi44OTU1LCAtODIuNjEzNywgLTgzLjE5MDcsIC04NC43NDgyLCAtODUuMjI2OSwgLTg0LjU4NjQsIC04Ni4xMDEzLCAtNjAuNTQ5NiwgLTM1LjI5MTYsIC0zNC4zMzc3LCAtMjUuMDU4MCwgLTIzLjQyNzksIC0yMy42ODkxLCAtMjUuODIzNiwgLTMxLjUzMzQsIC0zNC41MzAwLCAtMjkuODYwNiwgLTMyLjQ2MzgsIC0yNy45MzIxLCAtMjMuNTYyNCwgLTI0LjAwNDgsIC0yNC45MjA2LCAtMjUuMTc3NywgLTI2LjEyODgsIC0yNi43MjgwLCAtMzUuMzY4MywgLTMxLjAyNjMsIC0yOS4wMTExLCAtMzEuNDQ0NSwgLTMyLjE2NjAsIC0yNi4xNTI4LCAtMjMuMDQwOSwgLTIzLjg1NjAsIC0yNi4zMDM1LCAtMjYuNTU1NSwgLTI5Ljg3NzQsIC0zNC4zMTE0LCAtMzAuMzAxNCwgLTMwLjk4NzcsIC0zMC44OTg0LCAtMjQuMTYxNiwgLTIzLjI3NzYsIC0yMy43NzU3LCAtMjQuODg3NCwgLTI1LjY4OTMsIC0yNS41ODg1LCAtMjUuOTU0OCwgLTI2Ljc3MzUsIC0yNy43MjM0LCAtMjkuMTE2MiwgLTI3LjAwMTksIC0yNy4yMTc3LCAtMjUuOTc1NiwgLTI1Ljc1MzksIC0yOC4wNDYxLCAtMjYuNTE1MiwgLTI5LjIwNjAsIC0yOS4wMDgwLCAtMjQuNjc2MCwgLTI1LjA2NDEsIC0yNC4xMDU2LCAtMjQuMzA3OCwgLTI0LjgzMDgsIC0yNS4yOTM0LCAtMjQuNzExMywgLTI3Ljk5OTMsIC0yNy42NTEwLCAtMjYuNDI0OSwgLTMwLjI4NDYsIC0yNS40NDIzLCAtMjguODQ2MSwgLTM1LjkzMTYsIC0zMy43ODg3LCAtMzYuMzU5NCwgLTMzLjU3NjcsIC0yOS42NTQxLCAtMjguODAwNiwgLTMwLjk3OTUsIC0zMS42NjQ4LCAtMzAuNzI1MiwgLTMwLjMxMzUsIC0yOS4zODg1LCAtMzAuMTM0OCwgLTQwLjcxMzcsIC00MS45NTM2LCAtNDAuMjI2NywgLTQxLjY5MzcsIC00My4zMTI2LCAtNDMuNTkwMSwgLTQ1LjUwNDksIC00NC4xMTUyLCAtNDQuMzg1NiwgLTQ1LjA1MjAsIC00My45MjkwLCAtNDUuNTU5NiwgLTQ0LjE5MzUsIC00Ni40MjU5LCAtNDYuOTYwNiwgLTQ4Ljk4NjAsIC00OS44NzM3LCAtNDkuMzIxOSwgLTQ4LjcwMTUsIC00OC4xNDA1LCAtNTEuMDAyMywgLTUxLjE0MzQsIC01MC42MDYxLCAtNTAuODMwMywgLTUzLjEzNjEsIC01NC41OTg4LCAtNTQuOTgwMCwgLTU2LjY1MTksIC01Ni44NDE0LCAtNTYuNzQwOCwgLTU2LjMxODAsIC01Ny4zMTcwLCAtNTcuNTI3MCwgLTYwLjcyMTksIC01OS43MDMxLCAtNTguOTE3MCwgLTYwLjk5MjcsIC02My4zNjM5LCAtNjIuMTgzMywgLTYzLjE2NDMsIC02NS40NzM4LCAtNjUuNTI3OSwgLTY2LjMwNDcsIC02NS42MDg0LCAtNjYuMzUwNiwgLTY2LjIwODcsIC02Ni4yNTk5LCAtNjUuNzM5OCwgLTY2LjgwMzMsIC02Ni40NDE5LCAtNjkuMjI3NSwgLTcyLjE5NzcsIC03Mi4zMjU3LCAtNzIuNDE1OCwgLTcwLjExNTUsIC03MC44MzEzLCAtNzEuNjA5NiwgLTczLjYwMDcsIC03My41NTA2LCAtNzMuNDgyNiwgLTc0Ljg5NTgsIC03My4yNTgzLCAtNzYuNjYzMCwgLTc1Ljk4OTMsIC03Ni40NjE3LCAtNzcuNjE3NSwgLTc3LjY0NDgsIC03NS41NDc1LCAtNzYuMDE2MSwgLTc2LjczMDUsIC03Ny44MjU0LCAtNzkuODIzMCwgLTgwLjYwNjUsIC04MC40NzczLCAtODEuNTMzOCwgLTgyLjEwMzksIC04MS4wMDQ3LCAtODAuNDk2MCwgLTgyLjAzOTQsIC04Mi4yNDQ5LCAtODIuMzIzNywgLTgyLjgwNjYsIC04Mi44OTk0XSxcbiAgICAgICAgZ2FpbjogNSxcbiAgICAgIH0sIF0sXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2d1aXRhciBwYWQnLFxuICAgICAgbGF5ZXJzOiBbe1xuICAgICAgICBidWZmZXI6ICdzb3VuZHMvY28tbWl4L2d1aXRfbmFwcGVfbW9kZV8xLndhdicsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiAwLjUgKiA2MCAvIDEyMixcbiAgICAgICAgbGVuZ3RoOiA4LFxuICAgICAgICBpbnRlbnNpdHk6IFstODYuMzEwMCwgLTg2LjUwNTQsIC04NS45NjYyLCAtNzEuOTk1NCwgLTQxLjQ3MzAsIC0zMC43MTIyLCAtMjguMTYxOCwgLTIyLjA2NDIsIC0yMC4yNDI5LCAtMTkuNjc1MSwgLTE4LjYyMjcsIC0xNi43NjYzLCAtMTUuNDQyMSwgLTE2LjAyODUsIC0xNy4zOTc1LCAtMjAuMTM2NiwgLTIzLjUwNzAsIC0yNi4zOTUzLCAtMjYuNjU1MSwgLTI4LjI0ODcsIC0yNy42OTg3LCAtMjUuNDM3MywgLTI0LjU1MzksIC0yNS4zOTE4LCAtMjYuNjIyNiwgLTI2LjczNzAsIC0yNS45ODY3LCAtMjUuMjE1MiwgLTI1LjU5NTMsIC0yNC43MTU3LCAtMjUuMzUxMSwgLTI2LjE0MTIsIC0yNi40OTMzLCAtMjYuNzYxNiwgLTI1LjgyNjAsIC0yNC4wMDIwLCAtMjIuMzgxNiwgLTIxLjYzNDAsIC0xOS41NDM3LCAtMTcuMzg3NSwgLTE1LjY3ODksIC0xNS44MTk2LCAtMTYuNjUwNSwgLTIwLjA2NDAsIC0yNC4zMjM0LCAtMjMuNDMzNywgLTI2Ljg1NzIsIC0yMi42MjQ4LCAtMjMuOTI4OSwgLTIzLjg5NjQsIC0yMy41MzgxLCAtMjMuNDQ1OCwgLTIzLjQ1NzgsIC0yMy43NTUyLCAtMjEuOTA1NiwgLTI1LjMzMTUsIC0yMi4zOTIyLCAtMjIuMDc3MCwgLTI0LjA1MDcsIC0yMy42MjA3LCAtMjQuNjYxMCwgLTI2LjkwODksIC0yOC4yMjExLCAtMjUuMTgzNSwgLTI5LjAwMjQsIC0yOC44MjIwLCAtMjYuNDUyNiwgLTI1LjMwODQsIC0yNi45NDYzLCAtMjYuMTUxMCwgLTI3LjE3NDgsIC0yOS4yMDM3LCAtMjguNTQxNCwgLTI3Ljk5NzQsIC0yOS42MDc0LCAtMjcuMTg3NiwgLTI2LjkwNDgsIC0yNi40NDI5LCAtMjYuODYyOCwgLTI1Ljg4NDYsIC0yNS4zMDc0LCAtMjQuODY1NSwgLTI2LjYwNjUsIC0yOC41ODg3LCAtMzEuOTIxNiwgLTMxLjE3MDYsIC0zMi41MzgzLCAtMzQuNDcxNSwgLTMzLjgwMzEsIC0zMi45MTA1LCAtMzMuMTMxMywgLTMyLjcwMDAsIC0zMy4zMDQ4LCAtMzQuODQ1NiwgLTM0LjQ3NjQsIC0zMy4yNTk2LCAtMzEuOTYzMywgLTMxLjUxMTYsIC0zMy41MjYxLCAtMzQuNjg0MywgLTM2LjUzNDUsIC0zNy4zNTY0LCAtMzcuNzQ1NSwgLTM2LjgzODMsIC0zNi4yMDY4LCAtMzcuNDQxNSwgLTQwLjUxODgsIC0zOC4xMjgyLCAtMzcuOTA5NywgLTQwLjEyMTMsIC0zNy4zMjI4LCAtMzUuMjMzMSwgLTMzLjUwODYsIC0zMi42MTYxLCAtMzQuOTMxNSwgLTM2LjgzMzcsIC00MS42MjY4LCAtNDMuNDk3MSwgLTQxLjIxNjQsIC0zOS40NzY0LCAtMzguMjk1NCwgLTM3LjU2MTEsIC0zNC45Njk3LCAtMzYuNjg1NSwgLTM5LjE5MTksIC00Mi41NjY3LCAtNDIuODk3MCwgLTQwLjY5MTEsIC0zNi44NDk5LCAtMzguOTQxNCwgLTM3LjU2NzUsIC0zOC4wNzQ3LCAtMzcuNDYwNCwgLTM2LjMzNzYsIC0zNS43NTk0LCAtMzUuNjI3NSwgLTM1LjQzMDAsIC0zNS4yODQ2LCAtMzQuNzE1NywgLTM0LjQ0NDEsIC0zMy45MDE5LCAtMzMuNTY3MiwgLTMyLjgyNTIsIC0zMi4yMzI5LCAtMzIuMjQ5MSwgLTMxLjY5NzIsIC0zMS43MDcyLCAtMzEuNDU2MCwgLTMxLjEzMTIsIC0zMC40MTE4LCAtMjkuOTA0MSwgLTI5Ljk5MTYsIC0yOS45MzExLCAtMjkuMTU0MCwgLTMwLjA4MzIsIC0yOS4wNjUwLCAtMzIuMzk2OCwgLTMxLjMwOTksIC0zMC43MDM3LCAtMjcuNTQwMSwgLTI2Ljc1MzMsIC0zMC40MTE0LCAtMjguMTQ4NiwgLTMwLjI4ODUsIC0yNi43MDc3LCAtMjguNzQ4MywgLTI3LjYyNTAsIC0zMS4yNTI5LCAtMjguMjAyMSwgLTMyLjI5NDcsIC0zMC4wNzc5LCAtMzEuMzY3MywgLTMxLjE5MjgsIC0yOC41NzQ5LCAtMzMuMjY1NywgLTI3LjczOTQsIC0yOS42NTk0LCAtMzIuNTM2MywgLTI4LjM3MTUsIC0yOS45NzY1LCAtMjkuNDM0NCwgLTMwLjg1OTYsIC0zMS4wNjc0LCAtMzEuMTY2MCwgLTMxLjAwMzAsIC0zMi4yMTc0LCAtMzEuNzM4NCwgLTMzLjI2MzQsIC0zMi45MjUyLCAtMzMuMjc2OSwgLTM0LjQ2MjQsIC0zMy4yOTM0LCAtMzQuMjY5NywgLTM0LjAzMzgsIC0zMS42MjgzLCAtMzIuNzc4OSwgLTMxLjgzMTgsIC0zMS42OTAxLCAtMzIuMzI5MCwgLTMyLjI4OTQsIC0zMy40Njk5LCAtMzEuOTE3NiwgLTMyLjc4NTksIC0zMi43MDAzLCAtMzAuMjgwNywgLTMxLjg2NjUsIC0zMC43MzIwLCAtMzMuODE1MiwgLTM0LjYxNjcsIC0zNS41NDY1LCAtMzMuMzY5MywgLTM1LjMxMjYsIC0zMS43OTE1LCAtMzUuNTA4MywgLTM2Ljg0MDksIC0zMi4zODY0LCAtMzIuMTg3OCwgLTMyLjMzNDUsIC0zMy40NDE3LCAtMzEuNjM2NiwgLTI5LjExNTQsIC0yOS45Njk3LCAtMzIuMjMwMCwgLTM0LjM1MTYsIC0zMy42OTU2LCAtMzMuNzE0MywgLTM0LjU0ODcsIC0zNS4zOTQyLCAtMzQuNDE1MCwgLTMxLjg1MzYsIC0zMS4xMTYzLCAtMzEuMjg1NCwgLTMzLjk0NDUsIC0zMy41NzA1LCAtMzMuNzQ1OCwgLTMxLjY1MzQsIC0yOS41MzgyLCAtMjkuOTEzMCwgLTMwLjMyODMsIC0zMS45MjI1LCAtMzQuNTAzNywgLTM1LjU0NzgsIC0zNS42NjM5LCAtMzQuNzExOCwgLTM1LjY3NzQsIC0zMC41NDc3LCAtMjguMzE0MCwgLTI4LjU1NjEsIC0zMC44OTUzLCAtMzQuMzE0NCwgLTM0LjU3NDMsIC0zNy40Njk4LCAtMzUuNjQ0OCwgLTMyLjg4MzEsIC0zMS44NTM5LCAtMzQuMTYwMSwgLTM1LjA3ODEsIC0zNC42MzE1LCAtMzQuMjAzNSwgLTM0LjI3NzAsIC0zNC4wMjgwLCAtMzIuNDQ5NCwgLTM0LjMwMTYsIC0zNi43NjA2LCAtMzkuNjEyMiwgLTQwLjI2NzMsIC0zOS41Mjg1LCAtMzkuOTQwNywgLTM1Ljc3OTgsIC0zNi42MjI4LCAtMzkuNDI2NSwgLTQwLjU5MDksIC0zOC41NTQ1LCAtNDAuODI3NCwgLTM5LjA1MDEsIC00MS4xNDk0LCAtMzkuNDEwMCwgLTQwLjM2NTEsIC00NS45OTA3LCAtNDMuMjI1OCwgLTQyLjkzMTksIC00NS41MDMwLCAtNDMuMDIwNSwgLTQyLjA1NDIsIC00MS44MzMxLCAtNDAuNDgxMSwgLTM5LjU4NTEsIC0zOS43MDA1LCAtMzkuODQwMSwgLTM4Ljc2NjAsIC0zOC4wMzMyLCAtNDEuOTkxMCwgLTQzLjYyOTgsIC00My4xMDUzLCAtMzkuNDIxMCwgLTM3LjAyOTMsIC0zMy4zNTMzLCAtMzAuNDE1NywgLTI5LjA4ODgsIC0yMy42ODQxLCAtMjEuNTA1NiwgLTIxLjYxOTMsIC0yMi4zNjczLCAtMjMuNDMyOCwgLTI0LjQ3MzcsIC0yNS4yNzc0LCAtMjQuNDcyOCwgLTIyLjgxODIsIC0yMS42NDg4LCAtMjIuOTM1MCwgLTI2LjE3ODIsIC0yOC41NzcwLCAtMzAuMzkxNywgLTI5LjM0NDYsIC0yOC4xMjU3LCAtMjcuNTMzMywgLTI3Ljc0NjAsIC0yNy41OTc1LCAtMjYuNDIwMiwgLTI1LjQyNjAsIC0yNi4xMDQ0LCAtMjUuNDk5NiwgLTI2LjI5MDYsIC0yNS43MzE0LCAtMjUuMjY3NSwgLTI1LjAyMjAsIC0yNS4zODg2LCAtMjIuMTA2NSwgLTIxLjIyODIsIC0yMC40MjI2LCAtMTkuMzY0MywgLTE3LjUxNTIsIC0xNi4zODEyLCAtMTcuNzg2MywgLTE5LjgyMTQsIC0yMS4wODIyLCAtMjIuNzAyMywgLTIyLjgxMzQsIC0yMy45OTU4LCAtMjMuNzQxNSwgLTIzLjg1NDQsIC0yMi44NzIzLCAtMjQuOTMyMCwgLTI2LjMzNDUsIC0yNS4zNDQzLCAtMjUuMTQ2MiwgLTIzLjkzOTEsIC0yMi43Mzc4LCAtMjMuNjI1MywgLTI0Ljg1OTUsIC0yNC4yNDQwLCAtMjYuMTI3OCwgLTI3LjA5NDAsIC0yOC4zNjk5LCAtMjcuMzM3OCwgLTI3Ljk5MjQsIC0yNy40Mjg1LCAtMjguNzMyOCwgLTI4LjU1NDksIC0yOS45NTAyLCAtMzAuMDc4MSwgLTI3Ljc5MDAsIC0yNy43MzU5LCAtMjcuNDMzNywgLTMxLjMxOTgsIC0yOS4xMDc2LCAtMjYuOTUwNywgLTMwLjc1NzUsIC0zMC43MzExLCAtMjkuMTkyMCwgLTI5LjA4NDQsIC0zMS4yMDQ0LCAtMjkuNTU5MywgLTMwLjk5NjYsIC0yOS4zNDc1LCAtMjguODIwOCwgLTI5LjYxMjYsIC0yOC42MDE0LCAtMjYuMTQ3OCwgLTI2LjE1MjEsIC0zMC4wNTYyLCAtMzAuNzQyNiwgLTMwLjMwNTMsIC0zMS4zMjI2LCAtMzEuNDk1NywgLTI5LjM1OTEsIC0zMC42NzA0LCAtMzAuNzA0MCwgLTI2LjQ5OTIsIC0yNS45NjgwLCAtMjcuODI0OCwgLTI5LjMyMTAsIC0zMC42MjUwLCAtMzEuMjM4MSwgLTMzLjg1MjQsIC0zMS44ODc4LCAtMzEuMTIwNiwgLTMzLjc4MDEsIC0zNS40MDM4LCAtMzUuOTc5NiwgLTMyLjc0MjcsIC0zMS42ODY5LCAtMzIuNzcyOSwgLTMxLjUzNTMsIC0yOC42MTQ2LCAtMjguMzgwMiwgLTMwLjMzMjYsIC0zMi4wMjAzLCAtMzIuNDAzMywgLTMxLjk4ODcsIC0zMS4xNDAxLCAtMzAuNzIwOSwgLTMwLjQ4NDQsIC0zMC40NDA4LCAtMzMuODczOSwgLTM2LjA3NTEsIC0zNy42Mjk4LCAtMzQuOTg5OCwgLTM2LjA2NTYsIC0zNC45OTQ4LCAtMzMuNDU3MCwgLTM2LjQyNjAsIC0zNC4yMTU1LCAtMzIuMjc1NywgLTMwLjE4NDIsIC0yOS41Nzg0LCAtMjcuODUwMSwgLTI5LjA0OTQsIC0zMS4wNjQyLCAtMzEuOTM2OSwgLTMyLjQwMTUsIC0zOS42NjgyLCAtMzguOTE4NSwgLTM1LjMwMTEsIC0zMy43NDczLCAtMzQuNzI1MSwgLTM0LjUxNDcsIC0zNS40Mjc1LCAtMzEuNjkwNCwgLTMxLjIzNDIsIC0zMS4yNDM2LCAtMzEuMTYzMCwgLTMxLjMwNTUsIC0zMy44NzE2LCAtMzYuMDUzNCwgLTM3Ljg3MjEsIC00MC4xNjI2LCAtMzguMDk0MiwgLTQxLjQ5ODIsIC0zOS40MTUwLCAtMzcuODQ4MCwgLTQwLjYxMzQsIC0zNi44NTMzLCAtMzguMTA3MSwgLTM1LjMzNDMsIC0zNC41NTAzLCAtMzcuNjg3MCwgLTM3LjcwMTYsIC0zOS42MjA4LCAtNDEuMTU4MiwgLTQxLjUyMTksIC00My45NTUwLCAtNDEuODQzOSwgLTQyLjUzNTIsIC00MS44MjI1LCAtNDMuMTIwNywgLTQyLjQ5MzksIC00Mi41NjE1LCAtNDAuMDAxNSwgLTQwLjU0NDksIC00MC4zNzg5LCAtNDAuMTc3OSwgLTM5LjE3OTcsIC0zOC40NDE5LCAtMzguMjIzOCwgLTM4LjIwODMsIC0zOC4wNTc2LCAtMzcuNTY5OCwgLTM2Ljk1MzEsIC0zNi4wMzEwLCAtMzUuODEwOSwgLTM1LjQ0MzUsIC0zNS4yOTI5LCAtMzUuMjE1NywgLTM1LjE5MTYsIC0zNS40NjE5LCAtMzUuNTIzMiwgLTM1LjUzODQsIC0zNC45ODQ3LCAtMzUuMDA3OCwgLTM0LjgyOTEsIC0zNC40NDk3LCAtMzUuMDEwOSwgLTM1LjI2NDcsIC0zNC4yODY2LCAtMzYuNjQ2MywgLTM2LjEyMDUsIC0zNS4xMjI3LCAtMzMuMDA0OSwgLTMyLjY5NTIsIC0zNS44NTA0LCAtMzIuMTkyMiwgLTM1LjIxMzMsIC0zMy42MTEzLCAtMzQuODM2OSwgLTMyLjcwMjAsIC0zMy44MDI2LCAtMzMuNjkxNCwgLTM1Ljg2NDIsIC0zNC40MjM1LCAtMzUuNDM5MywgLTMzLjg3MDUsIC0zNS42MzAzLCAtMzUuODU4NSwgLTMyLjQ1NTUsIC0zMy45MDU5LCAtMzMuNTY2MSwgLTMyLjU0NjEsIC0zMS4xNzQwLCAtMjkuNjk5NCwgLTMwLjk2NTUsIC0zMC4wNjE3LCAtMzAuNzY5NiwgLTMxLjEyODcsIC0zMi4yODg2LCAtMzEuODUzOSwgLTMzLjY1MjEsIC0zMi43NjY2LCAtMzEuNDUxOSwgLTMwLjE0MjYsIC0zMC4xMzQ3LCAtMzEuMDY5MCwgLTMwLjc0ODQsIC0yOS45NzUzLCAtMzAuMDM5MSwgLTMwLjE5MTMsIC0zMC4wNTEyLCAtMzEuNjczMiwgLTMxLjU0MjcsIC0zMS4zMjI2LCAtMzAuNjkyOCwgLTMwLjAyNjAsIC0zMi41ODU5LCAtMzAuODE2OSwgLTMyLjAwNjMsIC0yOS4wOTYxLCAtMzEuMjg4OCwgLTMxLjcwNDEsIC0zMi42MDg1LCAtMzEuNTU2MCwgLTMzLjY3NjcsIC0yOC41Njg3LCAtMzIuMzYwNSwgLTMzLjgwODMsIC0yOS43NTE5LCAtMjguODg2NCwgLTI5LjU2NzAsIC0zMS41MDY0LCAtMjkuOTE0OSwgLTMwLjQ2MTQsIC0yOC43Mzg5LCAtMzAuMTc0MiwgLTMwLjU4MzYsIC0zMi4yNDIxLCAtMzMuMTM2MCwgLTMzLjE5NzksIC0zMi4yNzYxLCAtMzEuNjczNywgLTMyLjU3MjAsIC0zMi45MDEyLCAtMzIuMTUwOSwgLTMyLjUxNDAsIC0zMy4wMTMyLCAtMzEuMjM4OCwgLTMwLjMxNTYsIC0yOC45NjM3LCAtMjguOTE5NywgLTMwLjk5NDEsIC0zMi41NjgxLCAtMzQuMzYwMCwgLTM2LjIxNjQsIC0zNC43ODgzLCAtMzIuOTc2MCwgLTMyLjQyNjYsIC0zMS44MjQ0LCAtMzEuOTI3NCwgLTMxLjg3MjEsIC0zMy45NDA3LCAtMzIuOTIxNiwgLTM0Ljc2NjgsIC0zNC45NDg2LCAtMzUuMjUxMiwgLTM2Ljk3MjUsIC0zNi4xNTU0LCAtMzMuNDEyNiwgLTMzLjkxMDksIC0zNi43NzczLCAtMzYuNDE3MiwgLTM1LjQxNjYsIC0zMy42MDcyLCAtMzEuOTYzMywgLTMxLjcyMDIsIC0zMi44MTAxLCAtMzcuMTQ5NiwgLTM5LjcwMDgsIC0zOC4yODY1LCAtMzguMTM4NSwgLTM4LjA2MTMsIC0zOC40Nzc3LCAtMzcuODE4NiwgLTM2LjE5MzcsIC0zOS4wNjA5LCAtNDAuNDM3MiwgLTM5LjUwNDIsIC0zOS4wNjM3LCAtMzcuMzg1MywgLTM2Ljg3NzksIC0zOC42NjM2LCAtMzkuODk5OSwgLTQyLjkzMDEsIC00My41MjIwLCAtNDUuMzY2NiwgLTQyLjkxMTYsIC00MS40MzMzLCAtNDIuOTQzNSwgLTQ1LjUxNTIsIC00My4yOTIyLCAtNDQuMjI2OCwgLTQzLjUwOTMsIC00Mi4xNDI5LCAtNDMuNDY3MiwgLTQyLjUyNzEsIC00My4wNTgwLCAtNDIuODUwNiwgLTQ0LjgzODUsIC00Ny4zMDg0LCAtNDcuNzYxNywgLTQ5LjIwNzgsIC00Ni43NzYzLCAtNDYuNzEyNSwgLTQ3LjMxNTgsIC00Ny44MzI2LCAtNDYuNTMwOSwgLTQ1LjU5MzMsIC00NS4xMDM1LCAtNDQuNzQ2MSwgLTQ0LjczMzYsIC00NC4zMjIzLCAtNDIuODk1MywgLTQyLjEyNzgsIC00Mi41Mzg5LCAtNDMuMTc3MywgLTQzLjU5OTEsIC00Mi43NTg3LCAtNDIuOTg4MywgLTQzLjczNTAsIC00My4yODQzLCAtNDMuNTE3NiwgLTQyLjM1NzAsIC00MS41MzcxLCAtNDAuODczMywgLTQxLjQxMTYsIC00MS4yMjAzLCAtNDAuMDg5MiwgLTM4LjczMjAsIC00MC41MzQ3LCAtNDAuODQxNSwgLTQwLjMyMTgsIC00MC4xNTk5LCAtMzcuMzU2OCwgLTQwLjExMTEsIC00Mi45NzkyLCAtNDcuNTQyMCwgLTQzLjEwNzYsIC0zOC4xMjUzLCAtMzkuNzc1MSwgLTQwLjQ4NjMsIC0zOC45ODY0LCAtMzcuMTY3NCwgLTM3LjYwODgsIC0zNi4xMDIwXSxcbiAgICAgICAgZ2FpbjogMCxcbiAgICAgIH0sIHtcbiAgICAgICAgYnVmZmVyOiAnc291bmRzL2NvLW1peC9ndWl0X25hcHBlX21vZGVfMi53YXYnLFxuICAgICAgICBzdGFydE9mZnNldDogMC41ICogNjAgLyAxMjIsXG4gICAgICAgIGxlbmd0aDogOCxcbiAgICAgICAgaW50ZW5zaXR5OiBbLTg2LjYzNTEsIC04Ni4wOTk5LCAtODYuNjQxNSwgLTgyLjI3MTYsIC0zNy41ODMxLCAtMzEuNTg5MywgLTI4Ljc0MjMsIC0yNC4yODc5LCAtMjIuMTAxOSwgLTI1LjA1MzMsIC0yOS45NjQxLCAtMzAuNDgxNCwgLTMyLjcwNTYsIC0zNS40MzgwLCAtMzIuNTA1OSwgLTI1LjM1OTUsIC0yMy41Mzg4LCAtMjYuMjEwMiwgLTI1LjY5OTYsIC0yNS42OTk2LCAtMjkuMTIwNCwgLTM1Ljc0MDAsIC0zMi43NzY3LCAtMjcuNzk4MCwgLTI2LjAyODMsIC0zMy42OTI4LCAtMzAuMTIxOCwgLTI2LjgyMjAsIC0zMC42Nzk2LCAtMzQuNjI3OSwgLTMyLjU0NDMsIC0zMi4yODM0LCAtMjkuMDUyMCwgLTMyLjc0MjUsIC0zMy42NDM4LCAtMzIuODI0OCwgLTMzLjYyODcsIC0yNy40MTE5LCAtMjMuNzM4MCwgLTE5Ljk0MDYsIC0yNC44NjYzLCAtMjQuNzY3MywgLTIyLjkxMTMsIC0yOS45NDc1LCAtMzIuNjc0OSwgLTM0LjAzNDgsIC0zMC4yMDcwLCAtMjguNDcyMiwgLTMxLjQ5MjAsIC0zMi4wMjQxLCAtMzAuMjcyMCwgLTMyLjQ2NDksIC0zNC40MjM2LCAtMzAuMjMzNCwgLTI4LjMyNDYsIC0yNS41NTEyLCAtMzEuNjAxMSwgLTMyLjQ3OTksIC0zNC41MTU2LCAtMzkuMjM4MywgLTM2LjExOTQsIC0zNy40NzUxLCAtMzUuMzA2NCwgLTM0Ljg0MTAsIC0zOC4wNzM1LCAtMzUuOTg5NiwgLTM1LjI0MzAsIC0zNy45Mjc3LCAtMzcuNzM4MCwgLTM1Ljk4ODIsIC0zNS43NTMzLCAtMzQuODIzOSwgLTQxLjg1NjksIC00MS45MDQzLCAtNDAuNDcyOSwgLTQ0LjU5MTEsIC00MS43MjA3LCAtNDMuNTkxNiwgLTQ0LjI3MzcsIC00NC45MzY4LCAtNDkuMTc4NiwgLTQ2LjQ2NjksIC00Ni4wMjM5LCAtNDkuMDIyOSwgLTQ1LjM0ODAsIC00NC44NTMyLCAtNDIuODIyMCwgLTQzLjY0OTgsIC01MC4wNTY0LCAtNDguNDUzNywgLTQ5LjQ3NDcsIC01Mi4xMTgwLCAtNTAuODUwMiwgLTUzLjIzMTEsIC01My4wNTA1LCAtNTUuNzY1OSwgLTYwLjUyNjEsIC01NS4yNDQ0LCAtNTUuOTQ0OSwgLTU4LjM1MzQsIC01NC4yMjg4LCAtNTQuNTc4MCwgLTUxLjU4MTksIC01My45MzMyLCAtNTguODIyMCwgLTU2LjM1NjYsIC01OC41ODg3LCAtNTkuOTExMCwgLTU5LjQ3MjgsIC02MS40MjgxLCAtNjEuNTE4NywgLTY1Ljc0MzcsIC02OS4xMDcxLCAtNjMuODcwOCwgLTY2LjE5ODMsIC02Ni44MDg1LCAtNjIuNzU1NywgLTYzLjc1MDMsIC02MC45MTYyLCAtNjQuNzgxMiwgLTY3LjQ1NTIsIC02NC43NTU3LCAtNjguNTg2NywgLTY4LjQyMTgsIC02OC43ODc1LCAtNzAuMjk1OCwgLTcwLjgzMzUsIC03NS41NTY2LCAtNzYuNzg5NiwgLTcyLjUwMDAsIC03NS40OTc0LCAtNDguMjA5MywgLTM5LjUwMDQsIC0zMy42NDQyLCAtMjguOTEwMCwgLTI4LjE5NjIsIC0yOC4yOTYzLCAtMjkuNDUxOCwgLTMwLjU0OTcsIC0zMS40MTQ1LCAtMzEuMDY1NiwgLTI5LjQwODEsIC0yNy4yOTk0LCAtMjUuMDcxNSwgLTI0LjI0NjgsIC0yNC4yNTk5LCAtMjQuODg3NywgLTI2LjEzNzEsIC0yNy41NzEwLCAtMjguMDYzMSwgLTI4LjQxODcsIC0zMC41MjM4LCAtMzIuMjY3NywgLTI2LjkxNTksIC0yNC40NzQxLCAtMjQuNjc2NSwgLTI1LjIyNjQsIC0yNi42NjkwLCAtMjYuMjM4OCwgLTI2LjIyOTEsIC0yNy4wMjMyLCAtMjcuMzcwOCwgLTI4LjAxNDUsIC0yOC4wMzAzLCAtMjguODQ1NCwgLTMwLjA5NDQsIC0yOC4zMDEzLCAtMjkuMjQzNiwgLTMzLjM5NDcsIC0zMS41NjE3LCAtMzAuMDgzMSwgLTMwLjI3NDIsIC0zMS4yNjY4LCAtMzEuNTk2NywgLTI4LjUyMTMsIC0yNC45ODI4LCAtMjEuNjI1NywgLTIwLjcwOTIsIC0yMC4zNjM2LCAtMjIuMjY2NCwgLTI1Ljk5NzgsIC0yOS41MDMyLCAtMzAuNDg0NCwgLTI4LjYwNjEsIC0yNC44MTE2LCAtMjEuODc2MywgLTIwLjc3ODAsIC0yMC45NzUyLCAtMjIuODkwMSwgLTI2LjIxNTMsIC0yOC4zNTQzLCAtMzAuMjI3MywgLTI5LjczNjMsIC0yNy41Nzk4LCAtMjQuNDQzMiwgLTI0LjUyMDEsIC0zMC41MzAwLCAtMzMuOTQ1OSwgLTMwLjM0OTUsIC0yOS4zOTMxLCAtMzAuNTUzMywgLTI5LjAzNTIsIC0yNy4yODI0LCAtMjcuNDMyMCwgLTI5LjQ2MTIsIC0zMi45MjE1LCAtMzQuMzk1NSwgLTMwLjcyNTAsIC0yNy41NzY3LCAtMjUuNDkzOSwgLTI4LjYzMzUsIC0zMS44MDI4LCAtMzMuODYwMywgLTMyLjg2ODUsIC0zNS4zNjYwLCAtMzIuNzk0MywgLTI3LjY0NjMsIC0yNy45NDYxLCAtMjYuMjcxOSwgLTI5LjM4NjgsIC0zMC4yOTQ4LCAtMzEuMzIzMiwgLTMyLjI3NjgsIC0zMi45ODg3LCAtMzMuMDE1MSwgLTMwLjMzODQsIC0zMS40MTM1LCAtMzQuNTY0MCwgLTM0Ljk4NjMsIC0zOC40MzkwLCAtMzguMTA4MiwgLTM3Ljg0OTksIC0zNC4wMTQ0LCAtMzMuODMyOSwgLTMzLjUzNDQsIC0zMy40OTY3LCAtMzYuOTE3MSwgLTM4LjA3OTEsIC0zOS44Mjg1LCAtNDAuNjMzNywgLTM4LjI2NTIsIC0zOC42NDk3LCAtNDAuNTAxMiwgLTQxLjg5MDIsIC00My4xMzUyLCAtNDQuNTkzOSwgLTQ0LjEzOTksIC00My42NTQxLCAtNDAuODQxMCwgLTQxLjE3NTUsIC00MS45MjA1LCAtNDIuNjYyMywgLTQ1LjQ3OTksIC00Ny44NjI0LCAtNDguNjU3OCwgLTQ3LjcyNjEsIC00NS40MDkxLCAtNDcuNTgxMCwgLTQ5LjI5ODQsIC01MC4yMjI2LCAtNTEuMzM4MiwgLTUxLjc5MDIsIC01MS4zNzE2LCAtNTEuNjA3NCwgLTQ5LjkwMzMsIC01MC41MzgwLCAtNTEuNzUwNCwgLTUyLjUyNDAsIC01NC42NzYzLCAtNTUuNTU3NCwgLTU1LjUxNjIsIC01NS40MzcwLCAtNTMuNjYxNSwgLTU2Ljk3OTIsIC01OC41NDEzLCAtNTkuNTAwNiwgLTYwLjEwMzMsIC02MC4wNDAwLCAtNTkuNTU4NiwgLTQzLjg4MzQsIC0zNC45NTcyLCAtMzQuMjM1MSwgLTMxLjY5OTcsIC0zMi43MDgxLCAtMzMuOTQ2NywgLTMzLjYyOTcsIC0zMy4xMTY1LCAtMzMuNjYwNCwgLTM0LjUzNjQsIC0zNi4zOTY2LCAtMzkuMzg0NywgLTQyLjQ1MjQsIC00NS4zOTEwLCAtNDcuMzE1NCwgLTQ2LjU4NzQsIC00My45MjUxLCAtNDEuMTU3OSwgLTM2Ljc0MjEsIC0zNi4wNzQxLCAtMzYuMjkzOCwgLTM4LjUyMjgsIC0zNC4yMzI1LCAtMjkuNjI4MywgLTI2LjkzNjgsIC0yNS43MDk0LCAtMjUuNTE1OCwgLTI4LjY5NDEsIC0zMy4xMzA1LCAtMzYuNjc3MSwgLTM3LjQ4NTIsIC0zMy4xMzY0LCAtMzEuMTMwNSwgLTI5LjQwODYsIC0yNC44NTA1LCAtMjYuODU3MSwgLTMwLjk4MjAsIC0zMS4zOTg2LCAtMzIuODQzMSwgLTMzLjM1NzAsIC0zMS4wMTc4LCAtMjcuODMwNSwgLTI4LjM0NDQsIC0yNy44OTkxLCAtMjguNjQzNSwgLTI1LjIyOTIsIC0yNC43NTI5LCAtMjUuNjY0OCwgLTI0LjQ1ODYsIC0yOC4wOTEyLCAtMjguOTMzMCwgLTI5LjIxNjQsIC0zMy40MzI4LCAtMjguMzM2MywgLTI5LjU1NjMsIC0yOS41NTY2LCAtMjUuNzMyNCwgLTI4LjM1NjQsIC0yNy4xNDYyLCAtMzAuNTM4MCwgLTMyLjg0OTEsIC0zMS40MzgyLCAtMzEuMTU3NiwgLTMwLjgyNTUsIC0zMS42NzIzLCAtMjYuODU4MCwgLTE5LjYzNTcsIC0xOC41MDkwLCAtMTguMzQ5MSwgLTE3LjE2OTMsIC0yMC44NTg0LCAtMjQuMzM4OCwgLTI1LjUzOTMsIC0yNi4yMDQxLCAtMjIuODIwMywgLTE4LjkxOTMsIC0xNy45NDc5LCAtMTcuOTMzMywgLTE4LjAwNzYsIC0yMC44MzQ4LCAtMjQuNTI0OSwgLTI1LjYwNjYsIC0yMy45NzcwLCAtMjQuNzE0OCwgLTI0LjIwMzAsIC0zMC4wODM5LCAtMjUuNjEwNSwgLTIzLjMzNzQsIC0yNC40MjY4LCAtMjcuNDc5NiwgLTI1Ljg3NDUsIC0yMy40OTYyLCAtMjIuOTI1OCwgLTIxLjY5NTksIC0yMi41NjY4LCAtMjYuNDcwNywgLTMyLjMwMTcsIC0zMi40NzIyLCAtMjkuNzUxOSwgLTMyLjc0ODAsIC0zMS42MzgyLCAtMzAuMjkyNCwgLTMwLjQzNTMsIC0yOC4wMTkyLCAtMzAuOTM0NiwgLTMwLjUxOTAsIC0zMC41NjI4LCAtMjcuODAyMSwgLTI5LjgwNzEsIC0zMS42MTY2LCAtMzIuMDAyOCwgLTI5LjUzMzYsIC0zMC4zODE0LCAtMzAuNDYzNSwgLTMyLjI2MDYsIC0zNS42ODQ5LCAtMzIuODI4OCwgLTMwLjk0NDMsIC0yOS40MjY1LCAtMjkuNTY2NSwgLTI3LjYyNDksIC0yOS41NDg1LCAtMzEuODk4OSwgLTMyLjk1OTcsIC0zNC4wMjU1LCAtMzUuODA2OCwgLTM3LjQ1NzEsIC0zNy42ODU2LCAtMzguMzI2NywgLTM2LjY3MzIsIC0zMi4zMzEzLCAtMzEuNTY0MSwgLTMyLjk3OTAsIC0zMS41MTM3LCAtMzQuNzAwNiwgLTM1LjA1MzksIC0zNC4yMDM2LCAtMzUuMDEzOCwgLTM0Ljk1NjksIC0zNS4wNTgyLCAtMzEuMTQxNiwgLTMwLjc5NzYsIC0zMC45MzExLCAtMzAuNDE0NywgLTMyLjEwNDksIC0zOC4xNTg1LCAtMzkuOTM2NywgLTM1LjkzNDYsIC0zNS4wOTUyLCAtMzcuMDM2NiwgLTMyLjE2MjEsIC0yOS4zNTA4LCAtMzQuNjk3NywgLTMzLjMzMTMsIC0zMy4wNTc0LCAtMzcuMDY1MywgLTM3LjEwMzYsIC0zNi45ODM5LCAtMzYuMDM1MiwgLTM3LjYzNTEsIC0zNy4zNTQ1LCAtMzEuMjA5OSwgLTI3LjMyODQsIC0yNi41NDg0LCAtMjguNjAyOSwgLTMyLjM2ODUsIC0zMy4xMzE3LCAtMzMuNTE3NiwgLTM5LjczMTEsIC0zNi42MzA5LCAtMzcuMDIwNywgLTM3LjE1ODksIC0zNi4zOTQ1LCAtMzcuMDA2MywgLTM4LjY2NjcsIC0zOS43NDUxLCAtMzcuNTMyNiwgLTMyLjk1MDAsIC0zMC40OTI1LCAtMjkuMjc3NSwgLTMwLjk2MDgsIC0zNC4wODAyLCAtMzUuOTk1NCwgLTM5LjYyMTIsIC00NC4wNjUzLCAtNDIuMjA2MSwgLTM5LjYxNDEsIC0zNS4xMTgzLCAtMzUuMTc2OCwgLTM2LjEyMDEsIC0zOC44NDM3LCAtMzYuNjY0NSwgLTMxLjY0MzYsIC0yNy43Njc2LCAtMjUuMTg2NSwgLTI2LjM0NzQsIC0yNS42NDkyLCAtMjYuNjY0MCwgLTI4LjkyNzAsIC0zMS43MTY3LCAtMzEuMjE5OCwgLTMwLjI2MzEsIC0yNi4yMDgwLCAtMjMuNzUyMCwgLTI0Ljg2MzgsIC0yNC41ODc5LCAtMjYuMjI4MywgLTI4Ljc4NzIsIC0zMC4wMzg5LCAtMzAuMzk2NCwgLTMxLjMxNjcsIC0zNS43OTQ4LCAtMzQuMTA0NSwgLTM1LjM1NjksIC0zMi4yMDA5LCAtMzEuNjU1MSwgLTI4Ljg4NTksIC0zMS4wMzU2LCAtMjcuOTc3MiwgLTI3Ljc0MDAsIC0zMC43NTUyLCAtMjguNzM1MSwgLTMxLjY1MTYsIC0zMC40MTc2LCAtMzAuMjgxOCwgLTI4LjQwNjgsIC0yOS42MzEyLCAtMzAuMDQ4OSwgLTI5LjM2NjMsIC0zMy41MDk4LCAtMzIuNjAwOCwgLTMxLjU0ODgsIC0zNS4yNzQxLCAtMzMuNjQzMSwgLTI3LjYwNjQsIC0yNy45MTQyLCAtMzAuODczMiwgLTI3LjM5NDQsIC0yNy43OTMyLCAtMzIuMDE1OCwgLTMxLjUzOTIsIC0zNC4zNTIwLCAtMzQuNDcyMiwgLTMyLjI5MTYsIC0zMi4wMDc0LCAtMjguOTY4MywgLTMwLjYxNDYsIC0zMC42ODcwLCAtMzAuNTc4MiwgLTMyLjE4NTQsIC0zMi4wNzE0LCAtMzMuNjYyMiwgLTM0LjQyMjQsIC0zMS4wMDI1LCAtMzEuOTg0NywgLTM1LjI4OTIsIC0zMy4zMjk5LCAtMzIuMzUzNiwgLTMzLjcxODEsIC0zNC40MzE5LCAtMzMuNTEzNywgLTMzLjYzOTAsIC0zNS4yODQxLCAtMzYuMjc4MiwgLTM1LjY5NjksIC0zNS40Njc4LCAtNDAuMzA0NiwgLTM5LjQyMDMsIC0zOS4wMjY4LCAtMzcuNjY3MiwgLTM2Ljg0NTEsIC0zOS4wNzAwLCAtMzguNDY5OSwgLTM4LjQ5MjEsIC0zOS4zNzY2LCAtMzguODQzOCwgLTM4LjUxMDgsIC0zOS40MzM1LCAtNDEuODkxNywgLTQxLjcyMDEsIC00Mi42ODc1LCAtNDMuNDk5OCwgLTQ1Ljc4MTgsIC00My44MTUxLCAtNDUuMTk3NywgLTQ2Ljg3MjIsIC00Ni4yOTI3LCAtNDkuMzMxNCwgLTQ4LjAxNjAsIC00OC42MjQwLCAtNDcuNzkyMiwgLTQ2LjgyNTUsIC00Ni4zODg1LCAtNDcuMDE5NiwgLTQ4LjkwNjEsIC01MS4yNjgzLCAtNTIuNzc4MiwgLTQ4LjE2MDYsIC00My4wOTYxLCAtMzguMzY5NywgLTM2Ljk5NDksIC0zNy4yMTgzLCAtMzcuNzAxMSwgLTQwLjI4MjcsIC00My4zMDM5LCAtNDQuNzk0MSwgLTQ0LjIxNjMsIC00My41NTQ5LCAtNDIuNjczMCwgLTQxLjA4MzcsIC00Mi4wNjk0LCAtNDQuMTA0NCwgLTQ1LjY5MzEsIC00NS45MDQ5LCAtNDQuNTU1NSwgLTQxLjc1NjksIC00MS4xMDU3LCAtNDEuMjY2NywgLTQxLjc4ODMsIC00NC4wNzI0LCAtNDYuMTc4OCwgLTQ3LjcyMjMsIC00OC4wMzY4LCAtNDcuNDUwOCwgLTQ2LjI5MDIsIC00NS40MTg2LCAtNDcuMDgwOCwgLTQ5LjI1OTEsIC01MC44ODE5LCAtNTEuMDQxNCwgLTUwLjM4MzcsIC00OC4zNTcyLCAtNDguMjYyMywgLTQ4Ljc5ODgsIC00OS42MzkyLCAtNTEuNTAzNiwgLTUzLjIwNjYsIC01NC40NzAwLCAtNTQuNjM1OCwgLTU0LjgzNDksIC01NC4zNzAyLCAtNTMuODcwOCwgLTU1LjgzNzcsIC01OC4xNDA2LCAtNTkuNjczMiwgLTU4Ljk5NjAsIC01Ny45MTE2LCAtNTYuMDI1NCwgLTU2LjY3NjEsIC01Ny4yMzkzLCAtNTguNjU5OSwgLTYxLjAxNTUsIC02Mi42NDI1LCAtNjMuNTcyNSwgLTYzLjMyMDIsIC02My4zOTAzLCAtNjIuNTg5OSwgLTYyLjY5MzcsIC02NS4yMzE5LCAtNjcuNDA5NCwgLTY0LjIzNTAsIC00OS4xMjgwLCAtNDQuNjM4OCwgLTQyLjg3OTUsIC00Mi40MjM2LCAtNDQuNTE3NSwgLTQ1LjI4NjksIC00OC40NjQyLCAtNDguNTY1NSwgLTQ4LjE5MTUsIC00NC41NjE1LCAtNDIuNjIxOCwgLTQyLjMxMjMsIC00Mi40MDk2LCAtNDMuMjQ4MCwgLTQ0LjIzMDUsIC00Ni40MTcxLCAtNDkuMTgyNSwgLTQ5LjA1MjcsIC00OS4xMzM0LCAtNDguODAzOSwgLTQ5Ljc5NDQsIC00OC4wMDYwLCAtNDUuODc5NywgLTQzLjIxODEsIC00Mi40NzU5LCAtNDEuOTUzMiwgLTQyLjQzMTAsIC00NC4wMzA4LCAtNDUuNTUwMiwgLTQ1LjQzMDgsIC00NS41MTUyLCAtNDQuMDg0OCwgLTQxLjk4NDYsIC00MC45MTU4LCAtNDEuMzY5MywgLTQyLjYyMjQsIC00NS4wODQ2LCAtNDUuOTczMSwgLTQ2LjAwMTIsIC00NC43OTYxLCAtNDQuNzk0OF0sXG4gICAgICAgIGdhaW46IDMsXG4gICAgICB9LCBdLFxuICAgIH0sIF0sXG4gIH0sXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKlxuICAgKiAgV1dSWTpSXG4gICAqXG4gICAqL1xuICAnd3dyeS1yJzoge1xuICAgIHRlbXBvOiA4MS41LFxuICAgIHRlbXBvVW5pdDogMSAvIDQsXG4gICAgdHJhY2tzOiBbe1xuICAgICAgbmFtZTogJ2RydW1zJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy93d3J5LXIvZHJ1bXMubXAzJyxcbiAgICAgIG1hcmtlcnM6ICdzb3VuZHMvd3dyeS1yL2RydW1zLW1hcmtlcnMuanNvbicsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3ZlcnNlJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy93d3J5LXIvdm9pY2Utc29sby5tcDMnLFxuICAgICAgbWFya2VyczogJ3NvdW5kcy93d3J5LXIvdm9pY2Utc29sby1tYXJrZXJzLmpzb24nLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjaG9ydXMnLFxuICAgICAgYnVmZmVyOiAnc291bmRzL3d3cnktci9jaG9pcnMubXAzJyxcbiAgICAgIG1hcmtlcnM6ICdzb3VuZHMvd3dyeS1yL2Nob2lycy1tYXJrZXJzLmpzb24nLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmcmVkZHknLFxuICAgICAgYnVmZmVyOiAnc291bmRzL3d3cnktci9zaW5nLWl0Lm1wMycsXG4gICAgICBtYXJrZXJzOiAnc291bmRzL3d3cnktci9zaW5nLWl0LW1hcmtlcnMuanNvbicsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3Bvd2VyIGNob3JkJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy93d3J5LXIvZ3VpdGFyLWNob3JkLm1wMycsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2d1aXRhciByaWZmJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy93d3J5LXIvZ3VpdGFyLXJpZmYubXAzJyxcbiAgICAgIG1hcmtlcnM6ICdzb3VuZHMvd3dyeS1yL2d1aXRhci1yaWZmLW1hcmtlcnMuanNvbicsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2Nob3J1cycsXG4gICAgICBidWZmZXI6ICdzb3VuZHMvd3dyeS1yL2Nob2lycy5tcDMnLFxuICAgICAgbWFya2VyczogJ3NvdW5kcy93d3J5LXIvY2hvaXJzLW1hcmtlcnMuanNvbicsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2RydW1zJyxcbiAgICAgIGJ1ZmZlcjogJ3NvdW5kcy93d3J5LXIvZHJ1bXMubXAzJyxcbiAgICAgIG1hcmtlcnM6ICdzb3VuZHMvd3dyeS1yL2RydW1zLW1hcmtlcnMuanNvbicsXG4gICAgfSwgXSxcbiAgfSxcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWFwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi93ZWFrLW1hcFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9ICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMi5kZWZhdWx0KShvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSA/IGFyciA6ICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZnJvbSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59OyIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVyICovXG5cbmNvbnN0IHR5cGVDb3VudGVycyA9IHt9O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIG5ldyBjb250cm9sbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzIC0gRGVmYXVsdCBwYXJhbWV0ZXJzIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIFVzZXIgZGVmaW5lZCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmNsYXNzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBkZWZhdWx0cywgY29uZmlnID0ge30pIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICAvLyBoYW5kbGUgaWRcbiAgICBpZiAoIXR5cGVDb3VudGVyc1t0eXBlXSlcbiAgICAgIHR5cGVDb3VudGVyc1t0eXBlXSA9IDA7XG5cbiAgICBpZiAoIXRoaXMucGFyYW1zLmlkKSB7XG4gICAgICB0aGlzLmlkID0gYCR7dHlwZX0tJHt0eXBlQ291bnRlcnNbdHlwZV19YDtcbiAgICAgIHR5cGVDb3VudGVyc1t0eXBlXSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5wYXJhbXMuaWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2dyb3VwTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuXG4gICAgLy8gcmVnaXN0ZXIgY2FsbGJhY2sgaWYgZ2l2ZW5cbiAgICBpZiAodGhpcy5wYXJhbXMuY2FsbGJhY2spXG4gICAgICB0aGlzLmFkZExpc3RlbmVyKHRoaXMucGFyYW1zLmNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgY29udHJvbGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBhcHBsaWVkIHdoZW4gdGhlIGNvbnRyb2xsZXJcbiAgICogIHN0YXRlIGNoYW5nZS5cbiAgICovXG4gIGFkZExpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBsaXN0ZW5lciBpcyBhZGRlZCBmcm9tIGEgY29udGFpbmluZyBncm91cC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hZGRHcm91cExpc3RlbmVyKGlkLCBjYWxsSWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsSWQpXG4gICAgICB0aGlzLmFkZExpc3RlbmVyKGNhbGxiYWNrKTtcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2dyb3VwTGlzdGVuZXJzLmFkZCh7IGNhbGxJZCwgY2FsbGJhY2sgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RlbmVycy5cbiAgICogQHByaXZhdGVcbiAgICogQHRvZG8gLSByZWV4cG9zZSB3aGVuIGBjb250YWluZXJgIGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZC4uLlxuICAgKi9cbiAgLy8gcmVtb3ZlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgLy8gICB0aGlzLl9saXN0ZW5lcnMucmVtb3ZlKGNhbGxiYWNrKTtcbiAgLy8gfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBleGVjdXRlTGlzdGVuZXJzKC4uLnZhbHVlcykge1xuICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soLi4udmFsdWVzKSk7XG5cbiAgICB0aGlzLl9ncm91cExpc3RlbmVycy5mb3JFYWNoKChwYXlsb2FkKSA9PiB7XG4gICAgICBjb25zdCB7IGNhbGxiYWNrLCBjYWxsSWQgfSA9IHBheWxvYWQ7XG4gICAgICBjYWxsYmFjayhjYWxsSWQsIC4uLnZhbHVlcyk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZUNvbXBvbmVudDtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5cbmNvbnN0IEF1ZGlvQ29udGV4dCA9ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICdEcmFnIGFuZCBkcm9wIGF1ZGlvIGZpbGVzJyxcbiAgbGFiZWxQcm9jZXNzOiAncHJvY2Vzcy4uLicsXG4gIGF1ZGlvQ29udGV4dDogbnVsbCxcbiAgY29udGFpbmVyOiBudWxsLFxuICBjYWxsYmFjazogbnVsbCxcbn07XG5cbi8qKlxuICogRHJhZyBhbmQgZHJvcCB6b25lIGZvciBhdWRpbyBmaWxlcyByZXR1cm5pbmcgYEF1ZGlvQnVmZmVyYHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGFiZWw9J0RyYWcgYW5kIGRyb3AgYXVkaW8gZmlsZXMnXSAtIExhYmVsIG9mIHRoZVxuICogIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5sYWJlbFByb2Nlc3M9J3Byb2Nlc3MuLi4nXSAtIExhYmVsIG9mIHRoZSBjb250cm9sbGVyXG4gKiAgd2hpbGUgYXVkaW8gZmlsZXMgYXJlIGRlY29kZWQuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gW2NvbmZpZy5hdWRpb0NvbnRleHQ9bnVsbF0gLSBPcHRpb25uYWwgYXVkaW8gY29udGV4dFxuICogIHRvIHVzZSBpbiBvcmRlciB0byBkZWNvZGUgYXVkaW8gZmlsZXMuXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fGJhc2ljLWNvbnRyb2xsZXJ+R3JvdXB9IFtjb25maWcuY29udGFpbmVyPW51bGxdIC1cbiAqICBDb250YWluZXIgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNhbGxiYWNrPW51bGxdIC0gQ2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGVcbiAqICB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICdiYXNpYy1jb250cm9sbGVycyc7XG4gKlxuICogY29uc3QgZHJhZ0FuZERyb3AgPSBuZXcgY29udHJvbGxlcnMuRHJhZ0FuZERyb3Aoe1xuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJyxcbiAqICAgY2FsbGJhY2s6IChhdWRpb0ZpbGVzKSA9PiBjb25zb2xlLmxvZyhhdWRpb0ZpbGVzKSxcbiAqIH0pO1xuICovXG5jbGFzcyBEcmFnQW5kRHJvcCBleHRlbmRzIGRpc3BsYXkoQmFzZUNvbXBvbmVudCkge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoJ2RyYWctYW5kLWRyb3AnLCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG5cbiAgICBpZiAoIXRoaXMucGFyYW1zLmF1ZGlvQ29udGV4dClcbiAgICAgIHRoaXMucGFyYW1zLmF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhc3QgZGVjb2RlZCBgQXVkaW9CdWZmZXJgc1xuICAgKiBAdHlwZSB7QXJyYXk8QXVkaW9CdWZmZXI+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY29udGVudCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJkcm9wLXpvbmVcIj5cbiAgICAgICAgPHAgY2xhc3M9XCJsYWJlbFwiPiR7bGFiZWx9PC9wPlxuICAgICAgPC9kaXY+XG4gICAgYDtcblxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy4kZWwuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB0aGlzLiRkcm9wWm9uZSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5kcm9wLXpvbmUnKTtcbiAgICB0aGlzLiRsYWJlbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5sYWJlbCcpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kZHJvcFpvbmUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgdGhpcy4kZHJvcFpvbmUuY2xhc3NMaXN0LmFkZCgnZHJhZycpO1xuICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5JztcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLiRkcm9wWm9uZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgdGhpcy4kZHJvcFpvbmUuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZycpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuJGRyb3Bab25lLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgY29uc3QgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICAgIGNvbnN0IGF1ZGlvRmlsZXMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUudHlwZS5tYXRjaCgvXmF1ZGlvLykpO1xuICAgICAgY29uc3QgYnVmZmVycyA9IG5ldyBBcnJheShhdWRpb0ZpbGVzLmxlbmd0aCk7XG4gICAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICAgIHRoaXMuJGxhYmVsLnRleHRDb250ZW50ID0gdGhpcy5wYXJhbXMubGFiZWxQcm9jZXNzO1xuXG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgICAgIHRoaXMucGFyYW1zLmF1ZGlvQ29udGV4dFxuICAgICAgICAgICAgLmRlY29kZUF1ZGlvRGF0YShlLnRhcmdldC5yZXN1bHQpXG4gICAgICAgICAgICAudGhlbigoYXVkaW9CdWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgYnVmZmVyc1tpbmRleF0gPSBhdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgICAgY291bnRlciArPSAxO1xuXG4gICAgICAgICAgICAgIGlmIChjb3VudGVyID09PSBhdWRpb0ZpbGVzLmxlbmd0aCnCoHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnMoYnVmZmVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZHJvcFpvbmUuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZycpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGxhYmVsLnRleHRDb250ZW50ID0gdGhpcy5wYXJhbXMubGFiZWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBidWZmZXJzW2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY291bnRlciArPSAxO1xuXG4gICAgICAgICAgICAgIGlmIChjb3VudGVyID09PSBhdWRpb0ZpbGVzLmxlbmd0aCnCoHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnMoYnVmZmVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZHJvcFpvbmUuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZycpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGxhYmVsLnRleHRDb250ZW50ID0gdGhpcy5wYXJhbXMubGFiZWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgfSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdBbmREcm9wO1xuIiwiaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9CYXNlQ29tcG9uZW50JztcbmltcG9ydCBkaXNwbGF5IGZyb20gJy4uL21peGlucy9kaXNwbGF5JztcbmltcG9ydCBjb250YWluZXIgZnJvbSAnLi4vbWl4aW5zL2NvbnRhaW5lcic7XG5pbXBvcnQgKiBhcyBlbGVtZW50cyBmcm9tICcuLi91dGlscy9lbGVtZW50cyc7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsZWdlbmQ6ICcmbmJzcDsnLFxuICBkZWZhdWx0OiAnb3BlbmVkJyxcbiAgY29udGFpbmVyOiBudWxsLFxufTtcblxuLyoqXG4gKiBHcm91cCBvZiBjb250cm9sbGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5sYWJlbCAtIExhYmVsIG9mIHRoZSBncm91cC5cbiAqIEBwYXJhbSB7J29wZW5lZCd8J2Nsb3NlZCd9IFtjb25maWcuZGVmYXVsdD0nb3BlbmVkJ10gLSBEZWZhdWx0IHN0YXRlIG9mIHRoZVxuICogIGdyb3VwLlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxiYXNpYy1jb250cm9sbGVyfkdyb3VwfSBbY29uZmlnLmNvbnRhaW5lcj1udWxsXSAtXG4gKiAgQ29udGFpbmVyIG9mIHRoZSBjb250cm9sbGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICdiYXNpYy1jb250cm9sbGVycyc7XG4gKlxuICogLy8gY3JlYXRlIGEgZ3JvdXBcbiAqIGNvbnN0IGdyb3VwID0gbmV3IGNvbnRyb2xsZXJzLkdyb3VwKHtcbiAqICAgbGFiZWw6ICdHcm91cCcsXG4gKiAgIGRlZmF1bHQ6ICdvcGVuZWQnLFxuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJ1xuICogfSk7XG4gKlxuICogLy8gaW5zZXJ0IGNvbnRyb2xsZXJzIGluIHRoZSBncm91cFxuICogY29uc3QgZ3JvdXBTbGlkZXIgPSBuZXcgY29udHJvbGxlcnMuU2xpZGVyKHtcbiAqICAgbGFiZWw6ICdHcm91cCBTbGlkZXInLFxuICogICBtaW46IDIwLFxuICogICBtYXg6IDEwMDAsXG4gKiAgIHN0ZXA6IDEsXG4gKiAgIGRlZmF1bHQ6IDIwMCxcbiAqICAgdW5pdDogJ0h6JyxcbiAqICAgc2l6ZTogJ2xhcmdlJyxcbiAqICAgY29udGFpbmVyOiBncm91cCxcbiAqICAgY2FsbGJhY2s6ICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogfSk7XG4gKlxuICogY29uc3QgZ3JvdXBUZXh0ID0gbmV3IGNvbnRyb2xsZXJzLlRleHQoe1xuICogICBsYWJlbDogJ0dyb3VwIFRleHQnLFxuICogICBkZWZhdWx0OiAndGV4dCBpbnB1dCcsXG4gKiAgIHJlYWRvbmx5OiBmYWxzZSxcbiAqICAgY29udGFpbmVyOiBncm91cCxcbiAqICAgY2FsbGJhY2s6ICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogfSk7XG4gKi9cbmNsYXNzIEdyb3VwIGV4dGVuZHMgY29udGFpbmVyKGRpc3BsYXkoQmFzZUNvbXBvbmVudCkpIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ2dyb3VwJywgZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICB0aGlzLl9zdGF0ZXMgPSBbJ29wZW5lZCcsICdjbG9zZWQnXTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZXMuaW5kZXhPZih0aGlzLnBhcmFtcy5kZWZhdWx0KSA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgXCIke3ZhbHVlfVwiYCk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IHRoaXMucGFyYW1zLmRlZmF1bHQ7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGUgb2YgdGhlIGdyb3VwIChgJ29wZW5lZCdgIG9yIGAnY2xvc2VkJ2ApLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBgdmFsdWVgLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIHNldCBzdGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlIFwiJHt2YWx1ZX1cImApO1xuXG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9zdGF0ZSk7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCh2YWx1ZSk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlO1xuICB9XG5cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVuZGVyKCkge1xuICAgIGxldCBjb250ZW50ID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImdyb3VwLWhlYWRlclwiPlxuICAgICAgICAke2VsZW1lbnRzLnNtYWxsQXJyb3dSaWdodH1cbiAgICAgICAgJHtlbGVtZW50cy5zbWFsbEFycm93Qm90dG9tfVxuICAgICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+JHt0aGlzLnBhcmFtcy5sYWJlbH08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJncm91cC1jb250ZW50XCI+PC9kaXY+XG4gICAgYDtcblxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy4kZWwuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKHRoaXMuX3N0YXRlKTtcblxuICAgIHRoaXMuJGhlYWRlciA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5ncm91cC1oZWFkZXInKTtcbiAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZ3JvdXAtY29udGVudCcpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGhlYWRlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGUgPT09ICdjbG9zZWQnID8gJ29wZW5lZCcgOiAnY2xvc2VkJztcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcm91cDtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5pbXBvcnQgKiBhcyBlbGVtZW50cyBmcm9tICcuLi91dGlscy9lbGVtZW50cyc7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsYWJlbDogJyZuYnNwOycsXG4gIG1pbjogMCxcbiAgbWF4OiAxLFxuICBzdGVwOiAwLjAxLFxuICBkZWZhdWx0OiAwLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufTtcblxuLyoqXG4gKiBOdW1iZXIgQm94IGNvbnRyb2xsZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5sYWJlbCAtIExhYmVsIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcubWluPTBdIC0gTWluaW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm1heD0xXSAtIE1heGltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdGVwPTAuMDFdIC0gU3RlcCBiZXR3ZWVuIGNvbnNlY3V0aXZlIHZhbHVlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRlZmF1bHQ9MF0gLSBEZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxiYXNpYy1jb250cm9sbGVyfkdyb3VwfSBbY29uZmlnLmNvbnRhaW5lcj1udWxsXSAtXG4gKiAgQ29udGFpbmVyIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jYWxsYmFjaz1udWxsXSAtIENhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlXG4gKiAgdmFsdWUgY2hhbmdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnYmFzaWMtY29udHJvbGxlcnMnO1xuICpcbiAqIGNvbnN0IG51bWJlckJveCA9IG5ldyBjb250cm9sbGVycy5OdW1iZXJCb3goe1xuICogICBsYWJlbDogJ015IE51bWJlciBCb3gnLFxuICogICBtaW46IDAsXG4gKiAgIG1heDogMTAsXG4gKiAgIHN0ZXA6IDAuMSxcbiAqICAgZGVmYXVsdDogNSxcbiAqICAgY29udGFpbmVyOiAnI2NvbnRhaW5lcicsXG4gKiAgIGNhbGxiYWNrOiAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqIH0pO1xuICovXG5jbGFzcyBOdW1iZXJCb3ggZXh0ZW5kcyBkaXNwbGF5KEJhc2VDb21wb25lbnQpIHtcbiAgLy8gbGVnZW5kLCBtaW4gPSAwLCBtYXggPSAxLCBzdGVwID0gMC4wMSwgZGVmYXVsdFZhbHVlID0gMCwgJGNvbnRhaW5lciA9IG51bGwsIGNhbGxiYWNrID0gbnVsbFxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcignbnVtYmVyLWJveCcsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnBhcmFtcy5kZWZhdWx0O1xuICAgIHRoaXMuX2lzSW50U3RlcCA9ICh0aGlzLnBhcmFtcy5zdGVwICUgMSA9PT0gMCk7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCB2YWx1ZSBvZiB0aGUgY29udHJvbGxlci5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAvLyB1c2UgJG51bWJlciBlbGVtZW50IG1pbiwgbWF4IGFuZCBzdGVwIHN5c3RlbVxuICAgIHRoaXMuJG51bWJlci52YWx1ZSA9IHZhbHVlO1xuICAgIHZhbHVlID0gdGhpcy4kbnVtYmVyLnZhbHVlO1xuICAgIHZhbHVlID0gdGhpcy5faXNJbnRTdGVwID8gcGFyc2VJbnQodmFsdWUsIDEwKSA6IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbGFiZWwsIG1pbiwgbWF4LCBzdGVwIH0gPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBjb250ZW50ID0gYFxuICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPiR7bGFiZWx9PC9zcGFuPlxuICAgICAgPGRpdiBjbGFzcz1cImlubmVyLXdyYXBwZXJcIj5cbiAgICAgICAgJHtlbGVtZW50cy5hcnJvd0xlZnR9XG4gICAgICAgIDxpbnB1dCBjbGFzcz1cIm51bWJlclwiIHR5cGU9XCJudW1iZXJcIiBtaW49XCIke21pbn1cIiBtYXg9XCIke21heH1cIiBzdGVwPVwiJHtzdGVwfVwiIHZhbHVlPVwiJHt0aGlzLl92YWx1ZX1cIiAvPlxuICAgICAgICAke2VsZW1lbnRzLmFycm93UmlnaHR9XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuXG4gICAgdGhpcy4kZWwgPSBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKCdhbGlnbi1zbWFsbCcpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICB0aGlzLiRwcmV2ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFycm93LWxlZnQnKTtcbiAgICB0aGlzLiRuZXh0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFycm93LXJpZ2h0Jyk7XG4gICAgdGhpcy4kbnVtYmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cIm51bWJlclwiXScpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJHByZXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgY29uc3Qgc3RlcCA9IHRoaXMucGFyYW1zLnN0ZXA7XG4gICAgICBjb25zdCBkZWNpbWFscyA9IHN0ZXAudG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdO1xuICAgICAgY29uc3QgZXhwID0gZGVjaW1hbHMgPyBkZWNpbWFscy5sZW5ndGggOiAwO1xuICAgICAgY29uc3QgbXVsdCA9IE1hdGgucG93KDEwLCBleHApO1xuXG4gICAgICBjb25zdCBpbnRWYWx1ZSA9IE1hdGguZmxvb3IodGhpcy5fdmFsdWUgKiBtdWx0ICsgMC41KTtcbiAgICAgIGNvbnN0IGludFN0ZXAgPSBNYXRoLmZsb29yKHN0ZXAgKiBtdWx0ICsgMC41KTtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGludFZhbHVlIC0gaW50U3RlcCkgLyBtdWx0O1xuXG4gICAgICB0aGlzLl9wcm9wYWdhdGUodmFsdWUpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuJG5leHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgY29uc3Qgc3RlcCA9IHRoaXMucGFyYW1zLnN0ZXA7XG4gICAgICBjb25zdCBkZWNpbWFscyA9IHN0ZXAudG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdO1xuICAgICAgY29uc3QgZXhwID0gZGVjaW1hbHMgPyBkZWNpbWFscy5sZW5ndGggOiAwO1xuICAgICAgY29uc3QgbXVsdCA9IE1hdGgucG93KDEwLCBleHApO1xuXG4gICAgICBjb25zdCBpbnRWYWx1ZSA9IE1hdGguZmxvb3IodGhpcy5fdmFsdWUgKiBtdWx0ICsgMC41KTtcbiAgICAgIGNvbnN0IGludFN0ZXAgPSBNYXRoLmZsb29yKHN0ZXAgKiBtdWx0ICsgMC41KTtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGludFZhbHVlICsgaW50U3RlcCkgLyBtdWx0O1xuXG4gICAgICB0aGlzLl9wcm9wYWdhdGUodmFsdWUpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuJG51bWJlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gdGhpcy4kbnVtYmVyLnZhbHVlO1xuICAgICAgdmFsdWUgPSB0aGlzLl9pc0ludFN0ZXAgPyBwYXJzZUludCh2YWx1ZSwgMTApIDogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IE1hdGgubWluKHRoaXMucGFyYW1zLm1heCwgTWF0aC5tYXgodGhpcy5wYXJhbXMubWluLCB2YWx1ZSkpO1xuXG4gICAgICB0aGlzLl9wcm9wYWdhdGUodmFsdWUpO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfcHJvcGFnYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLl92YWx1ZSkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy4kbnVtYmVyLnZhbHVlID0gdmFsdWU7XG5cbiAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnModGhpcy5fdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlckJveDtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5pbXBvcnQgKiBhcyBlbGVtZW50cyBmcm9tICcuLi91dGlscy9lbGVtZW50cyc7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsYWJlbDogJyZuYnNwOycsXG4gIG9wdGlvbnM6IG51bGwsXG4gIGRlZmF1bHQ6IG51bGwsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgY2FsbGJhY2s6IG51bGwsXG59O1xuXG4vKipcbiAqIExpc3Qgb2YgYnV0dG9ucyB3aXRoIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxhYmVsIC0gTGFiZWwgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLm9wdGlvbnM9bnVsbF0gLSBWYWx1ZXMgb2YgdGhlIGRyb3AgZG93biBsaXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZGVmYXVsdD1udWxsXSAtIERlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fGJhc2ljLWNvbnRyb2xsZXJ+R3JvdXB9IFtjb25maWcuY29udGFpbmVyPW51bGxdIC1cbiAqICBDb250YWluZXIgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNhbGxiYWNrPW51bGxdIC0gQ2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGVcbiAqICB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICdiYXNpYy1jb250cm9sbGVycyc7XG4gKlxuICogY29uc3Qgc2VsZWN0QnV0dG9ucyA9IG5ldyBjb250cm9sbGVycy5TZWxlY3RCdXR0b25zKHtcbiAqICAgbGFiZWw6ICdTZWxlY3RCdXR0b25zJyxcbiAqICAgb3B0aW9uczogWydzdGFuZGJ5JywgJ3J1bicsICdlbmQnXSxcbiAqICAgZGVmYXVsdDogJ3J1bicsXG4gKiAgIGNvbnRhaW5lcjogJyNjb250YWluZXInLFxuICogICBjYWxsYmFjazogKHZhbHVlLCBpbmRleCkgPT4gY29uc29sZS5sb2codmFsdWUsIGluZGV4KSxcbiAqIH0pO1xuICovXG5jbGFzcyBTZWxlY3RCdXR0b25zIGV4dGVuZHMgZGlzcGxheShCYXNlQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCdzZWxlY3QtYnV0dG9ucycsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMucGFyYW1zLm9wdGlvbnMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmlnZ2VyQnV0dG9uOiBJbnZhbGlkIG9wdGlvbiBcIm9wdGlvbnNcIicpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnBhcmFtcy5kZWZhdWx0O1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3QgaW5kZXggPSBvcHRpb25zLmluZGV4T2YodGhpcy5fdmFsdWUpO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXggPT09IC0xID/CoDAgOiBpbmRleDtcbiAgICB0aGlzLl9tYXhJbmRleCA9IG9wdGlvbnMubGVuZ3RoIC0gMTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbHVlLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJhbXMub3B0aW9ucy5pbmRleE9mKHZhbHVlKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCBvcHRpb24gaW5kZXguXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgdGhpcy5faW5kZXg7XG4gIH1cblxuICBzZXQgaW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5fbWF4SW5kZXgpIHJldHVybjtcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wYXJhbXMub3B0aW9uc1tpbmRleF07XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9oaWdobGlnaHRCdG4odGhpcy5faW5kZXgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIGxhYmVsIH0gPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBjb250ZW50ID0gYFxuICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPiR7bGFiZWx9PC9zcGFuPlxuICAgICAgPGRpdiBjbGFzcz1cImlubmVyLXdyYXBwZXJcIj5cbiAgICAgICAgJHtlbGVtZW50cy5hcnJvd0xlZnR9XG4gICAgICAgICR7b3B0aW9ucy5tYXAoKG9wdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0blwiIGRhdGEtaW5kZXg9XCIke2luZGV4fVwiIGRhdGEtdmFsdWU9XCIke29wdGlvbn1cIj5cbiAgICAgICAgICAgICAgJHtvcHRpb259XG4gICAgICAgICAgICA8L2J1dHRvbj5gO1xuICAgICAgICB9KS5qb2luKCcnKX1cbiAgICAgICAgJHtlbGVtZW50cy5hcnJvd1JpZ2h0fVxuICAgICAgPC9kaXY+XG4gICAgYDtcblxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKHRoaXMudHlwZSk7XG4gICAgdGhpcy4kZWwuaW5uZXJIVE1MID0gY29udGVudDtcblxuICAgIHRoaXMuJHByZXYgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuYXJyb3ctbGVmdCcpO1xuICAgIHRoaXMuJG5leHQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuYXJyb3ctcmlnaHQnKTtcbiAgICB0aGlzLiRidG5zID0gQXJyYXkuZnJvbSh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuYnRuJykpO1xuXG4gICAgdGhpcy5faGlnaGxpZ2h0QnRuKHRoaXMuX2luZGV4KTtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kcHJldi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW5kZXggLSAxO1xuICAgICAgdGhpcy5fcHJvcGFnYXRlKGluZGV4KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJG5leHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZShpbmRleCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRidG5zLmZvckVhY2goKCRidG4sIGluZGV4KSA9PiB7XG4gICAgICAkYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGUoaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3Byb3BhZ2F0ZShpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9tYXhJbmRleCkgcmV0dXJuO1xuXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMucGFyYW1zLm9wdGlvbnNbaW5kZXhdO1xuICAgIHRoaXMuX2hpZ2hsaWdodEJ0bih0aGlzLl9pbmRleCk7XG5cbiAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnModGhpcy5fdmFsdWUsIHRoaXMuX2luZGV4KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfaGlnaGxpZ2h0QnRuKGFjdGl2ZUluZGV4KSB7XG4gICAgdGhpcy4kYnRucy5mb3JFYWNoKCgkYnRuLCBpbmRleCkgPT4ge1xuICAgICAgJGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcblxuICAgICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAkYnRuLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdEJ1dHRvbnM7XG4iLCJpbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IGRpc3BsYXkgZnJvbSAnLi4vbWl4aW5zL2Rpc3BsYXknO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi4vdXRpbHMvZWxlbWVudHMnO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmbmJzcDsnLFxuICBvcHRpb25zOiBudWxsLFxuICBkZWZhdWx0OiBudWxsLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufVxuXG4vKipcbiAqIERyb3AtZG93biBsaXN0IGNvbnRyb2xsZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubGFiZWwgLSBMYWJlbCBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcub3B0aW9ucz1udWxsXSAtIFZhbHVlcyBvZiB0aGUgZHJvcCBkb3duIGxpc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kZWZhdWx0PW51bGxdIC0gRGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2s9bnVsbF0gLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICogIHZhbHVlIGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRyb2xsZXJzJztcbiAqXG4gKiBjb25zdCBzZWxlY3RMaXN0ID0gbmV3IGNvbnRyb2xsZXJzLlNlbGVjdExpc3Qoe1xuICogICBsYWJlbDogJ1NlbGVjdExpc3QnLFxuICogICBvcHRpb25zOiBbJ3N0YW5kYnknLCAncnVuJywgJ2VuZCddLFxuICogICBkZWZhdWx0OiAncnVuJyxcbiAqICAgY29udGFpbmVyOiAnI2NvbnRhaW5lcicsXG4gKiAgIGNhbGxiYWNrOiAodmFsdWUsIGluZGV4KSA9PiBjb25zb2xlLmxvZyh2YWx1ZSwgaW5kZXgpLFxuICogfSk7XG4gKi9cbmNsYXNzIFNlbGVjdExpc3QgZXh0ZW5kcyBkaXNwbGF5KEJhc2VDb21wb25lbnQpIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ3NlbGVjdC1saXN0JywgZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5wYXJhbXMub3B0aW9ucykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWdnZXJCdXR0b246IEludmFsaWQgb3B0aW9uIFwib3B0aW9uc1wiJyk7XG5cbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMucGFyYW1zLmRlZmF1bHQ7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5wYXJhbXMub3B0aW9ucztcbiAgICBjb25zdCBpbmRleCA9IG9wdGlvbnMuaW5kZXhPZih0aGlzLl92YWx1ZSk7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleCA9PT0gLTEgP8KgMCA6IGluZGV4O1xuICAgIHRoaXMuX21heEluZGV4ID0gb3B0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgdmFsdWUuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy4kc2VsZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9pbmRleCA9IHRoaXMucGFyYW1zLm9wdGlvbnMuaW5kZXhPZih2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCBvcHRpb24gaW5kZXguXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG5cbiAgc2V0IGluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuX21heEluZGV4KSByZXR1cm47XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMucGFyYW1zLm9wdGlvbnNbaW5kZXhdO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBvcHRpb25zwqB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY29udGVudCA9IGBcbiAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj4ke2xhYmVsfTwvc3Bhbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJpbm5lci13cmFwcGVyXCI+XG4gICAgICAgICR7ZWxlbWVudHMuYXJyb3dMZWZ0fVxuICAgICAgICA8c2VsZWN0PlxuICAgICAgICAke29wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGA8b3B0aW9uIHZhbHVlPVwiJHtvcHRpb259XCI+JHtvcHRpb259PC9vcHRpb24+YDtcbiAgICAgICAgfSkuam9pbignJyl9XG4gICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICR7ZWxlbWVudHMuYXJyb3dSaWdodH1cbiAgICAgIDwvZGl2PlxuICAgIGA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcih0aGlzLnR5cGUpO1xuICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoJ2FsaWduLXNtYWxsJyk7XG4gICAgdGhpcy4kZWwuaW5uZXJIVE1MID0gY29udGVudDtcblxuICAgIHRoaXMuJHByZXYgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuYXJyb3ctbGVmdCcpO1xuICAgIHRoaXMuJG5leHQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuYXJyb3ctcmlnaHQnKTtcbiAgICB0aGlzLiRzZWxlY3QgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCdzZWxlY3QnKTtcbiAgICAvLyBzZXQgdG8gZGVmYXVsdCB2YWx1ZVxuICAgIHRoaXMuJHNlbGVjdC52YWx1ZSA9IG9wdGlvbnNbdGhpcy5faW5kZXhdO1xuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRwcmV2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pbmRleCAtIDE7XG4gICAgICB0aGlzLl9wcm9wYWdhdGUoaW5kZXgpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuJG5leHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZShpbmRleCk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGhpcy4kc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4kc2VsZWN0LnZhbHVlO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBhcmFtcy5vcHRpb25zLmluZGV4T2YodmFsdWUpO1xuICAgICAgdGhpcy5fcHJvcGFnYXRlKGluZGV4KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfcHJvcGFnYXRlKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fMKgaW5kZXggPiB0aGlzLl9tYXhJbmRleCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnBhcmFtcy5vcHRpb25zW2luZGV4XTtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy4kc2VsZWN0LnZhbHVlID0gdmFsdWU7XG5cbiAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnModGhpcy5fdmFsdWUsIHRoaXMuX2luZGV4KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RMaXN0O1xuIiwiaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9CYXNlQ29tcG9uZW50JztcbmltcG9ydCBkaXNwbGF5IGZyb20gJy4uL21peGlucy9kaXNwbGF5JztcbmltcG9ydCAqIGFzIGd1aUNvbXBvbmVudHMgZnJvbSAnZ3VpLWNvbXBvbmVudHMnO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmbmJzcDsnLFxuICBtaW46IDAsXG4gIG1heDogMSxcbiAgc3RlcDogMC4wMSxcbiAgZGVmYXVsdDogMCxcbiAgdW5pdDogJycsXG4gIHNpemU6ICdtZWRpdW0nLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufVxuXG4vKipcbiAqIFNsaWRlciBjb250cm9sbGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxhYmVsIC0gTGFiZWwgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5taW49MF0gLSBNaW5pbXVtIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcubWF4PTFdIC0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0ZXA9MC4wMV0gLSBTdGVwIGJldHdlZW4gY29uc2VjdXRpdmUgdmFsdWVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZGVmYXVsdD0wXSAtIERlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy51bml0PScnXSAtIFVuaXQgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHsnc21hbGwnfCdtZWRpdW0nfCdsYXJnZSd9IFtjb25maWcuc2l6ZT0nbWVkaXVtJ10gLSBTaXplIG9mIHRoZVxuICogIHNsaWRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2s9bnVsbF0gLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICogIHZhbHVlIGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRyb2xsZXJzJztcbiAqXG4gKiBjb25zdCBzbGlkZXIgPSBuZXcgY29udHJvbGxlcnMuU2xpZGVyKHtcbiAqICAgbGFiZWw6ICdNeSBTbGlkZXInLFxuICogICBtaW46IDIwLFxuICogICBtYXg6IDEwMDAsXG4gKiAgIHN0ZXA6IDEsXG4gKiAgIGRlZmF1bHQ6IDUzNyxcbiAqICAgdW5pdDogJ0h6JyxcbiAqICAgc2l6ZTogJ2xhcmdlJyxcbiAqICAgY29udGFpbmVyOiAnI2NvbnRhaW5lcicsXG4gKiAgIGNhbGxiYWNrOiAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqIH0pO1xuICovXG5jbGFzcyBTbGlkZXIgZXh0ZW5kcyBkaXNwbGF5KEJhc2VDb21wb25lbnQpIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ3NsaWRlcicsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnBhcmFtcy5kZWZhdWx0O1xuICAgIHRoaXMuX29uU2xpZGVyQ2hhbmdlID0gdGhpcy5fb25TbGlkZXJDaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbHVlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICh0aGlzLiRudW1iZXIgJiYgdGhpcy4kcmFuZ2UpIHtcbiAgICAgIHRoaXMuJG51bWJlci52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnNsaWRlci52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgbWluLCBtYXgsIHN0ZXAsIHVuaXQsIHNpemUgfSA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBgXG4gICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+JHtsYWJlbH08L3NwYW4+XG4gICAgICA8ZGl2IGNsYXNzPVwiaW5uZXItd3JhcHBlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicmFuZ2VcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm51bWJlci13cmFwcGVyXCI+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBjbGFzcz1cIm51bWJlclwiIG1pbj1cIiR7bWlufVwiIG1heD1cIiR7bWF4fVwiIHN0ZXA9XCIke3N0ZXB9XCIgdmFsdWU9XCIke3RoaXMuX3ZhbHVlfVwiIC8+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJ1bml0XCI+JHt1bml0fTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgdGhpcy4kZWwgPSBzdXBlci5yZW5kZXIodGhpcy50eXBlKTtcbiAgICB0aGlzLiRlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoYHNsaWRlci0ke3NpemV9YCk7XG5cbiAgICB0aGlzLiRyYW5nZSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5yYW5nZScpO1xuICAgIHRoaXMuJG51bWJlciA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoYGlucHV0W3R5cGU9XCJudW1iZXJcIl1gKTtcblxuICAgIHRoaXMuc2xpZGVyID0gbmV3IGd1aUNvbXBvbmVudHMuU2xpZGVyKHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy4kcmFuZ2UsXG4gICAgICBjYWxsYmFjazogdGhpcy5fb25TbGlkZXJDaGFuZ2UsXG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgc3RlcDogc3RlcCxcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX3ZhbHVlLFxuICAgICAgZm9yZWdyb3VuZENvbG9yOiAnI2FiYWJhYicsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVzaXplKCkge1xuICAgIHN1cGVyLnJlc2l6ZSgpO1xuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0wqB9ID0gdGhpcy4kcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5zbGlkZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJG51bWJlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy4kbnVtYmVyLnZhbHVlKTtcbiAgICAgIC8vIHRoZSBzbGlkZXIgcHJvcGFnYXRlcyB0aGUgdmFsdWVcbiAgICAgIHRoaXMuc2xpZGVyLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25TbGlkZXJDaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLiRudW1iZXIudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgdGhpcy5leGVjdXRlTGlzdGVuZXJzKHRoaXMuX3ZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTbGlkZXI7XG4iLCJpbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IGRpc3BsYXkgZnJvbSAnLi4vbWl4aW5zL2Rpc3BsYXknO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmbmJzcDsnLFxuICBkZWZhdWx0OiAnJyxcbiAgcmVhZG9ubHk6IGZhbHNlLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufVxuXG4vKipcbiAqIFRleHQgY29udHJvbGxlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5sYWJlbCAtIExhYmVsIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kZWZhdWx0PScnXSAtIERlZmF1bHQgdmFsdWUgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLnJlYWRvbmx5PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgY29udHJvbGxlciBpcyByZWFkb25seS5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2s9bnVsbF0gLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICogIHZhbHVlIGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRvbGxlcnMnO1xuICpcbiAqIGNvbnN0IHRleHQgPSBuZXcgY29udHJvbGxlcnMuVGV4dCh7XG4gKiAgIGxhYmVsOiAnTXkgVGV4dCcsXG4gKiAgIGRlZmF1bHQ6ICdkZWZhdWx0IHZhbHVlJyxcbiAqICAgcmVhZG9ubHk6IGZhbHNlLFxuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJyxcbiAqICAgY2FsbGJhY2s6ICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogfSk7XG4gKi9cbmNsYXNzIFRleHQgZXh0ZW5kcyBkaXNwbGF5KEJhc2VDb21wb25lbnQpIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ3RleHQnLCBkZWZhdWx0cywgY29uZmlnKTtcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wYXJhbXMuZGVmYXVsdDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbHVlLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuJGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcmVhZG9ubHkgPSB0aGlzLnBhcmFtcy5yZWFkb25seSA/ICdyZWFkb25seScgOiAnJztcbiAgICBjb25zdCBjb250ZW50ID0gYFxuICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPiR7dGhpcy5wYXJhbXMubGFiZWx9PC9zcGFuPlxuICAgICAgPGRpdiBjbGFzcz1cImlubmVyLXdyYXBwZXJcIj5cbiAgICAgICAgPGlucHV0IGNsYXNzPVwidGV4dFwiIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCIke3RoaXMuX3ZhbHVlfVwiICR7cmVhZG9ubHl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuXG4gICAgdGhpcy4kZWwgPSBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLiRlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIHRoaXMuJGlucHV0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnRleHQnKTtcblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKCkgPT4ge1xuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLiRpbnB1dC52YWx1ZTtcbiAgICAgIHRoaXMuZXhlY3V0ZUxpc3RlbmVycyh0aGlzLl92YWx1ZSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHQ7XG4iLCJpbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IGRpc3BsYXkgZnJvbSAnLi4vbWl4aW5zL2Rpc3BsYXknO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmbmJzcDsnLFxuICBjb250YWluZXI6IG51bGwsXG59O1xuXG4vKipcbiAqIFRpdGxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxhYmVsIC0gTGFiZWwgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fGJhc2ljLWNvbnRyb2xsZXJ+R3JvdXB9IFtjb25maWcuY29udGFpbmVyPW51bGxdIC1cbiAqICBDb250YWluZXIgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXIgZnJvbSAnYmFzaWMtY29udHJvbGxlcnMnO1xuICpcbiAqIGNvbnN0IHRpdGxlID0gbmV3IGNvbnRyb2xsZXJzLlRpdGxlKHtcbiAqICAgbGFiZWw6ICdNeSBUaXRsZScsXG4gKiAgIGNvbnRhaW5lcjogJyNjb250YWluZXInXG4gKiB9KTtcbiAqL1xuY2xhc3MgVGl0bGUgZXh0ZW5kcyBkaXNwbGF5KEJhc2VDb21wb25lbnQpIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ3RpdGxlJywgZGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjb250ZW50ID0gYDxzcGFuIGNsYXNzPVwibGFiZWxcIj4ke3RoaXMucGFyYW1zLmxhYmVsfTwvc3Bhbj5gO1xuXG4gICAgdGhpcy4kZWwgPSBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLiRlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpdGxlO1xuIiwiaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9CYXNlQ29tcG9uZW50JztcbmltcG9ydCBkaXNwbGF5IGZyb20gJy4uL21peGlucy9kaXNwbGF5JztcbmltcG9ydCAqIGFzIGVsZW1lbnRzIGZyb20gJy4uL3V0aWxzL2VsZW1lbnRzJztcblxuLyoqIEBtb2R1bGUgYmFzaWMtY29udHJvbGxlcnMgKi9cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGxhYmVsOiAnJmJuc3A7JyxcbiAgYWN0aXZlOiBmYWxzZSxcbiAgY29udGFpbmVyOiBudWxsLFxuICBjYWxsYmFjazogbnVsbCxcbn07XG5cbi8qKlxuICogT24vT2ZmIGNvbnRyb2xsZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubGFiZWwgLSBMYWJlbCBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuYWN0aXZlPWZhbHNlXSAtIERlZmF1bHQgc3RhdGUgb2YgdGhlIHRvZ2dsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2s9bnVsbF0gLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICogIHZhbHVlIGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRyb2xsZXJzJztcbiAqXG4gKiBjb25zdCB0b2dnbGUgPSBuZXcgY29udHJvbGxlcnMuVG9nZ2xlKHtcbiAqICAgbGFiZWw6ICdNeSBUb2dnbGUnLFxuICogICBhY3RpdmU6IGZhbHNlLFxuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJyxcbiAqICAgY2FsbGJhY2s6IChhY3RpdmUpID0+IGNvbnNvbGUubG9nKGFjdGl2ZSksXG4gKiB9KTtcbiAqL1xuY2xhc3MgVG9nZ2xlIGV4dGVuZHMgZGlzcGxheShCYXNlQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCd0b2dnbGUnLCBkZWZhdWx0cywgY29uZmlnKTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMucGFyYW1zLmFjdGl2ZTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWx1ZSBvZiB0aGUgdG9nZ2xlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2V0IHZhbHVlKGJvb2wpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGJvb2w7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYHZhbHVlYC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzZXQgYWN0aXZlKGJvb2wpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBib29sO1xuICAgIHRoaXMuX3VwZGF0ZUJ0bigpO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF91cGRhdGVCdG4oKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMuYWN0aXZlID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgICB0aGlzLiR0b2dnbGUuY2xhc3NMaXN0W21ldGhvZF0oJ2FjdGl2ZScpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgY29udGVudCA9IGBcbiAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj4ke3RoaXMucGFyYW1zLmxhYmVsfTwvc3Bhbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJpbm5lci13cmFwcGVyXCI+XG4gICAgICAgICR7ZWxlbWVudHMudG9nZ2xlfVxuICAgICAgPC9kaXY+YDtcblxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnYWxpZ24tc21hbGwnKTtcbiAgICB0aGlzLiRlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuXG4gICAgdGhpcy4kdG9nZ2xlID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnRvZ2dsZS1lbGVtZW50Jyk7XG4gICAgLy8gaW5pdGlhbGl6ZSBzdGF0ZVxuICAgIHRoaXMuYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kdG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5hY3RpdmUgPSAhdGhpcy5hY3RpdmU7XG4gICAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnModGhpcy5fYWN0aXZlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7XG4iLCJpbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IGRpc3BsYXkgZnJvbSAnLi4vbWl4aW5zL2Rpc3BsYXknO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmbmJzcDsnLFxuICBvcHRpb25zOiBudWxsLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufTtcblxuLyoqXG4gKiBMaXN0IG9mIGJ1dHRvbnMgd2l0aG91dCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5sYWJlbCAtIExhYmVsIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5vcHRpb25zPW51bGxdIC0gT3B0aW9ucyBmb3IgZWFjaCBidXR0b24uXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fGJhc2ljLWNvbnRyb2xsZXJ+R3JvdXB9IFtjb25maWcuY29udGFpbmVyPW51bGxdIC1cbiAqICBDb250YWluZXIgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNhbGxiYWNrPW51bGxdIC0gQ2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGVcbiAqICB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICdiYXNpYy1jb250cm9sbGVycyc7XG4gKlxuICogY29uc3QgdHJpZ2dlckJ1dHRvbnMgPSBuZXcgY29udHJvbGxlcnMuVHJpZ2dlckJ1dHRvbnMoe1xuICogICBsYWJlbDogJ015IFRyaWdnZXIgQnV0dG9ucycsXG4gKiAgIG9wdGlvbnM6IFsndmFsdWUgMScsICd2YWx1ZSAyJywgJ3ZhbHVlIDMnXSxcbiAqICAgY29udGFpbmVyOiAnI2NvbnRhaW5lcicsXG4gKiAgIGNhbGxiYWNrOiAodmFsdWUsIGluZGV4KSA9PiBjb25zb2xlLmxvZyh2YWx1ZSwgaW5kZXgpLFxuICogfSk7XG4gKi9cbmNsYXNzIFRyaWdnZXJCdXR0b25zIGV4dGVuZHMgZGlzcGxheShCYXNlQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCd0cmlnZ2VyLWJ1dHRvbnMnLCBkZWZhdWx0cywgY29uZmlnKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnBhcmFtcy5vcHRpb25zKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZ2dlckJ1dHRvbjogSW52YWxpZCBvcHRpb24gXCJvcHRpb25zXCInKTtcblxuICAgIHRoaXMuX2luZGV4ID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogTGFzdCB0cmlnZ2VyZWQgYnV0dG9uIHZhbHVlLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG5cbiAgLyoqXG4gICAqIExhc3QgdHJpZ2dlcmVkIGJ1dHRvbiBpbmRleC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgaW5kZXgoKSB7IHJldHVybiB0aGlzLl9pbmRleDsgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgb3B0aW9ucyB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICBjb25zdCBjb250ZW50ID0gYFxuICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPiR7bGFiZWx9PC9zcGFuPlxuICAgICAgPGRpdiBjbGFzcz1cImlubmVyLXdyYXBwZXJcIj5cbiAgICAgICAgJHtvcHRpb25zLm1hcCgob3B0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiBgPGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiPiR7b3B0aW9ufTwvYT5gO1xuICAgICAgICB9KS5qb2luKCcnKX1cbiAgICAgIDwvZGl2PmA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICB0aGlzLiRidXR0b25zID0gQXJyYXkuZnJvbSh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuYnRuJykpO1xuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRidXR0b25zLmZvckVhY2goKCRidG4sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyYW1zLm9wdGlvbnNbaW5kZXhdO1xuXG4gICAgICAkYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgdGhpcy5leGVjdXRlTGlzdGVuZXJzKHZhbHVlLCBpbmRleCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmlnZ2VyQnV0dG9ucztcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9CYXNlQ29tcG9uZW50JztcbmltcG9ydCBHcm91cCBmcm9tICcuL2NvbXBvbmVudHMvR3JvdXAnO1xuaW1wb3J0IE51bWJlckJveCBmcm9tICcuL2NvbXBvbmVudHMvTnVtYmVyQm94JztcbmltcG9ydCBTZWxlY3RCdXR0b25zIGZyb20gJy4vY29tcG9uZW50cy9TZWxlY3RCdXR0b25zJztcbmltcG9ydCBTZWxlY3RMaXN0IGZyb20gJy4vY29tcG9uZW50cy9TZWxlY3RMaXN0JztcbmltcG9ydCBTbGlkZXIgZnJvbSAnLi9jb21wb25lbnRzL1NsaWRlcic7XG5pbXBvcnQgVGV4dCBmcm9tICcuL2NvbXBvbmVudHMvVGV4dCc7XG5pbXBvcnQgVGl0bGUgZnJvbSAnLi9jb21wb25lbnRzL1RpdGxlJztcbmltcG9ydCBUb2dnbGUgZnJvbSAnLi9jb21wb25lbnRzL1RvZ2dsZSc7XG5pbXBvcnQgVHJpZ2dlckJ1dHRvbnMgZnJvbSAnLi9jb21wb25lbnRzL1RyaWdnZXJCdXR0b25zJztcblxuaW1wb3J0IGNvbnRhaW5lciBmcm9tICcuL21peGlucy9jb250YWluZXInO1xuXG4vLyBtYXAgdHlwZSBuYW1lcyB0byBjb25zdHJ1Y3RvcnNcbmNvbnN0IHR5cGVDdG9yTWFwID0ge1xuICAnZ3JvdXAnOiBHcm91cCxcbiAgJ251bWJlci1ib3gnOiBOdW1iZXJCb3gsXG4gICdzZWxlY3QtYnV0dG9ucyc6IFNlbGVjdEJ1dHRvbnMsXG4gICdzZWxlY3QtbGlzdCc6IFNlbGVjdExpc3QsXG4gICdzbGlkZXInOiBTbGlkZXIsXG4gICd0ZXh0JzogVGV4dCxcbiAgJ3RpdGxlJzogVGl0bGUsXG4gICd0b2dnbGUnOiBUb2dnbGUsXG4gICd0cmlnZ2VyLWJ1dHRvbnMnOiBUcmlnZ2VyQnV0dG9ucyxcbn07XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBjb250YWluZXI6ICdib2R5Jyxcbn07XG5cbmNsYXNzIENvbnRyb2wgZXh0ZW5kcyBjb250YWluZXIoQmFzZUNvbXBvbmVudCkge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcignY29udHJvbCcsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgbGV0ICRjb250YWluZXIgPSB0aGlzLnBhcmFtcy5jb250YWluZXI7XG5cbiAgICBpZiAodHlwZW9mICRjb250YWluZXIgPT09ICdzdHJpbmcnKVxuICAgICAgJGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJGNvbnRhaW5lcik7XG5cbiAgICB0aGlzLiRjb250YWluZXIgPSAkY29udGFpbmVyO1xuICB9XG59XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbi8qKlxuICogQ3JlYXRlIGEgd2hvbGUgY29udHJvbCBzdXJmYWNlIGZyb20gYSBqc29uIGRlZmluaXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gY29udGFpbmVyIC0gQ29udGFpbmVyIG9mIHRoZSBjb250cm9scy5cbiAqIEBwYXJhbSB7T2JqZWN0fSAtIERlZmluaXRpb25zIGZvciB0aGUgY29udHJvbHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gQSBgQ29udHJvbGAgaW5zdGFuY2UgdGhhdCBiZWhhdmVzIGxpa2UgYSBncm91cCB3aXRob3V0IGdyYXBoaWMuXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRyb2xsZXJzJztcbiAqXG4gKiBjb25zdCBkZWZpbml0aW9ucyA9IFtcbiAqICAge1xuICogICAgIGlkOiAnbXktc2xpZGVyJyxcbiAqICAgICB0eXBlOiAnc2xpZGVyJyxcbiAqICAgICBsYWJlbDogJ015IFNsaWRlcicsXG4gKiAgICAgc2l6ZTogJ2xhcmdlJyxcbiAqICAgICBtaW46IDAsXG4gKiAgICAgbWF4OiAxMDAwLFxuICogICAgIHN0ZXA6IDEsXG4gKiAgICAgZGVmYXVsdDogMjUzLFxuICogICB9LCB7XG4gKiAgICAgaWQ6ICdteS1ncm91cCcsXG4gKiAgICAgdHlwZTogJ2dyb3VwJyxcbiAqICAgICBsYWJlbDogJ0dyb3VwJyxcbiAqICAgICBkZWZhdWx0OiAnb3BlbmVkJyxcbiAqICAgICBlbGVtZW50czogW1xuICogICAgICAge1xuICogICAgICAgICBpZDogJ215LW51bWJlcicsXG4gKiAgICAgICAgIHR5cGU6ICdudW1iZXItYm94JyxcbiAqICAgICAgICAgZGVmYXVsdDogMC40LFxuICogICAgICAgICBtaW46IC0xLFxuICogICAgICAgICBtYXg6IDEsXG4gKiAgICAgICAgIHN0ZXA6IDAuMDEsXG4gKiAgICAgICB9XG4gKiAgICAgXSxcbiAqICAgfVxuICogXTtcbiAqXG4gKiBjb25zdCBjb250cm9scyA9IGNvbnRyb2xsZXJzLmNyZWF0ZSgnI2NvbnRhaW5lcicsIGRlZmluaXRpb25zKTtcbiAqXG4gKiAvLyBhZGQgYSBsaXN0ZW5lciBvbiBhbGwgdGhlIGNvbXBvbmVudCBpbnNpZGUgYG15LWdyb3VwYFxuICogY29udHJvbHMuYWRkTGlzdGVuZXIoJ215LWdyb3VwJywgKGlkLCB2YWx1ZSkgPT4gY29uc29sZS5sb2coaWQsIHZhbHVlKSk7XG4gKlxuICogLy8gcmV0cmlldmUgdGhlIGluc3RhbmNlIG9mIGBteS1udW1iZXJgXG4gKiBjb25zdCBteU51bWJlciA9IGNvbnRyb2xzLmdldENvbXBvbmVudCgnbXktZ3JvdXAvbXktbnVtYmVyJyk7XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShjb250YWluZXIsIGRlZmluaXRpb25zKSB7XG5cbiAgZnVuY3Rpb24gX3BhcnNlKGNvbnRhaW5lciwgZGVmaW5pdGlvbnMpIHtcbiAgICBkZWZpbml0aW9ucy5mb3JFYWNoKChkZWYsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gZGVmLnR5cGU7XG4gICAgICBjb25zdCBjdG9yID0gdHlwZUN0b3JNYXBbdHlwZV07XG4gICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWYpO1xuXG4gICAgICAvL1xuICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIGRlbGV0ZSBjb25maWcudHlwZTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gbmV3IGN0b3IoY29uZmlnKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdncm91cCcpXG4gICAgICAgIF9wYXJzZShjb21wb25lbnQsIGNvbmZpZy5lbGVtZW50cyk7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgX3Jvb3QgPSBuZXcgQ29udHJvbCh7IGNvbnRhaW5lcjogY29udGFpbmVyIH0pO1xuICBfcGFyc2UoX3Jvb3QsIGRlZmluaXRpb25zKTtcblxuICByZXR1cm4gX3Jvb3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZTtcbiIsImltcG9ydCAqIGFzIF9zdHlsZXMgZnJvbSAnLi91dGlscy9zdHlsZXMnO1xuZXhwb3J0IGNvbnN0IHN0eWxlcyA9IF9zdHlsZXM7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbi8vIGV4cG9zZSBmb3IgcGx1Z2luc1xuaW1wb3J0IF9CYXNlQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9CYXNlQ29tcG9uZW50JztcbmV4cG9ydCBjb25zdCBCYXNlQ29tcG9uZW50ID0gX0Jhc2VDb21wb25lbnQ7XG5cbi8vIGNvbXBvbmVudHNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JvdXAgfSBmcm9tICcuL2NvbXBvbmVudHMvR3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcmFnQW5kRHJvcCB9IGZyb20gJy4vY29tcG9uZW50cy9EcmFnQW5kRHJvcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE51bWJlckJveCB9IGZyb20gJy4vY29tcG9uZW50cy9OdW1iZXJCb3gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3RCdXR0b25zIH0gZnJvbSAnLi9jb21wb25lbnRzL1NlbGVjdEJ1dHRvbnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3RMaXN0IH0gZnJvbSAnLi9jb21wb25lbnRzL1NlbGVjdExpc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbGlkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvU2xpZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9UZXh0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGl0bGUgfSBmcm9tICcuL2NvbXBvbmVudHMvVGl0bGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb2dnbGUgfSBmcm9tICcuL2NvbXBvbmVudHMvVG9nZ2xlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVHJpZ2dlckJ1dHRvbnMgfSBmcm9tICcuL2NvbXBvbmVudHMvVHJpZ2dlckJ1dHRvbnMnO1xuXG4vLyBmYWN0b3J5XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZSB9IGZyb20gJy4vZmFjdG9yeSc7XG4vLyBkaXNwbGF5XG5leHBvcnQgeyBzZXRUaGVtZSAgfSBmcm9tICcuL21peGlucy9kaXNwbGF5JztcblxuLyoqXG4gKiBEaXNhYmxlIGRlZmF1bHQgc3R5bGluZyAoZXhwZWN0IGEgYnJva2VuIHVpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVN0eWxlcygpIHtcbiAgX3N0eWxlcy5kaXNhYmxlKCk7XG59O1xuIiwiXG5jb25zdCBzZXBhcmF0b3IgPSAnLyc7XG5cbmZ1bmN0aW9uIGdldEhlYWQocGF0aCkge1xuICByZXR1cm4gcGF0aC5zcGxpdChzZXBhcmF0b3IpWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRUYWlsKHBhdGgpIHtcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KHNlcGFyYXRvcik7XG4gIHBhcnRzLnNoaWZ0KCk7XG4gIHJldHVybiBwYXJ0cy5qb2luKHNlcGFyYXRvcik7XG59XG5cbmNvbnN0IGNvbnRhaW5lciA9IChzdXBlcmNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIHN1cGVyY2xhc3Mge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFNldCgpO1xuXG4gICAgLy8gc3VyZSBvZiB0aGF0ID9cbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzO1xuICAgIGRlbGV0ZSB0aGlzLl9ncm91cExpc3RlbmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gb25lIG9mIHRoZSBncm91cCBjaGlsZHJlbiBhY2NvcmRpbmcgdG8gaXRzIGBpZGAsIGBudWxsYCBvdGhlcndpc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SGVhZChpZCkge1xuXG4gIH1cblxuICBfZ2V0VGFpbChpZCkge1xuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY2hpbGQgb2YgdGhlIGdyb3VwIHJlY3Vyc2l2ZWx5IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYGlkYCxcbiAgICogYG51bGxgIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENvbXBvbmVudChpZCkge1xuICAgIGNvbnN0IGhlYWQgPSBnZXRIZWFkKGlkKTtcblxuICAgIGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBpZiAoaGVhZCA9PT0gY29tcG9uZW50LmlkKSB7XG4gICAgICAgIGlmIChoZWFkID09PSBpZClcbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQudHlwZSA9ICdncm91cCcpXG4gICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5nZXRDb21wb25lbnQoZ2V0VGFpbChpZCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgY29tcG9uZW50ICR7aWR9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgY29tcG9uZW50ICR7aWR9YCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIExpc3RlbmVyIG9uIGVhY2ggY29tcG9uZW50cyBvZiB0aGUgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFBhdGggdG8gY29tcG9uZW50IGlkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAqL1xuICBhZGRMaXN0ZW5lcihpZCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2FsbGJhY2sgPSBpZDtcbiAgICAgIHRoaXMuX2FkZEdyb3VwTGlzdGVuZXIoJycsICcnLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEdyb3VwTGlzdGVuZXIoaWQsICcnLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9hZGRHcm91cExpc3RlbmVyKGlkLCBjYWxsSWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRJZCA9IGdldEhlYWQoaWQpO1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5nZXRDb21wb25lbnQoY29tcG9uZW50SWQpO1xuXG4gICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgIGlkID0gZ2V0VGFpbChpZCk7XG4gICAgICAgIGNvbXBvbmVudC5fYWRkR3JvdXBMaXN0ZW5lcihpZCwgY2FsbElkLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBjb21wb25lbnQgJHt0aGlzLnJvb3RJZH0vJHtjb21wb25lbnRJZH1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgbGV0IF9jYWxsSWQgPSBjYWxsSWQ7IC8vIGNyZWF0ZSBhIG5ldyBicmFuY2hlXG4gICAgICAgIF9jYWxsSWQgKz0gKGNhbGxJZCA9PT0gJycpID8gY29tcG9uZW50LmlkIDogc2VwYXJhdG9yICsgY29tcG9uZW50LmlkO1xuICAgICAgICBjb21wb25lbnQuX2FkZEdyb3VwTGlzdGVuZXIoaWQsIF9jYWxsSWQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb250YWluZXI7XG4iLCJpbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi4vdXRpbHMvc3R5bGVzJztcblxuLyoqIEBtb2R1bGUgYmFzaWMtY29udHJvbGxlcnMgKi9cblxuLy8gZGVmYXVsdCB0aGVtZVxubGV0IHRoZW1lID0gJ2xpZ2h0Jztcbi8vIHNldCBvZiB0aGUgaW5zdGFuY2lhdGVkIGNvbnRyb2xsZXJzXG5jb25zdCBjb250cm9sbGVycyA9IG5ldyBTZXQoKTtcblxuXG4vKipcbiAqIENoYW5nZSB0aGUgdGhlbWUgb2YgdGhlIGNvbnRyb2xsZXJzLCBjdXJyZW50bHkgMyB0aGVtZXMgYXJlIGF2YWlsYWJsZTpcbiAqICAtIGAnbGlnaHQnYCAoZGVmYXVsdClcbiAqICAtIGAnZ3JleSdgXG4gKiAgLSBgJ2RhcmsnYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZSAtIE5hbWUgb2YgdGhlIHRoZW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VGhlbWUodmFsdWUpIHtcbiAgY29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4gY29udHJvbGxlci4kZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGVtZSkpO1xuICB0aGVtZSA9IHZhbHVlO1xuICBjb250cm9sbGVycy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiBjb250cm9sbGVyLiRlbC5jbGFzc0xpc3QuYWRkKHRoZW1lKSk7XG59XG5cbi8qKlxuICogZGlzcGxheSBtaXhpbiAtIGNvbXBvbmVudHMgd2l0aCBET01cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGRpc3BsYXkgPSAoc3VwZXJjbGFzcykgPT4gY2xhc3MgZXh0ZW5kcyBzdXBlcmNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLy8gaW5zZXJ0IHN0eWxlcyBhbmQgbGlzdGVuIHdpbmRvdyByZXNpemUgd2hlbiB0aGUgZmlyc3QgY29udHJvbGxlciBpcyBjcmVhdGVkXG4gICAgaWYgKGNvbnRyb2xsZXJzLnNpemUgPT09IDApIHtcbiAgICAgIHN0eWxlcy5pbnNlcnRTdHlsZVNoZWV0KCk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4gY29udHJvbGxlci5yZXNpemUoKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250cm9sbGVycy5hZGQodGhpcyk7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIGxldCAkY29udGFpbmVyID0gdGhpcy5wYXJhbXMuY29udGFpbmVyO1xuXG4gICAgaWYgKCRjb250YWluZXIpIHtcbiAgICAgIC8vIGNzcyBzZWxlY3RvclxuICAgICAgaWYgKHR5cGVvZiAkY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAkY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigkY29udGFpbmVyKTtcbiAgICAgIC8vIGdyb3VwXG4gICAgICB9IGVsc2UgaWYgKCRjb250YWluZXIuJGNvbnRhaW5lcikge1xuICAgICAgICAvLyB0aGlzLmdyb3VwID0gJGNvbnRhaW5lcjtcbiAgICAgICAgJGNvbnRhaW5lci5lbGVtZW50cy5hZGQodGhpcyk7XG4gICAgICAgICRjb250YWluZXIgPSAkY29udGFpbmVyLiRjb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgICRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXIoKSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzaXplKCksIDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy4kZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKHN0eWxlcy5ucywgdGhlbWUsIHRoaXMudHlwZSk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVzaXplKCkge1xuICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHdpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoO1xuICAgIGNvbnN0IG1ldGhvZCA9IHdpZHRoID4gNjAwID8gJ3JlbW92ZScgOiAnYWRkJztcblxuICAgIHRoaXMuJGVsLmNsYXNzTGlzdFttZXRob2RdKCdzbWFsbCcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BsYXk7XG4iLCJcbmV4cG9ydCBjb25zdCB0b2dnbGUgPSBgXG4gIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwidG9nZ2xlLWVsZW1lbnRcIiB2ZXJzaW9uPVwiMS4xXCIgdmlld0JveD1cIjAgMCA1MCA1MFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCI+XG4gICAgICA8ZyBjbGFzcz1cInhcIj5cbiAgICAgICAgPGxpbmUgeDE9XCI4XCIgeTE9XCI4XCIgeDI9XCI0MlwiIHkyPVwiNDJcIiBzdHJva2U9XCJ3aGl0ZVwiIC8+XG4gICAgICAgIDxsaW5lIHgxPVwiOFwiIHkxPVwiNDJcIiB4Mj1cIjQyXCIgeTI9XCI4XCIgc3Ryb2tlPVwid2hpdGVcIiAvPlxuICAgICAgPC9nPlxuICA8L3N2Zz5cbmA7XG5cbmV4cG9ydCBjb25zdCBhcnJvd1JpZ2h0ID0gYFxuICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImFycm93LXJpZ2h0XCIgdmVyc2lvbj1cIjEuMVwiIHZpZXdCb3g9XCIwIDAgNTAgNTBcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiPlxuICAgIDxsaW5lIHgxPVwiMTBcIiB5MT1cIjEwXCIgeDI9XCI0MFwiIHkyPVwiMjVcIiAvPlxuICAgIDxsaW5lIHgxPVwiMTBcIiB5MT1cIjQwXCIgeDI9XCI0MFwiIHkyPVwiMjVcIiAvPlxuICA8L3N2Zz5cbmA7XG5cbmV4cG9ydCBjb25zdCBhcnJvd0xlZnQgPSBgXG4gIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiYXJyb3ctbGVmdFwiIHZlcnNpb249XCIxLjFcIiB2aWV3Qm94PVwiMCAwIDUwIDUwXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIj5cbiAgICA8bGluZSB4MT1cIjQwXCIgeTE9XCIxMFwiIHgyPVwiMTBcIiB5Mj1cIjI1XCIgLz5cbiAgICA8bGluZSB4MT1cIjQwXCIgeTE9XCI0MFwiIHgyPVwiMTBcIiB5Mj1cIjI1XCIgLz5cbiAgPC9zdmc+XG5gO1xuXG5leHBvcnQgY29uc3Qgc21hbGxBcnJvd1JpZ2h0ID0gYFxuICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cInNtYWxsLWFycm93LXJpZ2h0XCIgdmlld0JveD1cIjAgMCA1MCA1MFwiPlxuICAgIDxwYXRoIGQ9XCJNIDIwIDE1IEwgMzUgMjUgTCAyMCAzNSBaXCIgLz5cbiAgPC9zdmc+XG5gO1xuXG5leHBvcnQgY29uc3Qgc21hbGxBcnJvd0JvdHRvbSA9IGBcbiAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJzbWFsbC1hcnJvdy1ib3R0b21cIiB2aWV3Qm94PVwiMCAwIDUwIDUwXCI+XG4gICAgPHBhdGggZD1cIk0gMTUgMTcgTCAzNSAxNyBMIDI1IDMyIFpcIiAvPlxuICA8L3N2Zz5cbmA7XG5cblxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiIC5iYXNpYy1jb250cm9sbGVycyB7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIHsgd2lkdGg6IDEwMCU7IG1heC13aWR0aDogODAwcHg7IGhlaWdodDogMzRweDsgcGFkZGluZzogM3B4OyBtYXJnaW46IDRweCAwOyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZlZmVmOyBib3JkZXI6IDFweCBzb2xpZCAjYWFhYWFhOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBib3JkZXItcmFkaXVzOiAycHg7IGRpc3BsYXk6IGJsb2NrOyBjb2xvcjogIzQ2NDY0NjsgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7IC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC1tcy11c2VyLXNlbGVjdDogbm9uZTsgdXNlci1zZWxlY3Q6IG5vbmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5sYWJlbCB7IGZvbnQ6IGl0YWxpYyBub3JtYWwgMS4yZW0gUXVpY2tzYW5kLCBhcmlhbCwgc2Fucy1zZXJpZjsgbGluZS1oZWlnaHQ6IDI2cHg7IG92ZXJmbG93OiBoaWRkZW47IHRleHQtYWxpZ246IHJpZ2h0OyBwYWRkaW5nOiAwIDhweCAwIDA7IGRpc3BsYXk6IGJsb2NrOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB3aWR0aDogMjQlOyBmbG9hdDogbGVmdDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLW1zLXVzZXItc2VsZWN0OiBub25lOyAtby11c2VyLXNlbGVjdDogbm9uZTsgdXNlci1zZWxlY3Q6IG5vbmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5pbm5lci13cmFwcGVyIHsgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtZmxleDsgZGlzcGxheTogaW5saW5lLWZsZXg7IC13ZWJraXQtZmxleC13cmFwOiBuby13cmFwOyBmbGV4LXdyYXA6IG5vLXdyYXA7IHdpZHRoOiA3NiU7IGZsb2F0OiBsZWZ0OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbCB7IGhlaWdodDogNDhweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGw6bm90KC5hbGlnbi1zbWFsbCkgeyBoZWlnaHQ6IGF1dG87IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsOm5vdCguYWxpZ24tc21hbGwpIC5sYWJlbCB7IHdpZHRoOiAxMDAlOyBmbG9hdDogbm9uZTsgdGV4dC1hbGlnbjogbGVmdDsgbGluZS1oZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsOm5vdCguYWxpZ24tc21hbGwpIC5pbm5lci13cmFwcGVyIHsgd2lkdGg6IDEwMCU7IGZsb2F0OiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbC5hbGlnbi1zbWFsbCAubGFiZWwgeyBkaXNwbGF5OiBibG9jazsgbWFyZ2luLXJpZ2h0OiAyMHB4OyB0ZXh0LWFsaWduOiBsZWZ0OyBsaW5lLWhlaWdodDogNDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwuYWxpZ24tc21hbGwgLmlubmVyLXdyYXBwZXIgeyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiBhdXRvOyB9IC5iYXNpYy1jb250cm9sbGVycyAuYXJyb3ctcmlnaHQsIC5iYXNpYy1jb250cm9sbGVycyAuYXJyb3ctbGVmdCB7IGJvcmRlci1yYWRpdXM6IDJweDsgd2lkdGg6IDE0cHg7IGhlaWdodDogMjZweDsgY3Vyc29yOiBwb2ludGVyOyBiYWNrZ3JvdW5kLWNvbG9yOiAjNDY0NjQ2OyB9IC5iYXNpYy1jb250cm9sbGVycyAuYXJyb3ctcmlnaHQgbGluZSwgLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1sZWZ0IGxpbmUgeyBzdHJva2Utd2lkdGg6IDNweDsgc3Ryb2tlOiAjZmZmZmZmOyB9IC5iYXNpYy1jb250cm9sbGVycyAuYXJyb3ctcmlnaHQ6aG92ZXIsIC5iYXNpYy1jb250cm9sbGVycyAuYXJyb3ctbGVmdDpob3ZlciB7IGJhY2tncm91bmQtY29sb3I6ICM2ODY4Njg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1yaWdodDphY3RpdmUsIC5iYXNpYy1jb250cm9sbGVycyAuYXJyb3ctbGVmdDphY3RpdmUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjOTA5MDkwOyB9IC5iYXNpYy1jb250cm9sbGVycyAuc21hbGwtYXJyb3ctcmlnaHQsIC5iYXNpYy1jb250cm9sbGVycyAuc21hbGwtYXJyb3ctYm90dG9tIHsgd2lkdGg6IDI2cHg7IGhlaWdodDogMjZweDsgY3Vyc29yOiBwb2ludGVyOyB9IC5iYXNpYy1jb250cm9sbGVycyAuc21hbGwtYXJyb3ctcmlnaHQgcGF0aCwgLmJhc2ljLWNvbnRyb2xsZXJzIC5zbWFsbC1hcnJvdy1ib3R0b20gcGF0aCB7IGZpbGw6ICM5MDkwOTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5zbWFsbC1hcnJvdy1yaWdodDpob3ZlciBwYXRoLCAuYmFzaWMtY29udHJvbGxlcnMgLnNtYWxsLWFycm93LWJvdHRvbTpob3ZlciBwYXRoIHsgZmlsbDogIzY4Njg2ODsgfSAuYmFzaWMtY29udHJvbGxlcnMgLnRvZ2dsZS1lbGVtZW50IHsgd2lkdGg6IDI2cHg7IGhlaWdodDogMjZweDsgYm9yZGVyLXJhZGl1czogMnB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjNDY0NjQ2OyBjdXJzb3I6IHBvaW50ZXI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC50b2dnbGUtZWxlbWVudDpob3ZlciB7IGJhY2tncm91bmQtY29sb3I6ICM2ODY4Njg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC50b2dnbGUtZWxlbWVudCBsaW5lIHsgc3Ryb2tlLXdpZHRoOiAzcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC50b2dnbGUtZWxlbWVudCAueCB7IGRpc3BsYXk6IG5vbmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC50b2dnbGUtZWxlbWVudC5hY3RpdmUgLnggeyBkaXNwbGF5OiBibG9jazsgfSAuYmFzaWMtY29udHJvbGxlcnMgLmJ0biB7IGRpc3BsYXk6IGJsb2NrOyB0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQ6IG5vcm1hbCBub3JtYWwgMTJweCBhcmlhbDsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyBoZWlnaHQ6IDI2cHg7IGxpbmUtaGVpZ2h0OiAyNnB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjNDY0NjQ2OyBib3JkZXI6IG5vbmU7IGNvbG9yOiAjZmZmZmZmOyBtYXJnaW46IDAgNHB4IDAgMDsgcGFkZGluZzogMDsgYm94LXNpemluZzogYm9yZGVyLWJveDsgYm9yZGVyLXJhZGl1czogMnB4OyBjdXJzb3I6IHBvaW50ZXI7IC13ZWJraXQtZmxleC1ncm93OiAxOyBmbGV4LWdyb3c6IDE7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5idG46bGFzdC1jaGlsZCB7IG1hcmdpbjogMDsgfSAuYmFzaWMtY29udHJvbGxlcnMgLmJ0bjpob3ZlciB7IGJhY2tncm91bmQtY29sb3I6ICM2ODY4Njg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5idG46YWN0aXZlLCAuYmFzaWMtY29udHJvbGxlcnMgLmJ0bi5hY3RpdmUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjOTA5MDkwOyB9IC5iYXNpYy1jb250cm9sbGVycyAuYnRuOmZvY3VzIHsgb3V0bGluZTogbm9uZTsgfSAuYmFzaWMtY29udHJvbGxlcnMgLm51bWJlciB7IGhlaWdodDogMjZweDsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBwb3NpdGlvbjogcmVsYXRpdmU7IGZvbnQ6IG5vcm1hbCBub3JtYWwgMS4yZW0gUXVpY2tzYW5kLCBhcmlhbCwgc2Fucy1zZXJpZjsgdmVydGljYWwtYWxpZ246IHRvcDsgYm9yZGVyOiBub25lOyBiYWNrZ3JvdW5kOiBub25lOyBjb2xvcjogIzQ2NDY0NjsgcGFkZGluZzogMCA0cHg7IG1hcmdpbjogMDsgYmFja2dyb3VuZC1jb2xvcjogI2Y5ZjlmOTsgYm9yZGVyLXJhZGl1czogMnB4OyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9IC5iYXNpYy1jb250cm9sbGVycyAubnVtYmVyOmZvY3VzIHsgb3V0bGluZTogbm9uZTsgfSAuYmFzaWMtY29udHJvbGxlcnMgc2VsZWN0IHsgaGVpZ2h0OiAyNnB4OyBsaW5lLWhlaWdodDogMjZweDsgYmFja2dyb3VuZC1jb2xvcjogI2Y5ZjlmOTsgYm9yZGVyLXJhZGl1czogMnB4OyBib3JkZXI6IG5vbmU7IHZlcnRpY2FsLWFsaWduOiB0b3A7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgfSAuYmFzaWMtY29udHJvbGxlcnMgc2VsZWN0OmZvY3VzIHsgb3V0bGluZTogbm9uZTsgfSAuYmFzaWMtY29udHJvbGxlcnMgaW5wdXRbdHlwZT10ZXh0XSB7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDI2cHg7IGxpbmUtaGVpZ2h0OiAyNnB4OyBib3JkZXI6IDA7IHBhZGRpbmc6IDAgNHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmOWY5OyBib3JkZXItcmFkaXVzOiAycHg7IGNvbG9yOiAjNTY1NjU2OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbCAuYXJyb3ctcmlnaHQsIC5iYXNpYy1jb250cm9sbGVycy5zbWFsbCAuYXJyb3ctbGVmdCB7IHdpZHRoOiAyNHB4OyBoZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIC50b2dnbGUtZWxlbWVudCB7IHdpZHRoOiA0MHB4OyBoZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIC5idG4geyBoZWlnaHQ6IDQwcHg7IGxpbmUtaGVpZ2h0OiA0MHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbCAubnVtYmVyIHsgaGVpZ2h0OiA0MHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbCBzZWxlY3QgeyBoZWlnaHQ6IDQwcHg7IGxpbmUtaGVpZ2h0OiA0MHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbCBpbnB1dFt0eXBlPXRleHRdIHsgaGVpZ2h0OiA0MHB4OyBsaW5lLWhlaWdodDogNDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMudGl0bGUgeyBib3JkZXI6IG5vbmUgIWltcG9ydGFudDsgbWFyZ2luLWJvdHRvbTogMDsgbWFyZ2luLXRvcDogOHB4OyBwYWRkaW5nLXRvcDogOHB4OyBwYWRkaW5nLWJvdHRvbTogMDsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDsgaGVpZ2h0OiAyNXB4OyB9IC5iYXNpYy1jb250cm9sbGVycy50aXRsZSAubGFiZWwgeyBmb250OiBub3JtYWwgYm9sZCAxLjNlbSBRdWlja3NhbmQsIGFyaWFsLCBzYW5zLXNlcmlmOyBoZWlnaHQ6IDEwMCU7IG92ZXJmbG93OiBoaWRkZW47IHRleHQtYWxpZ246IGxlZnQ7IHBhZGRpbmc6IDA7IHdpZHRoOiAxMDAlOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyAtd2Via2l0LWZsZXgtZ3JvdzogMTsgZmxleC1ncm93OiAxOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cCB7IGhlaWdodDogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwIC5ncm91cC1oZWFkZXIgLmxhYmVsIHsgZm9udDogbm9ybWFsIGJvbGQgMS4zZW0gUXVpY2tzYW5kLCBhcmlhbCwgc2Fucy1zZXJpZjsgaGVpZ2h0OiAyNnB4OyBsaW5lLWhlaWdodDogMjZweDsgb3ZlcmZsb3c6IGhpZGRlbjsgdGV4dC1hbGlnbjogbGVmdDsgcGFkZGluZzogMCAwIDAgMzZweDsgd2lkdGg6IDEwMCU7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC13ZWJraXQtZmxleC1ncm93OiAxOyBmbGV4LWdyb3c6IDE7IGZsb2F0OiBub25lOyBjdXJzb3I6IHBvaW50ZXI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwIC5ncm91cC1oZWFkZXIgLnNtYWxsLWFycm93LXJpZ2h0IHsgd2lkdGg6IDI2cHg7IGhlaWdodDogMjZweDsgcG9zaXRpb246IGFic29sdXRlOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cCAuZ3JvdXAtaGVhZGVyIC5zbWFsbC1hcnJvdy1ib3R0b20geyB3aWR0aDogMjZweDsgaGVpZ2h0OiAyNnB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwIC5ncm91cC1jb250ZW50IHsgb3ZlcmZsb3c6IGhpZGRlbjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAgLmdyb3VwLWNvbnRlbnQgPiBkaXYgeyBtYXJnaW46IDRweCBhdXRvOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cCAuZ3JvdXAtY29udGVudCA+IGRpdjpsYXN0LWNoaWxkIHsgbWFyZ2luLWJvdHRvbTogMDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAub3BlbmVkIC5ncm91cC1oZWFkZXIgLnNtYWxsLWFycm93LXJpZ2h0IHsgZGlzcGxheTogbm9uZTsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAub3BlbmVkIC5ncm91cC1oZWFkZXIgLnNtYWxsLWFycm93LWJvdHRvbSB7IGRpc3BsYXk6IGJsb2NrOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cC5vcGVuZWQgLmdyb3VwLWNvbnRlbnQgeyBkaXNwbGF5OiBibG9jazsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAuY2xvc2VkIC5ncm91cC1oZWFkZXIgLnNtYWxsLWFycm93LXJpZ2h0IHsgZGlzcGxheTogYmxvY2s7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwLmNsb3NlZCAuZ3JvdXAtaGVhZGVyIC5zbWFsbC1hcnJvdy1ib3R0b20geyBkaXNwbGF5OiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cC5jbG9zZWQgLmdyb3VwLWNvbnRlbnQgeyBkaXNwbGF5OiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIgLnJhbmdlIHsgaGVpZ2h0OiAyNnB4OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG1hcmdpbjogMDsgLXdlYmtpdC1mbGV4LWdyb3c6IDQ7IGZsZXgtZ3JvdzogNDsgcG9zaXRpb246IHJlbGF0aXZlOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIgLnJhbmdlIGNhbnZhcyB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIgLm51bWJlci13cmFwcGVyIHsgZGlzcGxheTogaW5saW5lOyBoZWlnaHQ6IDI2cHg7IHRleHQtYWxpZ246IHJpZ2h0OyAtd2Via2l0LWZsZXgtZ3JvdzogMzsgZmxleC1ncm93OiAzOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIgLm51bWJlci13cmFwcGVyIC5udW1iZXIgeyBsZWZ0OiA1cHg7IHdpZHRoOiA1NHB4OyB0ZXh0LWFsaWduOiByaWdodDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc2xpZGVyIC5udW1iZXItd3JhcHBlciAudW5pdCB7IGZvbnQ6IGl0YWxpYyBub3JtYWwgMWVtIFF1aWNrc2FuZCwgYXJpYWwsIHNhbnMtc2VyaWY7IGxpbmUtaGVpZ2h0OiAyNnB4OyBoZWlnaHQ6IDI2cHg7IHdpZHRoOiAzMHB4OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHBvc2l0aW9uOiByZWxhdGl2ZTsgcGFkZGluZy1sZWZ0OiA1cHg7IHBhZGRpbmctcmlnaHQ6IDVweDsgY29sb3I6ICM1NjU2NTY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNsaWRlciAubnVtYmVyLXdyYXBwZXIgLnVuaXQgc3VwIHsgbGluZS1oZWlnaHQ6IDdweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc2xpZGVyLnNsaWRlci1sYXJnZSAucmFuZ2UgeyAtd2Via2l0LWZsZXgtZ3JvdzogNTA7IGZsZXgtZ3JvdzogNTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNsaWRlci5zbGlkZXItbGFyZ2UgLm51bWJlci13cmFwcGVyIHsgLXdlYmtpdC1mbGV4LWdyb3c6IDE7IGZsZXgtZ3JvdzogMTsgfSAuYmFzaWMtY29udHJvbGxlcnMuc2xpZGVyLnNsaWRlci1zbWFsbCAucmFuZ2UgeyAtd2Via2l0LWZsZXgtZ3JvdzogMjsgZmxleC1ncm93OiAyOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIuc2xpZGVyLXNtYWxsIC5udW1iZXItd3JhcHBlciB7IC13ZWJraXQtZmxleC1ncm93OiA0OyBmbGV4LWdyb3c6IDQ7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsLnNsaWRlciAucmFuZ2UgeyBoZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsLnNsaWRlciAubnVtYmVyLXdyYXBwZXIgeyBoZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsLnNsaWRlciAubnVtYmVyLXdyYXBwZXIgLnVuaXQgeyBsaW5lLWhlaWdodDogNDBweDsgaGVpZ2h0OiA0MHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5udW1iZXItYm94IC5udW1iZXIgeyB3aWR0aDogMTIwcHg7IG1hcmdpbjogMCAxMHB4OyB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB9IC5iYXNpYy1jb250cm9sbGVycy5zZWxlY3QtbGlzdCBzZWxlY3QgeyBtYXJnaW46IDAgMTBweDsgd2lkdGg6IDEyMHB4OyBmb250OiBub3JtYWwgbm9ybWFsIDEuMmVtIFF1aWNrc2FuZCwgYXJpYWwsIHNhbnMtc2VyaWY7IGNvbG9yOiAjNDY0NjQ2OyB9IC5iYXNpYy1jb250cm9sbGVycy5zZWxlY3QtYnV0dG9ucyAuYnRuOmZpcnN0LW9mLXR5cGUgeyBtYXJnaW4tbGVmdDogNHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy50ZXh0IGlucHV0W3R5cGU9dGV4dF0geyBmb250OiBub3JtYWwgbm9ybWFsIDEuMmVtIFF1aWNrc2FuZCwgYXJpYWwsIHNhbnMtc2VyaWY7IGNvbG9yOiAjNDY0NjQ2OyB9IC5iYXNpYy1jb250cm9sbGVycy5kcmFnLWFuZC1kcm9wIHsgd2lkdGg6IDEwMCU7IHRleHQtYWxpZ246IGNlbnRlcjsgZm9udC13ZWlnaHQ6IGJvbGQ7IGhlaWdodDogMTAwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRyYWctYW5kLWRyb3AgLmRyb3Atem9uZSB7IGJvcmRlcjogMXB4IGRvdHRlZCAjYzRjNGM0OyBib3JkZXItcmFkaXVzOiAycHg7IHRyYW5zaXRpb246IGJhY2tncm91bmQgMjAwbXM7IGhlaWdodDogOTBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZHJhZy1hbmQtZHJvcCAuZHJvcC16b25lLmRyYWcgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjYzRjNGM0OyB9IC5iYXNpYy1jb250cm9sbGVycy5kcmFnLWFuZC1kcm9wIC5sYWJlbCB7IGRpc3BsYXk6IGJsb2NrOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiA5MHB4OyBsaW5lLWhlaWdodDogOTBweDsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRyYWctYW5kLWRyb3AucHJvY2VzcyAubGFiZWwgeyBkaXNwbGF5OiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbC5kcmFnLWFuZC1kcm9wIHsgaGVpZ2h0OiAxMjBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwuZHJhZy1hbmQtZHJvcCAuZHJvcC16b25lIHsgaGVpZ2h0OiAxMTBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwuZHJhZy1hbmQtZHJvcCAubGFiZWwgeyBkaXNwbGF5OiBibG9jazsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTEwcHg7IGxpbmUtaGVpZ2h0OiAxMTBweDsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjMzYzNjM2OyBib3JkZXI6IDFweCBzb2xpZCAjNTg1ODU4OyBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KTsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAudG9nZ2xlLWVsZW1lbnQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZlZmVmOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC50b2dnbGUtZWxlbWVudCBsaW5lIHsgc3Ryb2tlOiAjMzYzNjM2OyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC50b2dnbGUtZWxlbWVudDpob3ZlciB7IGJhY2tncm91bmQtY29sb3I6ICNjZGNkY2Q7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmFycm93LXJpZ2h0LCAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYXJyb3ctbGVmdCB7IGJhY2tncm91bmQtY29sb3I6ICNlZmVmZWY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmFycm93LXJpZ2h0IGxpbmUsIC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5hcnJvdy1sZWZ0IGxpbmUgeyBzdHJva2U6ICMzNjM2MzY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmFycm93LXJpZ2h0OmhvdmVyLCAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYXJyb3ctbGVmdDpob3ZlciB7IGJhY2tncm91bmQtY29sb3I6ICNjZGNkY2Q7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmFycm93LXJpZ2h0OmFjdGl2ZSwgLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmFycm93LWxlZnQ6YWN0aXZlIHsgYmFja2dyb3VuZC1jb2xvcjogI2FiYWJhYjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuc21hbGwtYXJyb3ctcmlnaHQgcGF0aCwgLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLnNtYWxsLWFycm93LWJvdHRvbSBwYXRoIHsgZmlsbDogI2FiYWJhYjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuc21hbGwtYXJyb3ctcmlnaHQ6aG92ZXIgcGF0aCwgLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLnNtYWxsLWFycm93LWJvdHRvbTpob3ZlciBwYXRoIHsgZmlsbDogI2NkY2RjZDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAubnVtYmVyLCAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSBzZWxlY3QsIC5iYXNpYy1jb250cm9sbGVycy5ncmV5IGlucHV0W3R5cGU9dGV4dF0geyBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KTsgYmFja2dyb3VuZC1jb2xvcjogIzQ1NDU0NTsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYnRuIHsgYmFja2dyb3VuZC1jb2xvcjogI2VmZWZlZjsgY29sb3I6ICMzNjM2MzY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmJ0bjpob3ZlciB7IGJhY2tncm91bmQtY29sb3I6ICNjZGNkY2Q7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmJ0bjphY3RpdmUsIC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5idG4uYWN0aXZlIHsgYmFja2dyb3VuZC1jb2xvcjogI2FiYWJhYjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleS5zbGlkZXIgLmlubmVyLXdyYXBwZXIgLm51bWJlci13cmFwcGVyIC51bml0IHsgY29sb3I6ICNiY2JjYmM7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkuZ3JvdXAgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjNTA1MDUwOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5LmRyYWctYW5kLWRyb3AgLmRyb3Atem9uZSB7IGJvcmRlcjogMXB4IGRvdHRlZCAjNzI3MjcyOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5LmRyYWctYW5kLWRyb3AgLmRyb3Atem9uZS5kcmFnIHsgYmFja2dyb3VuZC1jb2xvcjogIzcyNzI3MjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayB7IGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7IGJvcmRlcjogMXB4IHNvbGlkICMyODI4Mjg7IGNvbG9yOiAjZmZmZmZmOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC50b2dnbGUtZWxlbWVudCB7IGJhY2tncm91bmQtY29sb3I6ICM0NjQ2NDY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLnRvZ2dsZS1lbGVtZW50IGxpbmUgeyBzdHJva2U6ICNmZmZmZmY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLnRvZ2dsZS1lbGVtZW50OmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogIzY4Njg2ODsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYXJyb3ctcmlnaHQsIC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5hcnJvdy1sZWZ0IHsgYmFja2dyb3VuZC1jb2xvcjogIzQ2NDY0NjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYXJyb3ctcmlnaHQgbGluZSwgLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLmFycm93LWxlZnQgbGluZSB7IHN0cm9rZTogI2ZmZmZmZjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYXJyb3ctcmlnaHQ6aG92ZXIsIC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5hcnJvdy1sZWZ0OmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogIzY4Njg2ODsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYXJyb3ctcmlnaHQ6YWN0aXZlLCAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYXJyb3ctbGVmdDphY3RpdmUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjOTA5MDkwOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5zbWFsbC1hcnJvdy1yaWdodCBwYXRoLCAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuc21hbGwtYXJyb3ctYm90dG9tIHBhdGggeyBmaWxsOiAjOTA5MDkwOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5zbWFsbC1hcnJvdy1yaWdodDpob3ZlciBwYXRoLCAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuc21hbGwtYXJyb3ctYm90dG9tOmhvdmVyIHBhdGggeyBmaWxsOiAjNjg2ODY4OyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5udW1iZXIsIC5iYXNpYy1jb250cm9sbGVycy5kYXJrIHNlbGVjdCwgLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgaW5wdXRbdHlwZT10ZXh0XSB7IGNvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzMzMzOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5idG4geyBiYWNrZ3JvdW5kLWNvbG9yOiAjNDY0NjQ2OyBjb2xvcjogI2ZmZmZmZjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYnRuOmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogIzY4Njg2ODsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYnRuOmFjdGl2ZSwgLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLmJ0bi5hY3RpdmUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjOTA5MDkwOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrLnNsaWRlciAuaW5uZXItd3JhcHBlciAubnVtYmVyLXdyYXBwZXIgLnVuaXQgeyBjb2xvcjogI2NkY2RjZDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyay5ncm91cCB7IGJhY2tncm91bmQtY29sb3I6ICMzZTNlM2U7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsuZHJhZy1hbmQtZHJvcCAuZHJvcC16b25lIHsgYm9yZGVyOiAxcHggZG90dGVkICM0MjQyNDI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsuZHJhZy1hbmQtZHJvcCAuZHJvcC16b25lLmRyYWcgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjNDI0MjQyOyB9IFwiOyIsImltcG9ydCB7IG5hbWUgfSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy1kZWNsYXJhdGlvbnMuanMnO1xuXG5leHBvcnQgY29uc3QgbnMgPSBuYW1lO1xuXG5jb25zdCBuc0NsYXNzID0gYC4ke25zfWA7XG5sZXQgX2Rpc2FibGVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICBfZGlzYWJsZWQgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0U3R5bGVTaGVldCgpIHtcbiAgaWYgKF9kaXNhYmxlZCkgcmV0dXJuO1xuXG4gIGNvbnN0ICRjc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAkY3NzLnNldEF0dHJpYnV0ZSgnZGF0YS1uYW1lc3BhY2UnLCBucyk7XG4gICRjc3MudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKCRjc3Muc3R5bGVTaGVldClcbiAgICAkY3NzLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHN0eWxlcztcbiAgZWxzZVxuICAgICRjc3MuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGVzKSk7XG5cbiAgLy8gaW5zZXJ0IGJlZm9yZSBsaW5rIG9yIHN0eWxlcyBpZiBleGlzdHNcbiAgY29uc3QgJGxpbmsgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ2xpbmsnKTtcbiAgY29uc3QgJHN0eWxlID0gZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpO1xuXG4gIGlmICgkbGluaylcbiAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZSgkY3NzLCAkbGluayk7XG4gIGVsc2UgaWYgKCRzdHlsZSlcbiAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZSgkY3NzLCAkc3R5bGUpO1xuICBlbHNlXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkY3NzKTtcbn1cblxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9mcm9tXCI6IFwiZ2l0aHViOmlyY2FtLWpzdG9vbHMvYmFzaWMtY29udHJvbGxlcnMjdjEuMC4xXCIsXG4gIFwiX2lkXCI6IFwiYmFzaWMtY29udHJvbGxlcnNAMS4wLjFcIixcbiAgXCJfaW5CdW5kbGVcIjogZmFsc2UsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL2Jhc2ljLWNvbnRyb2xsZXJzXCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInJhd1wiOiBcImJhc2ljLWNvbnRyb2xsZXJzQGdpdGh1YjppcmNhbS1qc3Rvb2xzL2Jhc2ljLWNvbnRyb2xsZXJzI3YxLjAuMVwiLFxuICAgIFwibmFtZVwiOiBcImJhc2ljLWNvbnRyb2xsZXJzXCIsXG4gICAgXCJlc2NhcGVkTmFtZVwiOiBcImJhc2ljLWNvbnRyb2xsZXJzXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiZ2l0aHViOmlyY2FtLWpzdG9vbHMvYmFzaWMtY29udHJvbGxlcnMjdjEuMC4xXCIsXG4gICAgXCJzYXZlU3BlY1wiOiBcImdpdGh1YjppcmNhbS1qc3Rvb2xzL2Jhc2ljLWNvbnRyb2xsZXJzI3YxLjAuMVwiLFxuICAgIFwiZmV0Y2hTcGVjXCI6IG51bGwsXG4gICAgXCJnaXRDb21taXR0aXNoXCI6IFwidjEuMC4xXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvc291bmR3b3Jrc1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiZ2l0aHViOmlyY2FtLWpzdG9vbHMvYmFzaWMtY29udHJvbGxlcnMjOTYyNWE1MTMxODNjMWEzODkzMWM2NjMzNTRkZWJlOTRkYWZiODQxY1wiLFxuICBcIl9zcGVjXCI6IFwiYmFzaWMtY29udHJvbGxlcnNAZ2l0aHViOmlyY2FtLWpzdG9vbHMvYmFzaWMtY29udHJvbGxlcnMjdjEuMC4xXCIsXG4gIFwiX3doZXJlXCI6IFwiL1VzZXJzL3NjdXJ0by9jb2xvb3Avbm9kZV9tb2R1bGVzL3NvdW5kd29ya3NcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pcmNhbS1qc3Rvb2xzL2Jhc2ljLWNvbnRyb2xsZXJzL2lzc3Vlc1wiXG4gIH0sXG4gIFwiYnVuZGxlRGVwZW5kZW5jaWVzXCI6IGZhbHNlLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJiYWJlbC1ydW50aW1lXCI6IFwiXjYuMTguMFwiLFxuICAgIFwiZ3VpLWNvbXBvbmVudHNcIjogXCJnaXRodWI6aXJjYW0tanN0b29scy9ndWktY29tcG9uZW50cyN2MS4wLjFcIlxuICB9LFxuICBcImRlcHJlY2F0ZWRcIjogZmFsc2UsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJTZXQgb2Ygc2ltcGxlIGNvbnRyb2xsZXJzIGZvciByYXBpZCBwcm90b3R5cGluZ1wiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJiYWJlbC1jb3JlXCI6IFwiXjYuMTguMlwiLFxuICAgIFwiYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1lczIwMTUtbW9kdWxlcy1jb21tb25qc1wiOiBcIl42LjE4LjBcIixcbiAgICBcImJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tcnVudGltZVwiOiBcIl42LjE1LjBcIixcbiAgICBcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi4xOC4wXCIsXG4gICAgXCJjb2xvcnNcIjogXCJeMS4xLjJcIixcbiAgICBcImZzLWV4dHJhXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJqc2RvYy10by1tYXJrZG93blwiOiBcIl4yLjAuMVwiLFxuICAgIFwibm9kZS1zYXNzXCI6IFwiXjMuMTMuMFwiLFxuICAgIFwid2F0Y2hcIjogXCJeMS4wLjFcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2lyY2FtLWpzdG9vbHMvYmFzaWMtY29udHJvbGxlcnMjcmVhZG1lXCIsXG4gIFwibGljZW5zZVwiOiBcIkJTRC0zLUNsYXVzZVwiLFxuICBcIm1haW5cIjogXCJkaXN0L2luZGV4LmpzXCIsXG4gIFwibmFtZVwiOiBcImJhc2ljLWNvbnRyb2xsZXJzXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2lyY2FtLWpzdG9vbHMvYmFzaWMtY29udHJvbGxlcnMuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImRvY1wiOiBcImpzZG9jMm1kIC10IHRtcGwvUkVBRE1FLmhicyAtLXNlcGFyYXRvcnMgc3JjLyoqLyouanMgc3JjLyouanMgPiBSRUFETUUubWRcIixcbiAgICBcInByZXdhdGNoXCI6IFwibm9kZSAuL2Jpbi9ydW5uZXIgLS10cmFuc3BpbGVcIixcbiAgICBcInRyYW5zcGlsZVwiOiBcIm5vZGUgLi9iaW4vcnVubmVyIC0tdHJhbnNwaWxlXCIsXG4gICAgXCJ3YXRjaFwiOiBcIm5vZGUgLi9iaW4vcnVubmVyIC0td2F0Y2hcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIxLjAuMVwiXG59XG4iLCIvKipcclxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcclxuICovXHJcblxyXG52YXIgQmxvYkJ1aWxkZXIgPSB0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gQmxvYkJ1aWxkZXIgOlxyXG4gIHR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBXZWJLaXRCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1vekJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1vekJsb2JCdWlsZGVyIDogXHJcbiAgZmFsc2U7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xyXG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXHJcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXHJcbiAqL1xyXG5cclxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcclxuICAgIHJldHVybiBiLnNpemUgPT09IDI7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcclxuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XHJcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcclxuICByZXR1cm4gYXJ5Lm1hcChmdW5jdGlvbihjaHVuaykge1xyXG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XHJcblxyXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcclxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXHJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBidWY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNodW5rO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcclxuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICBiYi5hcHBlbmQocGFydCk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEJsb2IobWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpLCBvcHRpb25zIHx8IHt9KTtcclxufTtcclxuXHJcbmlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBCbG9iQnVpbGRlckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG4gIEJsb2JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBCbG9iLnByb3RvdHlwZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBCbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufSkoKTtcclxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpO1xudmFyICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7IHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnkgfSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLk1hcDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLldlYWtNYXA7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG4iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIGlmICghREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSwgJ19jJyk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZSgpO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZiAoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIGhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCBLRVkpO1xuICAgICAgICBpZiAoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKSByZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIElTX1dFQUsgfHwgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBBID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZVxuICAgICAgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgICAvLyB3ZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICAgICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDBcbiAgICAgICYmIHVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gbWF5IHRocm93XG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNFVCA9ICdTZXQnO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShTRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrTWFwJyk7XG4iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qanNoaW50IGJyb3dzZXI6dHJ1ZSwgbm9kZTp0cnVlKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlbGVnYXRlO1xuXG4vKipcbiAqIERPTSBldmVudCBkZWxlZ2F0b3JcbiAqXG4gKiBUaGUgZGVsZWdhdG9yIHdpbGwgbGlzdGVuXG4gKiBmb3IgZXZlbnRzIHRoYXQgYnViYmxlIHVwXG4gKiB0byB0aGUgcm9vdCBub2RlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOb2RlfHN0cmluZ30gW3Jvb3RdIFRoZSByb290IG5vZGUgb3IgYSBzZWxlY3RvciBzdHJpbmcgbWF0Y2hpbmcgdGhlIHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBEZWxlZ2F0ZShyb290KSB7XG5cbiAgLyoqXG4gICAqIE1haW50YWluIGEgbWFwIG9mIGxpc3RlbmVyXG4gICAqIGxpc3RzLCBrZXllZCBieSBldmVudCBuYW1lLlxuICAgKlxuICAgKiBAdHlwZSBPYmplY3RcbiAgICovXG4gIHRoaXMubGlzdGVuZXJNYXAgPSBbe30sIHt9XTtcbiAgaWYgKHJvb3QpIHtcbiAgICB0aGlzLnJvb3Qocm9vdCk7XG4gIH1cblxuICAvKiogQHR5cGUgZnVuY3Rpb24oKSAqL1xuICB0aGlzLmhhbmRsZSA9IERlbGVnYXRlLnByb3RvdHlwZS5oYW5kbGUuYmluZCh0aGlzKTtcbn1cblxuLyoqXG4gKiBTdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICogb24gdGhlIHByb3ZpZGVkIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7Tm9kZXxzdHJpbmd9IFtyb290XSBUaGUgcm9vdCBub2RlIG9yIGEgc2VsZWN0b3Igc3RyaW5nIG1hdGNoaW5nIHRoZSByb290IG5vZGVcbiAqIEByZXR1cm5zIHtEZWxlZ2F0ZX0gVGhpcyBtZXRob2QgaXMgY2hhaW5hYmxlXG4gKi9cbkRlbGVnYXRlLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24ocm9vdCkge1xuICB2YXIgbGlzdGVuZXJNYXAgPSB0aGlzLmxpc3RlbmVyTWFwO1xuICB2YXIgZXZlbnRUeXBlO1xuXG4gIC8vIFJlbW92ZSBtYXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG4gIGlmICh0aGlzLnJvb3RFbGVtZW50KSB7XG4gICAgZm9yIChldmVudFR5cGUgaW4gbGlzdGVuZXJNYXBbMV0pIHtcbiAgICAgIGlmIChsaXN0ZW5lck1hcFsxXS5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChldmVudFR5cGUgaW4gbGlzdGVuZXJNYXBbMF0pIHtcbiAgICAgIGlmIChsaXN0ZW5lck1hcFswXS5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gcm9vdCBvciByb290IGlzIG5vdFxuICAvLyBhIGRvbSBub2RlLCB0aGVuIHJlbW92ZSBpbnRlcm5hbFxuICAvLyByb290IHJlZmVyZW5jZSBhbmQgZXhpdCBoZXJlXG4gIGlmICghcm9vdCB8fCAhcm9vdC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMucm9vdEVsZW1lbnQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcm9vdCBub2RlIGF0IHdoaWNoXG4gICAqIGxpc3RlbmVycyBhcmUgYXR0YWNoZWQuXG4gICAqXG4gICAqIEB0eXBlIE5vZGVcbiAgICovXG4gIHRoaXMucm9vdEVsZW1lbnQgPSByb290O1xuXG4gIC8vIFNldCB1cCBtYXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG4gIGZvciAoZXZlbnRUeXBlIGluIGxpc3RlbmVyTWFwWzFdKSB7XG4gICAgaWYgKGxpc3RlbmVyTWFwWzFdLmhhc093blByb3BlcnR5KGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgZm9yIChldmVudFR5cGUgaW4gbGlzdGVuZXJNYXBbMF0pIHtcbiAgICBpZiAobGlzdGVuZXJNYXBbMF0uaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSkge1xuICAgICAgdGhpcy5yb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgdGhpcy5oYW5kbGUsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5EZWxlZ2F0ZS5wcm90b3R5cGUuY2FwdHVyZUZvclR5cGUgPSBmdW5jdGlvbihldmVudFR5cGUpIHtcbiAgcmV0dXJuIFsnYmx1cicsICdlcnJvcicsICdmb2N1cycsICdsb2FkJywgJ3Jlc2l6ZScsICdzY3JvbGwnXS5pbmRleE9mKGV2ZW50VHlwZSkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBBdHRhY2ggYSBoYW5kbGVyIHRvIG9uZVxuICogZXZlbnQgZm9yIGFsbCBlbGVtZW50c1xuICogdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IsXG4gKiBub3cgb3IgaW4gdGhlIGZ1dHVyZVxuICpcbiAqIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIHJlY2VpdmVzXG4gKiB0aHJlZSBhcmd1bWVudHM6IHRoZSBET00gZXZlbnRcbiAqIG9iamVjdCwgdGhlIG5vZGUgdGhhdCBtYXRjaGVkXG4gKiB0aGUgc2VsZWN0b3Igd2hpbGUgdGhlIGV2ZW50XG4gKiB3YXMgYnViYmxpbmcgYW5kIGEgcmVmZXJlbmNlXG4gKiB0byBpdHNlbGYuIFdpdGhpbiB0aGUgaGFuZGxlcixcbiAqICd0aGlzJyBpcyBlcXVhbCB0byB0aGUgc2Vjb25kXG4gKiBhcmd1bWVudC5cbiAqXG4gKiBUaGUgbm9kZSB0aGF0IGFjdHVhbGx5IHJlY2VpdmVkXG4gKiB0aGUgZXZlbnQgY2FuIGJlIGFjY2Vzc2VkIHZpYVxuICogJ2V2ZW50LnRhcmdldCcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBMaXN0ZW4gZm9yIHRoZXNlIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzZWxlY3RvciBPbmx5IGhhbmRsZSBldmVudHMgb24gZWxlbWVudHMgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvciwgaWYgdW5kZWZpbmVkIG1hdGNoIHJvb3QgZWxlbWVudFxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBoYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb24gLSBldmVudCBkYXRhIHBhc3NlZCBoZXJlIHdpbGwgYmUgaW4gZXZlbnQuZGF0YVxuICogQHBhcmFtIHtib29sZWFufSBbdXNlQ2FwdHVyZV0gc2VlICd1c2VDYXB0dXJlJyBpbiA8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXI+XG4gKiBAcmV0dXJucyB7RGVsZWdhdGV9IFRoaXMgbWV0aG9kIGlzIGNoYWluYWJsZVxuICovXG5EZWxlZ2F0ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIHZhciByb290LCBsaXN0ZW5lck1hcCwgbWF0Y2hlciwgbWF0Y2hlclBhcmFtO1xuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcbiAgfVxuXG4gIC8vIGhhbmRsZXIgY2FuIGJlIHBhc3NlZCBhc1xuICAvLyB0aGUgc2Vjb25kIG9yIHRoaXJkIGFyZ3VtZW50XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1c2VDYXB0dXJlID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gc2VsZWN0b3I7XG4gICAgc2VsZWN0b3IgPSBudWxsO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gc2Vuc2libGUgZGVmYXVsdHNcbiAgLy8gaWYgdXNlQ2FwdHVyZSBub3Qgc2V0XG4gIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICB1c2VDYXB0dXJlID0gdGhpcy5jYXB0dXJlRm9yVHlwZShldmVudFR5cGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFuZGxlciBtdXN0IGJlIGEgdHlwZSBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgcm9vdCA9IHRoaXMucm9vdEVsZW1lbnQ7XG4gIGxpc3RlbmVyTWFwID0gdGhpcy5saXN0ZW5lck1hcFt1c2VDYXB0dXJlID8gMSA6IDBdO1xuXG4gIC8vIEFkZCBtYXN0ZXIgaGFuZGxlciBmb3IgdHlwZSBpZiBub3QgY3JlYXRlZCB5ZXRcbiAgaWYgKCFsaXN0ZW5lck1hcFtldmVudFR5cGVdKSB7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCB1c2VDYXB0dXJlKTtcbiAgICB9XG4gICAgbGlzdGVuZXJNYXBbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG5cbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIG1hdGNoZXJQYXJhbSA9IG51bGw7XG5cbiAgICAvLyBDT01QTEVYIC0gbWF0Y2hlc1Jvb3QgbmVlZHMgdG8gaGF2ZSBhY2Nlc3MgdG9cbiAgICAvLyB0aGlzLnJvb3RFbGVtZW50LCBzbyBiaW5kIHRoZSBmdW5jdGlvbiB0byB0aGlzLlxuICAgIG1hdGNoZXIgPSBtYXRjaGVzUm9vdC5iaW5kKHRoaXMpO1xuXG4gIC8vIENvbXBpbGUgYSBtYXRjaGVyIGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3JcbiAgfSBlbHNlIGlmICgvXlthLXpdKyQvaS50ZXN0KHNlbGVjdG9yKSkge1xuICAgIG1hdGNoZXJQYXJhbSA9IHNlbGVjdG9yO1xuICAgIG1hdGNoZXIgPSBtYXRjaGVzVGFnO1xuICB9IGVsc2UgaWYgKC9eI1thLXowLTlcXC1fXSskL2kudGVzdChzZWxlY3RvcikpIHtcbiAgICBtYXRjaGVyUGFyYW0gPSBzZWxlY3Rvci5zbGljZSgxKTtcbiAgICBtYXRjaGVyID0gbWF0Y2hlc0lkO1xuICB9IGVsc2Uge1xuICAgIG1hdGNoZXJQYXJhbSA9IHNlbGVjdG9yO1xuICAgIG1hdGNoZXIgPSBtYXRjaGVzO1xuICB9XG5cbiAgLy8gQWRkIHRvIHRoZSBsaXN0IG9mIGxpc3RlbmVyc1xuICBsaXN0ZW5lck1hcFtldmVudFR5cGVdLnB1c2goe1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgIG1hdGNoZXI6IG1hdGNoZXIsXG4gICAgbWF0Y2hlclBhcmFtOiBtYXRjaGVyUGFyYW1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4gKiBmb3IgZWxlbWVudHMgdGhhdCBtYXRjaFxuICogdGhlIHNlbGVjdG9yLCBmb3JldmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtldmVudFR5cGVdIFJlbW92ZSBoYW5kbGVycyBmb3IgZXZlbnRzIG1hdGNoaW5nIHRoaXMgdHlwZSwgY29uc2lkZXJpbmcgdGhlIG90aGVyIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2VsZWN0b3JdIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQsIG9ubHkgaGFuZGxlcnMgd2hpY2ggbWF0Y2ggdGhlIG90aGVyIHR3byB3aWxsIGJlIHJlbW92ZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gW2hhbmRsZXJdIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQsIG9ubHkgaGFuZGxlcnMgd2hpY2ggbWF0Y2ggdGhlIHByZXZpb3VzIHR3byB3aWxsIGJlIHJlbW92ZWRcbiAqIEByZXR1cm5zIHtEZWxlZ2F0ZX0gVGhpcyBtZXRob2QgaXMgY2hhaW5hYmxlXG4gKi9cbkRlbGVnYXRlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIHZhciBpLCBsaXN0ZW5lciwgbGlzdGVuZXJNYXAsIGxpc3RlbmVyTGlzdCwgc2luZ2xlRXZlbnRUeXBlO1xuXG4gIC8vIEhhbmRsZXIgY2FuIGJlIHBhc3NlZCBhc1xuICAvLyB0aGUgc2Vjb25kIG9yIHRoaXJkIGFyZ3VtZW50XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1c2VDYXB0dXJlID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gc2VsZWN0b3I7XG4gICAgc2VsZWN0b3IgPSBudWxsO1xuICB9XG5cbiAgLy8gSWYgdXNlQ2FwdHVyZSBub3Qgc2V0LCByZW1vdmVcbiAgLy8gYWxsIGV2ZW50IGxpc3RlbmVyc1xuICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5vZmYoZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgdGhpcy5vZmYoZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlciwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJNYXAgPSB0aGlzLmxpc3RlbmVyTWFwW3VzZUNhcHR1cmUgPyAxIDogMF07XG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgZm9yIChzaW5nbGVFdmVudFR5cGUgaW4gbGlzdGVuZXJNYXApIHtcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5oYXNPd25Qcm9wZXJ0eShzaW5nbGVFdmVudFR5cGUpKSB7XG4gICAgICAgIHRoaXMub2ZmKHNpbmdsZUV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJMaXN0ID0gbGlzdGVuZXJNYXBbZXZlbnRUeXBlXTtcbiAgaWYgKCFsaXN0ZW5lckxpc3QgfHwgIWxpc3RlbmVyTGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFJlbW92ZSBvbmx5IHBhcmFtZXRlciBtYXRjaGVzXG4gIC8vIGlmIHNwZWNpZmllZFxuICBmb3IgKGkgPSBsaXN0ZW5lckxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsaXN0ZW5lciA9IGxpc3RlbmVyTGlzdFtpXTtcblxuICAgIGlmICgoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBsaXN0ZW5lci5zZWxlY3RvcikgJiYgKCFoYW5kbGVyIHx8IGhhbmRsZXIgPT09IGxpc3RlbmVyLmhhbmRsZXIpKSB7XG4gICAgICBsaXN0ZW5lckxpc3Quc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsbCBsaXN0ZW5lcnMgcmVtb3ZlZFxuICBpZiAoIWxpc3RlbmVyTGlzdC5sZW5ndGgpIHtcbiAgICBkZWxldGUgbGlzdGVuZXJNYXBbZXZlbnRUeXBlXTtcblxuICAgIC8vIFJlbW92ZSB0aGUgbWFpbiBoYW5kbGVyXG4gICAgaWYgKHRoaXMucm9vdEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCB1c2VDYXB0dXJlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBIYW5kbGUgYW4gYXJiaXRyYXJ5IGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKi9cbkRlbGVnYXRlLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgaSwgbCwgdHlwZSA9IGV2ZW50LnR5cGUsIHJvb3QsIHBoYXNlLCBsaXN0ZW5lciwgcmV0dXJuZWQsIGxpc3RlbmVyTGlzdCA9IFtdLCB0YXJnZXQsIC8qKiBAY29uc3QgKi8gRVZFTlRJR05PUkUgPSAnZnRMYWJzRGVsZWdhdGVJZ25vcmUnO1xuXG4gIGlmIChldmVudFtFVkVOVElHTk9SRV0gPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgLy8gSGFyZGNvZGUgdmFsdWUgb2YgTm9kZS5URVhUX05PREVcbiAgLy8gYXMgbm90IGRlZmluZWQgaW4gSUU4XG4gIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IDMpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJvb3QgPSB0aGlzLnJvb3RFbGVtZW50O1xuXG4gIHBoYXNlID0gZXZlbnQuZXZlbnRQaGFzZSB8fCAoIGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCA/IDMgOiAyICk7XG4gIFxuICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgY2FzZSAxOiAvL0V2ZW50LkNBUFRVUklOR19QSEFTRTpcbiAgICAgIGxpc3RlbmVyTGlzdCA9IHRoaXMubGlzdGVuZXJNYXBbMV1bdHlwZV07XG4gICAgYnJlYWs7XG4gICAgY2FzZSAyOiAvL0V2ZW50LkFUX1RBUkdFVDpcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVyTWFwWzBdICYmIHRoaXMubGlzdGVuZXJNYXBbMF1bdHlwZV0pIGxpc3RlbmVyTGlzdCA9IGxpc3RlbmVyTGlzdC5jb25jYXQodGhpcy5saXN0ZW5lck1hcFswXVt0eXBlXSk7XG4gICAgICBpZiAodGhpcy5saXN0ZW5lck1hcFsxXSAmJiB0aGlzLmxpc3RlbmVyTWFwWzFdW3R5cGVdKSBsaXN0ZW5lckxpc3QgPSBsaXN0ZW5lckxpc3QuY29uY2F0KHRoaXMubGlzdGVuZXJNYXBbMV1bdHlwZV0pO1xuICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy9FdmVudC5CVUJCTElOR19QSEFTRTpcbiAgICAgIGxpc3RlbmVyTGlzdCA9IHRoaXMubGlzdGVuZXJNYXBbMF1bdHlwZV07XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBOZWVkIHRvIGNvbnRpbnVvdXNseSBjaGVja1xuICAvLyB0aGF0IHRoZSBzcGVjaWZpYyBsaXN0IGlzXG4gIC8vIHN0aWxsIHBvcHVsYXRlZCBpbiBjYXNlIG9uZVxuICAvLyBvZiB0aGUgY2FsbGJhY2tzIGFjdHVhbGx5XG4gIC8vIGNhdXNlcyB0aGUgbGlzdCB0byBiZSBkZXN0cm95ZWQuXG4gIGwgPSBsaXN0ZW5lckxpc3QubGVuZ3RoO1xuICB3aGlsZSAodGFyZ2V0ICYmIGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyTGlzdFtpXTtcblxuICAgICAgLy8gQmFpbCBmcm9tIHRoaXMgbG9vcCBpZlxuICAgICAgLy8gdGhlIGxlbmd0aCBjaGFuZ2VkIGFuZFxuICAgICAgLy8gbm8gbW9yZSBsaXN0ZW5lcnMgYXJlXG4gICAgICAvLyBkZWZpbmVkIGJldHdlZW4gaSBhbmQgbC5cbiAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBtYXRjaCBhbmQgZmlyZVxuICAgICAgLy8gdGhlIGV2ZW50IGlmIHRoZXJlJ3Mgb25lXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzpNQ0c6MjAxMjAxMTc6IE5lZWQgYSB3YXlcbiAgICAgIC8vIHRvIGNoZWNrIGlmIGV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxuICAgICAgLy8gd2FzIGNhbGxlZC4gSWYgc28sIGJyZWFrIGJvdGggbG9vcHMuXG4gICAgICBpZiAobGlzdGVuZXIubWF0Y2hlci5jYWxsKHRhcmdldCwgbGlzdGVuZXIubWF0Y2hlclBhcmFtLCB0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybmVkID0gdGhpcy5maXJlKGV2ZW50LCB0YXJnZXQsIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcCBwcm9wYWdhdGlvbiB0byBzdWJzZXF1ZW50XG4gICAgICAvLyBjYWxsYmFja3MgaWYgdGhlIGNhbGxiYWNrIHJldHVybmVkXG4gICAgICAvLyBmYWxzZVxuICAgICAgaWYgKHJldHVybmVkID09PSBmYWxzZSkge1xuICAgICAgICBldmVudFtFVkVOVElHTk9SRV0gPSB0cnVlO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzpNQ0c6MjAxMjAxMTc6IE5lZWQgYSB3YXkgdG9cbiAgICAvLyBjaGVjayBpZiBldmVudCNzdG9wUHJvcGFnYXRpb25cbiAgICAvLyB3YXMgY2FsbGVkLiBJZiBzbywgYnJlYWsgbG9vcGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIERPTS4gU3RvcCBpZiB0aGVcbiAgICAvLyBkZWxlZ2F0aW9uIHJvb3QgaGFzIGJlZW4gcmVhY2hlZFxuICAgIGlmICh0YXJnZXQgPT09IHJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGwgPSBsaXN0ZW5lckxpc3QubGVuZ3RoO1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICB9XG59O1xuXG4vKipcbiAqIEZpcmUgYSBsaXN0ZW5lciBvbiBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5lclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkRlbGVnYXRlLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24oZXZlbnQsIHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIGxpc3RlbmVyLmhhbmRsZXIuY2FsbCh0YXJnZXQsIGV2ZW50LCB0YXJnZXQpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIGVsZW1lbnRcbiAqIG1hdGNoZXMgYSBnZW5lcmljIHNlbGVjdG9yLlxuICpcbiAqIEB0eXBlIGZ1bmN0aW9uKClcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBBIENTUyBzZWxlY3RvclxuICovXG52YXIgbWF0Y2hlcyA9IChmdW5jdGlvbihlbCkge1xuICBpZiAoIWVsKSByZXR1cm47XG4gIHZhciBwID0gZWwucHJvdG90eXBlO1xuICByZXR1cm4gKHAubWF0Y2hlcyB8fCBwLm1hdGNoZXNTZWxlY3RvciB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHAub01hdGNoZXNTZWxlY3Rvcik7XG59KEVsZW1lbnQpKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIGVsZW1lbnRcbiAqIG1hdGNoZXMgYSB0YWcgc2VsZWN0b3IuXG4gKlxuICogVGFncyBhcmUgTk9UIGNhc2Utc2Vuc2l0aXZlLFxuICogZXhjZXB0IGluIFhNTCAoYW5kIFhNTC1iYXNlZFxuICogbGFuZ3VhZ2VzIHN1Y2ggYXMgWEhUTUwpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSB0YWcgbmFtZSB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB0ZXN0IHdpdGhcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1RhZyh0YWdOYW1lLCBlbGVtZW50KSB7XG4gIHJldHVybiB0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gZWxlbWVudFxuICogbWF0Y2hlcyB0aGUgcm9vdC5cbiAqXG4gKiBAcGFyYW0gez9TdHJpbmd9IHNlbGVjdG9yIEluIHRoaXMgY2FzZSB0aGlzIGlzIGFsd2F5cyBwYXNzZWQgdGhyb3VnaCBhcyBudWxsIGFuZCBub3QgdXNlZFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHRlc3Qgd2l0aFxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5mdW5jdGlvbiBtYXRjaGVzUm9vdChzZWxlY3RvciwgZWxlbWVudCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSovXG4gIGlmICh0aGlzLnJvb3RFbGVtZW50ID09PSB3aW5kb3cpIHJldHVybiBlbGVtZW50ID09PSBkb2N1bWVudDtcbiAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnQgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgSUQgb2ZcbiAqIHRoZSBlbGVtZW50IGluICd0aGlzJ1xuICogbWF0Y2hlcyB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogSURzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHRlc3Qgd2l0aFxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5mdW5jdGlvbiBtYXRjaGVzSWQoaWQsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlkID09PSBlbGVtZW50LmlkO1xufVxuXG4vKipcbiAqIFNob3J0IGhhbmQgZm9yIG9mZigpXG4gKiBhbmQgcm9vdCgpLCBpZSBib3RoXG4gKiB3aXRoIG5vIHBhcmFtZXRlcnNcbiAqXG4gKiBAcmV0dXJuIHZvaWRcbiAqL1xuRGVsZWdhdGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vZmYoKTtcbiAgdGhpcy5yb290KCk7XG59O1xuIiwiLypqc2hpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHByZXNlcnZlIENyZWF0ZSBhbmQgbWFuYWdlIGEgRE9NIGV2ZW50IGRlbGVnYXRvci5cbiAqXG4gKiBAY29kaW5nc3RhbmRhcmQgZnRsYWJzLWpzdjJcbiAqIEBjb3B5cmlnaHQgVGhlIEZpbmFuY2lhbCBUaW1lcyBMaW1pdGVkIFtBbGwgUmlnaHRzIFJlc2VydmVkXVxuICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcbiAqL1xudmFyIERlbGVnYXRlID0gcmVxdWlyZSgnLi9kZWxlZ2F0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJvb3QpIHtcbiAgcmV0dXJuIG5ldyBEZWxlZ2F0ZShyb290KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkRlbGVnYXRlID0gRGVsZWdhdGU7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmVcbiAgICA6ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhdGlvbi5wb3J0XG4gICAgICA/IGxvY2F0aW9uLnBvcnRcbiAgICAgIDogKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnRyYW5zcG9ydE9wdGlvbnMgPSBvcHRzLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG4gIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG4gIH1cblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSAhIW9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIGRldGVjdCBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudFxuICB0aGlzLmlzUmVhY3ROYXRpdmUgPSAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnKTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIG9yIFJlYWN0TmF0aXZlIGNsaWVudFxuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaXNSZWFjdE5hdGl2ZSkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLnRyYW5zcG9ydE9wdGlvbnNbbmFtZV0gfHwge307XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiBvcHRpb25zLmhvc3RuYW1lIHx8IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogb3B0aW9ucy5wb3J0IHx8IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGgsXG4gICAgZm9yY2VKU09OUDogb3B0aW9ucy5mb3JjZUpTT05QIHx8IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiBvcHRpb25zLmZvcmNlQmFzZTY0IHx8IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogb3B0aW9ucy5lbmFibGVzWERSIHx8IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiBvcHRpb25zLnRpbWVzdGFtcFBhcmFtIHx8IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogb3B0aW9ucy5wb2xpY3lQb3J0IHx8IHRoaXMucG9saWN5UG9ydCxcbiAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuICAgIGtleTogb3B0aW9ucy5rZXkgfHwgdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlIHx8IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuICAgIGNhOiBvcHRpb25zLmNhIHx8IHRoaXMuY2EsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzIHx8IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MgfHwgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5yZXF1ZXN0VGltZW91dCxcbiAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApLFxuICAgIGlzUmVhY3ROYXRpdmU6IHRoaXMuaXNSZWFjdE5hdGl2ZVxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG4gIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShKU09OLnBhcnNlKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UgKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlICgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gcmVzdWx0cyBvZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBkZXRlY3Rpb25cbiAgdGhpcy5pc1JlYWN0TmF0aXZlID0gb3B0cy5pc1JlYWN0TmF0aXZlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIFVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbCBpcyBzaGlwcGVkLlxuICovXG5mdW5jdGlvbiBnbG9iICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbn1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICB2YXIgZ2xvYmFsID0gZ2xvYigpO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW8gPSAoZ2xvYmFsLl9fX2VpbyB8fCBbXSk7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9IGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuIiwiLyogZ2xvYmFsIGF0dGFjaEV2ZW50ICovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lKSB8fFxuICAgICAgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgb3B0cy5yZXF1ZXN0VGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QgKG9wdHMpIHtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT09IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICcqLyonKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgIHhoci50aW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zdXBwb3J0c0JpbmFyeSAmJiBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBhdHRhY2hFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHRlcm1pbmF0aW9uRXZlbnQgPSAnb25wYWdlaGlkZScgaW4gc2VsZiA/ICdwYWdlaGlkZScgOiAndW5sb2FkJztcbiAgICBhZGRFdmVudExpc3RlbmVyKHRlcm1pbmF0aW9uRXZlbnQsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5cbi8qKlxuICogUG9sbGluZyBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG9uUGF1c2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSAoKSB7XG4gICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgIG9uUGF1c2UoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygncG9sbGluZycpO1xuICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICB0aGlzLmRvUG9sbCgpO1xuICB0aGlzLmVtaXQoJ3BvbGwnKTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAocGFja2V0LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgaWYgKCdvcGVuaW5nJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cbnZhciBCcm93c2VyV2ViU29ja2V0LCBOb2RlV2ViU29ja2V0O1xuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJvd3NlcldlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXJXZWJTb2NrZXQgPSBzZWxmLldlYlNvY2tldCB8fCBzZWxmLk1veldlYlNvY2tldDtcbn0gZWxzZSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldEltcGwgPSBCcm93c2VyV2ViU29ja2V0IHx8IE5vZGVXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPVxuICAgICAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgJiYgIXRoaXMuaXNSZWFjdE5hdGl2ZVxuICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgID8gbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgOiBuZXcgV2ViU29ja2V0SW1wbCh1cmkpXG4gICAgICAgIDogbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAoJ3dzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhV2ViU29ja2V0SW1wbCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldEltcGwgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBzZWxmW1snQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyldKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuICB9XG59O1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSksIHsgc3RyaWN0OiBmYWxzZSB9KSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldCh7IHR5cGU6IHBhY2tldC50eXBlLCBkYXRhOiBmci5yZXN1bHQgfSwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICBkYXRhID0gdHJ5RGVjb2RlKGRhdGEpO1xuICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbmZ1bmN0aW9uIHRyeURlY29kZShkYXRhKSB7XG4gIHRyeSB7XG4gICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghYmFzZTY0ZW5jb2Rlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJycsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKGNociAhPT0gJzonKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA9PT0gJycgfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cblxuICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoZXJyLnR5cGUgPT09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgaSArPSBuO1xuICAgIGxlbmd0aCA9ICcnO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAhPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09PSAyNTUpIGJyZWFrO1xuXG4gICAgICAvLyAzMTAgPSBjaGFyIGxlbmd0aCBvZiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblxudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHZhciB2YWx1ZTtcblx0dmFyIGV4dHJhO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciB2YWx1ZTtcblx0dmFyIG91dHB1dCA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdH1cblx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHR9XG5cdHZhciBzeW1ib2wgPSAnJztcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdH1cblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0cmV0dXJuIHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciBjb2RlUG9pbnQ7XG5cdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuXHR9XG5cdHJldHVybiBieXRlU3RyaW5nO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdH1cblxuXHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0dmFyIGJ5dGUxO1xuXHR2YXIgYnl0ZTI7XG5cdHZhciBieXRlMztcblx0dmFyIGJ5dGU0O1xuXHR2YXIgY29kZVBvaW50O1xuXG5cdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0cmV0dXJuIGJ5dGUxO1xuXHR9XG5cblx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcbn1cblxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdGJ5dGVJbmRleCA9IDA7XG5cdHZhciBjb2RlUG9pbnRzID0gW107XG5cdHZhciB0bXA7XG5cdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHR9XG5cdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dmVyc2lvbjogJzIuMS4yJyxcblx0ZW5jb2RlOiB1dGY4ZW5jb2RlLFxuXHRkZWNvZGU6IHV0ZjhkZWNvZGVcbn07XG4iLCJmdW5jdGlvbiBnZXRTY2FsZShkb21haW4sIHJhbmdlKSB7XG4gIGNvbnN0IHNsb3BlID0gKHJhbmdlWzFdIC0gcmFuZ2VbMF0pIC8gKGRvbWFpblsxXSAtIGRvbWFpblswXSk7XG4gIGNvbnN0IGludGVyY2VwdCA9IHJhbmdlWzBdIC0gc2xvcGUgKiBkb21haW5bMF07XG5cbiAgZnVuY3Rpb24gc2NhbGUodmFsKSB7XG4gICAgcmV0dXJuIHNsb3BlICogdmFsICsgaW50ZXJjZXB0O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh2YWwgLSBpbnRlcmNlcHQpIC8gc2xvcGU7XG4gIH1cblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGdldENsaXBwZXIobWluLCBtYXgsIHN0ZXApIHtcbiAgcmV0dXJuICh2YWwpID0+IHtcbiAgICBjb25zdCBjbGlwcGVkVmFsdWUgPSBNYXRoLnJvdW5kKHZhbCAvIHN0ZXApICogc3RlcDtcbiAgICBjb25zdCBmaXhlZCA9IE1hdGgubWF4KE1hdGgubG9nMTAoMSAvIHN0ZXApLCAwKTtcbiAgICBjb25zdCBmaXhlZFZhbHVlID0gY2xpcHBlZFZhbHVlLnRvRml4ZWQoZml4ZWQpOyAvLyBmaXggZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCBwYXJzZUZsb2F0KGZpeGVkVmFsdWUpKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAbW9kdWxlIGd1aS1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBWZXJzYXRpbGUgY2FudmFzIGJhc2VkIHNsaWRlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7J2p1bXAnfCdwcm9wb3J0aW9ubmFsJ3wnaGFuZGxlJ30gW29wdGlvbnMubW9kZT0nanVtcCddIC0gTW9kZSBvZiB0aGUgc2xpZGVyOlxuICogIC0gaW4gJ2p1bXAnIG1vZGUsIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIG9uICd0b3VjaHN0YXJ0JyBvciAnbW91c2Vkb3duJywgYW5kXG4gKiAgICBvbiBtb3ZlLlxuICogIC0gaW4gJ3Byb3BvcnRpb25uYWwnIG1vZGUsIHRoZSB2YWx1ZSBpcyB1cGRhdGVkIHJlbGF0aXZlbHkgdG8gbW92ZS5cbiAqICAtIGluICdoYW5kbGUnIG1vZGUsIHRoZSBzbGlkZXIgY2FuIGJlIGdyYWJiZWQgb25seSBhcm91bmQgaXRzIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdIC0gQ2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgdmFsdWVcbiAqICBvZiB0aGUgc2xpZGVyIGNoYW5nZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MjAwXSAtIFdpZHRoIG9mIHRoZSBzbGlkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTMwXSAtIEhlaWdodCBvZiB0aGUgc2xpZGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbj0wXSAtIE1pbmltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4PTFdIC0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdGVwPTAuMDFdIC0gU3RlcCBiZXR3ZWVuIGVhY2ggY29uc2VjdXRpdmUgdmFsdWVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlZmF1bHQ9MF0gLSBEZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gW29wdGlvbnMuY29udGFpbmVyPSdib2R5J10gLSBDU1MgU2VsZWN0b3Igb3IgRE9NXG4gKiAgZWxlbWVudCBpbiB3aGljaCBpbnNlcnRpbmcgdGhlIHNsaWRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I9JyM0NjQ2NDYnXSAtIEJhY2tncm91bmQgY29sb3Igb2YgdGhlXG4gKiAgc2xpZGVyLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcmVncm91bmRDb2xvcj0nc3RlZWxibHVlJ10gLSBGb3JlZ3JvdW5kIGNvbG9yIG9mXG4gKiAgdGhlIHNsaWRlci5cbiAqIEBwYXJhbSB7J2hvcml6b250YWwnfCd2ZXJ0aWNhbCd9IFtvcHRpb25zLm9yaWVudGF0aW9uPSdob3Jpem9udGFsJ10gLVxuICogIE9yaWVudGF0aW9uIG9mIHRoZSBzbGlkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tYXJrZXJzPVtdXSAtIExpc3Qgb2YgdmFsdWVzIHdoZXJlIG1hcmtlcnMgc2hvdWxkXG4gKiAgYmUgZGlzcGxheWVkIG9uIHRoZSBzbGlkZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNob3dIYW5kbGU9dHJ1ZV0gLSBJbiAnaGFuZGxlJyBtb2RlLCBkZWZpbmUgaWYgdGhlXG4gKiAgZHJhZ2dhYmxlIHNob3VsZCBiZSBzaG93IG9yIG5vdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oYW5kbGVTaXplPTIwXSAtIFNpemUgb2YgdGhlIGRyYWdnYWJsZSB6b25lLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhhbmRsZUNvbG9yPSdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknXSAtIENvbG9yIG9mIHRoZVxuICogIGRyYWdnYWJsZSB6b25lICh3aGVuIGBzaG93SGFuZGxlYCBpcyBgdHJ1ZWApLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBTbGlkZXJ9IGZyb20gJ2d1aS1jb21wb25lbnRzJztcbiAqXG4gKiBjb25zdCBzbGlkZXIgPSBuZXcgU2xpZGVyKHtcbiAqICAgbW9kZTogJ2p1bXAnLFxuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJyxcbiAqICAgZGVmYXVsdDogMC42LFxuICogICBtYXJrZXJzOiBbMC41XSxcbiAqICAgY2FsbGJhY2s6ICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogfSk7XG4gKi9cbmNsYXNzIFNsaWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIG1vZGU6ICdqdW1wJyxcbiAgICAgIGNhbGxiYWNrOiB2YWx1ZSA9PiB7fSxcbiAgICAgIHdpZHRoOiAyMDAsXG4gICAgICBoZWlnaHQ6IDMwLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgc3RlcDogMC4wMSxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICBjb250YWluZXI6ICdib2R5JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0NjQ2NDYnLFxuICAgICAgZm9yZWdyb3VuZENvbG9yOiAnc3RlZWxibHVlJyxcbiAgICAgIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICBtYXJrZXJzOiBbXSxcblxuICAgICAgLy8gaGFuZGxlIHNwZWNpZmljIG9wdGlvbnNcbiAgICAgIHNob3dIYW5kbGU6IHRydWUsXG4gICAgICBoYW5kbGVTaXplOiAyMCxcbiAgICAgIGhhbmRsZUNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICB9O1xuXG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fYm91bmRpbmdDbGllbnRSZWN0ID0gbnVsbDtcbiAgICB0aGlzLl90b3VjaElkID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSBudWxsO1xuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IG51bGw7XG4gICAgLy8gZm9yIHByb3BvcnRpb25uYWwgbW9kZVxuICAgIHRoaXMuX2N1cnJlbnRNb3VzZVBvc2l0aW9uID0geyB4OiBudWxsLCB5OiBudWxsIH07XG4gICAgdGhpcy5fY3VycmVudFNsaWRlclBvc2l0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuX29uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3VzZVVwID0gdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vblRvdWNoU3RhcnQgPSB0aGlzLl9vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblRvdWNoTW92ZSA9IHRoaXMuX29uVG91Y2hNb3ZlIC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVG91Y2hFbmQgPSB0aGlzLl9vblRvdWNoRW5kLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG5cblxuICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnQoKTtcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB0aGlzLl9yZXNpemVFbGVtZW50KCk7XG4gICAgdGhpcy5fc2V0U2NhbGVzKCk7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHRoaXMuX29uUmVzaXplKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUodGhpcy5wYXJhbXMuZGVmYXVsdCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgLy8gZG9uJ3QgdHJpZ2dlciB0aGUgY2FsbGJhY2sgd2hlbiB2YWx1ZSBpcyBzZXQgZnJvbSBvdXRzaWRlXG4gICAgdGhpcy5fdXBkYXRlVmFsdWUodmFsLCB0cnVlLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIHNsaWRlciB0byBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKHRoaXMucGFyYW1zLmRlZmF1bHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgc2xpZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBOZXcgd2lkdGggb2YgdGhlIHNsaWRlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIE5ldyBoZWlnaHQgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5wYXJhbXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnBhcmFtcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLl9yZXNpemVFbGVtZW50KCk7XG4gICAgdGhpcy5fc2V0U2NhbGVzKCk7XG4gICAgdGhpcy5fb25SZXNpemUoKTtcbiAgICB0aGlzLl91cGRhdGVWYWx1ZSh0aGlzLl92YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBfdXBkYXRlVmFsdWUodmFsdWUsIHNpbGVudCA9IGZhbHNlLCBmb3JjZVJlbmRlciA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjayB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY2xpcHBlZFZhbHVlID0gdGhpcy5jbGlwcGVyKHZhbHVlKTtcblxuICAgIC8vIHJlc2l6ZSByZW5kZXIgYnV0IGRvbid0IHRyaWdnZXIgY2FsbGJhY2tcbiAgICBpZiAoY2xpcHBlZFZhbHVlID09PSB0aGlzLl92YWx1ZSAmJiBmb3JjZVJlbmRlciA9PT0gdHJ1ZSlcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLl9yZW5kZXIoY2xpcHBlZFZhbHVlKSk7XG5cbiAgICAvLyB0cmlnZ2VyIGNhbGxiYWNrXG4gICAgaWYgKGNsaXBwZWRWYWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gY2xpcHBlZFZhbHVlO1xuXG4gICAgICBpZiAoIXNpbGVudClcbiAgICAgICAgY2FsbGJhY2soY2xpcHBlZFZhbHVlKTtcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX3JlbmRlcihjbGlwcGVkVmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlRWxlbWVudCgpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5wYXJhbXM7XG4gICAgdGhpcy4kY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5jdHggPSB0aGlzLiRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KVxuICAgICAgdGhpcy4kY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuJGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcblxuICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRjYW52YXMpO1xuICB9XG5cbiAgX3Jlc2l6ZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnBhcmFtcztcblxuICAgIC8vIGxvZ2ljYWwgYW5kIHBpeGVsIHNpemUgb2YgdGhlIGNhbnZhc1xuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSAoZnVuY3Rpb24oY3R4KSB7XG4gICAgY29uc3QgZFBSID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICBjb25zdCBiUFIgPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgcmV0dXJuIGRQUiAvIGJQUjtcbiAgICB9KHRoaXMuY3R4KSk7XG5cbiAgICB0aGlzLl9jYW52YXNXaWR0aCA9IHdpZHRoICogdGhpcy5fcGl4ZWxSYXRpbztcbiAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSBoZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvO1xuXG4gICAgdGhpcy5jdHguY2FudmFzLndpZHRoID0gdGhpcy5fY2FudmFzV2lkdGg7XG4gICAgdGhpcy5jdHguY2FudmFzLmhlaWdodCA9IHRoaXMuX2NhbnZhc0hlaWdodDtcbiAgICB0aGlzLmN0eC5jYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgdGhpcy5jdHguY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gIH1cblxuICBfb25SZXNpemUoKSB7XG4gICAgdGhpcy5fYm91bmRpbmdDbGllbnRSZWN0ID0gdGhpcy4kY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgX3NldFNjYWxlcygpIHtcbiAgICBjb25zdCB7IG9yaWVudGF0aW9uLCB3aWR0aCwgaGVpZ2h0LCBtaW4sIG1heCwgc3RlcCB9ID0gdGhpcy5wYXJhbXM7XG4gICAgLy8gZGVmaW5lIHRyYW5zZmVydCBmdW5jdGlvbnNcbiAgICBjb25zdCBzY3JlZW5TaXplID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICB3aWR0aCA6IGhlaWdodDtcblxuICAgIGNvbnN0IGNhbnZhc1NpemUgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgIHRoaXMuX2NhbnZhc1dpZHRoIDogdGhpcy5fY2FudmFzSGVpZ2h0O1xuXG4gICAgY29uc3QgZG9tYWluID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IFttaW4sIG1heF0gOiBbbWF4LCBtaW5dO1xuICAgIGNvbnN0IHNjcmVlblJhbmdlID0gWzAsIHNjcmVlblNpemVdO1xuICAgIGNvbnN0IGNhbnZhc1JhbmdlID0gWzAsIGNhbnZhc1NpemVdO1xuXG4gICAgdGhpcy5zY3JlZW5TY2FsZSA9IGdldFNjYWxlKGRvbWFpbiwgc2NyZWVuUmFuZ2UpO1xuICAgIHRoaXMuY2FudmFzU2NhbGUgPSBnZXRTY2FsZShkb21haW4sIGNhbnZhc1JhbmdlKTtcbiAgICB0aGlzLmNsaXBwZXIgPSBnZXRDbGlwcGVyKG1pbiwgbWF4LCBzdGVwKTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgdGhpcy4kY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQpO1xuICB9XG5cbiAgX29uU3RhcnQoeCwgeSkge1xuICAgIGxldCBzdGFydGVkID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGhpcy5wYXJhbXMubW9kZSkge1xuICAgICAgY2FzZSAnanVtcCc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHgsIHkpO1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwcm9wb3J0aW9ubmFsJzpcbiAgICAgICAgdGhpcy5fY3VycmVudE1vdXNlUG9zaXRpb24ueCA9IHg7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRNb3VzZVBvc2l0aW9uLnkgPSB5O1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdoYW5kbGUnOlxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMucGFyYW1zLm9yaWVudGF0aW9uO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuc2NyZWVuU2NhbGUodGhpcy5fdmFsdWUpO1xuICAgICAgICBjb25zdCBjb21wYXJlID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IHggOiB5O1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMucGFyYW1zLmhhbmRsZVNpemUgLyAyO1xuXG4gICAgICAgIGlmIChjb21wYXJlIDwgcG9zaXRpb24gKyBkZWx0YSAmJiBjb21wYXJlID4gcG9zaXRpb24gLSBkZWx0YSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRNb3VzZVBvc2l0aW9uLnggPSB4O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRNb3VzZVBvc2l0aW9uLnkgPSB5O1xuICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhcnRlZDtcbiAgfVxuXG4gIF9vbk1vdmUoeCwgeSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJhbXMubW9kZSkge1xuICAgICAgY2FzZSAnanVtcCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHJvcG9ydGlvbm5hbCc6XG4gICAgICBjYXNlICdoYW5kbGUnOlxuICAgICAgICBjb25zdCBkZWx0YVggPSB4IC0gdGhpcy5fY3VycmVudE1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgZGVsdGFZID0geSAtIHRoaXMuX2N1cnJlbnRNb3VzZVBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRNb3VzZVBvc2l0aW9uLnggPSB4O1xuICAgICAgICB0aGlzLl9jdXJyZW50TW91c2VQb3NpdGlvbi55ID0geTtcblxuICAgICAgICB4ID0gdGhpcy5zY3JlZW5TY2FsZSh0aGlzLl92YWx1ZSkgKyBkZWx0YVg7XG4gICAgICAgIHkgPSB0aGlzLnNjcmVlblNjYWxlKHRoaXMuX3ZhbHVlKSArIGRlbHRhWTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oeCwgeSk7XG4gIH1cblxuICBfb25FbmQoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmFtcy5tb2RlKSB7XG4gICAgICBjYXNlICdqdW1wJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwcm9wb3J0aW9ubmFsJzpcbiAgICAgIGNhc2UgJ2hhbmRsZSc6XG4gICAgICAgIHRoaXMuX2N1cnJlbnRNb3VzZVBvc2l0aW9uLnggPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50TW91c2VQb3NpdGlvbi55ID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gbW91c2UgZXZlbnRzXG4gIF9vbk1vdXNlRG93bihlKSB7XG4gICAgY29uc3QgcGFnZVggPSBlLnBhZ2VYO1xuICAgIGNvbnN0IHBhZ2VZID0gZS5wYWdlWTtcbiAgICBjb25zdCB4ID0gcGFnZVggLSB0aGlzLl9ib3VuZGluZ0NsaWVudFJlY3QubGVmdDtcbiAgICBjb25zdCB5ID0gcGFnZVkgLSB0aGlzLl9ib3VuZGluZ0NsaWVudFJlY3QudG9wO1xuXG4gICAgaWYgKHRoaXMuX29uU3RhcnQoeCwgeSkgPT09IHRydWUpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgfVxuICB9XG5cbiAgX29uTW91c2VNb3ZlKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgdGV4dCBzZWxlY3Rpb25cblxuICAgIGNvbnN0IHBhZ2VYID0gZS5wYWdlWDtcbiAgICBjb25zdCBwYWdlWSA9IGUucGFnZVk7XG4gICAgbGV0IHggPSBwYWdlWCAtIHRoaXMuX2JvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0OztcbiAgICBsZXQgeSA9IHBhZ2VZIC0gdGhpcy5fYm91bmRpbmdDbGllbnRSZWN0LnRvcDs7XG5cbiAgICB0aGlzLl9vbk1vdmUoeCwgeSk7XG4gIH1cblxuICBfb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLl9vbkVuZCgpO1xuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gIH1cblxuICAvLyB0b3VjaCBldmVudHNcbiAgX29uVG91Y2hTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuX3RvdWNoSWQgIT09IG51bGwpIHJldHVybjtcblxuICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgIHRoaXMuX3RvdWNoSWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG4gICAgY29uc3QgcGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICBjb25zdCBwYWdlWSA9IHRvdWNoLnBhZ2VZO1xuICAgIGNvbnN0IHggPSBwYWdlWCAtIHRoaXMuX2JvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0O1xuICAgIGNvbnN0IHkgPSBwYWdlWSAtIHRoaXMuX2JvdW5kaW5nQ2xpZW50UmVjdC50b3A7XG5cbiAgICBpZiAodGhpcy5fb25TdGFydCh4LCB5KSA9PT0gdHJ1ZSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgfVxuICB9XG5cbiAgX29uVG91Y2hNb3ZlKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgdGV4dCBzZWxlY3Rpb25cblxuICAgIGNvbnN0IHRvdWNoZXMgPSBBcnJheS5mcm9tKGUudG91Y2hlcyk7XG4gICAgY29uc3QgdG91Y2ggPSB0b3VjaGVzLmZpbHRlcigodCkgPT4gdC5pZGVudGlmaWVyID09PSB0aGlzLl90b3VjaElkKVswXTtcblxuICAgIGlmICh0b3VjaCkge1xuICAgICAgY29uc3QgcGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgIGNvbnN0IHBhZ2VZID0gdG91Y2gucGFnZVk7XG4gICAgICBjb25zdCB4ID0gcGFnZVggLSB0aGlzLl9ib3VuZGluZ0NsaWVudFJlY3QubGVmdDtcbiAgICAgIGNvbnN0IHkgPSBwYWdlWSAtIHRoaXMuX2JvdW5kaW5nQ2xpZW50UmVjdC50b3A7XG5cbiAgICAgIHRoaXMuX29uTW92ZSh4LCB5KTtcbiAgICB9XG4gIH1cblxuICBfb25Ub3VjaEVuZChlKSB7XG4gICAgY29uc3QgdG91Y2hlcyA9IEFycmF5LmZyb20oZS50b3VjaGVzKTtcbiAgICBjb25zdCB0b3VjaCA9IHRvdWNoZXMuZmlsdGVyKCh0KSA9PiB0LmlkZW50aWZpZXIgPT09IHRoaXMuX3RvdWNoSWQpWzBdO1xuXG4gICAgaWYgKHRvdWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX29uRW5kKCk7XG4gICAgICB0aGlzLl90b3VjaElkID0gbnVsbDtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oeCwgeSkge1xuICAgIGNvbnN0IHvCoG9yaWVudGF0aW9uLCBoZWlnaHQgfSA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IHggOiB5O1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zY3JlZW5TY2FsZS5pbnZlcnQocG9zaXRpb24pO1xuXG4gICAgdGhpcy5fdXBkYXRlVmFsdWUodmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW5kZXIoY2xpcHBlZFZhbHVlKSB7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kQ29sb3IsIGZvcmVncm91bmRDb2xvciwgb3JpZW50YXRpb24gfSA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNhbnZhc1Bvc2l0aW9uID0gTWF0aC5yb3VuZCh0aGlzLmNhbnZhc1NjYWxlKGNsaXBwZWRWYWx1ZSkpO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fY2FudmFzV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5fY2FudmFzSGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgLy8gYmFja2dyb3VuZFxuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgLy8gZm9yZWdyb3VuZFxuICAgIGN0eC5maWxsU3R5bGUgPSBmb3JlZ3JvdW5kQ29sb3I7XG5cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJylcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNQb3NpdGlvbiwgaGVpZ2h0KTtcbiAgICBlbHNlXG4gICAgICBjdHguZmlsbFJlY3QoMCwgY2FudmFzUG9zaXRpb24sIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgLy8gbWFya2Vyc1xuICAgIGNvbnN0IG1hcmtlcnMgPSB0aGlzLnBhcmFtcy5tYXJrZXJzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJzW2ldO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmNhbnZhc1NjYWxlKG1hcmtlcik7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb3NpdGlvbiAtIDAuNSwgMSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24gLSAwLjUsIGhlaWdodCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbygxLCBoZWlnaHQgLSBwb3NpdGlvbiArIDAuNSk7XG4gICAgICAgIGN0eC5saW5lVG8od2lkdGggLSAxLCBoZWlnaHQgLSBwb3NpdGlvbiArIDAuNSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgbW9kZVxuICAgIGlmICh0aGlzLnBhcmFtcy5tb2RlID09PSAnaGFuZGxlJyAmJiB0aGlzLnBhcmFtcy5zaG93SGFuZGxlKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHRoaXMucGFyYW1zLmhhbmRsZVNpemUgKiB0aGlzLl9waXhlbFJhdGlvIC8gMjtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gY2FudmFzUG9zaXRpb24gLSBkZWx0YTtcbiAgICAgIGNvbnN0IGVuZCA9IGNhbnZhc1Bvc2l0aW9uICsgZGVsdGE7XG5cbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wYXJhbXMuaGFuZGxlQ29sb3I7XG5cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIGN0eC5maWxsUmVjdChzdGFydCwgMCwgZW5kIC0gc3RhcnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgc3RhcnQsIHdpZHRoLCBlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTbGlkZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgZ3VpLWNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTbGlkZXIgfSBmcm9tICcuL1NsaWRlcic7XG4iLCIvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAodHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIi8qKlxuICogbG9kYXNoIDMuMC4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS43LjAgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlSW50ZXJwb2xhdGU7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciByZUludGVycG9sYXRlID0gcmVxdWlyZSgnbG9kYXNoLl9yZWludGVycG9sYXRlJyksXG4gICAgdGVtcGxhdGVTZXR0aW5ncyA9IHJlcXVpcmUoJ2xvZGFzaC50ZW1wbGF0ZXNldHRpbmdzJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaFxuICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAqL1xudmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4vKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkluRGVmYXVsdHMob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgPyBzb3VyY2Vba2V5XSA6IG5ld1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBlcnJvclRhZykgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gKlxuICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J3RlbXBsYXRlU291cmNlc1tuXSddXG4gKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICpcbiAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICpcbiAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gKlxuICogLy8gVXNlIHRoZSBFUyBkZWxpbWl0ZXIgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIGRlZmF1bHQgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gKlxuICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAqIGNvbXBpbGVkKGRhdGEpO1xuICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAqXG4gKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAqIGNvbXBpbGVkLnNvdXJjZTtcbiAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAqIC8vICAgcmV0dXJuIF9fcDtcbiAqIC8vIH1cbiAqXG4gKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAqICAgdmFyIEpTVCA9IHtcXFxuICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gKiAgIH07XFxcbiAqICcpO1xuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgdmFyIHNldHRpbmdzID0gdGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzLl8udGVtcGxhdGVTZXR0aW5ncyB8fCB0ZW1wbGF0ZVNldHRpbmdzO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGFzc2lnbkluRGVmYXVsdHMpO1xuXG4gIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGFzc2lnbkluRGVmYXVsdHMpLFxuICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gIHZhciBpc0VzY2FwaW5nLFxuICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgLCAnZycpO1xuXG4gIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgdmFyIHNvdXJjZVVSTCA9ICdzb3VyY2VVUkwnIGluIG9wdGlvbnMgPyAnLy8jIHNvdXJjZVVSTD0nICsgb3B0aW9ucy5zb3VyY2VVUkwgKyAnXFxuJyA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gIH1cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciByZUludGVycG9sYXRlID0gcmVxdWlyZSgnbG9kYXNoLl9yZWludGVycG9sYXRlJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInYF0vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJ2AnOiAnJiM5NjsnXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlXG4gKiBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBcIidcIiwgYW5kIFwiXFxgXCIgaW4gYHN0cmluZ2AgdG9cbiAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBCYWNrdGlja3MgYXJlIGVzY2FwZWQgYmVjYXVzZSBpbiBJRSA8IDksIHRoZXkgY2FuIGJyZWFrIG91dCBvZlxuICogYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyM1OV0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzU5KSxcbiAqIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSwgWyMxMDhdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDgpLCBhbmRcbiAqIFsjMTMzXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTMzKSBvZiB0aGVcbiAqIFtIVE1MNSBTZWN1cml0eSBDaGVhdHNoZWV0XShodHRwczovL2h0bWw1c2VjLm9yZy8pIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGVTZXR0aW5ncztcbiIsIi8vIFRISVMgRklMRSBJUyBHRU5FUkFURUQgLSBETyBOT1QgRURJVCFcbi8qIW1vYmlsZS1kZXRlY3QgdjEuNC4zIDIwMTgtMDktMDgqL1xuLypnbG9iYWwgbW9kdWxlOmZhbHNlLCBkZWZpbmU6ZmFsc2UqL1xuLypqc2hpbnQgbGF0ZWRlZjpmYWxzZSovXG4vKiFAbGljZW5zZSBDb3B5cmlnaHQgMjAxMywgSGVpbnJpY2ggR29lYmwsIExpY2Vuc2U6IE1JVCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oZ29lYmwvbW9iaWxlLWRldGVjdC5qcyovXG4oZnVuY3Rpb24gKGRlZmluZSwgdW5kZWZpbmVkKSB7XG5kZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBpbXBsID0ge307XG5cbiAgICBpbXBsLm1vYmlsZURldGVjdFJ1bGVzID0ge1xuICAgIFwicGhvbmVzXCI6IHtcbiAgICAgICAgXCJpUGhvbmVcIjogXCJcXFxcYmlQaG9uZVxcXFxifFxcXFxiaVBvZFxcXFxiXCIsXG4gICAgICAgIFwiQmxhY2tCZXJyeVwiOiBcIkJsYWNrQmVycnl8XFxcXGJCQjEwXFxcXGJ8cmltWzAtOV0rXCIsXG4gICAgICAgIFwiSFRDXCI6IFwiSFRDfEhUQy4qKFNlbnNhdGlvbnxFdm98VmlzaW9ufEV4cGxvcmVyfDY4MDB8ODEwMHw4OTAwfEE3MjcyfFM1MTBlfEMxMTBlfExlZ2VuZHxEZXNpcmV8VDgyODIpfEFQWDUxNUNLVHxRdGVrOTA5MHxBUEE5MjkyS1R8SERfbWluaXxTZW5zYXRpb24uKlo3MTBlfFBHODYxMDB8WjcxNWV8RGVzaXJlLiooQTgxODF8SEQpfEFEUjYyMDB8QURSNjQwMEx8QURSNjQyNXwwMDFIVHxJbnNwaXJlIDRHfEFuZHJvaWQuKlxcXFxiRVZPXFxcXGJ8VC1Nb2JpbGUgRzF8WjUyMG18QW5kcm9pZCBbMC05Ll0rOyBQaXhlbFwiLFxuICAgICAgICBcIk5leHVzXCI6IFwiTmV4dXMgT25lfE5leHVzIFN8R2FsYXh5LipOZXh1c3xBbmRyb2lkLipOZXh1cy4qTW9iaWxlfE5leHVzIDR8TmV4dXMgNXxOZXh1cyA2XCIsXG4gICAgICAgIFwiRGVsbFwiOiBcIkRlbGxbO10/IChTdHJlYWt8QWVyb3xWZW51ZXxWZW51ZSBQcm98Rmxhc2h8U21va2V8TWluaSAzaVgpfFhDRDI4fFhDRDM1fFxcXFxiMDAxRExcXFxcYnxcXFxcYjEwMURMXFxcXGJ8XFxcXGJHUzAxXFxcXGJcIixcbiAgICAgICAgXCJNb3Rvcm9sYVwiOiBcIk1vdG9yb2xhfERST0lEWHxEUk9JRCBCSU9OSUN8XFxcXGJEcm9pZFxcXFxiLipCdWlsZHxBbmRyb2lkLipYb29tfEhSSTM5fE1PVC18QTEyNjB8QTE2ODB8QTU1NXxBODUzfEE4NTV8QTk1M3xBOTU1fEE5NTZ8TW90b3JvbGEuKkVMRUNUUklGWXxNb3Rvcm9sYS4qaTF8aTg2N3xpOTQwfE1CMjAwfE1CMzAwfE1CNTAxfE1CNTAyfE1CNTA4fE1CNTExfE1CNTIwfE1CNTI1fE1CNTI2fE1CNjExfE1CNjEyfE1CNjMyfE1CODEwfE1CODU1fE1CODYwfE1CODYxfE1CODY1fE1CODcwfE1FNTAxfE1FNTAyfE1FNTExfE1FNTI1fE1FNjAwfE1FNjMyfE1FNzIyfE1FODExfE1FODYwfE1FODYzfE1FODY1fE1UNjIwfE1UNzEwfE1UNzE2fE1UNzIwfE1UODEwfE1UODcwfE1UOTE3fE1vdG9yb2xhLipUSVRBTklVTXxXWDQzNXxXWDQ0NXxYVDMwMHxYVDMwMXxYVDMxMXxYVDMxNnxYVDMxN3xYVDMxOXxYVDMyMHxYVDM5MHxYVDUwMnxYVDUzMHxYVDUzMXxYVDUzMnxYVDUzNXxYVDYwM3xYVDYxMHxYVDYxMXxYVDYxNXxYVDY4MXxYVDcwMXxYVDcwMnxYVDcxMXxYVDcyMHxYVDgwMHxYVDgwNnxYVDg2MHxYVDg2MnxYVDg3NXxYVDg4MnxYVDg4M3xYVDg5NHxYVDkwMXxYVDkwN3xYVDkwOXxYVDkxMHxYVDkxMnxYVDkyOHxYVDkyNnxYVDkxNXxYVDkxOXxYVDkyNXxYVDEwMjF8XFxcXGJNb3RvIEVcXFxcYnxYVDEwNjh8WFQxMDkyfFhUMTA1MlwiLFxuICAgICAgICBcIlNhbXN1bmdcIjogXCJcXFxcYlNhbXN1bmdcXFxcYnxTTS1HOTUwRnxTTS1HOTU1RnxTTS1HOTI1MHxHVC0xOTMwMHxTR0gtSTMzN3xCR1QtUzUyMzB8R1QtQjIxMDB8R1QtQjI3MDB8R1QtQjI3MTB8R1QtQjMyMTB8R1QtQjMzMTB8R1QtQjM0MTB8R1QtQjM3MzB8R1QtQjM3NDB8R1QtQjU1MTB8R1QtQjU1MTJ8R1QtQjU3MjJ8R1QtQjY1MjB8R1QtQjczMDB8R1QtQjczMjB8R1QtQjczMzB8R1QtQjczNTB8R1QtQjc1MTB8R1QtQjc3MjJ8R1QtQjc4MDB8R1QtQzMwMTB8R1QtQzMwMTF8R1QtQzMwNjB8R1QtQzMyMDB8R1QtQzMyMTJ8R1QtQzMyMTJJfEdULUMzMjYyfEdULUMzMjIyfEdULUMzMzAwfEdULUMzMzAwS3xHVC1DMzMwM3xHVC1DMzMwM0t8R1QtQzMzMTB8R1QtQzMzMjJ8R1QtQzMzMzB8R1QtQzMzNTB8R1QtQzM1MDB8R1QtQzM1MTB8R1QtQzM1MzB8R1QtQzM2MzB8R1QtQzM3ODB8R1QtQzUwMTB8R1QtQzUyMTJ8R1QtQzY2MjB8R1QtQzY2MjV8R1QtQzY3MTJ8R1QtRTEwNTB8R1QtRTEwNzB8R1QtRTEwNzV8R1QtRTEwODB8R1QtRTEwODF8R1QtRTEwODV8R1QtRTEwODd8R1QtRTExMDB8R1QtRTExMDd8R1QtRTExMTB8R1QtRTExMjB8R1QtRTExMjV8R1QtRTExMzB8R1QtRTExNjB8R1QtRTExNzB8R1QtRTExNzV8R1QtRTExODB8R1QtRTExODJ8R1QtRTEyMDB8R1QtRTEyMTB8R1QtRTEyMjV8R1QtRTEyMzB8R1QtRTEzOTB8R1QtRTIxMDB8R1QtRTIxMjB8R1QtRTIxMjF8R1QtRTIxNTJ8R1QtRTIyMjB8R1QtRTIyMjJ8R1QtRTIyMzB8R1QtRTIyMzJ8R1QtRTIyNTB8R1QtRTIzNzB8R1QtRTI1NTB8R1QtRTI2NTJ8R1QtRTMyMTB8R1QtRTMyMTN8R1QtSTU1MDB8R1QtSTU1MDN8R1QtSTU3MDB8R1QtSTU4MDB8R1QtSTU4MDF8R1QtSTY0MTB8R1QtSTY0MjB8R1QtSTcxMTB8R1QtSTc0MTB8R1QtSTc1MDB8R1QtSTgwMDB8R1QtSTgxNTB8R1QtSTgxNjB8R1QtSTgxOTB8R1QtSTgzMjB8R1QtSTgzMzB8R1QtSTgzNTB8R1QtSTg1MzB8R1QtSTg3MDB8R1QtSTg3MDN8R1QtSTg5MTB8R1QtSTkwMDB8R1QtSTkwMDF8R1QtSTkwMDN8R1QtSTkwMTB8R1QtSTkwMjB8R1QtSTkwMjN8R1QtSTkwNzB8R1QtSTkwODJ8R1QtSTkxMDB8R1QtSTkxMDN8R1QtSTkyMjB8R1QtSTkyNTB8R1QtSTkzMDB8R1QtSTkzMDV8R1QtSTk1MDB8R1QtSTk1MDV8R1QtTTM1MTB8R1QtTTU2NTB8R1QtTTc1MDB8R1QtTTc2MDB8R1QtTTc2MDN8R1QtTTg4MDB8R1QtTTg5MTB8R1QtTjcwMDB8R1QtUzMxMTB8R1QtUzMzMTB8R1QtUzMzNTB8R1QtUzMzNTN8R1QtUzMzNzB8R1QtUzM2NTB8R1QtUzM2NTN8R1QtUzM3NzB8R1QtUzM4NTB8R1QtUzUyMTB8R1QtUzUyMjB8R1QtUzUyMjl8R1QtUzUyMzB8R1QtUzUyMzN8R1QtUzUyNTB8R1QtUzUyNTN8R1QtUzUyNjB8R1QtUzUyNjN8R1QtUzUyNzB8R1QtUzUzMDB8R1QtUzUzMzB8R1QtUzUzNTB8R1QtUzUzNjB8R1QtUzUzNjN8R1QtUzUzNjl8R1QtUzUzODB8R1QtUzUzODBEfEdULVM1NTYwfEdULVM1NTcwfEdULVM1NjAwfEdULVM1NjAzfEdULVM1NjEwfEdULVM1NjIwfEdULVM1NjYwfEdULVM1NjcwfEdULVM1NjkwfEdULVM1NzUwfEdULVM1NzgwfEdULVM1ODMwfEdULVM1ODM5fEdULVM2MTAyfEdULVM2NTAwfEdULVM3MDcwfEdULVM3MjAwfEdULVM3MjIwfEdULVM3MjMwfEdULVM3MjMzfEdULVM3MjUwfEdULVM3NTAwfEdULVM3NTMwfEdULVM3NTUwfEdULVM3NTYyfEdULVM3NzEwfEdULVM4MDAwfEdULVM4MDAzfEdULVM4NTAwfEdULVM4NTMwfEdULVM4NjAwfFNDSC1BMzEwfFNDSC1BNTMwfFNDSC1BNTcwfFNDSC1BNjEwfFNDSC1BNjMwfFNDSC1BNjUwfFNDSC1BNzkwfFNDSC1BNzk1fFNDSC1BODUwfFNDSC1BODcwfFNDSC1BODkwfFNDSC1BOTMwfFNDSC1BOTUwfFNDSC1BOTcwfFNDSC1BOTkwfFNDSC1JMTAwfFNDSC1JMTEwfFNDSC1JNDAwfFNDSC1JNDA1fFNDSC1JNTAwfFNDSC1JNTEwfFNDSC1JNTE1fFNDSC1JNjAwfFNDSC1JNzMwfFNDSC1JNzYwfFNDSC1JNzcwfFNDSC1JODMwfFNDSC1JOTEwfFNDSC1JOTIwfFNDSC1JOTU5fFNDSC1MQzExfFNDSC1OMTUwfFNDSC1OMzAwfFNDSC1SMTAwfFNDSC1SMzAwfFNDSC1SMzUxfFNDSC1SNDAwfFNDSC1SNDEwfFNDSC1UMzAwfFNDSC1VMzEwfFNDSC1VMzIwfFNDSC1VMzUwfFNDSC1VMzYwfFNDSC1VMzY1fFNDSC1VMzcwfFNDSC1VMzgwfFNDSC1VNDEwfFNDSC1VNDMwfFNDSC1VNDUwfFNDSC1VNDYwfFNDSC1VNDcwfFNDSC1VNDkwfFNDSC1VNTQwfFNDSC1VNTUwfFNDSC1VNjIwfFNDSC1VNjQwfFNDSC1VNjUwfFNDSC1VNjYwfFNDSC1VNzAwfFNDSC1VNzQwfFNDSC1VNzUwfFNDSC1VODEwfFNDSC1VODIwfFNDSC1VOTAwfFNDSC1VOTQwfFNDSC1VOTYwfFNDUy0yNlVDfFNHSC1BMTA3fFNHSC1BMTE3fFNHSC1BMTI3fFNHSC1BMTM3fFNHSC1BMTU3fFNHSC1BMTY3fFNHSC1BMTc3fFNHSC1BMTg3fFNHSC1BMTk3fFNHSC1BMjI3fFNHSC1BMjM3fFNHSC1BMjU3fFNHSC1BNDM3fFNHSC1BNTE3fFNHSC1BNTk3fFNHSC1BNjM3fFNHSC1BNjU3fFNHSC1BNjY3fFNHSC1BNjg3fFNHSC1BNjk3fFNHSC1BNzA3fFNHSC1BNzE3fFNHSC1BNzI3fFNHSC1BNzM3fFNHSC1BNzQ3fFNHSC1BNzY3fFNHSC1BNzc3fFNHSC1BNzk3fFNHSC1BODE3fFNHSC1BODI3fFNHSC1BODM3fFNHSC1BODQ3fFNHSC1BODY3fFNHSC1BODc3fFNHSC1BODg3fFNHSC1BODk3fFNHSC1BOTI3fFNHSC1CMTAwfFNHSC1CMTMwfFNHSC1CMjAwfFNHSC1CMjIwfFNHSC1DMTAwfFNHSC1DMTEwfFNHSC1DMTIwfFNHSC1DMTMwfFNHSC1DMTQwfFNHSC1DMTYwfFNHSC1DMTcwfFNHSC1DMTgwfFNHSC1DMjAwfFNHSC1DMjA3fFNHSC1DMjEwfFNHSC1DMjI1fFNHSC1DMjMwfFNHSC1DNDE3fFNHSC1DNDUwfFNHSC1EMzA3fFNHSC1EMzQ3fFNHSC1EMzU3fFNHSC1ENDA3fFNHSC1ENDE1fFNHSC1ENzgwfFNHSC1EODA3fFNHSC1EOTgwfFNHSC1FMTA1fFNHSC1FMjAwfFNHSC1FMzE1fFNHSC1FMzE2fFNHSC1FMzE3fFNHSC1FMzM1fFNHSC1FNTkwfFNHSC1FNjM1fFNHSC1FNzE1fFNHSC1FODkwfFNHSC1GMzAwfFNHSC1GNDgwfFNHSC1JMjAwfFNHSC1JMzAwfFNHSC1JMzIwfFNHSC1JNTUwfFNHSC1JNTc3fFNHSC1JNjAwfFNHSC1JNjA3fFNHSC1JNjE3fFNHSC1JNjI3fFNHSC1JNjM3fFNHSC1JNjc3fFNHSC1JNzAwfFNHSC1JNzE3fFNHSC1JNzI3fFNHSC1pNzQ3TXxTR0gtSTc3N3xTR0gtSTc4MHxTR0gtSTgyN3xTR0gtSTg0N3xTR0gtSTg1N3xTR0gtSTg5NnxTR0gtSTg5N3xTR0gtSTkwMHxTR0gtSTkwN3xTR0gtSTkxN3xTR0gtSTkyN3xTR0gtSTkzN3xTR0gtSTk5N3xTR0gtSjE1MHxTR0gtSjIwMHxTR0gtTDE3MHxTR0gtTDcwMHxTR0gtTTExMHxTR0gtTTE1MHxTR0gtTTIwMHxTR0gtTjEwNXxTR0gtTjUwMHxTR0gtTjYwMHxTR0gtTjYyMHxTR0gtTjYyNXxTR0gtTjcwMHxTR0gtTjcxMHxTR0gtUDEwN3xTR0gtUDIwN3xTR0gtUDMwMHxTR0gtUDMxMHxTR0gtUDUyMHxTR0gtUDczNXxTR0gtUDc3N3xTR0gtUTEwNXxTR0gtUjIxMHxTR0gtUjIyMHxTR0gtUjIyNXxTR0gtUzEwNXxTR0gtUzMwN3xTR0gtVDEwOXxTR0gtVDExOXxTR0gtVDEzOXxTR0gtVDIwOXxTR0gtVDIxOXxTR0gtVDIyOXxTR0gtVDIzOXxTR0gtVDI0OXxTR0gtVDI1OXxTR0gtVDMwOXxTR0gtVDMxOXxTR0gtVDMyOXxTR0gtVDMzOXxTR0gtVDM0OXxTR0gtVDM1OXxTR0gtVDM2OXxTR0gtVDM3OXxTR0gtVDQwOXxTR0gtVDQyOXxTR0gtVDQzOXxTR0gtVDQ1OXxTR0gtVDQ2OXxTR0gtVDQ3OXxTR0gtVDQ5OXxTR0gtVDUwOXxTR0gtVDUxOXxTR0gtVDUzOXxTR0gtVDU1OXxTR0gtVDU4OXxTR0gtVDYwOXxTR0gtVDYxOXxTR0gtVDYyOXxTR0gtVDYzOXxTR0gtVDY1OXxTR0gtVDY2OXxTR0gtVDY3OXxTR0gtVDcwOXxTR0gtVDcxOXxTR0gtVDcyOXxTR0gtVDczOXxTR0gtVDc0NnxTR0gtVDc0OXxTR0gtVDc1OXxTR0gtVDc2OXxTR0gtVDgwOXxTR0gtVDgxOXxTR0gtVDgzOXxTR0gtVDkxOXxTR0gtVDkyOXxTR0gtVDkzOXxTR0gtVDk1OXxTR0gtVDk4OXxTR0gtVTEwMHxTR0gtVTIwMHxTR0gtVTgwMHxTR0gtVjIwNXxTR0gtVjIwNnxTR0gtWDEwMHxTR0gtWDEwNXxTR0gtWDEyMHxTR0gtWDE0MHxTR0gtWDQyNnxTR0gtWDQyN3xTR0gtWDQ3NXxTR0gtWDQ5NXxTR0gtWDQ5N3xTR0gtWDUwN3xTR0gtWDYwMHxTR0gtWDYxMHxTR0gtWDYyMHxTR0gtWDYzMHxTR0gtWDcwMHxTR0gtWDgyMHxTR0gtWDg5MHxTR0gtWjEzMHxTR0gtWjE1MHxTR0gtWjE3MHxTR0gtWlgxMHxTR0gtWlgyMHxTSFctTTExMHxTUEgtQTEyMHxTUEgtQTQwMHxTUEgtQTQyMHxTUEgtQTQ2MHxTUEgtQTUwMHxTUEgtQTU2MHxTUEgtQTYwMHxTUEgtQTYyMHxTUEgtQTY2MHxTUEgtQTcwMHxTUEgtQTc0MHxTUEgtQTc2MHxTUEgtQTc5MHxTUEgtQTgwMHxTUEgtQTgyMHxTUEgtQTg0MHxTUEgtQTg4MHxTUEgtQTkwMHxTUEgtQTk0MHxTUEgtQTk2MHxTUEgtRDYwMHxTUEgtRDcwMHxTUEgtRDcxMHxTUEgtRDcyMHxTUEgtSTMwMHxTUEgtSTMyNXxTUEgtSTMzMHxTUEgtSTM1MHxTUEgtSTUwMHxTUEgtSTYwMHxTUEgtSTcwMHxTUEgtTDcwMHxTUEgtTTEwMHxTUEgtTTIyMHxTUEgtTTI0MHxTUEgtTTMwMHxTUEgtTTMwNXxTUEgtTTMyMHxTUEgtTTMzMHxTUEgtTTM1MHxTUEgtTTM2MHxTUEgtTTM3MHxTUEgtTTM4MHxTUEgtTTUxMHxTUEgtTTU0MHxTUEgtTTU1MHxTUEgtTTU2MHxTUEgtTTU3MHxTUEgtTTU4MHxTUEgtTTYxMHxTUEgtTTYyMHxTUEgtTTYzMHxTUEgtTTgwMHxTUEgtTTgxMHxTUEgtTTg1MHxTUEgtTTkwMHxTUEgtTTkxMHxTUEgtTTkyMHxTUEgtTTkzMHxTUEgtTjEwMHxTUEgtTjIwMHxTUEgtTjI0MHxTUEgtTjMwMHxTUEgtTjQwMHxTUEgtWjQwMHxTV0MtRTEwMHxTQ0gtaTkwOXxHVC1ONzEwMHxHVC1ONzEwNXxTQ0gtSTUzNXxTTS1OOTAwQXxTR0gtSTMxN3xTR0gtVDk5OUx8R1QtUzUzNjBCfEdULUk4MjYyfEdULVM2ODAyfEdULVM2MzEyfEdULVM2MzEwfEdULVM1MzEyfEdULVM1MzEwfEdULUk5MTA1fEdULUk4NTEwfEdULVM2NzkwTnxTTS1HNzEwNXxTTS1OOTAwNXxHVC1TNTMwMXxHVC1JOTI5NXxHVC1JOTE5NXxTTS1DMTAxfEdULVM3MzkyfEdULVM3NTYwfEdULUI3NjEwfEdULUk1NTEwfEdULVM3NTgyfEdULVM3NTMwRXxHVC1JODc1MHxTTS1HOTAwNlZ8U00tRzkwMDhWfFNNLUc5MDA5RHxTTS1HOTAwQXxTTS1HOTAwRHxTTS1HOTAwRnxTTS1HOTAwSHxTTS1HOTAwSXxTTS1HOTAwSnxTTS1HOTAwS3xTTS1HOTAwTHxTTS1HOTAwTXxTTS1HOTAwUHxTTS1HOTAwUjR8U00tRzkwMFN8U00tRzkwMFR8U00tRzkwMFZ8U00tRzkwMFc4fFNIVi1FMTYwS3xTQ0gtUDcwOXxTQ0gtUDcyOXxTTS1UMjU1OHxHVC1JOTIwNXxTTS1HOTM1MHxTTS1KMTIwRnxTTS1HOTIwRnxTTS1HOTIwVnxTTS1HOTMwRnxTTS1OOTEwQ3xTTS1BMzEwRnxHVC1JOTE5MHxTTS1KNTAwRk58U00tRzkwM0Z8U00tSjMzMEZcIixcbiAgICAgICAgXCJMR1wiOiBcIlxcXFxiTEdcXFxcYjt8TEdbLSBdPyhDODAwfEM5MDB8RTQwMHxFNjEwfEU5MDB8RS05MDB8RjE2MHxGMTgwS3xGMTgwTHxGMTgwU3w3MzB8ODU1fEwxNjB8TFM3NDB8TFM4NDB8TFM5NzB8TFU2MjAwfE1TNjkwfE1TNjk1fE1TNzcwfE1TODQwfE1TODcwfE1TOTEwfFA1MDB8UDcwMHxQNzA1fFZNNjk2fEFTNjgwfEFTNjk1fEFYODQwfEM3Mjl8RTk3MHxHUzUwNXwyNzJ8QzM5NXxFNzM5Qkt8RTk2MHxMNTVDfEw3NUN8TFM2OTZ8TFM4NjB8UDc2OUJLfFAzNTB8UDUwMHxQNTA5fFA4NzB8VU4yNzJ8VVM3MzB8VlM4NDB8VlM5NTB8TE4yNzJ8TE41MTB8TFM2NzB8TFM4NTV8TFc2OTB8TU4yNzB8TU41MTB8UDUwOXxQNzY5fFA5MzB8VU4yMDB8VU4yNzB8VU41MTB8VU42MTB8VVM2NzB8VVM3NDB8VVM3NjB8VVgyNjV8VVg4NDB8Vk4yNzF8Vk41MzB8VlM2NjB8VlM3MDB8VlM3NDB8VlM3NTB8VlM5MTB8VlM5MjB8VlM5MzB8Vlg5MjAwfFZYMTEwMDB8QVg4NDBBfExXNzcwfFA1MDZ8UDkyNXxQOTk5fEU2MTJ8RDk1NXxEODAyfE1TMzIzfE0yNTcpXCIsXG4gICAgICAgIFwiU29ueVwiOiBcIlNvbnlTVHxTb255TFR8U29ueUVyaWNzc29ufFNvbnlFcmljc3NvbkxUMTVpdnxMVDE4aXxFMTBpfExUMjhofExUMjZ3fFNvbnlFcmljc3Nvbk1UMjdpfEM1MzAzfEM2OTAyfEM2OTAzfEM2OTA2fEM2OTQzfEQyNTMzXCIsXG4gICAgICAgIFwiQXN1c1wiOiBcIkFzdXMuKkdhbGF4eXxQYWRGb25lLipNb2JpbGVcIixcbiAgICAgICAgXCJOb2tpYUx1bWlhXCI6IFwiTHVtaWEgWzAtOV17Myw0fVwiLFxuICAgICAgICBcIk1pY3JvbWF4XCI6IFwiTWljcm9tYXguKlxcXFxiKEEyMTB8QTkyfEE4OHxBNzJ8QTExMXxBMTEwUXxBMTE1fEExMTZ8QTExMHxBOTBTfEEyNnxBNTF8QTM1fEE1NHxBMjV8QTI3fEE4OXxBNjh8QTY1fEE1N3xBOTApXFxcXGJcIixcbiAgICAgICAgXCJQYWxtXCI6IFwiUGFsbVNvdXJjZXxQYWxtXCIsXG4gICAgICAgIFwiVmVydHVcIjogXCJWZXJ0dXxWZXJ0dS4qTHRkfFZlcnR1LipBc2NlbnR8VmVydHUuKkF5eHRhfFZlcnR1LipDb25zdGVsbGF0aW9uKEZ8UXVlc3QpP3xWZXJ0dS4qTW9uaWthfFZlcnR1LipTaWduYXR1cmVcIixcbiAgICAgICAgXCJQYW50ZWNoXCI6IFwiUEFOVEVDSHxJTS1BODUwU3xJTS1BODQwU3xJTS1BODMwTHxJTS1BODMwS3xJTS1BODMwU3xJTS1BODIwTHxJTS1BODEwS3xJTS1BODEwU3xJTS1BODAwU3xJTS1UMTAwS3xJTS1BNzI1THxJTS1BNzgwTHxJTS1BNzc1Q3xJTS1BNzcwS3xJTS1BNzYwU3xJTS1BNzUwS3xJTS1BNzQwU3xJTS1BNzMwU3xJTS1BNzIwTHxJTS1BNzEwS3xJTS1BNjkwTHxJTS1BNjkwU3xJTS1BNjUwU3xJTS1BNjMwS3xJTS1BNjAwU3xWRUdBIFBUTDIxfFBUMDAzfFA4MDEwfEFEUjkxMEx8UDYwMzB8UDYwMjB8UDkwNzB8UDQxMDB8UDkwNjB8UDUwMDB8Q0RNODk5MnxUWFQ4MDQ1fEFEUjg5OTV8SVMxMVBUfFAyMDMwfFA2MDEwfFA4MDAwfFBUMDAyfElTMDZ8Q0RNODk5OXxQOTA1MHxQVDAwMXxUWFQ4MDQwfFAyMDIwfFA5MDIwfFAyMDAwfFA3MDQwfFA3MDAwfEM3OTBcIixcbiAgICAgICAgXCJGbHlcIjogXCJJUTIzMHxJUTQ0NHxJUTQ1MHxJUTQ0MHxJUTQ0MnxJUTQ0MXxJUTI0NXxJUTI1NnxJUTIzNnxJUTI1NXxJUTIzNXxJUTI0NXxJUTI3NXxJUTI0MHxJUTI4NXxJUTI4MHxJUTI3MHxJUTI2MHxJUTI1MFwiLFxuICAgICAgICBcIldpa29cIjogXCJLSVRFIDRHfEhJR0hXQVl8R0VUQVdBWXxTVEFJUldBWXxEQVJLU0lERXxEQVJLRlVMTHxEQVJLTklHSFR8REFSS01PT058U0xJREV8V0FYIDRHfFJBSU5CT1d8QkxPT018U1VOU0VUfEdPQSg/IW5uYSl8TEVOTll8QkFSUll8SUdHWXxPWlpZfENJTksgRklWRXxDSU5LIFBFQVh8Q0lOSyBQRUFYIDJ8Q0lOSyBTTElNfENJTksgU0xJTSAyfENJTksgK3xDSU5LIEtJTkd8Q0lOSyBQRUFYfENJTksgU0xJTXxTVUJMSU1cIixcbiAgICAgICAgXCJpTW9iaWxlXCI6IFwiaS1tb2JpbGUgKElRfGktU1RZTEV8aWRlYXxaQUF8SGl0eilcIixcbiAgICAgICAgXCJTaW1WYWxsZXlcIjogXCJcXFxcYihTUC04MHxYVC05MzB8U1gtMzQwfFhULTkzMHxTWC0zMTB8U1AtMzYwfFNQNjB8U1BULTgwMHxTUC0xMjB8U1BULTgwMHxTUC0xNDB8U1BYLTV8U1BYLTh8U1AtMTAwfFNQWC04fFNQWC0xMilcXFxcYlwiLFxuICAgICAgICBcIldvbGZnYW5nXCI6IFwiQVQtQjI0RHxBVC1BUzUwSER8QVQtQVM0MFd8QVQtQVM1NUhEfEFULUFTNDVxMnxBVC1CMjZEfEFULUFTNTBRXCIsXG4gICAgICAgIFwiQWxjYXRlbFwiOiBcIkFsY2F0ZWxcIixcbiAgICAgICAgXCJOaW50ZW5kb1wiOiBcIk5pbnRlbmRvICgzRFN8U3dpdGNoKVwiLFxuICAgICAgICBcIkFtb2lcIjogXCJBbW9pXCIsXG4gICAgICAgIFwiSU5RXCI6IFwiSU5RXCIsXG4gICAgICAgIFwiR2VuZXJpY1Bob25lXCI6IFwiVGFwYXRhbGt8UERBO3xTQUdFTXxcXFxcYm1tcFxcXFxifHBvY2tldHxcXFxcYnBzcFxcXFxifHN5bWJpYW58U21hcnRwaG9uZXxzbWFydGZvbnx0cmVvfHVwLmJyb3dzZXJ8dXAubGlua3x2b2RhZm9uZXxcXFxcYndhcFxcXFxifG5va2lhfFNlcmllczQwfFNlcmllczYwfFM2MHxTb255RXJpY3Nzb258TjkwMHxNQVVJLipXQVAuKkJyb3dzZXJcIlxuICAgIH0sXG4gICAgXCJ0YWJsZXRzXCI6IHtcbiAgICAgICAgXCJpUGFkXCI6IFwiaVBhZHxpUGFkLipNb2JpbGVcIixcbiAgICAgICAgXCJOZXh1c1RhYmxldFwiOiBcIkFuZHJvaWQuKk5leHVzW1xcXFxzXSsoN3w5fDEwKVwiLFxuICAgICAgICBcIkdvb2dsZVRhYmxldFwiOiBcIkFuZHJvaWQuKlBpeGVsIENcIixcbiAgICAgICAgXCJTYW1zdW5nVGFibGV0XCI6IFwiU0FNU1VORy4qVGFibGV0fEdhbGF4eS4qVGFifFNDLTAxQ3xHVC1QMTAwMHxHVC1QMTAwM3xHVC1QMTAxMHxHVC1QMzEwNXxHVC1QNjIxMHxHVC1QNjgwMHxHVC1QNjgxMHxHVC1QNzEwMHxHVC1QNzMwMHxHVC1QNzMxMHxHVC1QNzUwMHxHVC1QNzUxMHxTQ0gtSTgwMHxTQ0gtSTgxNXxTQ0gtSTkwNXxTR0gtSTk1N3xTR0gtSTk4N3xTR0gtVDg0OXxTR0gtVDg1OXxTR0gtVDg2OXxTUEgtUDEwMHxHVC1QMzEwMHxHVC1QMzEwOHxHVC1QMzExMHxHVC1QNTEwMHxHVC1QNTExMHxHVC1QNjIwMHxHVC1QNzMyMHxHVC1QNzUxMXxHVC1OODAwMHxHVC1QODUxMHxTR0gtSTQ5N3xTUEgtUDUwMHxTR0gtVDc3OXxTQ0gtSTcwNXxTQ0gtSTkxNXxHVC1OODAxM3xHVC1QMzExM3xHVC1QNTExM3xHVC1QODExMHxHVC1OODAxMHxHVC1OODAwNXxHVC1OODAyMHxHVC1QMTAxM3xHVC1QNjIwMXxHVC1QNzUwMXxHVC1ONTEwMHxHVC1ONTEwNXxHVC1ONTExMHxTSFYtRTE0MEt8U0hWLUUxNDBMfFNIVi1FMTQwU3xTSFYtRTE1MFN8U0hWLUUyMzBLfFNIVi1FMjMwTHxTSFYtRTIzMFN8U0hXLU0xODBLfFNIVy1NMTgwTHxTSFctTTE4MFN8U0hXLU0xODBXfFNIVy1NMzAwV3xTSFctTTMwNVd8U0hXLU0zODBLfFNIVy1NMzgwU3xTSFctTTM4MFd8U0hXLU00MzBXfFNIVy1NNDgwS3xTSFctTTQ4MFN8U0hXLU00ODBXfFNIVy1NNDg1V3xTSFctTTQ4Nld8U0hXLU01MDBXfEdULUk5MjI4fFNDSC1QNzM5fFNDSC1JOTI1fEdULUk5MjAwfEdULVA1MjAwfEdULVA1MjEwfEdULVA1MjEwWHxTTS1UMzExfFNNLVQzMTB8U00tVDMxMFh8U00tVDIxMHxTTS1UMjEwUnxTTS1UMjExfFNNLVA2MDB8U00tUDYwMXxTTS1QNjA1fFNNLVA5MDB8U00tUDkwMXxTTS1UMjE3fFNNLVQyMTdBfFNNLVQyMTdTfFNNLVA2MDAwfFNNLVQzMTAwfFNHSC1JNDY3fFhFNTAwfFNNLVQxMTB8R1QtUDUyMjB8R1QtSTkyMDBYfEdULU41MTEwWHxHVC1ONTEyMHxTTS1QOTA1fFNNLVQxMTF8U00tVDIxMDV8U00tVDMxNXxTTS1UMzIwfFNNLVQzMjBYfFNNLVQzMjF8U00tVDUyMHxTTS1UNTI1fFNNLVQ1MzBOVXxTTS1UMjMwTlV8U00tVDMzME5VfFNNLVQ5MDB8WEU1MDBUMUN8U00tUDYwNVZ8U00tUDkwNVZ8U00tVDMzN1Z8U00tVDUzN1Z8U00tVDcwN1Z8U00tVDgwN1Z8U00tUDYwMFh8U00tUDkwMFh8U00tVDIxMFh8U00tVDIzMHxTTS1UMjMwWHxTTS1UMzI1fEdULVA3NTAzfFNNLVQ1MzF8U00tVDMzMHxTTS1UNTMwfFNNLVQ3MDV8U00tVDcwNUN8U00tVDUzNXxTTS1UMzMxfFNNLVQ4MDB8U00tVDcwMHxTTS1UNTM3fFNNLVQ4MDd8U00tUDkwN0F8U00tVDMzN0F8U00tVDUzN0F8U00tVDcwN0F8U00tVDgwN0F8U00tVDIzN3xTTS1UODA3UHxTTS1QNjA3VHxTTS1UMjE3VHxTTS1UMzM3VHxTTS1UODA3VHxTTS1UMTE2TlF8U00tVDExNkJVfFNNLVA1NTB8U00tVDM1MHxTTS1UNTUwfFNNLVQ5MDAwfFNNLVA5MDAwfFNNLVQ3MDVZfFNNLVQ4MDV8R1QtUDMxMTN8U00tVDcxMHxTTS1UODEwfFNNLVQ4MTV8U00tVDM2MHxTTS1UNTMzfFNNLVQxMTN8U00tVDMzNXxTTS1UNzE1fFNNLVQ1NjB8U00tVDY3MHxTTS1UNjc3fFNNLVQzNzd8U00tVDU2N3xTTS1UMzU3VHxTTS1UNTU1fFNNLVQ1NjF8U00tVDcxM3xTTS1UNzE5fFNNLVQ4MTN8U00tVDgxOXxTTS1UNTgwfFNNLVQzNTVZP3xTTS1UMjgwfFNNLVQ4MTdBfFNNLVQ4MjB8U00tVzcwMHxTTS1QNTgwfFNNLVQ1ODd8U00tUDM1MHxTTS1QNTU1TXxTTS1QMzU1TXxTTS1UMTEzTlV8U00tVDgxNVl8U00tVDU4NXxTTS1UMjg1fFNNLVQ4MjV8U00tVzcwOHxTTS1UODM1XCIsXG4gICAgICAgIFwiS2luZGxlXCI6IFwiS2luZGxlfFNpbGsuKkFjY2VsZXJhdGVkfEFuZHJvaWQuKlxcXFxiKEtGT1R8S0ZUVHxLRkpXSXxLRkpXQXxLRk9URXxLRlNPV0l8S0ZUSFdJfEtGVEhXQXxLRkFQV0l8S0ZBUFdBfFdGSldBRXxLRlNBV0F8S0ZTQVdJfEtGQVNXSXxLRkFSV0l8S0ZGT1dJfEtGR0lXSXxLRk1FV0kpXFxcXGJ8QW5kcm9pZC4qU2lsa1xcL1swLTkuXSsgbGlrZSBDaHJvbWVcXC9bMC05Ll0rICg/IU1vYmlsZSlcIixcbiAgICAgICAgXCJTdXJmYWNlVGFibGV0XCI6IFwiV2luZG93cyBOVCBbMC05Ll0rOyBBUk07LiooVGFibGV0fEFSTUJKUylcIixcbiAgICAgICAgXCJIUFRhYmxldFwiOiBcIkhQIFNsYXRlICg3fDh8MTApfEhQIEVsaXRlUGFkIDkwMHxocC10YWJsZXR8RWxpdGVCb29rLipUb3VjaHxIUCA4fFNsYXRlIDIxfEhQIFNsYXRlQm9vayAxMFwiLFxuICAgICAgICBcIkFzdXNUYWJsZXRcIjogXCJeLipQYWRGb25lKCg/IU1vYmlsZSkuKSokfFRyYW5zZm9ybWVyfFRGMTAxfFRGMTAxR3xURjMwMFR8VEYzMDBUR3xURjMwMFRMfFRGNzAwVHxURjcwMEtMfFRGNzAxVHxURjgxMEN8TUUxNzF8TUUzMDFUfE1FMzAyQ3xNRTM3MU1HfE1FMzcwVHxNRTM3Mk1HfE1FMTcyVnxNRTE3M1h8TUU0MDBDfFNsaWRlciBTTDEwMXxcXFxcYkswMEZcXFxcYnxcXFxcYkswMENcXFxcYnxcXFxcYkswMEVcXFxcYnxcXFxcYkswMExcXFxcYnxUWDIwMUxBfE1FMTc2Q3xNRTEwMkF8XFxcXGJNODBUQVxcXFxifE1FMzcyQ0x8TUU1NjBDR3xNRTM3MkNHfE1FMzAyS0x8IEswMTAgfCBLMDExIHwgSzAxNyB8IEswMUUgfE1FNTcyQ3xNRTEwM0t8TUUxNzBDfE1FMTcxQ3xcXFxcYk1FNzBDXFxcXGJ8TUU1ODFDfE1FNTgxQ0x8TUU4NTEwQ3xNRTE4MUN8UDAxWXxQTzFNQXxQMDFafFxcXFxiUDAyN1xcXFxifFxcXFxiUDAyNFxcXFxifFxcXFxiUDAwQ1xcXFxiXCIsXG4gICAgICAgIFwiQmxhY2tCZXJyeVRhYmxldFwiOiBcIlBsYXlCb29rfFJJTSBUYWJsZXRcIixcbiAgICAgICAgXCJIVEN0YWJsZXRcIjogXCJIVENfRmx5ZXJfUDUxMnxIVEMgRmx5ZXJ8SFRDIEpldHN0cmVhbXxIVEMtUDcxNWF8SFRDIEVWTyBWaWV3IDRHfFBHNDEyMDB8UEcwOTQxMFwiLFxuICAgICAgICBcIk1vdG9yb2xhVGFibGV0XCI6IFwieG9vbXxzaG9sZXN0fE1aNjE1fE1aNjA1fE1aNTA1fE1aNjAxfE1aNjAyfE1aNjAzfE1aNjA0fE1aNjA2fE1aNjA3fE1aNjA4fE1aNjA5fE1aNjE1fE1aNjE2fE1aNjE3XCIsXG4gICAgICAgIFwiTm9va1RhYmxldFwiOiBcIkFuZHJvaWQuKk5vb2t8Tm9va0NvbG9yfG5vb2sgYnJvd3NlcnxCTlJWMjAwfEJOUlYyMDBBfEJOVFYyNTB8Qk5UVjI1MEF8Qk5UVjQwMHxCTlRWNjAwfExvZ2ljUEQgWm9vbTJcIixcbiAgICAgICAgXCJBY2VyVGFibGV0XCI6IFwiQW5kcm9pZC4qOyBcXFxcYihBMTAwfEExMDF8QTExMHxBMjAwfEEyMTB8QTIxMXxBNTAwfEE1MDF8QTUxMHxBNTExfEE3MDB8QTcwMXxXNTAwfFc1MDBQfFc1MDF8VzUwMVB8VzUxMHxXNTExfFc3MDB8RzEwMHxHMTAwV3xCMS1BNzF8QjEtNzEwfEIxLTcxMXxBMS04MTB8QTEtODExfEExLTgzMClcXFxcYnxXMy04MTB8XFxcXGJBMy1BMTBcXFxcYnxcXFxcYkEzLUExMVxcXFxifFxcXFxiQTMtQTIwXFxcXGJ8XFxcXGJBMy1BMzBcIixcbiAgICAgICAgXCJUb3NoaWJhVGFibGV0XCI6IFwiQW5kcm9pZC4qKEFUMTAwfEFUMTA1fEFUMjAwfEFUMjA1fEFUMjcwfEFUMjc1fEFUMzAwfEFUMzA1fEFUMVM1fEFUNTAwfEFUNTcwfEFUNzAwfEFUODMwKXxUT1NISUJBLipGT0xJT1wiLFxuICAgICAgICBcIkxHVGFibGV0XCI6IFwiXFxcXGJMLTA2Q3xMRy1WOTA5fExHLVY5MDB8TEctVjcwMHxMRy1WNTEwfExHLVY1MDB8TEctVjQxMHxMRy1WNDAwfExHLVZLODEwXFxcXGJcIixcbiAgICAgICAgXCJGdWppdHN1VGFibGV0XCI6IFwiQW5kcm9pZC4qXFxcXGIoRi0wMUR8Ri0wMkZ8Ri0wNUV8Ri0xMER8TTUzMnxRNTcyKVxcXFxiXCIsXG4gICAgICAgIFwiUHJlc3RpZ2lvVGFibGV0XCI6IFwiUE1QMzE3MEJ8UE1QMzI3MEJ8UE1QMzQ3MEJ8UE1QNzE3MEJ8UE1QMzM3MEJ8UE1QMzU3MEN8UE1QNTg3MEN8UE1QMzY3MEJ8UE1QNTU3MEN8UE1QNTc3MER8UE1QMzk3MEJ8UE1QMzg3MEN8UE1QNTU4MEN8UE1QNTg4MER8UE1QNTc4MER8UE1QNTU4OEN8UE1QNzI4MEN8UE1QNzI4MEMzR3xQTVA3MjgwfFBNUDc4ODBEfFBNUDU1OTdEfFBNUDU1OTd8UE1QNzEwMER8UEVSMzQ2NHxQRVIzMjc0fFBFUjM1NzR8UEVSMzg4NHxQRVI1Mjc0fFBFUjU0NzR8UE1QNTA5N0NQUk98UE1QNTA5N3xQTVA3MzgwRHxQTVA1Mjk3Q3xQTVA1Mjk3Q19RVUFEfFBNUDgxMkV8UE1QODEyRTNHfFBNUDgxMkZ8UE1QODEwRXxQTVA4ODBURHxQTVQzMDE3fFBNVDMwMzd8UE1UMzA0N3xQTVQzMDU3fFBNVDcwMDh8UE1UNTg4N3xQTVQ1MDAxfFBNVDUwMDJcIixcbiAgICAgICAgXCJMZW5vdm9UYWJsZXRcIjogXCJMZW5vdm8gVEFCfElkZWEoVGFifFBhZCkoIEExfEExMHwgSzF8KXxUaGlua1BhZChbIF0rKT9UYWJsZXR8WVQzLTg1ME18WVQzLVg5MEx8WVQzLVg5MEZ8WVQzLVg5MFh8TGVub3ZvLiooUzIxMDl8UzIxMTB8UzUwMDB8UzYwMDB8SzMwMTF8QTMwMDB8QTM1MDB8QTEwMDB8QTIxMDd8QTIxMDl8QTExMDd8QTU1MDB8QTc2MDB8QjYwMDB8QjgwMDB8QjgwODApKC18KShGTHxGfEhWfEh8KXxUQi1YMTAzRnxUQi1YMzA0RnxUQi1YMzA0THxUQi04NzAzRnxUYWIyQTctMTBGfFRCMi1YMzBMXCIsXG4gICAgICAgIFwiRGVsbFRhYmxldFwiOiBcIlZlbnVlIDExfFZlbnVlIDh8VmVudWUgN3xEZWxsIFN0cmVhayAxMHxEZWxsIFN0cmVhayA3XCIsXG4gICAgICAgIFwiWWFydmlrVGFibGV0XCI6IFwiQW5kcm9pZC4qXFxcXGIoVEFCMjEwfFRBQjIxMXxUQUIyMjR8VEFCMjUwfFRBQjI2MHxUQUIyNjR8VEFCMzEwfFRBQjM2MHxUQUIzNjR8VEFCNDEwfFRBQjQxMXxUQUI0MjB8VEFCNDI0fFRBQjQ1MHxUQUI0NjB8VEFCNDYxfFRBQjQ2NHxUQUI0NjV8VEFCNDY3fFRBQjQ2OHxUQUIwNy0xMDB8VEFCMDctMTAxfFRBQjA3LTE1MHxUQUIwNy0xNTF8VEFCMDctMTUyfFRBQjA3LTIwMHxUQUIwNy0yMDEtM0d8VEFCMDctMjEwfFRBQjA3LTIxMXxUQUIwNy0yMTJ8VEFCMDctMjE0fFRBQjA3LTIyMHxUQUIwNy00MDB8VEFCMDctNDg1fFRBQjA4LTE1MHxUQUIwOC0yMDB8VEFCMDgtMjAxLTNHfFRBQjA4LTIwMS0zMHxUQUIwOS0xMDB8VEFCMDktMjExfFRBQjA5LTQxMHxUQUIxMC0xNTB8VEFCMTAtMjAxfFRBQjEwLTIxMXxUQUIxMC00MDB8VEFCMTAtNDEwfFRBQjEzLTIwMXxUQUIyNzRFVUt8VEFCMjc1RVVLfFRBQjM3NEVVS3xUQUI0NjJFVUt8VEFCNDc0RVVLfFRBQjktMjAwKVxcXFxiXCIsXG4gICAgICAgIFwiTWVkaW9uVGFibGV0XCI6IFwiQW5kcm9pZC4qXFxcXGJPWU9cXFxcYnxMSUZFLiooUDkyMTJ8UDk1MTR8UDk1MTZ8Uzk1MTIpfExJRkVUQUJcIixcbiAgICAgICAgXCJBcm5vdmFUYWJsZXRcIjogXCI5N0c0fEFOMTBHMnxBTjdiRzN8QU43ZkczfEFOOEczfEFOOGNHM3xBTjdHM3xBTjlHM3xBTjdkRzN8QU43ZEczU1R8QU43ZEczQ2hpbGRQYWR8QU4xMGJHM3xBTjEwYkczRFR8QU45RzJcIixcbiAgICAgICAgXCJJbnRlbnNvVGFibGV0XCI6IFwiSU5NODAwMktQfElOTTEwMTBGUHxJTk04MDVORHxJbnRlbnNvIFRhYnxUQUIxMDA0XCIsXG4gICAgICAgIFwiSVJVVGFibGV0XCI6IFwiTTcwMnByb1wiLFxuICAgICAgICBcIk1lZ2Fmb25UYWJsZXRcIjogXCJNZWdhRm9uIFY5fFxcXFxiWlRFIFY5XFxcXGJ8QW5kcm9pZC4qXFxcXGJNVDdBXFxcXGJcIixcbiAgICAgICAgXCJFYm9kYVRhYmxldFwiOiBcIkUtQm9kYSAoU3VwcmVtZXxJbXByZXNzcGVlZHxJenp5Y29tbXxFc3NlbnRpYWwpXCIsXG4gICAgICAgIFwiQWxsVmlld1RhYmxldFwiOiBcIkFsbHZpZXcuKihWaXZhfEFsbGRyb3xDaXR5fFNwZWVkfEFsbCBUVnxGcmVuenl8UXVhc2FyfFNoaW5lfFRYMXxBWDF8QVgyKVwiLFxuICAgICAgICBcIkFyY2hvc1RhYmxldFwiOiBcIlxcXFxiKDEwMUc5fDgwRzl8QTEwMUlUKVxcXFxifFFpbGl2ZSA5N1J8QXJjaG9zNXxcXFxcYkFSQ0hPUyAoNzB8Nzl8ODB8OTB8OTd8MTAxfEZBTUlMWVBBRHwpKGJ8Y3wpKEcxMHwgQ29iYWx0fCBUSVRBTklVTShIRHwpfCBYZW5vbnwgTmVvbnxYU0t8IDJ8IFhTIDJ8IFBMQVRJTlVNfCBDQVJCT058R0FNRVBBRClcXFxcYlwiLFxuICAgICAgICBcIkFpbm9sVGFibGV0XCI6IFwiTk9WTzd8Tk9WTzh8Tk9WTzEwfE5vdm83QXVyb3JhfE5vdm83QmFzaWN8Tk9WTzdQQUxBRElOfG5vdm85LVNwYXJrXCIsXG4gICAgICAgIFwiTm9raWFMdW1pYVRhYmxldFwiOiBcIkx1bWlhIDI1MjBcIixcbiAgICAgICAgXCJTb255VGFibGV0XCI6IFwiU29ueS4qVGFibGV0fFhwZXJpYSBUYWJsZXR8U29ueSBUYWJsZXQgU3xTTy0wM0V8U0dQVDEyfFNHUFQxM3xTR1BUMTE0fFNHUFQxMjF8U0dQVDEyMnxTR1BUMTIzfFNHUFQxMTF8U0dQVDExMnxTR1BUMTEzfFNHUFQxMzF8U0dQVDEzMnxTR1BUMTMzfFNHUFQyMTF8U0dQVDIxMnxTR1BUMjEzfFNHUDMxMXxTR1AzMTJ8U0dQMzIxfEVCUkQxMTAxfEVCUkQxMTAyfEVCUkQxMjAxfFNHUDM1MXxTR1AzNDF8U0dQNTExfFNHUDUxMnxTR1A1MjF8U0dQNTQxfFNHUDU1MXxTR1A2MjF8U0dQNjQxfFNHUDYxMnxTT1QzMXxTR1A3NzF8U0dQNjExfFNHUDYxMnxTR1A3MTJcIixcbiAgICAgICAgXCJQaGlsaXBzVGFibGV0XCI6IFwiXFxcXGIoUEkyMDEwfFBJMzAwMHxQSTMxMDB8UEkzMTA1fFBJMzExMHxQSTMyMDV8UEkzMjEwfFBJMzkwMHxQSTQwMTB8UEk3MDAwfFBJNzEwMClcXFxcYlwiLFxuICAgICAgICBcIkN1YmVUYWJsZXRcIjogXCJBbmRyb2lkLiooSzhHVHxVOUdUfFUxMEdUfFUxNkdUfFUxN0dUfFUxOEdUfFUxOUdUfFUyMEdUfFUyM0dUfFUzMEdUKXxDVUJFIFU4R1RcIixcbiAgICAgICAgXCJDb2J5VGFibGV0XCI6IFwiTUlEMTA0MnxNSUQxMDQ1fE1JRDExMjV8TUlEMTEyNnxNSUQ3MDEyfE1JRDcwMTR8TUlENzAxNXxNSUQ3MDM0fE1JRDcwMzV8TUlENzAzNnxNSUQ3MDQyfE1JRDcwNDh8TUlENzEyN3xNSUQ4MDQyfE1JRDgwNDh8TUlEODEyN3xNSUQ5MDQyfE1JRDk3NDB8TUlEOTc0MnxNSUQ3MDIyfE1JRDcwMTBcIixcbiAgICAgICAgXCJNSURUYWJsZXRcIjogXCJNOTcwMXxNOTAwMHxNOTEwMHxNODA2fE0xMDUyfE04MDZ8VDcwM3xNSUQ3MDF8TUlENzEzfE1JRDcxMHxNSUQ3Mjd8TUlENzYwfE1JRDgzMHxNSUQ3Mjh8TUlEOTMzfE1JRDEyNXxNSUQ4MTB8TUlENzMyfE1JRDEyMHxNSUQ5MzB8TUlEODAwfE1JRDczMXxNSUQ5MDB8TUlEMTAwfE1JRDgyMHxNSUQ3MzV8TUlEOTgwfE1JRDEzMHxNSUQ4MzN8TUlENzM3fE1JRDk2MHxNSUQxMzV8TUlEODYwfE1JRDczNnxNSUQxNDB8TUlEOTMwfE1JRDgzNXxNSUQ3MzN8TUlENFgxMFwiLFxuICAgICAgICBcIk1TSVRhYmxldFwiOiBcIk1TSSBcXFxcYihQcmltbyA3M0t8UHJpbW8gNzNMfFByaW1vIDgxTHxQcmltbyA3N3xQcmltbyA5M3xQcmltbyA3NXxQcmltbyA3NnxQcmltbyA3M3xQcmltbyA4MXxQcmltbyA5MXxQcmltbyA5MHxFbmpveSA3MXxFbmpveSA3fEVuam95IDEwKVxcXFxiXCIsXG4gICAgICAgIFwiU01pVFRhYmxldFwiOiBcIkFuZHJvaWQuKihcXFxcYk1JRFxcXFxifE1JRC01NjB8TVRWLVQxMjAwfE1UVi1QTkQ1MzF8TVRWLVAxMTAxfE1UVi1QTkQ1MzApXCIsXG4gICAgICAgIFwiUm9ja0NoaXBUYWJsZXRcIjogXCJBbmRyb2lkLiooUksyODE4fFJLMjgwOEF8UksyOTE4fFJLMzA2Nil8UksyNzM4fFJLMjgwOEFcIixcbiAgICAgICAgXCJGbHlUYWJsZXRcIjogXCJJUTMxMHxGbHkgVmlzaW9uXCIsXG4gICAgICAgIFwiYnFUYWJsZXRcIjogXCJBbmRyb2lkLiooYnEpPy4qKEVsY2Fub3xDdXJpZXxFZGlzb258TWF4d2VsbHxLZXBsZXJ8UGFzY2FsfFRlc2xhfEh5cGF0aWF8UGxhdG9ufE5ld3RvbnxMaXZpbmdzdG9uZXxDZXJ2YW50ZXN8QXZhbnR8QXF1YXJpcyAoW0V8TV0xMHxNOCkpfE1heHdlbGwuKkxpdGV8TWF4d2VsbC4qUGx1c1wiLFxuICAgICAgICBcIkh1YXdlaVRhYmxldFwiOiBcIk1lZGlhUGFkfE1lZGlhUGFkIDcgWW91dGh8SURFT1MgUzd8UzctMjAxY3xTNy0yMDJ1fFM3LTEwMXxTNy0xMDN8UzctMTA0fFM3LTEwNXxTNy0xMDZ8UzctMjAxfFM3LVNsaW18TTItQTAxTHxCQUgtTDA5fEJBSC1XMDlcIixcbiAgICAgICAgXCJOZWNUYWJsZXRcIjogXCJcXFxcYk4tMDZEfFxcXFxiTi0wOERcIixcbiAgICAgICAgXCJQYW50ZWNoVGFibGV0XCI6IFwiUGFudGVjaC4qUDQxMDBcIixcbiAgICAgICAgXCJCcm9uY2hvVGFibGV0XCI6IFwiQnJvbmNoby4qKE43MDF8TjcwOHxOODAyfGE3MTApXCIsXG4gICAgICAgIFwiVmVyc3VzVGFibGV0XCI6IFwiVE9VQ0hQQUQuKls3ODkxMF18XFxcXGJUT1VDSFRBQlxcXFxiXCIsXG4gICAgICAgIFwiWnluY1RhYmxldFwiOiBcInoxMDAwfFo5OSAyR3x6OTl8ejkzMHx6OTk5fHo5OTB8ejkwOXxaOTE5fHo5MDBcIixcbiAgICAgICAgXCJQb3NpdGl2b1RhYmxldFwiOiBcIlRCMDdTVEF8VEIxMFNUQXxUQjA3RlRBfFRCMTBGVEFcIixcbiAgICAgICAgXCJOYWJpVGFibGV0XCI6IFwiQW5kcm9pZC4qXFxcXGJOYWJpXCIsXG4gICAgICAgIFwiS29ib1RhYmxldFwiOiBcIktvYm8gVG91Y2h8XFxcXGJLMDgwXFxcXGJ8XFxcXGJWb3hcXFxcYiBCdWlsZHxcXFxcYkFyY1xcXFxiIEJ1aWxkXCIsXG4gICAgICAgIFwiRGFuZXdUYWJsZXRcIjogXCJEU2xpZGUuKlxcXFxiKDcwMHw3MDFSfDcwMnw3MDNSfDcwNHw4MDJ8OTcwfDk3MXw5NzJ8OTczfDk3NHwxMDEwfDEwMTIpXFxcXGJcIixcbiAgICAgICAgXCJUZXhldFRhYmxldFwiOiBcIk5hdmlQYWR8VEItNzcyQXxUTS03MDQ1fFRNLTcwNTV8VE0tOTc1MHxUTS03MDE2fFRNLTcwMjR8VE0tNzAyNnxUTS03MDQxfFRNLTcwNDN8VE0tNzA0N3xUTS04MDQxfFRNLTk3NDF8VE0tOTc0N3xUTS05NzQ4fFRNLTk3NTF8VE0tNzAyMnxUTS03MDIxfFRNLTcwMjB8VE0tNzAxMXxUTS03MDEwfFRNLTcwMjN8VE0tNzAyNXxUTS03MDM3V3xUTS03MDM4V3xUTS03MDI3V3xUTS05NzIwfFRNLTk3MjV8VE0tOTczN1d8VE0tMTAyMHxUTS05NzM4V3xUTS05NzQwfFRNLTk3NDNXfFRCLTgwN0F8VEItNzcxQXxUQi03MjdBfFRCLTcyNUF8VEItNzE5QXxUQi04MjNBfFRCLTgwNUF8VEItNzIzQXxUQi03MTVBfFRCLTcwN0F8VEItNzA1QXxUQi03MDlBfFRCLTcxMUF8VEItODkwSER8VEItODgwSER8VEItNzkwSER8VEItNzgwSER8VEItNzcwSER8VEItNzIxSER8VEItNzEwSER8VEItNDM0SER8VEItODYwSER8VEItODQwSER8VEItNzYwSER8VEItNzUwSER8VEItNzQwSER8VEItNzMwSER8VEItNzIySER8VEItNzIwSER8VEItNzAwSER8VEItNTAwSER8VEItNDcwSER8VEItNDMxSER8VEItNDMwSER8VEItNTA2fFRCLTUwNHxUQi00NDZ8VEItNDM2fFRCLTQxNnxUQi0xNDZTRXxUQi0xMjZTRVwiLFxuICAgICAgICBcIlBsYXlzdGF0aW9uVGFibGV0XCI6IFwiUGxheXN0YXRpb24uKihQb3J0YWJsZXxWaXRhKVwiLFxuICAgICAgICBcIlRyZWtzdG9yVGFibGV0XCI6IFwiU1QxMDQxNi0xfFZUMTA0MTYtMXxTVDcwNDA4LTF8U1Q3MDJ4eC0xfFNUNzAyeHgtMnxTVDgwMjA4fFNUOTcyMTZ8U1Q3MDEwNC0yfFZUMTA0MTYtMnxTVDEwMjE2LTJBfFN1cmZUYWJcIixcbiAgICAgICAgXCJQeWxlQXVkaW9UYWJsZXRcIjogXCJcXFxcYihQVEJMMTBDRVV8UFRCTDEwQ3xQVEJMNzJCQ3xQVEJMNzJCQ0VVfFBUQkw3Q0VVfFBUQkw3Q3xQVEJMOTJCQ3xQVEJMOTJCQ0VVfFBUQkw5Q0VVfFBUQkw5Q1VLfFBUQkw5QylcXFxcYlwiLFxuICAgICAgICBcIkFkdmFuVGFibGV0XCI6IFwiQW5kcm9pZC4qIFxcXFxiKEUzQXxUM1h8VDVDfFQ1QnxUM0V8VDNDfFQzQnxUMUp8VDFGfFQyQXxUMUh8VDFpfEUxQ3xUMS1FfFQ1LUF8VDR8RTEtQnxUMkNpfFQxLUJ8VDEtRHxPMS1BfEUxLUF8VDEtQXxUM0F8VDRpKVxcXFxiIFwiLFxuICAgICAgICBcIkRhbnlUZWNoVGFibGV0XCI6IFwiR2VuaXVzIFRhYiBHM3xHZW5pdXMgVGFiIFMyfEdlbml1cyBUYWIgUTN8R2VuaXVzIFRhYiBHNHxHZW5pdXMgVGFiIFE0fEdlbml1cyBUYWIgRy1JSXxHZW5pdXMgVEFCIEdJSXxHZW5pdXMgVEFCIEdJSUl8R2VuaXVzIFRhYiBTMVwiLFxuICAgICAgICBcIkdhbGFwYWRUYWJsZXRcIjogXCJBbmRyb2lkLipcXFxcYkcxXFxcXGIoPyFcXFxcKSlcIixcbiAgICAgICAgXCJNaWNyb21heFRhYmxldFwiOiBcIkZ1bmJvb2t8TWljcm9tYXguKlxcXFxiKFAyNTB8UDU2MHxQMzYwfFAzNjJ8UDYwMHxQMzAwfFAzNTB8UDUwMHxQMjc1KVxcXFxiXCIsXG4gICAgICAgIFwiS2FyYm9ublRhYmxldFwiOiBcIkFuZHJvaWQuKlxcXFxiKEEzOXxBMzd8QTM0fFNUOHxTVDEwfFNUN3xTbWFydCBUYWIzfFNtYXJ0IFRhYjIpXFxcXGJcIixcbiAgICAgICAgXCJBbGxGaW5lVGFibGV0XCI6IFwiRmluZTcgR2VuaXVzfEZpbmU3IFNoaW5lfEZpbmU3IEFpcnxGaW5lOCBTdHlsZXxGaW5lOSBNb3JlfEZpbmUxMCBKb3l8RmluZTExIFdpZGVcIixcbiAgICAgICAgXCJQUk9TQ0FOVGFibGV0XCI6IFwiXFxcXGIoUEVNNjN8UExUMTAyM0d8UExUMTA0MXxQTFQxMDQ0fFBMVDEwNDRHfFBMVDEwOTF8UExUNDMxMXxQTFQ0MzExUEx8UExUNDMxNXxQTFQ3MDMwfFBMVDcwMzN8UExUNzAzM0R8UExUNzAzNXxQTFQ3MDM1RHxQTFQ3MDQ0S3xQTFQ3MDQ1S3xQTFQ3MDQ1S0J8UExUNzA3MUtHfFBMVDcwNzJ8UExUNzIyM0d8UExUNzIyNUd8UExUNzc3N0d8UExUNzgxMEt8UExUNzg0OUd8UExUNzg1MUd8UExUNzg1Mkd8UExUODAxNXxQTFQ4MDMxfFBMVDgwMzR8UExUODAzNnxQTFQ4MDgwS3xQTFQ4MDgyfFBMVDgwODh8UExUODIyM0d8UExUODIzNEd8UExUODIzNUd8UExUODgxNkt8UExUOTAxMXxQTFQ5MDQ1S3xQTFQ5MjMzR3xQTFQ5NzM1fFBMVDk3NjBHfFBMVDk3NzBHKVxcXFxiXCIsXG4gICAgICAgIFwiWU9ORVNUYWJsZXRcIjogXCJCUTEwNzh8QkMxMDAzfEJDMTA3N3xSSzk3MDJ8QkM5NzMwfEJDOTAwMXxJVDkwMDF8QkM3MDA4fEJDNzAxMHxCQzcwOHxCQzcyOHxCQzcwMTJ8QkM3MDMwfEJDNzAyN3xCQzcwMjZcIixcbiAgICAgICAgXCJDaGFuZ0ppYVRhYmxldFwiOiBcIlRQQzcxMDJ8VFBDNzEwM3xUUEM3MTA1fFRQQzcxMDZ8VFBDNzEwN3xUUEM3MjAxfFRQQzcyMDN8VFBDNzIwNXxUUEM3MjEwfFRQQzc3MDh8VFBDNzcwOXxUUEM3NzEyfFRQQzcxMTB8VFBDODEwMXxUUEM4MTAzfFRQQzgxMDV8VFBDODEwNnxUUEM4MjAzfFRQQzgyMDV8VFBDODUwM3xUUEM5MTA2fFRQQzk3MDF8VFBDOTcxMDF8VFBDOTcxMDN8VFBDOTcxMDV8VFBDOTcxMDZ8VFBDOTcxMTF8VFBDOTcxMTN8VFBDOTcyMDN8VFBDOTc2MDN8VFBDOTc4MDl8VFBDOTcyMDV8VFBDMTAxMDF8VFBDMTAxMDN8VFBDMTAxMDZ8VFBDMTAxMTF8VFBDMTAyMDN8VFBDMTAyMDV8VFBDMTA1MDNcIixcbiAgICAgICAgXCJHVVRhYmxldFwiOiBcIlRYLUExMzAxfFRYLU05MDAyfFE3MDJ8a2YwMjZcIixcbiAgICAgICAgXCJQb2ludE9mVmlld1RhYmxldFwiOiBcIlRBQi1QNTA2fFRBQi1uYXZpLTctM0ctTXxUQUItUDUxN3xUQUItUC01Mjd8VEFCLVA3MDF8VEFCLVA3MDN8VEFCLVA3MjF8VEFCLVA3MzFOfFRBQi1QNzQxfFRBQi1QODI1fFRBQi1QOTA1fFRBQi1QOTI1fFRBQi1QUjk0NXxUQUItUEwxMDE1fFRBQi1QMTAyNXxUQUItUEkxMDQ1fFRBQi1QMTMyNXxUQUItUFJPVEFCWzAtOV0rfFRBQi1QUk9UQUIyNXxUQUItUFJPVEFCMjZ8VEFCLVBST1RBQjI3fFRBQi1QUk9UQUIyNlhMfFRBQi1QUk9UQUIyLUlQUzl8VEFCLVBST1RBQjMwLUlQUzl8VEFCLVBST1RBQjI1WFhMfFRBQi1QUk9UQUIyNi1JUFMxMHxUQUItUFJPVEFCMzAtSVBTMTBcIixcbiAgICAgICAgXCJPdmVybWF4VGFibGV0XCI6IFwiT1YtKFN0ZWVsQ29yZXxOZXdCYXNlfEJhc2Vjb3JlfEJhc2VvbmV8RXhlbGxlbnxRdWF0dG9yfEVkdVRhYnxTb2x1dGlvbnxBQ1RJT058QmFzaWNUYWJ8VGVkZHlUYWJ8TWFnaWNUYWJ8U3RyZWFtfFRCLTA4fFRCLTA5KXxRdWFsY29yZSAxMDI3XCIsXG4gICAgICAgIFwiSENMVGFibGV0XCI6IFwiSENMLipUYWJsZXR8Q29ubmVjdC0zRy0yLjB8Q29ubmVjdC0yRy0yLjB8TUUgVGFibGV0IFUxfE1FIFRhYmxldCBVMnxNRSBUYWJsZXQgRzF8TUUgVGFibGV0IFgxfE1FIFRhYmxldCBZMnxNRSBUYWJsZXQgU3luY1wiLFxuICAgICAgICBcIkRQU1RhYmxldFwiOiBcIkRQUyBEcmVhbSA5fERQUyBEdWFsIDdcIixcbiAgICAgICAgXCJWaXN0dXJlVGFibGV0XCI6IFwiVjk3IEhEfGk3NSAzR3xWaXN0dXJlIFY0KCBIRCk/fFZpc3R1cmUgVjUoIEhEKT98VmlzdHVyZSBWMTBcIixcbiAgICAgICAgXCJDcmVzdGFUYWJsZXRcIjogXCJDVFAoLSk/ODEwfENUUCgtKT84MTh8Q1RQKC0pPzgyOHxDVFAoLSk/ODM4fENUUCgtKT84ODh8Q1RQKC0pPzk3OHxDVFAoLSk/OTgwfENUUCgtKT85ODd8Q1RQKC0pPzk4OHxDVFAoLSk/OTg5XCIsXG4gICAgICAgIFwiTWVkaWF0ZWtUYWJsZXRcIjogXCJcXFxcYk1UODEyNXxNVDgzODl8TVQ4MTM1fE1UODM3N1xcXFxiXCIsXG4gICAgICAgIFwiQ29uY29yZGVUYWJsZXRcIjogXCJDb25jb3JkZShbIF0rKT9UYWJ8Q29uQ29yZGUgUmVhZE1hblwiLFxuICAgICAgICBcIkdvQ2xldmVyVGFibGV0XCI6IFwiR09DTEVWRVIgVEFCfEE3R09DTEVWRVJ8TTEwNDJ8TTc4NDF8TTc0MnxSMTA0MkJLfFIxMDQxfFRBQiBBOTc1fFRBQiBBNzg0MnxUQUIgQTc0MXxUQUIgQTc0MUx8VEFCIE03MjNHfFRBQiBNNzIxfFRBQiBBMTAyMXxUQUIgSTkyMXxUQUIgUjcyMXxUQUIgSTcyMHxUQUIgVDc2fFRBQiBSNzB8VEFCIFI3Ni4yfFRBQiBSMTA2fFRBQiBSODMuMnxUQUIgTTgxM0d8VEFCIEk3MjF8R0NUQTcyMnxUQUIgSTcwfFRBQiBJNzF8VEFCIFM3M3xUQUIgUjczfFRBQiBSNzR8VEFCIFI5M3xUQUIgUjc1fFRBQiBSNzYuMXxUQUIgQTczfFRBQiBBOTN8VEFCIEE5My4yfFRBQiBUNzJ8VEFCIFI4M3xUQUIgUjk3NHxUQUIgUjk3M3xUQUIgQTEwMXxUQUIgQTEwM3xUQUIgQTEwNHxUQUIgQTEwNC4yfFIxMDVCS3xNNzEzR3xBOTcyQkt8VEFCIEE5NzF8VEFCIFI5NzQuMnxUQUIgUjEwNHxUQUIgUjgzLjN8VEFCIEExMDQyXCIsXG4gICAgICAgIFwiTW9kZWNvbVRhYmxldFwiOiBcIkZyZWVUQUIgOTAwMHxGcmVlVEFCIDcuNHxGcmVlVEFCIDcwMDR8RnJlZVRBQiA3ODAwfEZyZWVUQUIgMjA5NnxGcmVlVEFCIDcuNXxGcmVlVEFCIDEwMTR8RnJlZVRBQiAxMDAxIHxGcmVlVEFCIDgwMDF8RnJlZVRBQiA5NzA2fEZyZWVUQUIgOTcwMnxGcmVlVEFCIDcwMDN8RnJlZVRBQiA3MDAyfEZyZWVUQUIgMTAwMnxGcmVlVEFCIDc4MDF8RnJlZVRBQiAxMzMxfEZyZWVUQUIgMTAwNHxGcmVlVEFCIDgwMDJ8RnJlZVRBQiA4MDE0fEZyZWVUQUIgOTcwNHxGcmVlVEFCIDEwMDNcIixcbiAgICAgICAgXCJWb25pbm9UYWJsZXRcIjogXCJcXFxcYihBcmd1c1sgX10/U3xEaWFtb25kWyBfXT83OUhEfEVtZXJhbGRbIF9dPzc4RXxMdW5hWyBfXT83MEN8T255eFsgX10/U3xPbnl4WyBfXT9afE9yaW5bIF9dP0hEfE9yaW5bIF9dP1N8T3Rpc1sgX10/U3xTcGVlZFN0YXJbIF9dP1N8TWFnbmV0WyBfXT9NOXxQcmltdXNbIF9dPzk0WyBfXT8zR3xQcmltdXNbIF9dPzk0SER8UHJpbXVzWyBfXT9RU3xBbmRyb2lkLipcXFxcYlE4XFxcXGJ8U2lyaXVzWyBfXT9FVk9bIF9dP1FTfFNpcml1c1sgX10/UVN8U3Bpcml0WyBfXT9TKVxcXFxiXCIsXG4gICAgICAgIFwiRUNTVGFibGV0XCI6IFwiVjA3T1QyfFRNMTA1QXxTMTBPVDF8VFIxMENTMVwiLFxuICAgICAgICBcIlN0b3JleFRhYmxldFwiOiBcImVaZWVbXyddPyhUYWJ8R28pWzAtOV0rfFRhYkxDN3xMb29uZXkgVHVuZXMgVGFiXCIsXG4gICAgICAgIFwiVm9kYWZvbmVUYWJsZXRcIjogXCJTbWFydFRhYihbIF0rKT9bMC05XSt8U21hcnRUYWJJSTEwfFNtYXJ0VGFiSUk3fFZGLTE0OTdcIixcbiAgICAgICAgXCJFc3NlbnRpZWxCVGFibGV0XCI6IFwiU21hcnRbICddP1RBQlsgXSs/WzAtOV0rfEZhbWlseVsgJ10/VEFCMlwiLFxuICAgICAgICBcIlJvc3NNb29yVGFibGV0XCI6IFwiUk0tNzkwfFJNLTk5N3xSTUQtODc4R3xSTUQtOTc0UnxSTVQtNzA1QXxSTVQtNzAxfFJNRS02MDF8Uk1ULTUwMXxSTVQtNzExXCIsXG4gICAgICAgIFwiaU1vYmlsZVRhYmxldFwiOiBcImktbW9iaWxlIGktbm90ZVwiLFxuICAgICAgICBcIlRvbGlub1RhYmxldFwiOiBcInRvbGlubyB0YWIgWzAtOS5dK3x0b2xpbm8gc2hpbmVcIixcbiAgICAgICAgXCJBdWRpb1NvbmljVGFibGV0XCI6IFwiXFxcXGJDLTIyUXxUNy1RQ3xULTE3QnxULTE3UFxcXFxiXCIsXG4gICAgICAgIFwiQU1QRVRhYmxldFwiOiBcIkFuZHJvaWQuKiBBNzggXCIsXG4gICAgICAgIFwiU2trVGFibGV0XCI6IFwiQW5kcm9pZC4qIChTS1lQQUR8UEhPRU5JWHxDWUNMT1BTKVwiLFxuICAgICAgICBcIlRlY25vVGFibGV0XCI6IFwiVEVDTk8gUDl8VEVDTk8gRFA4RFwiLFxuICAgICAgICBcIkpYRFRhYmxldFwiOiBcIkFuZHJvaWQuKiBcXFxcYihGMzAwMHxBMzMwMHxKWEQ1MDAwfEpYRDMwMDB8SlhEMjAwMHxKWEQzMDBCfEpYRDMwMHxTNTgwMHxTNzgwMHxTNjAyYnxTNTExMGJ8UzczMDB8UzUzMDB8UzYwMnxTNjAzfFM1MTAwfFM1MTEwfFM2MDF8UzcxMDBhfFAzMDAwRnxQMzAwMHN8UDEwMXxQMjAwc3xQMTAwMG18UDIwMG18UDkxMDB8UDEwMDBzfFM2NjAwYnxTOTA4fFAxMDAwfFAzMDB8UzE4fFM2NjAwfFM5MTAwKVxcXFxiXCIsXG4gICAgICAgIFwiaUpveVRhYmxldFwiOiBcIlRhYmxldCAoU3Bpcml0IDd8RXNzZW50aWF8R2FsYXRlYXxGdXNpb258T25peCA3fExhbmRhfFRpdGFufFNjb29ieXxEZW94fFN0ZWxsYXxUaGVtaXN8QXJnb258VW5pcXVlIDd8U3lnbnVzfEhleGVufEZpbml0eSA3fENyZWFtfENyZWFtIFgyfEphZGV8TmVvbiA3fE5lcm9uIDd8S2FuZHl8U2NhcGV8U2FwaHlyIDd8UmViZWx8QmlveHxSZWJlbHxSZWJlbCA4R0J8TXlzdHxEcmFjbyA3fE15c3R8VGFiNy0wMDR8TXlzdHxUYWRlbyBKb25lc3xUYWJsZXQgQm9pbmd8QXJyb3d8RHJhY28gRHVhbCBDYW18QXVyaXh8TWludHxBbWl0eXxSZXZvbHV0aW9ufEZpbml0eSA5fE5lb24gOXxUOXd8QW1pdHkgNEdCIER1YWwgQ2FtfFN0b25lIDRHQnxTdG9uZSA4R0J8QW5kcm9tZWRhfFNpbGtlbnxYMnxBbmRyb21lZGEgSUl8SGFsbGV5fEZsYW1lfFNhcGh5ciA5LDd8VG91Y2ggOHxQbGFuZXR8VHJpdG9ufFVuaXF1ZSAxMHxIZXhlbiAxMHxNZW1waGlzIDRHQnxNZW1waGlzIDhHQnxPbml4IDEwKVwiLFxuICAgICAgICBcIkZYMlRhYmxldFwiOiBcIkZYMiBQQUQ3fEZYMiBQQUQxMFwiLFxuICAgICAgICBcIlhvcm9UYWJsZXRcIjogXCJLaWRzUEFEIDcwMXxQQURbIF0/NzEyfFBBRFsgXT83MTR8UEFEWyBdPzcxNnxQQURbIF0/NzE3fFBBRFsgXT83MTh8UEFEWyBdPzcyMHxQQURbIF0/NzIxfFBBRFsgXT83MjJ8UEFEWyBdPzc5MHxQQURbIF0/NzkyfFBBRFsgXT85MDB8UEFEWyBdPzk3MTVEfFBBRFsgXT85NzE2RFJ8UEFEWyBdPzk3MThEUnxQQURbIF0/OTcxOVFSfFBBRFsgXT85NzIwUVJ8VGVsZVBBRDEwMzB8VGVsZXBhZDEwMzJ8VGVsZVBBRDczMHxUZWxlUEFENzMxfFRlbGVQQUQ3MzJ8VGVsZVBBRDczNVF8VGVsZVBBRDgzMHxUZWxlUEFEOTczMHxUZWxlUEFENzk1fE1lZ2FQQUQgMTMzMXxNZWdhUEFEIDE4NTF8TWVnYVBBRCAyMTUxXCIsXG4gICAgICAgIFwiVmlld3NvbmljVGFibGV0XCI6IFwiVmlld1BhZCAxMHBpfFZpZXdQYWQgMTBlfFZpZXdQYWQgMTBzfFZpZXdQYWQgRTcyfFZpZXdQYWQ3fFZpZXdQYWQgRTEwMHxWaWV3UGFkIDdlfFZpZXdTb25pYyBWQjczM3xWQjEwMGFcIixcbiAgICAgICAgXCJWZXJpem9uVGFibGV0XCI6IFwiUVRBUVozfFFUQUlSN3xRVEFRVFozfFFUQVNVTjF8UVRBU1VOMnxRVEFYSUExXCIsXG4gICAgICAgIFwiT2R5c1RhYmxldFwiOiBcIkxPT1h8WEVOTzEwfE9EWVNbIC1dKFNwYWNlfEVWT3xYcHJlc3N8Tk9PTil8XFxcXGJYRUxJT1xcXFxifFhlbGlvMTBQcm98WEVMSU83UEhPTkVUQUJ8WEVMSU8xMEVYVFJFTUV8WEVMSU9QVDJ8TkVPX1FVQUQxMFwiLFxuICAgICAgICBcIkNhcHRpdmFUYWJsZXRcIjogXCJDQVBUSVZBIFBBRFwiLFxuICAgICAgICBcIkljb25iaXRUYWJsZXRcIjogXCJOZXRUQUJ8TlQtMzcwMnxOVC0zNzAyU3xOVC0zNzAyU3xOVC0zNjAzUHxOVC0zNjAzUHxOVC0wNzA0U3xOVC0wNzA0U3xOVC0zODA1Q3xOVC0zODA1Q3xOVC0wODA2Q3xOVC0wODA2Q3xOVC0wOTA5VHxOVC0wOTA5VHxOVC0wOTA3U3xOVC0wOTA3U3xOVC0wOTAyU3xOVC0wOTAyU1wiLFxuICAgICAgICBcIlRlY2xhc3RUYWJsZXRcIjogXCJUOTggNEd8XFxcXGJQODBcXFxcYnxcXFxcYlg5MEhEXFxcXGJ8WDk4IEFpcnxYOTggQWlyIDNHfFxcXFxiWDg5XFxcXGJ8UDgwIDNHfFxcXFxiWDgwaFxcXFxifFA5OCBBaXJ8XFxcXGJYODlIRFxcXFxifFA5OCAzR3xcXFxcYlA5MEhEXFxcXGJ8UDg5IDNHfFg5OCAzR3xcXFxcYlA3MGhcXFxcYnxQNzlIRCAzR3xHMThkIDNHfFxcXFxiUDc5SERcXFxcYnxcXFxcYlA4OXNcXFxcYnxcXFxcYkE4OFxcXFxifFxcXFxiUDEwSERcXFxcYnxcXFxcYlAxOUhEXFxcXGJ8RzE4IDNHfFxcXFxiUDc4SERcXFxcYnxcXFxcYkE3OFxcXFxifFxcXFxiUDc1XFxcXGJ8RzE3cyAzR3xHMTdoIDNHfFxcXFxiUDg1dFxcXFxifFxcXFxiUDkwXFxcXGJ8XFxcXGJQMTFcXFxcYnxcXFxcYlA5OHRcXFxcYnxcXFxcYlA5OEhEXFxcXGJ8XFxcXGJHMThkXFxcXGJ8XFxcXGJQODVzXFxcXGJ8XFxcXGJQMTFIRFxcXFxifFxcXFxiUDg4c1xcXFxifFxcXFxiQTgwSERcXFxcYnxcXFxcYkE4MHNlXFxcXGJ8XFxcXGJBMTBoXFxcXGJ8XFxcXGJQODlcXFxcYnxcXFxcYlA3OHNcXFxcYnxcXFxcYkcxOFxcXFxifFxcXFxiUDg1XFxcXGJ8XFxcXGJBNzBoXFxcXGJ8XFxcXGJBNzBcXFxcYnxcXFxcYkcxN1xcXFxifFxcXFxiUDE4XFxcXGJ8XFxcXGJBODBzXFxcXGJ8XFxcXGJBMTFzXFxcXGJ8XFxcXGJQODhIRFxcXFxifFxcXFxiQTgwaFxcXFxifFxcXFxiUDc2c1xcXFxifFxcXFxiUDc2aFxcXFxifFxcXFxiUDk4XFxcXGJ8XFxcXGJBMTBIRFxcXFxifFxcXFxiUDc4XFxcXGJ8XFxcXGJQODhcXFxcYnxcXFxcYkExMVxcXFxifFxcXFxiQTEwdFxcXFxifFxcXFxiUDc2YVxcXFxifFxcXFxiUDc2dFxcXFxifFxcXFxiUDc2ZVxcXFxifFxcXFxiUDg1SERcXFxcYnxcXFxcYlA4NWFcXFxcYnxcXFxcYlA4NlxcXFxifFxcXFxiUDc1SERcXFxcYnxcXFxcYlA3NnZcXFxcYnxcXFxcYkExMlxcXFxifFxcXFxiUDc1YVxcXFxifFxcXFxiQTE1XFxcXGJ8XFxcXGJQNzZUaVxcXFxifFxcXFxiUDgxSERcXFxcYnxcXFxcYkExMFxcXFxifFxcXFxiVDc2MFZFXFxcXGJ8XFxcXGJUNzIwSERcXFxcYnxcXFxcYlA3NlxcXFxifFxcXFxiUDczXFxcXGJ8XFxcXGJQNzFcXFxcYnxcXFxcYlA3MlxcXFxifFxcXFxiVDcyMFNFXFxcXGJ8XFxcXGJDNTIwVGlcXFxcYnxcXFxcYlQ3NjBcXFxcYnxcXFxcYlQ3MjBWRVxcXFxifFQ3MjAtM0dFfFQ3MjAtV2lGaVwiLFxuICAgICAgICBcIk9uZGFUYWJsZXRcIjogXCJcXFxcYihWOTc1aXxWaTMwfFZYNTMwfFY3MDF8Vmk2MHxWNzAxc3xWaTUwfFY4MDFzfFY3MTl8Vng2MTB3fFZYNjEwV3xWODE5aXxWaTEwfFZYNTgwV3xWaTEwfFY3MTFzfFY4MTN8VjgxMXxWODIwd3xWODIwfFZpMjB8VjcxMXxWSTMwV3xWNzEyfFY4OTF3fFY5NzJ8VjgxOXd8VjgyMHd8Vmk2MHxWODIwd3xWNzExfFY4MTNzfFY4MDF8VjgxOXxWOTc1c3xWODAxfFY4MTl8VjgxOXxWODE4fFY4MTF8VjcxMnxWOTc1bXxWMTAxd3xWOTYxd3xWODEyfFY4MTh8Vjk3MXxWOTcxc3xWOTE5fFY5ODl8VjExNnd8VjEwMnd8Vjk3M3xWaTQwKVxcXFxiW1xcXFxzXSt8VjEwIFxcXFxiNEdcXFxcYlwiLFxuICAgICAgICBcIkpheXRlY2hUYWJsZXRcIjogXCJUUEMtUEE3NjJcIixcbiAgICAgICAgXCJCbGF1cHVua3RUYWJsZXRcIjogXCJFbmRlYXZvdXIgODAwTkd8RW5kZWF2b3VyIDEwMTBcIixcbiAgICAgICAgXCJEaWdtYVRhYmxldFwiOiBcIlxcXFxiKGlEeDEwfGlEeDl8aUR4OHxpRHg3fGlEeEQ3fGlEeEQ4fGlEc1E4fGlEc1E3fGlEc1E4fGlEc0QxMHxpRG5EN3wzVFM4MDRIfGlEc1ExMXxpRGo3fGlEczEwKVxcXFxiXCIsXG4gICAgICAgIFwiRXZvbGlvVGFibGV0XCI6IFwiQVJJQV9NaW5pX3dpZml8QXJpYVsgX11NaW5pfEV2b2xpbyBYMTB8RXZvbGlvIFg3fEV2b2xpbyBYOHxcXFxcYkV2b3RhYlxcXFxifFxcXFxiTmV1cmFcXFxcYlwiLFxuICAgICAgICBcIkxhdmFUYWJsZXRcIjogXCJRUEFEIEU3MDR8XFxcXGJJdm9yeVNcXFxcYnxFLVRBQiBJVk9SWXxcXFxcYkUtVEFCXFxcXGJcIixcbiAgICAgICAgXCJBb2NUYWJsZXRcIjogXCJNVzA4MTF8TVcwODEyfE1XMDkyMnxNVEs4MzgyfE1XMTAzMXxNVzA4MzF8TVcwODIxfE1XMDkzMXxNVzA3MTJcIixcbiAgICAgICAgXCJNcG1hblRhYmxldFwiOiBcIk1QMTEgT0NUQXxNUDEwIE9DVEF8TVBRQzExMTR8TVBRQzEwMDR8TVBRQzk5NHxNUFFDOTc0fE1QUUM5NzN8TVBRQzgwNHxNUFFDNzg0fE1QUUM3ODB8XFxcXGJNUEc3XFxcXGJ8TVBEQ0c3NXxNUERDRzcxfE1QREMxMDA2fE1QMTAxREN8TVBEQzkwMDB8TVBEQzkwNXxNUERDNzA2SER8TVBEQzcwNnxNUERDNzA1fE1QREMxMTB8TVBEQzEwMHxNUERDOTl8TVBEQzk3fE1QREM4OHxNUERDOHxNUERDNzd8TVA3MDl8TUlENzAxfE1JRDcxMXxNSUQxNzB8TVBEQzcwM3xNUFFDMTAxMFwiLFxuICAgICAgICBcIkNlbGtvblRhYmxldFwiOiBcIkNUNjk1fENUODg4fENUW1xcXFxzXT85MTB8Q1Q3IFRhYnxDVDkgVGFifENUMyBUYWJ8Q1QyIFRhYnxDVDEgVGFifEM4MjB8QzcyMHxcXFxcYkNULTFcXFxcYlwiLFxuICAgICAgICBcIldvbGRlclRhYmxldFwiOiBcIm1pVGFiIFxcXFxiKERJQU1PTkR8U1BBQ0V8QlJPT0tMWU58TkVPfEZMWXxNQU5IQVRUQU58RlVOS3xFVk9MVVRJT058U0tZfEdPQ0FSfElST058R0VOSVVTfFBPUHxNSU5UfEVQU0lMT058QlJPQURXQVl8SlVNUHxIT1B8TEVHRU5EfE5FVyBBR0V8TElORXxBRFZBTkNFfEZFRUx8Rk9MTE9XfExJS0V8TElOS3xMSVZFfFRISU5LfEZSRUVET018Q0hJQ0FHT3xDTEVWRUxBTkR8QkFMVElNT1JFLUdIfElPV0F8Qk9TVE9OfFNFQVRUTEV8UEhPRU5JWHxEQUxMQVN8SU4gMTAxfE1hc3RlckNoZWYpXFxcXGJcIixcbiAgICAgICAgXCJNZWRpYWNvbVRhYmxldFwiOiBcIk0tTVBJMTBDM0d8TS1TUDEwRUd8TS1TUDEwRUdQfE0tU1AxMEhYQUh8TS1TUDdIWEFIfE0tU1AxMEhYQkh8TS1TUDhIWEFIfE0tU1A4TVhBXCIsXG4gICAgICAgIFwiTWlUYWJsZXRcIjogXCJcXFxcYk1JIFBBRFxcXFxifFxcXFxiSE0gTk9URSAxV1xcXFxiXCIsXG4gICAgICAgIFwiTmliaXJ1VGFibGV0XCI6IFwiTmliaXJ1IE0xfE5pYmlydSBKdXBpdGVyIE9uZVwiLFxuICAgICAgICBcIk5leG9UYWJsZXRcIjogXCJORVhPIE5PVkF8TkVYTyAxMHxORVhPIEFWSU98TkVYTyBGUkVFfE5FWE8gR098TkVYTyBFVk98TkVYTyAzR3xORVhPIFNNQVJUfE5FWE8gS0lERE98TkVYTyBNT0JJXCIsXG4gICAgICAgIFwiTGVhZGVyVGFibGV0XCI6IFwiVEJMVDEwUXxUQkxUMTBJfFRCTC0xMFdES0J8VEJMLTEwV0RLQk8yMDEzfFRCTC1XMjMwVjJ8VEJMLVc0NTB8VEJMLVc1MDB8U1Y1NzJ8VEJMVDdJfFRCQS1BQzctOEd8VEJMVDc5fFRCTC04VzE2fFRCTC0xMFczMnxUQkwtMTBXS0J8VEJMLVcxMDBcIixcbiAgICAgICAgXCJVYmlzbGF0ZVRhYmxldFwiOiBcIlViaVNsYXRlW1xcXFxzXT83Q1wiLFxuICAgICAgICBcIlBvY2tldEJvb2tUYWJsZXRcIjogXCJQb2NrZXRib29rXCIsXG4gICAgICAgIFwiS29jYXNvVGFibGV0XCI6IFwiXFxcXGIoVEItMTIwNylcXFxcYlwiLFxuICAgICAgICBcIkhpc2Vuc2VUYWJsZXRcIjogXCJcXFxcYihGNTI4MXxFMjM3MSlcXFxcYlwiLFxuICAgICAgICBcIkh1ZGxcIjogXCJIdWRsIEhUN1MzfEh1ZGwgMlwiLFxuICAgICAgICBcIlRlbHN0cmFUYWJsZXRcIjogXCJULUh1YjJcIixcbiAgICAgICAgXCJHZW5lcmljVGFibGV0XCI6IFwiQW5kcm9pZC4qXFxcXGI5N0RcXFxcYnxUYWJsZXQoPyEuKlBDKXxCTlRWMjUwQXxNSUQtV0NETUF8TG9naWNQRCBab29tMnxcXFxcYkE3RUJcXFxcYnxDYXROb3ZhOHxBMV8wN3xDVDcwNHxDVDEwMDJ8XFxcXGJNNzIxXFxcXGJ8cmszMHNka3xcXFxcYkVWT1RBQlxcXFxifE03NThBfEVUOTA0fEFMVU1JVU0xMHxTbWFydGZyZW4gVGFifEVuZGVhdm91ciAxMDEwfFRhYmxldC1QQy00fFRhZ2kgVGFifFxcXFxiTTZwcm9cXFxcYnxDVDEwMjBXfGFyYyAxMEhEfFxcXFxiVFA3NTBcXFxcYnxcXFxcYlFUQVFaM1xcXFxifFdWVDEwMXxUTTEwODh8S1QxMDdcIlxuICAgIH0sXG4gICAgXCJvc3NcIjoge1xuICAgICAgICBcIkFuZHJvaWRPU1wiOiBcIkFuZHJvaWRcIixcbiAgICAgICAgXCJCbGFja0JlcnJ5T1NcIjogXCJibGFja2JlcnJ5fFxcXFxiQkIxMFxcXFxifHJpbSB0YWJsZXQgb3NcIixcbiAgICAgICAgXCJQYWxtT1NcIjogXCJQYWxtT1N8YXZhbnRnb3xibGF6ZXJ8ZWxhaW5lfGhpcHRvcHxwYWxtfHBsdWNrZXJ8eGlpbm9cIixcbiAgICAgICAgXCJTeW1iaWFuT1NcIjogXCJTeW1iaWFufFN5bWJPU3xTZXJpZXM2MHxTZXJpZXM0MHxTWUItWzAtOV0rfFxcXFxiUzYwXFxcXGJcIixcbiAgICAgICAgXCJXaW5kb3dzTW9iaWxlT1NcIjogXCJXaW5kb3dzIENFLiooUFBDfFNtYXJ0cGhvbmV8TW9iaWxlfFswLTldezN9eFswLTldezN9KXxXaW5kb3cgTW9iaWxlfFdpbmRvd3MgUGhvbmUgWzAtOS5dK3xXQ0U7XCIsXG4gICAgICAgIFwiV2luZG93c1Bob25lT1NcIjogXCJXaW5kb3dzIFBob25lIDEwLjB8V2luZG93cyBQaG9uZSA4LjF8V2luZG93cyBQaG9uZSA4LjB8V2luZG93cyBQaG9uZSBPU3xYQkxXUDd8WnVuZVdQN3xXaW5kb3dzIE5UIDYuWzIzXTsgQVJNO1wiLFxuICAgICAgICBcImlPU1wiOiBcIlxcXFxiaVBob25lLipNb2JpbGV8XFxcXGJpUG9kfFxcXFxiaVBhZHxBcHBsZUNvcmVNZWRpYVwiLFxuICAgICAgICBcIk1lZUdvT1NcIjogXCJNZWVHb1wiLFxuICAgICAgICBcIk1hZW1vT1NcIjogXCJNYWVtb1wiLFxuICAgICAgICBcIkphdmFPU1wiOiBcIkoyTUVcXC98XFxcXGJNSURQXFxcXGJ8XFxcXGJDTERDXFxcXGJcIixcbiAgICAgICAgXCJ3ZWJPU1wiOiBcIndlYk9TfGhwd09TXCIsXG4gICAgICAgIFwiYmFkYU9TXCI6IFwiXFxcXGJCYWRhXFxcXGJcIixcbiAgICAgICAgXCJCUkVXT1NcIjogXCJCUkVXXCJcbiAgICB9LFxuICAgIFwidWFzXCI6IHtcbiAgICAgICAgXCJDaHJvbWVcIjogXCJcXFxcYkNyTW9cXFxcYnxDcmlPU3xBbmRyb2lkLipDaHJvbWVcXC9bLjAtOV0qIChNb2JpbGUpP1wiLFxuICAgICAgICBcIkRvbGZpblwiOiBcIlxcXFxiRG9sZmluXFxcXGJcIixcbiAgICAgICAgXCJPcGVyYVwiOiBcIk9wZXJhLipNaW5pfE9wZXJhLipNb2JpfEFuZHJvaWQuKk9wZXJhfE1vYmlsZS4qT1BSXFwvWzAtOS5dKyR8Q29hc3RcXC9bMC05Ll0rXCIsXG4gICAgICAgIFwiU2t5ZmlyZVwiOiBcIlNreWZpcmVcIixcbiAgICAgICAgXCJFZGdlXCI6IFwiTW9iaWxlIFNhZmFyaVxcL1suMC05XSogRWRnZVwiLFxuICAgICAgICBcIklFXCI6IFwiSUVNb2JpbGV8TVNJRU1vYmlsZVwiLFxuICAgICAgICBcIkZpcmVmb3hcIjogXCJmZW5uZWN8ZmlyZWZveC4qbWFlbW98KE1vYmlsZXxUYWJsZXQpLipGaXJlZm94fEZpcmVmb3guKk1vYmlsZXxGeGlPU1wiLFxuICAgICAgICBcIkJvbHRcIjogXCJib2x0XCIsXG4gICAgICAgIFwiVGVhU2hhcmtcIjogXCJ0ZWFzaGFya1wiLFxuICAgICAgICBcIkJsYXplclwiOiBcIkJsYXplclwiLFxuICAgICAgICBcIlNhZmFyaVwiOiBcIlZlcnNpb24uKk1vYmlsZS4qU2FmYXJpfFNhZmFyaS4qTW9iaWxlfE1vYmlsZVNhZmFyaVwiLFxuICAgICAgICBcIldlQ2hhdFwiOiBcIlxcXFxiTWljcm9NZXNzZW5nZXJcXFxcYlwiLFxuICAgICAgICBcIlVDQnJvd3NlclwiOiBcIlVDLipCcm93c2VyfFVDV0VCXCIsXG4gICAgICAgIFwiYmFpZHVib3hhcHBcIjogXCJiYWlkdWJveGFwcFwiLFxuICAgICAgICBcImJhaWR1YnJvd3NlclwiOiBcImJhaWR1YnJvd3NlclwiLFxuICAgICAgICBcIkRpaWdvQnJvd3NlclwiOiBcIkRpaWdvQnJvd3NlclwiLFxuICAgICAgICBcIlB1ZmZpblwiOiBcIlB1ZmZpblwiLFxuICAgICAgICBcIk1lcmN1cnlcIjogXCJcXFxcYk1lcmN1cnlcXFxcYlwiLFxuICAgICAgICBcIk9iaWdvQnJvd3NlclwiOiBcIk9iaWdvXCIsXG4gICAgICAgIFwiTmV0RnJvbnRcIjogXCJORi1Ccm93c2VyXCIsXG4gICAgICAgIFwiR2VuZXJpY0Jyb3dzZXJcIjogXCJOb2tpYUJyb3dzZXJ8T3ZpQnJvd3NlcnxPbmVCcm93c2VyfFR3b25reUJlYW1Ccm93c2VyfFNFTUMuKkJyb3dzZXJ8Rmx5Rmxvd3xNaW5pbW98TmV0RnJvbnR8Tm92YXJyYS1WaXNpb258TVFRQnJvd3NlcnxNaWNyb01lc3NlbmdlclwiLFxuICAgICAgICBcIlBhbGVNb29uXCI6IFwiQW5kcm9pZC4qUGFsZU1vb258TW9iaWxlLipQYWxlTW9vblwiXG4gICAgfSxcbiAgICBcInByb3BzXCI6IHtcbiAgICAgICAgXCJNb2JpbGVcIjogXCJNb2JpbGVcXC9bVkVSXVwiLFxuICAgICAgICBcIkJ1aWxkXCI6IFwiQnVpbGRcXC9bVkVSXVwiLFxuICAgICAgICBcIlZlcnNpb25cIjogXCJWZXJzaW9uXFwvW1ZFUl1cIixcbiAgICAgICAgXCJWZW5kb3JJRFwiOiBcIlZlbmRvcklEXFwvW1ZFUl1cIixcbiAgICAgICAgXCJpUGFkXCI6IFwiaVBhZC4qQ1BVW2EteiBdK1tWRVJdXCIsXG4gICAgICAgIFwiaVBob25lXCI6IFwiaVBob25lLipDUFVbYS16IF0rW1ZFUl1cIixcbiAgICAgICAgXCJpUG9kXCI6IFwiaVBvZC4qQ1BVW2EteiBdK1tWRVJdXCIsXG4gICAgICAgIFwiS2luZGxlXCI6IFwiS2luZGxlXFwvW1ZFUl1cIixcbiAgICAgICAgXCJDaHJvbWVcIjogW1xuICAgICAgICAgICAgXCJDaHJvbWVcXC9bVkVSXVwiLFxuICAgICAgICAgICAgXCJDcmlPU1xcL1tWRVJdXCIsXG4gICAgICAgICAgICBcIkNyTW9cXC9bVkVSXVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQ29hc3RcIjogW1xuICAgICAgICAgICAgXCJDb2FzdFxcL1tWRVJdXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJEb2xmaW5cIjogXCJEb2xmaW5cXC9bVkVSXVwiLFxuICAgICAgICBcIkZpcmVmb3hcIjogW1xuICAgICAgICAgICAgXCJGaXJlZm94XFwvW1ZFUl1cIixcbiAgICAgICAgICAgIFwiRnhpT1NcXC9bVkVSXVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiRmVubmVjXCI6IFwiRmVubmVjXFwvW1ZFUl1cIixcbiAgICAgICAgXCJFZGdlXCI6IFwiRWRnZVxcL1tWRVJdXCIsXG4gICAgICAgIFwiSUVcIjogW1xuICAgICAgICAgICAgXCJJRU1vYmlsZVxcL1tWRVJdO1wiLFxuICAgICAgICAgICAgXCJJRU1vYmlsZSBbVkVSXVwiLFxuICAgICAgICAgICAgXCJNU0lFIFtWRVJdO1wiLFxuICAgICAgICAgICAgXCJUcmlkZW50XFwvWzAtOS5dKzsuKnJ2OltWRVJdXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJOZXRGcm9udFwiOiBcIk5ldEZyb250XFwvW1ZFUl1cIixcbiAgICAgICAgXCJOb2tpYUJyb3dzZXJcIjogXCJOb2tpYUJyb3dzZXJcXC9bVkVSXVwiLFxuICAgICAgICBcIk9wZXJhXCI6IFtcbiAgICAgICAgICAgIFwiIE9QUlxcL1tWRVJdXCIsXG4gICAgICAgICAgICBcIk9wZXJhIE1pbmlcXC9bVkVSXVwiLFxuICAgICAgICAgICAgXCJWZXJzaW9uXFwvW1ZFUl1cIlxuICAgICAgICBdLFxuICAgICAgICBcIk9wZXJhIE1pbmlcIjogXCJPcGVyYSBNaW5pXFwvW1ZFUl1cIixcbiAgICAgICAgXCJPcGVyYSBNb2JpXCI6IFwiVmVyc2lvblxcL1tWRVJdXCIsXG4gICAgICAgIFwiVUNCcm93c2VyXCI6IFtcbiAgICAgICAgICAgIFwiVUNXRUJbVkVSXVwiLFxuICAgICAgICAgICAgXCJVQy4qQnJvd3NlclxcL1tWRVJdXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNUVFCcm93c2VyXCI6IFwiTVFRQnJvd3NlclxcL1tWRVJdXCIsXG4gICAgICAgIFwiTWljcm9NZXNzZW5nZXJcIjogXCJNaWNyb01lc3NlbmdlclxcL1tWRVJdXCIsXG4gICAgICAgIFwiYmFpZHVib3hhcHBcIjogXCJiYWlkdWJveGFwcFxcL1tWRVJdXCIsXG4gICAgICAgIFwiYmFpZHVicm93c2VyXCI6IFwiYmFpZHVicm93c2VyXFwvW1ZFUl1cIixcbiAgICAgICAgXCJTYW1zdW5nQnJvd3NlclwiOiBcIlNhbXN1bmdCcm93c2VyXFwvW1ZFUl1cIixcbiAgICAgICAgXCJJcm9uXCI6IFwiSXJvblxcL1tWRVJdXCIsXG4gICAgICAgIFwiU2FmYXJpXCI6IFtcbiAgICAgICAgICAgIFwiVmVyc2lvblxcL1tWRVJdXCIsXG4gICAgICAgICAgICBcIlNhZmFyaVxcL1tWRVJdXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJTa3lmaXJlXCI6IFwiU2t5ZmlyZVxcL1tWRVJdXCIsXG4gICAgICAgIFwiVGl6ZW5cIjogXCJUaXplblxcL1tWRVJdXCIsXG4gICAgICAgIFwiV2Via2l0XCI6IFwid2Via2l0WyBcXC9dW1ZFUl1cIixcbiAgICAgICAgXCJQYWxlTW9vblwiOiBcIlBhbGVNb29uXFwvW1ZFUl1cIixcbiAgICAgICAgXCJHZWNrb1wiOiBcIkdlY2tvXFwvW1ZFUl1cIixcbiAgICAgICAgXCJUcmlkZW50XCI6IFwiVHJpZGVudFxcL1tWRVJdXCIsXG4gICAgICAgIFwiUHJlc3RvXCI6IFwiUHJlc3RvXFwvW1ZFUl1cIixcbiAgICAgICAgXCJHb2FubmFcIjogXCJHb2FubmFcXC9bVkVSXVwiLFxuICAgICAgICBcImlPU1wiOiBcIiBcXFxcYmk/T1NcXFxcYiBbVkVSXVsgO117MX1cIixcbiAgICAgICAgXCJBbmRyb2lkXCI6IFwiQW5kcm9pZCBbVkVSXVwiLFxuICAgICAgICBcIkJsYWNrQmVycnlcIjogW1xuICAgICAgICAgICAgXCJCbGFja0JlcnJ5W1xcXFx3XStcXC9bVkVSXVwiLFxuICAgICAgICAgICAgXCJCbGFja0JlcnJ5LipWZXJzaW9uXFwvW1ZFUl1cIixcbiAgICAgICAgICAgIFwiVmVyc2lvblxcL1tWRVJdXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJCUkVXXCI6IFwiQlJFVyBbVkVSXVwiLFxuICAgICAgICBcIkphdmFcIjogXCJKYXZhXFwvW1ZFUl1cIixcbiAgICAgICAgXCJXaW5kb3dzIFBob25lIE9TXCI6IFtcbiAgICAgICAgICAgIFwiV2luZG93cyBQaG9uZSBPUyBbVkVSXVwiLFxuICAgICAgICAgICAgXCJXaW5kb3dzIFBob25lIFtWRVJdXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJXaW5kb3dzIFBob25lXCI6IFwiV2luZG93cyBQaG9uZSBbVkVSXVwiLFxuICAgICAgICBcIldpbmRvd3MgQ0VcIjogXCJXaW5kb3dzIENFXFwvW1ZFUl1cIixcbiAgICAgICAgXCJXaW5kb3dzIE5UXCI6IFwiV2luZG93cyBOVCBbVkVSXVwiLFxuICAgICAgICBcIlN5bWJpYW5cIjogW1xuICAgICAgICAgICAgXCJTeW1iaWFuT1NcXC9bVkVSXVwiLFxuICAgICAgICAgICAgXCJTeW1iaWFuXFwvW1ZFUl1cIlxuICAgICAgICBdLFxuICAgICAgICBcIndlYk9TXCI6IFtcbiAgICAgICAgICAgIFwid2ViT1NcXC9bVkVSXVwiLFxuICAgICAgICAgICAgXCJocHdPU1xcL1tWRVJdO1wiXG4gICAgICAgIF1cbiAgICB9LFxuICAgIFwidXRpbHNcIjoge1xuICAgICAgICBcIkJvdFwiOiBcIkdvb2dsZWJvdHxmYWNlYm9va2V4dGVybmFsaGl0fEFkc0JvdC1Hb29nbGV8R29vZ2xlIEtleXdvcmQgU3VnZ2VzdGlvbnxGYWNlYm90fFlhbmRleEJvdHxZYW5kZXhNb2JpbGVCb3R8YmluZ2JvdHxpYV9hcmNoaXZlcnxBaHJlZnNCb3R8RXpvb21zfEdTTEZib3R8V0JTZWFyY2hCb3R8VHdpdHRlcmJvdHxUd2VldG1lbWVCb3R8VHdpa2xlfFBhcGVyTGlCb3R8V290Ym94fFVud2luZEZldGNob3J8RXhhYm90fE1KMTJib3R8WWFuZGV4SW1hZ2VzfFR1cm5pdGluQm90fFBpbmdkb21cIixcbiAgICAgICAgXCJNb2JpbGVCb3RcIjogXCJHb29nbGVib3QtTW9iaWxlfEFkc0JvdC1Hb29nbGUtTW9iaWxlfFlhaG9vU2Vla2VyXFwvTTFBMS1SMkQyXCIsXG4gICAgICAgIFwiRGVza3RvcE1vZGVcIjogXCJXUERlc2t0b3BcIixcbiAgICAgICAgXCJUVlwiOiBcIlNvbnlEVFZ8SGJiVFZcIixcbiAgICAgICAgXCJXZWJLaXRcIjogXCIod2Via2l0KVsgXFwvXShbXFxcXHcuXSspXCIsXG4gICAgICAgIFwiQ29uc29sZVwiOiBcIlxcXFxiKE5pbnRlbmRvfE5pbnRlbmRvIFdpaVV8TmludGVuZG8gM0RTfE5pbnRlbmRvIFN3aXRjaHxQTEFZU1RBVElPTnxYYm94KVxcXFxiXCIsXG4gICAgICAgIFwiV2F0Y2hcIjogXCJTTS1WNzAwXCJcbiAgICB9XG59O1xuXG4gICAgLy8gZm9sbG93aW5nIHBhdHRlcm5zIGNvbWUgZnJvbSBodHRwOi8vZGV0ZWN0bW9iaWxlYnJvd3NlcnMuY29tL1xuICAgIGltcGwuZGV0ZWN0TW9iaWxlQnJvd3NlcnMgPSB7XG4gICAgICAgIGZ1bGxQYXR0ZXJuOiAvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2ksXG4gICAgICAgIHNob3J0UGF0dGVybjogLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2ksXG4gICAgICAgIHRhYmxldFBhdHRlcm46IC9hbmRyb2lkfGlwYWR8cGxheWJvb2t8c2lsay9pXG4gICAgfTtcblxuICAgIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgaXNBcnJheTtcblxuICAgIGltcGwuRkFMTEJBQ0tfUEhPTkUgPSAnVW5rbm93blBob25lJztcbiAgICBpbXBsLkZBTExCQUNLX1RBQkxFVCA9ICdVbmtub3duVGFibGV0JztcbiAgICBpbXBsLkZBTExCQUNLX01PQklMRSA9ICdVbmtub3duTW9iaWxlJztcblxuICAgIGlzQXJyYXkgPSAoJ2lzQXJyYXknIGluIEFycmF5KSA/XG4gICAgICAgIEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7IH07XG5cbiAgICBmdW5jdGlvbiBlcXVhbElDKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYS50b0xvd2VyQ2FzZSgpID09PSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbnNJQyhhcnJheSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlTEMsIGksIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKCFsZW4gfHwgIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVMQyA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlTEMgPT09IGFycmF5W2ldLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFByb3BzVG9SZWdFeHAob2JqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wLmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBuZXcgUmVnRXhwKG9iamVjdFtrZXldLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZVVzZXJBZ2VudCh1c2VyQWdlbnQpIHtcbiAgICAgICAgcmV0dXJuICh1c2VyQWdlbnQgfHwgJycpLnN1YnN0cigwLCA1MDApOyAvLyBtaXRpZ2F0ZSB2dWxuZXJhYmxlIHRvIFJlRG9TXG4gICAgfVxuXG4gICAgKGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHZhciBrZXksIHZhbHVlcywgdmFsdWUsIGksIGxlbiwgdmVyUG9zLCBtb2JpbGVEZXRlY3RSdWxlcyA9IGltcGwubW9iaWxlRGV0ZWN0UnVsZXM7XG4gICAgICAgIGZvciAoa2V5IGluIG1vYmlsZURldGVjdFJ1bGVzLnByb3BzKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKG1vYmlsZURldGVjdFJ1bGVzLnByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gbW9iaWxlRGV0ZWN0UnVsZXMucHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZlclBvcyA9IHZhbHVlLmluZGV4T2YoJ1tWRVJdJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJQb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmVyUG9zKSArICcoW1xcXFx3Ll9cXFxcK10rKScgKyB2YWx1ZS5zdWJzdHJpbmcodmVyUG9zICsgNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ldID0gbmV3IFJlZ0V4cCh2YWx1ZSwgJ2knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9iaWxlRGV0ZWN0UnVsZXMucHJvcHNba2V5XSA9IHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb252ZXJ0UHJvcHNUb1JlZ0V4cChtb2JpbGVEZXRlY3RSdWxlcy5vc3MpO1xuICAgICAgICBjb252ZXJ0UHJvcHNUb1JlZ0V4cChtb2JpbGVEZXRlY3RSdWxlcy5waG9uZXMpO1xuICAgICAgICBjb252ZXJ0UHJvcHNUb1JlZ0V4cChtb2JpbGVEZXRlY3RSdWxlcy50YWJsZXRzKTtcbiAgICAgICAgY29udmVydFByb3BzVG9SZWdFeHAobW9iaWxlRGV0ZWN0UnVsZXMudWFzKTtcbiAgICAgICAgY29udmVydFByb3BzVG9SZWdFeHAobW9iaWxlRGV0ZWN0UnVsZXMudXRpbHMpO1xuXG4gICAgICAgIC8vIGNvcHkgc29tZSBwYXR0ZXJucyB0byBvc3MwIHdoaWNoIGFyZSB0ZXN0ZWQgZmlyc3QgKHNlZSBpc3N1ZSMxNSlcbiAgICAgICAgbW9iaWxlRGV0ZWN0UnVsZXMub3NzMCA9IHtcbiAgICAgICAgICAgIFdpbmRvd3NQaG9uZU9TOiBtb2JpbGVEZXRlY3RSdWxlcy5vc3MuV2luZG93c1Bob25lT1MsXG4gICAgICAgICAgICBXaW5kb3dzTW9iaWxlT1M6IG1vYmlsZURldGVjdFJ1bGVzLm9zcy5XaW5kb3dzTW9iaWxlT1NcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGVzdCB1c2VyQWdlbnQgc3RyaW5nIGFnYWluc3QgYSBzZXQgb2YgcnVsZXMgYW5kIGZpbmQgdGhlIGZpcnN0IG1hdGNoZWQga2V5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBydWxlcyAoa2V5IGlzIFN0cmluZywgdmFsdWUgaXMgUmVnRXhwKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyQWdlbnQgdGhlIG5hdmlnYXRvci51c2VyQWdlbnQgKG9yIEhUVFAtSGVhZGVyICdVc2VyLUFnZW50JykuXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSB0aGUgbWF0Y2hlZCBrZXkgaWYgZm91bmQsIG90aGVyd2lzZSA8dHQ+bnVsbDwvdHQ+XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbXBsLmZpbmRNYXRjaCA9IGZ1bmN0aW9uKHJ1bGVzLCB1c2VyQWdlbnQpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKHJ1bGVzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzW2tleV0udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IHVzZXJBZ2VudCBzdHJpbmcgYWdhaW5zdCBhIHNldCBvZiBydWxlcyBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoZWQga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcnVsZXMgKGtleSBpcyBTdHJpbmcsIHZhbHVlIGlzIFJlZ0V4cClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlckFnZW50IHRoZSBuYXZpZ2F0b3IudXNlckFnZW50IChvciBIVFRQLUhlYWRlciAnVXNlci1BZ2VudCcpLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgbWF0Y2hlZCBrZXlzLCBtYXkgYmUgZW1wdHkgd2hlbiB0aGVyZSBpcyBubyBtYXRjaCwgYnV0IG5vdCA8dHQ+bnVsbDwvdHQ+XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbXBsLmZpbmRNYXRjaGVzID0gZnVuY3Rpb24ocnVsZXMsIHVzZXJBZ2VudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AuY2FsbChydWxlcywga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlc1trZXldLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGUgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaW4gdGhlIFVzZXItQWdlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJBZ2VudFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdmVyc2lvbiBvciA8dHQ+bnVsbDwvdHQ+IGlmIHZlcnNpb24gbm90IGZvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbXBsLmdldFZlcnNpb25TdHIgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCB1c2VyQWdlbnQpIHtcbiAgICAgICAgdmFyIHByb3BzID0gaW1wbC5tb2JpbGVEZXRlY3RSdWxlcy5wcm9wcywgcGF0dGVybnMsIGksIGxlbiwgbWF0Y2g7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wLmNhbGwocHJvcHMsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIHBhdHRlcm5zID0gcHJvcHNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gcGF0dGVybnNbaV0uZXhlYyh1c2VyQWdlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGUgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaW4gdGhlIFVzZXItQWdlbnQuXG4gICAgICogV2lsbCByZXR1cm4gYSBmbG9hdCBudW1iZXIuIChlZy4gMl8wIHdpbGwgcmV0dXJuIDIuMCwgNC4zLjEgd2lsbCByZXR1cm4gNC4zMSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlckFnZW50XG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2ZXJzaW9uIG9yIDx0dD5OYU48L3R0PiBpZiB2ZXJzaW9uIG5vdCBmb3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW1wbC5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgdXNlckFnZW50KSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gaW1wbC5nZXRWZXJzaW9uU3RyKHByb3BlcnR5TmFtZSwgdXNlckFnZW50KTtcbiAgICAgICAgcmV0dXJuIHZlcnNpb24gPyBpbXBsLnByZXBhcmVWZXJzaW9uTm8odmVyc2lvbikgOiBOYU47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnNpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSB2ZXJzaW9uIG51bWJlciBhcyBhIGZsb2F0aW5nIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW1wbC5wcmVwYXJlVmVyc2lvbk5vID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgdmFyIG51bWJlcnM7XG5cbiAgICAgICAgbnVtYmVycyA9IHZlcnNpb24uc3BsaXQoL1thLXouXyBcXC9cXC1dL2kpO1xuICAgICAgICBpZiAobnVtYmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBudW1iZXJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBudW1iZXJzWzBdICsgJy4nO1xuICAgICAgICAgICAgbnVtYmVycy5zaGlmdCgpO1xuICAgICAgICAgICAgdmVyc2lvbiArPSBudW1iZXJzLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIodmVyc2lvbik7XG4gICAgfTtcblxuICAgIGltcGwuaXNNb2JpbGVGYWxsYmFjayA9IGZ1bmN0aW9uICh1c2VyQWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIGltcGwuZGV0ZWN0TW9iaWxlQnJvd3NlcnMuZnVsbFBhdHRlcm4udGVzdCh1c2VyQWdlbnQpIHx8XG4gICAgICAgICAgICBpbXBsLmRldGVjdE1vYmlsZUJyb3dzZXJzLnNob3J0UGF0dGVybi50ZXN0KHVzZXJBZ2VudC5zdWJzdHIoMCw0KSk7XG4gICAgfTtcblxuICAgIGltcGwuaXNUYWJsZXRGYWxsYmFjayA9IGZ1bmN0aW9uICh1c2VyQWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIGltcGwuZGV0ZWN0TW9iaWxlQnJvd3NlcnMudGFibGV0UGF0dGVybi50ZXN0KHVzZXJBZ2VudCk7XG4gICAgfTtcblxuICAgIGltcGwucHJlcGFyZURldGVjdGlvbkNhY2hlID0gZnVuY3Rpb24gKGNhY2hlLCB1c2VyQWdlbnQsIG1heFBob25lV2lkdGgpIHtcbiAgICAgICAgaWYgKGNhY2hlLm1vYmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBob25lLCB0YWJsZXQsIHBob25lU2l6ZWQ7XG5cbiAgICAgICAgLy8gZmlyc3QgY2hlY2sgZm9yIHN0cm9uZ2VyIHRhYmxldCBydWxlcywgdGhlbiBwaG9uZSAoc2VlIGlzc3VlIzUpXG4gICAgICAgIHRhYmxldCA9IGltcGwuZmluZE1hdGNoKGltcGwubW9iaWxlRGV0ZWN0UnVsZXMudGFibGV0cywgdXNlckFnZW50KTtcbiAgICAgICAgaWYgKHRhYmxldCkge1xuICAgICAgICAgICAgY2FjaGUubW9iaWxlID0gY2FjaGUudGFibGV0ID0gdGFibGV0O1xuICAgICAgICAgICAgY2FjaGUucGhvbmUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB1bmFtYmlndW91c2x5IGlkZW50aWZpZWQgYXMgdGFibGV0XG4gICAgICAgIH1cblxuICAgICAgICBwaG9uZSA9IGltcGwuZmluZE1hdGNoKGltcGwubW9iaWxlRGV0ZWN0UnVsZXMucGhvbmVzLCB1c2VyQWdlbnQpO1xuICAgICAgICBpZiAocGhvbmUpIHtcbiAgICAgICAgICAgIGNhY2hlLm1vYmlsZSA9IGNhY2hlLnBob25lID0gcGhvbmU7XG4gICAgICAgICAgICBjYWNoZS50YWJsZXQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB1bmFtYmlndW91c2x5IGlkZW50aWZpZWQgYXMgcGhvbmVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG91ciBydWxlcyBoYXZlbid0IGZvdW5kIGEgbWF0Y2ggLT4gdHJ5IG1vcmUgZ2VuZXJhbCBmYWxsYmFjayBydWxlc1xuICAgICAgICBpZiAoaW1wbC5pc01vYmlsZUZhbGxiYWNrKHVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIHBob25lU2l6ZWQgPSBNb2JpbGVEZXRlY3QuaXNQaG9uZVNpemVkKG1heFBob25lV2lkdGgpO1xuICAgICAgICAgICAgaWYgKHBob25lU2l6ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlLm1vYmlsZSA9IGltcGwuRkFMTEJBQ0tfTU9CSUxFO1xuICAgICAgICAgICAgICAgIGNhY2hlLnRhYmxldCA9IGNhY2hlLnBob25lID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGhvbmVTaXplZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlLm1vYmlsZSA9IGNhY2hlLnBob25lID0gaW1wbC5GQUxMQkFDS19QSE9ORTtcbiAgICAgICAgICAgICAgICBjYWNoZS50YWJsZXQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5tb2JpbGUgPSBjYWNoZS50YWJsZXQgPSBpbXBsLkZBTExCQUNLX1RBQkxFVDtcbiAgICAgICAgICAgICAgICBjYWNoZS5waG9uZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW1wbC5pc1RhYmxldEZhbGxiYWNrKHVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIGNhY2hlLm1vYmlsZSA9IGNhY2hlLnRhYmxldCA9IGltcGwuRkFMTEJBQ0tfVEFCTEVUO1xuICAgICAgICAgICAgY2FjaGUucGhvbmUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IG1vYmlsZSBhdCBhbGwhXG4gICAgICAgICAgICBjYWNoZS5tb2JpbGUgPSBjYWNoZS50YWJsZXQgPSBjYWNoZS5waG9uZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdCBpcyBhIHJlZmVyZW5jZSB0byBhIE1vYmlsZURldGVjdCBpbnN0YW5jZVxuICAgIGltcGwubW9iaWxlR3JhZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAvLyBpbXBsIG5vdGU6XG4gICAgICAgIC8vIFRvIGtlZXAgaW4gc3luYyB3LyBNb2JpbGVfRGV0ZWN0LnBocCBlYXNpbHksIHRoZSBmb2xsb3dpbmcgY29kZSBpcyB0aWdodGx5IGFsaWduZWQgdG8gdGhlIFBIUCB2ZXJzaW9uLlxuICAgICAgICAvLyBXaGVuIGNoYW5nZXMgYXJlIG1hZGUgaW4gTW9iaWxlX0RldGVjdC5waHAsIGNvcHkgdGhpcyBtZXRob2QgYW5kIHJlcGxhY2U6XG4gICAgICAgIC8vICAgICAkdGhpcy0+IC8gdC5cbiAgICAgICAgLy8gICAgIHNlbGY6Ok1PQklMRV9HUkFERV8oLikgLyAnJDEnXG4gICAgICAgIC8vICAgICAsIHNlbGY6OlZFUlNJT05fVFlQRV9GTE9BVCAvIChub3RoaW5nKVxuICAgICAgICAvLyAgICAgaXNJT1MoKSAvIG9zKCdpT1MnKVxuICAgICAgICAvLyAgICAgW3JlZ10gLyAobm90aGluZykgICA8LS0ganNkZWxpdnIgY29tcGxhaW5pbmcgYWJvdXQgdW5lc2NhcGVkIHVuaWNvZGUgY2hhcmFjdGVyIFUrMDBBRVxuICAgICAgICB2YXIgJGlzTW9iaWxlID0gdC5tb2JpbGUoKSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBBcHBsZSBpT1MgMy4yLTUuMSAtIFRlc3RlZCBvbiB0aGUgb3JpZ2luYWwgaVBhZCAoNC4zIC8gNS4wKSwgaVBhZCAyICg0LjMpLCBpUGFkIDMgKDUuMSksIG9yaWdpbmFsIGlQaG9uZSAoMy4xKSwgaVBob25lIDMgKDMuMiksIDNHUyAoNC4zKSwgNCAoNC4zIC8gNS4wKSwgYW5kIDRTICg1LjEpXG4gICAgICAgICAgICB0Lm9zKCdpT1MnKSAmJiB0LnZlcnNpb24oJ2lQYWQnKT49NC4zIHx8XG4gICAgICAgICAgICB0Lm9zKCdpT1MnKSAmJiB0LnZlcnNpb24oJ2lQaG9uZScpPj0zLjEgfHxcbiAgICAgICAgICAgIHQub3MoJ2lPUycpICYmIHQudmVyc2lvbignaVBvZCcpPj0zLjEgfHxcblxuICAgICAgICAgICAgLy8gQW5kcm9pZCAyLjEtMi4zIC0gVGVzdGVkIG9uIHRoZSBIVEMgSW5jcmVkaWJsZSAoMi4yKSwgb3JpZ2luYWwgRHJvaWQgKDIuMiksIEhUQyBBcmlhICgyLjEpLCBHb29nbGUgTmV4dXMgUyAoMi4zKS4gRnVuY3Rpb25hbCBvbiAxLjUgJiAxLjYgYnV0IHBlcmZvcm1hbmNlIG1heSBiZSBzbHVnZ2lzaCwgdGVzdGVkIG9uIEdvb2dsZSBHMSAoMS41KVxuICAgICAgICAgICAgLy8gQW5kcm9pZCAzLjEgKEhvbmV5Y29tYikgIC0gVGVzdGVkIG9uIHRoZSBTYW1zdW5nIEdhbGF4eSBUYWIgMTAuMSBhbmQgTW90b3JvbGEgWE9PTVxuICAgICAgICAgICAgLy8gQW5kcm9pZCA0LjAgKElDUykgIC0gVGVzdGVkIG9uIGEgR2FsYXh5IE5leHVzLiBOb3RlOiB0cmFuc2l0aW9uIHBlcmZvcm1hbmNlIGNhbiBiZSBwb29yIG9uIHVwZ3JhZGVkIGRldmljZXNcbiAgICAgICAgICAgIC8vIEFuZHJvaWQgNC4xIChKZWxseSBCZWFuKSAgLSBUZXN0ZWQgb24gYSBHYWxheHkgTmV4dXMgYW5kIEdhbGF4eSA3XG4gICAgICAgICAgICAoIHQudmVyc2lvbignQW5kcm9pZCcpPjIuMSAmJiB0LmlzKCdXZWJraXQnKSApIHx8XG5cbiAgICAgICAgICAgIC8vIFdpbmRvd3MgUGhvbmUgNy03LjUgLSBUZXN0ZWQgb24gdGhlIEhUQyBTdXJyb3VuZCAoNy4wKSBIVEMgVHJvcGh5ICg3LjUpLCBMRy1FOTAwICg3LjUpLCBOb2tpYSBMdW1pYSA4MDBcbiAgICAgICAgICAgIHQudmVyc2lvbignV2luZG93cyBQaG9uZSBPUycpPj03LjAgfHxcblxuICAgICAgICAgICAgLy8gQmxhY2tiZXJyeSA3IC0gVGVzdGVkIG9uIEJsYWNrQmVycnkgVG9yY2ggOTgxMFxuICAgICAgICAgICAgLy8gQmxhY2tiZXJyeSA2LjAgLSBUZXN0ZWQgb24gdGhlIFRvcmNoIDk4MDAgYW5kIFN0eWxlIDk2NzBcbiAgICAgICAgICAgIHQuaXMoJ0JsYWNrQmVycnknKSAmJiB0LnZlcnNpb24oJ0JsYWNrQmVycnknKT49Ni4wIHx8XG4gICAgICAgICAgICAvLyBCbGFja2JlcnJ5IFBsYXlib29rICgxLjAtMi4wKSAtIFRlc3RlZCBvbiBQbGF5Qm9va1xuICAgICAgICAgICAgdC5tYXRjaCgnUGxheWJvb2suKlRhYmxldCcpIHx8XG5cbiAgICAgICAgICAgIC8vIFBhbG0gV2ViT1MgKDEuNC0yLjApIC0gVGVzdGVkIG9uIHRoZSBQYWxtIFBpeGkgKDEuNCksIFByZSAoMS40KSwgUHJlIDIgKDIuMClcbiAgICAgICAgICAgICggdC52ZXJzaW9uKCd3ZWJPUycpPj0xLjQgJiYgdC5tYXRjaCgnUGFsbXxQcmV8UGl4aScpICkgfHxcbiAgICAgICAgICAgIC8vIFBhbG0gV2ViT1MgMy4wICAtIFRlc3RlZCBvbiBIUCBUb3VjaFBhZFxuICAgICAgICAgICAgdC5tYXRjaCgnaHAuKlRvdWNoUGFkJykgfHxcblxuICAgICAgICAgICAgLy8gRmlyZWZveCBNb2JpbGUgKDEyIEJldGEpIC0gVGVzdGVkIG9uIEFuZHJvaWQgMi4zIGRldmljZVxuICAgICAgICAgICAgKCB0LmlzKCdGaXJlZm94JykgJiYgdC52ZXJzaW9uKCdGaXJlZm94Jyk+PTEyICkgfHxcblxuICAgICAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIC0gVGVzdGVkIG9uIEFuZHJvaWQgNC4wLCA0LjEgZGV2aWNlXG4gICAgICAgICAgICAoIHQuaXMoJ0Nocm9tZScpICYmIHQuaXMoJ0FuZHJvaWRPUycpICYmIHQudmVyc2lvbignQW5kcm9pZCcpPj00LjAgKSB8fFxuXG4gICAgICAgICAgICAvLyBTa3lmaXJlIDQuMSAtIFRlc3RlZCBvbiBBbmRyb2lkIDIuMyBkZXZpY2VcbiAgICAgICAgICAgICggdC5pcygnU2t5ZmlyZScpICYmIHQudmVyc2lvbignU2t5ZmlyZScpPj00LjEgJiYgdC5pcygnQW5kcm9pZE9TJykgJiYgdC52ZXJzaW9uKCdBbmRyb2lkJyk+PTIuMyApIHx8XG5cbiAgICAgICAgICAgIC8vIE9wZXJhIE1vYmlsZSAxMS41LTEyOiBUZXN0ZWQgb24gQW5kcm9pZCAyLjNcbiAgICAgICAgICAgICggdC5pcygnT3BlcmEnKSAmJiB0LnZlcnNpb24oJ09wZXJhIE1vYmknKT4xMSAmJiB0LmlzKCdBbmRyb2lkT1MnKSApIHx8XG5cbiAgICAgICAgICAgIC8vIE1lZWdvIDEuMiAtIFRlc3RlZCBvbiBOb2tpYSA5NTAgYW5kIE45XG4gICAgICAgICAgICB0LmlzKCdNZWVHb09TJykgfHxcblxuICAgICAgICAgICAgLy8gVGl6ZW4gKHByZS1yZWxlYXNlKSAtIFRlc3RlZCBvbiBlYXJseSBoYXJkd2FyZVxuICAgICAgICAgICAgdC5pcygnVGl6ZW4nKSB8fFxuXG4gICAgICAgICAgICAvLyBTYW1zdW5nIEJhZGEgMi4wIC0gVGVzdGVkIG9uIGEgU2Ftc3VuZyBXYXZlIDMsIERvbHBoaW4gYnJvd3NlclxuICAgICAgICAgICAgLy8gQHRvZG86IG1vcmUgdGVzdHMgaGVyZSFcbiAgICAgICAgICAgIHQuaXMoJ0RvbGZpbicpICYmIHQudmVyc2lvbignQmFkYScpPj0yLjAgfHxcblxuICAgICAgICAgICAgLy8gVUMgQnJvd3NlciAtIFRlc3RlZCBvbiBBbmRyb2lkIDIuMyBkZXZpY2VcbiAgICAgICAgICAgICggKHQuaXMoJ1VDIEJyb3dzZXInKSB8fCB0LmlzKCdEb2xmaW4nKSkgJiYgdC52ZXJzaW9uKCdBbmRyb2lkJyk+PTIuMyApIHx8XG5cbiAgICAgICAgICAgIC8vIEtpbmRsZSAzIGFuZCBGaXJlICAtIFRlc3RlZCBvbiB0aGUgYnVpbHQtaW4gV2ViS2l0IGJyb3dzZXIgZm9yIGVhY2hcbiAgICAgICAgICAgICggdC5tYXRjaCgnS2luZGxlIEZpcmUnKSB8fFxuICAgICAgICAgICAgICAgIHQuaXMoJ0tpbmRsZScpICYmIHQudmVyc2lvbignS2luZGxlJyk+PTMuMCApIHx8XG5cbiAgICAgICAgICAgIC8vIE5vb2sgQ29sb3IgMS40LjEgLSBUZXN0ZWQgb24gb3JpZ2luYWwgTm9vayBDb2xvciwgbm90IE5vb2sgVGFibGV0XG4gICAgICAgICAgICB0LmlzKCdBbmRyb2lkT1MnKSAmJiB0LmlzKCdOb29rVGFibGV0JykgfHxcblxuICAgICAgICAgICAgLy8gQ2hyb21lIERlc2t0b3AgMTEtMjEgLSBUZXN0ZWQgb24gT1MgWCAxMC43IGFuZCBXaW5kb3dzIDdcbiAgICAgICAgICAgIHQudmVyc2lvbignQ2hyb21lJyk+PTExICYmICEkaXNNb2JpbGUgfHxcblxuICAgICAgICAgICAgLy8gU2FmYXJpIERlc2t0b3AgNC01IC0gVGVzdGVkIG9uIE9TIFggMTAuNyBhbmQgV2luZG93cyA3XG4gICAgICAgICAgICB0LnZlcnNpb24oJ1NhZmFyaScpPj01LjAgJiYgISRpc01vYmlsZSB8fFxuXG4gICAgICAgICAgICAvLyBGaXJlZm94IERlc2t0b3AgNC0xMyAtIFRlc3RlZCBvbiBPUyBYIDEwLjcgYW5kIFdpbmRvd3MgN1xuICAgICAgICAgICAgdC52ZXJzaW9uKCdGaXJlZm94Jyk+PTQuMCAmJiAhJGlzTW9iaWxlIHx8XG5cbiAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIDctOSAtIFRlc3RlZCBvbiBXaW5kb3dzIFhQLCBWaXN0YSBhbmQgN1xuICAgICAgICAgICAgdC52ZXJzaW9uKCdNU0lFJyk+PTcuMCAmJiAhJGlzTW9iaWxlIHx8XG5cbiAgICAgICAgICAgIC8vIE9wZXJhIERlc2t0b3AgMTAtMTIgLSBUZXN0ZWQgb24gT1MgWCAxMC43IGFuZCBXaW5kb3dzIDdcbiAgICAgICAgICAgIC8vIEByZWZlcmVuY2U6IGh0dHA6Ly9teS5vcGVyYS5jb20vY29tbXVuaXR5L29wZW53ZWIvaWRvcGVyYS9cbiAgICAgICAgICAgIHQudmVyc2lvbignT3BlcmEnKT49MTAgJiYgISRpc01vYmlsZVxuXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgcmV0dXJuICdBJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHQub3MoJ2lPUycpICYmIHQudmVyc2lvbignaVBhZCcpPDQuMyB8fFxuICAgICAgICAgICAgdC5vcygnaU9TJykgJiYgdC52ZXJzaW9uKCdpUGhvbmUnKTwzLjEgfHxcbiAgICAgICAgICAgIHQub3MoJ2lPUycpICYmIHQudmVyc2lvbignaVBvZCcpPDMuMSB8fFxuXG4gICAgICAgICAgICAvLyBCbGFja2JlcnJ5IDUuMDogVGVzdGVkIG9uIHRoZSBTdG9ybSAyIDk1NTAsIEJvbGQgOTc3MFxuICAgICAgICAgICAgdC5pcygnQmxhY2tiZXJyeScpICYmIHQudmVyc2lvbignQmxhY2tCZXJyeScpPj01ICYmIHQudmVyc2lvbignQmxhY2tCZXJyeScpPDYgfHxcblxuICAgICAgICAgICAgLy9PcGVyYSBNaW5pICg1LjAtNi41KSAtIFRlc3RlZCBvbiBpT1MgMy4yLzQuMyBhbmQgQW5kcm9pZCAyLjNcbiAgICAgICAgICAgICggdC52ZXJzaW9uKCdPcGVyYSBNaW5pJyk+PTUuMCAmJiB0LnZlcnNpb24oJ09wZXJhIE1pbmknKTw9Ni41ICYmXG4gICAgICAgICAgICAgICAgKHQudmVyc2lvbignQW5kcm9pZCcpPj0yLjMgfHwgdC5pcygnaU9TJykpICkgfHxcblxuICAgICAgICAgICAgLy8gTm9raWEgU3ltYmlhbl4zIC0gVGVzdGVkIG9uIE5va2lhIE44IChTeW1iaWFuXjMpLCBDNyAoU3ltYmlhbl4zKSwgYWxzbyB3b3JrcyBvbiBOOTcgKFN5bWJpYW5eMSlcbiAgICAgICAgICAgIHQubWF0Y2goJ05va2lhTjh8Tm9raWFDN3xOOTcuKlNlcmllczYwfFN5bWJpYW4vMycpIHx8XG5cbiAgICAgICAgICAgIC8vIEB0b2RvOiByZXBvcnQgdGhpcyAodGVzdGVkIG9uIE5va2lhIE43MSlcbiAgICAgICAgICAgIHQudmVyc2lvbignT3BlcmEgTW9iaScpPj0xMSAmJiB0LmlzKCdTeW1iaWFuT1MnKVxuICAgICAgICAgICAgKXtcbiAgICAgICAgICAgIHJldHVybiAnQic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgIC8vIEJsYWNrYmVycnkgNC54IC0gVGVzdGVkIG9uIHRoZSBDdXJ2ZSA4MzMwXG4gICAgICAgICAgICB0LnZlcnNpb24oJ0JsYWNrQmVycnknKTw1LjAgfHxcbiAgICAgICAgICAgIC8vIFdpbmRvd3MgTW9iaWxlIC0gVGVzdGVkIG9uIHRoZSBIVEMgTGVvIChXaW5NbyA1LjIpXG4gICAgICAgICAgICB0Lm1hdGNoKCdNU0lFTW9iaWxlfFdpbmRvd3MgQ0UuKk1vYmlsZScpIHx8IHQudmVyc2lvbignV2luZG93cyBNb2JpbGUnKTw9NS4yXG5cbiAgICAgICAgICAgICl7XG4gICAgICAgICAgICByZXR1cm4gJ0MnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9BbGwgb2xkZXIgc21hcnRwaG9uZSBwbGF0Zm9ybXMgYW5kIGZlYXR1cmVwaG9uZXMgLSBBbnkgZGV2aWNlIHRoYXQgZG9lc24ndCBzdXBwb3J0IG1lZGlhIHF1ZXJpZXNcbiAgICAgICAgLy93aWxsIHJlY2VpdmUgdGhlIGJhc2ljLCBDIGdyYWRlIGV4cGVyaWVuY2UuXG4gICAgICAgIHJldHVybiAnQyc7XG4gICAgfTtcblxuICAgIGltcGwuZGV0ZWN0T1MgPSBmdW5jdGlvbiAodWEpIHtcbiAgICAgICAgcmV0dXJuIGltcGwuZmluZE1hdGNoKGltcGwubW9iaWxlRGV0ZWN0UnVsZXMub3NzMCwgdWEpIHx8XG4gICAgICAgICAgICBpbXBsLmZpbmRNYXRjaChpbXBsLm1vYmlsZURldGVjdFJ1bGVzLm9zcywgdWEpO1xuICAgIH07XG5cbiAgICBpbXBsLmdldERldmljZVNtYWxsZXJTaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcmVlbi53aWR0aCA8IHdpbmRvdy5zY3JlZW4uaGVpZ2h0ID9cbiAgICAgICAgICAgIHdpbmRvdy5zY3JlZW4ud2lkdGggOlxuICAgICAgICAgICAgd2luZG93LnNjcmVlbi5oZWlnaHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBNb2JpbGVEZXRlY3Qgb2JqZWN0LlxuICAgICAqIDxicj5cbiAgICAgKiBTdWNoIGFuIG9iamVjdCB3aWxsIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIHVzZXItYWdlbnQgc3RyaW5nIGFuZCBjYWNoZSBtb3N0IG9mIHRoZSBkZXRlY3QgcXVlcmllcy48YnI+XG4gICAgICogPGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICNkOWVkZjc7IGJvcmRlcjogMXB4IHNvbGlkICNiY2U4ZjE7IGNvbG9yOiAjM2E4N2FkOyBwYWRkaW5nOiAxNHB4OyBib3JkZXItcmFkaXVzOiAycHg7IG1hcmdpbi10b3A6IDIwcHhcIj5cbiAgICAgKiAgICAgPHN0cm9uZz5GaW5kIGluZm9ybWF0aW9uIGhvdyB0byBkb3dubG9hZCBhbmQgaW5zdGFsbDo8L3N0cm9uZz5cbiAgICAgKiAgICAgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9oZ29lYmwvbW9iaWxlLWRldGVjdC5qcy9cIj5naXRodWIuY29tL2hnb2VibC9tb2JpbGUtZGV0ZWN0LmpzLzwvYT5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxwcmU+XG4gICAgICogICAgIHZhciBtZCA9IG5ldyBNb2JpbGVEZXRlY3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAqICAgICBpZiAobWQubW9iaWxlKCkpIHtcbiAgICAgKiAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSAobWQubW9iaWxlR3JhZGUoKSA9PT0gJ0EnKSA/ICcvbW9iaWxlLycgOiAnL2x5bngvJztcbiAgICAgKiAgICAgfVxuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCB0eXBpY2FsbHkgdGFrZW4gZnJvbSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCBvciBodHRwX2hlYWRlclsnVXNlci1BZ2VudCddXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhQaG9uZVdpZHRoPTYwMF0gPHN0cm9uZz5vbmx5IGZvciBicm93c2Vyczwvc3Ryb25nPiBzcGVjaWZ5IGEgdmFsdWUgZm9yIHRoZSBtYXhpbXVtXG4gICAgICogICAgICAgIHdpZHRoIG9mIHNtYWxsZXN0IGRldmljZSBzaWRlIChpbiBsb2dpY2FsIFwiQ1NTXCIgcGl4ZWxzKSB1bnRpbCBhIGRldmljZSBkZXRlY3RlZCBhcyBtb2JpbGUgd2lsbCBiZSBoYW5kbGVkXG4gICAgICogICAgICAgIGFzIHBob25lLlxuICAgICAqICAgICAgICBUaGlzIGlzIG9ubHkgdXNlZCBpbiBjYXNlcyB3aGVyZSB0aGUgZGV2aWNlIGNhbm5vdCBiZSBjbGFzc2lmaWVkIGFzIHBob25lIG9yIHRhYmxldC48YnI+XG4gICAgICogICAgICAgIFNlZSA8YSBocmVmPVwiaHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9ndWlkZS9wcmFjdGljZXMvc2NyZWVuc19zdXBwb3J0Lmh0bWxcIj5EZWNsYXJpbmcgVGFibGV0IExheW91dHNcbiAgICAgKiAgICAgICAgZm9yIEFuZHJvaWQ8L2E+Ljxicj5cbiAgICAgKiAgICAgICAgSWYgeW91IHByb3ZpZGUgYSB2YWx1ZSA8IDAsIHRoZW4gdGhpcyBcImZ1enp5XCIgY2hlY2sgaXMgZGlzYWJsZWQuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGdsb2JhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vYmlsZURldGVjdCh1c2VyQWdlbnQsIG1heFBob25lV2lkdGgpIHtcbiAgICAgICAgdGhpcy51YSA9IHByZXBhcmVVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgLy82MDBkcCBpcyB0eXBpY2FsIDdcIiB0YWJsZXQgbWluaW11bSB3aWR0aFxuICAgICAgICB0aGlzLm1heFBob25lV2lkdGggPSBtYXhQaG9uZVdpZHRoIHx8IDYwMDtcbiAgICB9XG5cbiAgICBNb2JpbGVEZXRlY3QucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogTW9iaWxlRGV0ZWN0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXRlY3RlZCBwaG9uZSBvciB0YWJsZXQgdHlwZSBvciA8dHQ+bnVsbDwvdHQ+IGlmIGl0IGlzIG5vdCBhIG1vYmlsZSBkZXZpY2UuXG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogRm9yIGEgbGlzdCBvZiBwb3NzaWJsZSByZXR1cm4gdmFsdWVzIHNlZSB7QGxpbmsgTW9iaWxlRGV0ZWN0I3Bob25lfSBhbmQge0BsaW5rIE1vYmlsZURldGVjdCN0YWJsZXR9Ljxicj5cbiAgICAgICAgICogPGJyPlxuICAgICAgICAgKiBJZiB0aGUgZGV2aWNlIGlzIG5vdCBkZXRlY3RlZCBieSB0aGUgcmVndWxhciBleHByZXNzaW9ucyBmcm9tIE1vYmlsZS1EZXRlY3QsIGEgdGVzdCBpcyBtYWRlIGFnYWluc3RcbiAgICAgICAgICogdGhlIHBhdHRlcm5zIG9mIDxhIGhyZWY9XCJodHRwOi8vZGV0ZWN0bW9iaWxlYnJvd3NlcnMuY29tL1wiPmRldGVjdG1vYmlsZWJyb3dzZXJzLmNvbTwvYT4uIElmIHRoaXMgdGVzdFxuICAgICAgICAgKiBpcyBwb3NpdGl2ZSwgYSB2YWx1ZSBvZiA8Y29kZT5Vbmtub3duUGhvbmU8L2NvZGU+LCA8Y29kZT5Vbmtub3duVGFibGV0PC9jb2RlPiBvclxuICAgICAgICAgKiA8Y29kZT5Vbmtub3duTW9iaWxlPC9jb2RlPiBpcyByZXR1cm5lZC48YnI+XG4gICAgICAgICAqIFdoZW4gdXNlZCBpbiBicm93c2VyLCB0aGUgZGVjaXNpb24gd2hldGhlciBwaG9uZSBvciB0YWJsZXQgaXMgbWFkZSBiYXNlZCBvbiA8Y29kZT5zY3JlZW4ud2lkdGgvaGVpZ2h0PC9jb2RlPi48YnI+XG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogV2hlbiB1c2VkIHNlcnZlci1zaWRlIChub2RlLmpzKSwgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiA8Y29kZT5Vbmtub3duVGFibGV0PC9jb2RlPlxuICAgICAgICAgKiBhbmQgPGNvZGU+VW5rbm93bk1vYmlsZTwvY29kZT4sIHNvIHlvdSB3aWxsIGdldCA8Y29kZT5Vbmtub3duTW9iaWxlPC9jb2RlPiBoZXJlLjxicj5cbiAgICAgICAgICogQmUgYXdhcmUgdGhhdCBzaW5jZSB2MS4wLjAgaW4gdGhpcyBzcGVjaWFsIGNhc2UgeW91IHdpbGwgZ2V0IDxjb2RlPlVua25vd25Nb2JpbGU8L2NvZGU+IG9ubHkgZm9yOlxuICAgICAgICAgKiB7QGxpbmsgTW9iaWxlRGV0ZWN0I21vYmlsZX0sIG5vdCBmb3Ige0BsaW5rIE1vYmlsZURldGVjdCNwaG9uZX0gYW5kIHtAbGluayBNb2JpbGVEZXRlY3QjdGFibGV0fS5cbiAgICAgICAgICogSW4gdmVyc2lvbnMgYmVmb3JlIHYxLjAuMCBhbGwgMyBtZXRob2RzIHJldHVybmVkIDxjb2RlPlVua25vd25Nb2JpbGU8L2NvZGU+IHdoaWNoIHdhcyB0ZWRpb3VzIHRvIHVzZS5cbiAgICAgICAgICogPGJyPlxuICAgICAgICAgKiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIHVzZSB0aGUgcmV0dXJuIHZhbHVlIGp1c3QgYXMgYSBib29sZWFuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUga2V5IGZvciB0aGUgcGhvbmUgZmFtaWx5IG9yIHRhYmxldCBmYW1pbHksIGUuZy4gXCJOZXh1c1wiLlxuICAgICAgICAgKiBAZnVuY3Rpb24gTW9iaWxlRGV0ZWN0I21vYmlsZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9iaWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbXBsLnByZXBhcmVEZXRlY3Rpb25DYWNoZSh0aGlzLl9jYWNoZSwgdGhpcy51YSwgdGhpcy5tYXhQaG9uZVdpZHRoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5tb2JpbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRldGVjdGVkIHBob25lIHR5cGUvZmFtaWx5IHN0cmluZyBvciA8dHQ+bnVsbDwvdHQ+LlxuICAgICAgICAgKiA8YnI+XG4gICAgICAgICAqIFRoZSByZXR1cm5lZCB0YWJsZXQgKGZhbWlseSBvciBwcm9kdWNlcikgaXMgb25lIG9mIGZvbGxvd2luZyBrZXlzOjxicj5cbiAgICAgICAgICogPGJyPjx0dD5pUGhvbmUsIEJsYWNrQmVycnksIEhUQywgTmV4dXMsIERlbGwsIE1vdG9yb2xhLCBTYW1zdW5nLCBMRywgU29ueSwgQXN1cyxcbiAgICAgICAgICogTm9raWFMdW1pYSwgTWljcm9tYXgsIFBhbG0sIFZlcnR1LCBQYW50ZWNoLCBGbHksIFdpa28sIGlNb2JpbGUsIFNpbVZhbGxleSxcbiAgICAgICAgICogV29sZmdhbmcsIEFsY2F0ZWwsIE5pbnRlbmRvLCBBbW9pLCBJTlEsIEdlbmVyaWNQaG9uZTwvdHQ+PGJyPlxuICAgICAgICAgKiA8YnI+XG4gICAgICAgICAqIElmIHRoZSBkZXZpY2UgaXMgbm90IGRldGVjdGVkIGJ5IHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIGZyb20gTW9iaWxlLURldGVjdCwgYSB0ZXN0IGlzIG1hZGUgYWdhaW5zdFxuICAgICAgICAgKiB0aGUgcGF0dGVybnMgb2YgPGEgaHJlZj1cImh0dHA6Ly9kZXRlY3Rtb2JpbGVicm93c2Vycy5jb20vXCI+ZGV0ZWN0bW9iaWxlYnJvd3NlcnMuY29tPC9hPi4gSWYgdGhpcyB0ZXN0XG4gICAgICAgICAqIGlzIHBvc2l0aXZlLCBhIHZhbHVlIG9mIDxjb2RlPlVua25vd25QaG9uZTwvY29kZT4gb3IgPGNvZGU+VW5rbm93bk1vYmlsZTwvY29kZT4gaXMgcmV0dXJuZWQuPGJyPlxuICAgICAgICAgKiBXaGVuIHVzZWQgaW4gYnJvd3NlciwgdGhlIGRlY2lzaW9uIHdoZXRoZXIgcGhvbmUgb3IgdGFibGV0IGlzIG1hZGUgYmFzZWQgb24gPGNvZGU+c2NyZWVuLndpZHRoL2hlaWdodDwvY29kZT4uPGJyPlxuICAgICAgICAgKiA8YnI+XG4gICAgICAgICAqIFdoZW4gdXNlZCBzZXJ2ZXItc2lkZSAobm9kZS5qcyksIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gPGNvZGU+VW5rbm93blRhYmxldDwvY29kZT5cbiAgICAgICAgICogYW5kIDxjb2RlPlVua25vd25Nb2JpbGU8L2NvZGU+LCBzbyB5b3Ugd2lsbCBnZXQgPGNvZGU+bnVsbDwvY29kZT4gaGVyZSwgd2hpbGUge0BsaW5rIE1vYmlsZURldGVjdCNtb2JpbGV9XG4gICAgICAgICAqIHdpbGwgcmV0dXJuIDxjb2RlPlVua25vd25Nb2JpbGU8L2NvZGU+Ljxicj5cbiAgICAgICAgICogQmUgYXdhcmUgdGhhdCBzaW5jZSB2MS4wLjAgaW4gdGhpcyBzcGVjaWFsIGNhc2UgeW91IHdpbGwgZ2V0IDxjb2RlPlVua25vd25Nb2JpbGU8L2NvZGU+IG9ubHkgZm9yOlxuICAgICAgICAgKiB7QGxpbmsgTW9iaWxlRGV0ZWN0I21vYmlsZX0sIG5vdCBmb3Ige0BsaW5rIE1vYmlsZURldGVjdCNwaG9uZX0gYW5kIHtAbGluayBNb2JpbGVEZXRlY3QjdGFibGV0fS5cbiAgICAgICAgICogSW4gdmVyc2lvbnMgYmVmb3JlIHYxLjAuMCBhbGwgMyBtZXRob2RzIHJldHVybmVkIDxjb2RlPlVua25vd25Nb2JpbGU8L2NvZGU+IHdoaWNoIHdhcyB0ZWRpb3VzIHRvIHVzZS5cbiAgICAgICAgICogPGJyPlxuICAgICAgICAgKiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIHVzZSB0aGUgcmV0dXJuIHZhbHVlIGp1c3QgYXMgYSBib29sZWFuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUga2V5IG9mIHRoZSBwaG9uZSBmYW1pbHkgb3IgcHJvZHVjZXIsIGUuZy4gXCJpUGhvbmVcIlxuICAgICAgICAgKiBAZnVuY3Rpb24gTW9iaWxlRGV0ZWN0I3Bob25lXG4gICAgICAgICAqL1xuICAgICAgICBwaG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW1wbC5wcmVwYXJlRGV0ZWN0aW9uQ2FjaGUodGhpcy5fY2FjaGUsIHRoaXMudWEsIHRoaXMubWF4UGhvbmVXaWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUucGhvbmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRldGVjdGVkIHRhYmxldCB0eXBlL2ZhbWlseSBzdHJpbmcgb3IgPHR0Pm51bGw8L3R0Pi5cbiAgICAgICAgICogPGJyPlxuICAgICAgICAgKiBUaGUgcmV0dXJuZWQgdGFibGV0IChmYW1pbHkgb3IgcHJvZHVjZXIpIGlzIG9uZSBvZiBmb2xsb3dpbmcga2V5czo8YnI+XG4gICAgICAgICAqIDxicj48dHQ+aVBhZCwgTmV4dXNUYWJsZXQsIEdvb2dsZVRhYmxldCwgU2Ftc3VuZ1RhYmxldCwgS2luZGxlLCBTdXJmYWNlVGFibGV0LFxuICAgICAgICAgKiBIUFRhYmxldCwgQXN1c1RhYmxldCwgQmxhY2tCZXJyeVRhYmxldCwgSFRDdGFibGV0LCBNb3Rvcm9sYVRhYmxldCwgTm9va1RhYmxldCxcbiAgICAgICAgICogQWNlclRhYmxldCwgVG9zaGliYVRhYmxldCwgTEdUYWJsZXQsIEZ1aml0c3VUYWJsZXQsIFByZXN0aWdpb1RhYmxldCxcbiAgICAgICAgICogTGVub3ZvVGFibGV0LCBEZWxsVGFibGV0LCBZYXJ2aWtUYWJsZXQsIE1lZGlvblRhYmxldCwgQXJub3ZhVGFibGV0LFxuICAgICAgICAgKiBJbnRlbnNvVGFibGV0LCBJUlVUYWJsZXQsIE1lZ2Fmb25UYWJsZXQsIEVib2RhVGFibGV0LCBBbGxWaWV3VGFibGV0LFxuICAgICAgICAgKiBBcmNob3NUYWJsZXQsIEFpbm9sVGFibGV0LCBOb2tpYUx1bWlhVGFibGV0LCBTb255VGFibGV0LCBQaGlsaXBzVGFibGV0LFxuICAgICAgICAgKiBDdWJlVGFibGV0LCBDb2J5VGFibGV0LCBNSURUYWJsZXQsIE1TSVRhYmxldCwgU01pVFRhYmxldCwgUm9ja0NoaXBUYWJsZXQsXG4gICAgICAgICAqIEZseVRhYmxldCwgYnFUYWJsZXQsIEh1YXdlaVRhYmxldCwgTmVjVGFibGV0LCBQYW50ZWNoVGFibGV0LCBCcm9uY2hvVGFibGV0LFxuICAgICAgICAgKiBWZXJzdXNUYWJsZXQsIFp5bmNUYWJsZXQsIFBvc2l0aXZvVGFibGV0LCBOYWJpVGFibGV0LCBLb2JvVGFibGV0LCBEYW5ld1RhYmxldCxcbiAgICAgICAgICogVGV4ZXRUYWJsZXQsIFBsYXlzdGF0aW9uVGFibGV0LCBUcmVrc3RvclRhYmxldCwgUHlsZUF1ZGlvVGFibGV0LCBBZHZhblRhYmxldCxcbiAgICAgICAgICogRGFueVRlY2hUYWJsZXQsIEdhbGFwYWRUYWJsZXQsIE1pY3JvbWF4VGFibGV0LCBLYXJib25uVGFibGV0LCBBbGxGaW5lVGFibGV0LFxuICAgICAgICAgKiBQUk9TQ0FOVGFibGV0LCBZT05FU1RhYmxldCwgQ2hhbmdKaWFUYWJsZXQsIEdVVGFibGV0LCBQb2ludE9mVmlld1RhYmxldCxcbiAgICAgICAgICogT3Zlcm1heFRhYmxldCwgSENMVGFibGV0LCBEUFNUYWJsZXQsIFZpc3R1cmVUYWJsZXQsIENyZXN0YVRhYmxldCxcbiAgICAgICAgICogTWVkaWF0ZWtUYWJsZXQsIENvbmNvcmRlVGFibGV0LCBHb0NsZXZlclRhYmxldCwgTW9kZWNvbVRhYmxldCwgVm9uaW5vVGFibGV0LFxuICAgICAgICAgKiBFQ1NUYWJsZXQsIFN0b3JleFRhYmxldCwgVm9kYWZvbmVUYWJsZXQsIEVzc2VudGllbEJUYWJsZXQsIFJvc3NNb29yVGFibGV0LFxuICAgICAgICAgKiBpTW9iaWxlVGFibGV0LCBUb2xpbm9UYWJsZXQsIEF1ZGlvU29uaWNUYWJsZXQsIEFNUEVUYWJsZXQsIFNra1RhYmxldCxcbiAgICAgICAgICogVGVjbm9UYWJsZXQsIEpYRFRhYmxldCwgaUpveVRhYmxldCwgRlgyVGFibGV0LCBYb3JvVGFibGV0LCBWaWV3c29uaWNUYWJsZXQsXG4gICAgICAgICAqIFZlcml6b25UYWJsZXQsIE9keXNUYWJsZXQsIENhcHRpdmFUYWJsZXQsIEljb25iaXRUYWJsZXQsIFRlY2xhc3RUYWJsZXQsXG4gICAgICAgICAqIE9uZGFUYWJsZXQsIEpheXRlY2hUYWJsZXQsIEJsYXVwdW5rdFRhYmxldCwgRGlnbWFUYWJsZXQsIEV2b2xpb1RhYmxldCxcbiAgICAgICAgICogTGF2YVRhYmxldCwgQW9jVGFibGV0LCBNcG1hblRhYmxldCwgQ2Vsa29uVGFibGV0LCBXb2xkZXJUYWJsZXQsIE1lZGlhY29tVGFibGV0LFxuICAgICAgICAgKiBNaVRhYmxldCwgTmliaXJ1VGFibGV0LCBOZXhvVGFibGV0LCBMZWFkZXJUYWJsZXQsIFViaXNsYXRlVGFibGV0LFxuICAgICAgICAgKiBQb2NrZXRCb29rVGFibGV0LCBLb2Nhc29UYWJsZXQsIEhpc2Vuc2VUYWJsZXQsIEh1ZGwsIFRlbHN0cmFUYWJsZXQsXG4gICAgICAgICAqIEdlbmVyaWNUYWJsZXQ8L3R0Pjxicj5cbiAgICAgICAgICogPGJyPlxuICAgICAgICAgKiBJZiB0aGUgZGV2aWNlIGlzIG5vdCBkZXRlY3RlZCBieSB0aGUgcmVndWxhciBleHByZXNzaW9ucyBmcm9tIE1vYmlsZS1EZXRlY3QsIGEgdGVzdCBpcyBtYWRlIGFnYWluc3RcbiAgICAgICAgICogdGhlIHBhdHRlcm5zIG9mIDxhIGhyZWY9XCJodHRwOi8vZGV0ZWN0bW9iaWxlYnJvd3NlcnMuY29tL1wiPmRldGVjdG1vYmlsZWJyb3dzZXJzLmNvbTwvYT4uIElmIHRoaXMgdGVzdFxuICAgICAgICAgKiBpcyBwb3NpdGl2ZSwgYSB2YWx1ZSBvZiA8Y29kZT5Vbmtub3duVGFibGV0PC9jb2RlPiBvciA8Y29kZT5Vbmtub3duTW9iaWxlPC9jb2RlPiBpcyByZXR1cm5lZC48YnI+XG4gICAgICAgICAqIFdoZW4gdXNlZCBpbiBicm93c2VyLCB0aGUgZGVjaXNpb24gd2hldGhlciBwaG9uZSBvciB0YWJsZXQgaXMgbWFkZSBiYXNlZCBvbiA8Y29kZT5zY3JlZW4ud2lkdGgvaGVpZ2h0PC9jb2RlPi48YnI+XG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogV2hlbiB1c2VkIHNlcnZlci1zaWRlIChub2RlLmpzKSwgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiA8Y29kZT5Vbmtub3duVGFibGV0PC9jb2RlPlxuICAgICAgICAgKiBhbmQgPGNvZGU+VW5rbm93bk1vYmlsZTwvY29kZT4sIHNvIHlvdSB3aWxsIGdldCA8Y29kZT5udWxsPC9jb2RlPiBoZXJlLCB3aGlsZSB7QGxpbmsgTW9iaWxlRGV0ZWN0I21vYmlsZX1cbiAgICAgICAgICogd2lsbCByZXR1cm4gPGNvZGU+VW5rbm93bk1vYmlsZTwvY29kZT4uPGJyPlxuICAgICAgICAgKiBCZSBhd2FyZSB0aGF0IHNpbmNlIHYxLjAuMCBpbiB0aGlzIHNwZWNpYWwgY2FzZSB5b3Ugd2lsbCBnZXQgPGNvZGU+VW5rbm93bk1vYmlsZTwvY29kZT4gb25seSBmb3I6XG4gICAgICAgICAqIHtAbGluayBNb2JpbGVEZXRlY3QjbW9iaWxlfSwgbm90IGZvciB7QGxpbmsgTW9iaWxlRGV0ZWN0I3Bob25lfSBhbmQge0BsaW5rIE1vYmlsZURldGVjdCN0YWJsZXR9LlxuICAgICAgICAgKiBJbiB2ZXJzaW9ucyBiZWZvcmUgdjEuMC4wIGFsbCAzIG1ldGhvZHMgcmV0dXJuZWQgPGNvZGU+VW5rbm93bk1vYmlsZTwvY29kZT4gd2hpY2ggd2FzIHRlZGlvdXMgdG8gdXNlLlxuICAgICAgICAgKiA8YnI+XG4gICAgICAgICAqIEluIG1vc3QgY2FzZXMgeW91IHdpbGwgdXNlIHRoZSByZXR1cm4gdmFsdWUganVzdCBhcyBhIGJvb2xlYW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBrZXkgb2YgdGhlIHRhYmxldCBmYW1pbHkgb3IgcHJvZHVjZXIsIGUuZy4gXCJTYW1zdW5nVGFibGV0XCJcbiAgICAgICAgICogQGZ1bmN0aW9uIE1vYmlsZURldGVjdCN0YWJsZXRcbiAgICAgICAgICovXG4gICAgICAgIHRhYmxldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW1wbC5wcmVwYXJlRGV0ZWN0aW9uQ2FjaGUodGhpcy5fY2FjaGUsIHRoaXMudWEsIHRoaXMubWF4UGhvbmVXaWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUudGFibGV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSAoZmlyc3QpIGRldGVjdGVkIHVzZXItYWdlbnQgc3RyaW5nIG9yIDx0dD5udWxsPC90dD4uXG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogVGhlIHJldHVybmVkIHVzZXItYWdlbnQgaXMgb25lIG9mIGZvbGxvd2luZyBrZXlzOjxicj5cbiAgICAgICAgICogPGJyPjx0dD5DaHJvbWUsIERvbGZpbiwgT3BlcmEsIFNreWZpcmUsIEVkZ2UsIElFLCBGaXJlZm94LCBCb2x0LCBUZWFTaGFyaywgQmxhemVyLFxuICAgICAgICAgKiBTYWZhcmksIFdlQ2hhdCwgVUNCcm93c2VyLCBiYWlkdWJveGFwcCwgYmFpZHVicm93c2VyLCBEaWlnb0Jyb3dzZXIsIFB1ZmZpbixcbiAgICAgICAgICogTWVyY3VyeSwgT2JpZ29Ccm93c2VyLCBOZXRGcm9udCwgR2VuZXJpY0Jyb3dzZXIsIFBhbGVNb29uPC90dD48YnI+XG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogSW4gbW9zdCBjYXNlcyBjYWxsaW5nIHtAbGluayBNb2JpbGVEZXRlY3QjdXNlckFnZW50fSB3aWxsIGJlIHN1ZmZpY2llbnQuIEJ1dCB0aGVyZSBhcmUgcmFyZVxuICAgICAgICAgKiBjYXNlcyB3aGVyZSBhIG1vYmlsZSBkZXZpY2UgcHJldGVuZHMgdG8gYmUgbW9yZSB0aGFuIG9uZSBwYXJ0aWN1bGFyIGJyb3dzZXIuIFlvdSBjYW4gZ2V0IHRoZVxuICAgICAgICAgKiBsaXN0IG9mIGFsbCBtYXRjaGVzIHdpdGgge0BsaW5rIE1vYmlsZURldGVjdCN1c2VyQWdlbnRzfSBvciBjaGVjayBmb3IgYSBwYXJ0aWN1bGFyIHZhbHVlIGJ5XG4gICAgICAgICAqIHByb3ZpZGluZyBvbmUgb2YgdGhlIGRlZmluZWQga2V5cyBhcyBmaXJzdCBhcmd1bWVudCB0byB7QGxpbmsgTW9iaWxlRGV0ZWN0I2lzfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGtleSBmb3IgdGhlIGRldGVjdGVkIHVzZXItYWdlbnQgb3IgPHR0Pm51bGw8L3R0PlxuICAgICAgICAgKiBAZnVuY3Rpb24gTW9iaWxlRGV0ZWN0I3VzZXJBZ2VudFxuICAgICAgICAgKi9cbiAgICAgICAgdXNlckFnZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FjaGUudXNlckFnZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS51c2VyQWdlbnQgPSBpbXBsLmZpbmRNYXRjaChpbXBsLm1vYmlsZURldGVjdFJ1bGVzLnVhcywgdGhpcy51YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUudXNlckFnZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBkZXRlY3RlZCB1c2VyLWFnZW50IHN0cmluZ3MuXG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogVGhlIGFycmF5IGlzIGVtcHR5IG9yIGNvbnRhaW5zIG9uZSBvciBtb3JlIG9mIGZvbGxvd2luZyBrZXlzOjxicj5cbiAgICAgICAgICogPGJyPjx0dD5DaHJvbWUsIERvbGZpbiwgT3BlcmEsIFNreWZpcmUsIEVkZ2UsIElFLCBGaXJlZm94LCBCb2x0LCBUZWFTaGFyaywgQmxhemVyLFxuICAgICAgICAgKiBTYWZhcmksIFdlQ2hhdCwgVUNCcm93c2VyLCBiYWlkdWJveGFwcCwgYmFpZHVicm93c2VyLCBEaWlnb0Jyb3dzZXIsIFB1ZmZpbixcbiAgICAgICAgICogTWVyY3VyeSwgT2JpZ29Ccm93c2VyLCBOZXRGcm9udCwgR2VuZXJpY0Jyb3dzZXIsIFBhbGVNb29uPC90dD48YnI+XG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogSW4gbW9zdCBjYXNlcyBjYWxsaW5nIHtAbGluayBNb2JpbGVEZXRlY3QjdXNlckFnZW50fSB3aWxsIGJlIHN1ZmZpY2llbnQuIEJ1dCB0aGVyZSBhcmUgcmFyZVxuICAgICAgICAgKiBjYXNlcyB3aGVyZSBhIG1vYmlsZSBkZXZpY2UgcHJldGVuZHMgdG8gYmUgbW9yZSB0aGFuIG9uZSBwYXJ0aWN1bGFyIGJyb3dzZXIuIFlvdSBjYW4gZ2V0IHRoZVxuICAgICAgICAgKiBsaXN0IG9mIGFsbCBtYXRjaGVzIHdpdGgge0BsaW5rIE1vYmlsZURldGVjdCN1c2VyQWdlbnRzfSBvciBjaGVjayBmb3IgYSBwYXJ0aWN1bGFyIHZhbHVlIGJ5XG4gICAgICAgICAqIHByb3ZpZGluZyBvbmUgb2YgdGhlIGRlZmluZWQga2V5cyBhcyBmaXJzdCBhcmd1bWVudCB0byB7QGxpbmsgTW9iaWxlRGV0ZWN0I2lzfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXJyYXkgb2YgZGV0ZWN0ZWQgdXNlci1hZ2VudCBrZXlzIG9yIDx0dD5bXTwvdHQ+XG4gICAgICAgICAqIEBmdW5jdGlvbiBNb2JpbGVEZXRlY3QjdXNlckFnZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckFnZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLnVzZXJBZ2VudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLnVzZXJBZ2VudHMgPSBpbXBsLmZpbmRNYXRjaGVzKGltcGwubW9iaWxlRGV0ZWN0UnVsZXMudWFzLCB0aGlzLnVhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS51c2VyQWdlbnRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXRlY3RlZCBvcGVyYXRpbmcgc3lzdGVtIHN0cmluZyBvciA8dHQ+bnVsbDwvdHQ+LlxuICAgICAgICAgKiA8YnI+XG4gICAgICAgICAqIFRoZSBvcGVyYXRpbmcgc3lzdGVtIGlzIG9uZSBvZiBmb2xsb3dpbmcga2V5czo8YnI+XG4gICAgICAgICAqIDxicj48dHQ+QW5kcm9pZE9TLCBCbGFja0JlcnJ5T1MsIFBhbG1PUywgU3ltYmlhbk9TLCBXaW5kb3dzTW9iaWxlT1MsIFdpbmRvd3NQaG9uZU9TLFxuICAgICAgICAgKiBpT1MsIE1lZUdvT1MsIE1hZW1vT1MsIEphdmFPUywgd2ViT1MsIGJhZGFPUywgQlJFV09TPC90dD48YnI+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBrZXkgZm9yIHRoZSBkZXRlY3RlZCBvcGVyYXRpbmcgc3lzdGVtLlxuICAgICAgICAgKiBAZnVuY3Rpb24gTW9iaWxlRGV0ZWN0I29zXG4gICAgICAgICAqL1xuICAgICAgICBvczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLm9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5vcyA9IGltcGwuZGV0ZWN0T1ModGhpcy51YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUub3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdmVyc2lvbiAoYXMgTnVtYmVyKSBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaW4gdGhlIFVzZXItQWdlbnQuXG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICogV2lsbCByZXR1cm4gYSBmbG9hdCBudW1iZXIuIChlZy4gMl8wIHdpbGwgcmV0dXJuIDIuMCwgNC4zLjEgd2lsbCByZXR1cm4gNC4zMSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBhIGtleSBkZWZpbmluZyBhIHRoaW5nIHdoaWNoIGhhcyBhIHZlcnNpb24uPGJyPlxuICAgICAgICAgKiAgICAgICAgWW91IGNhbiB1c2Ugb25lIG9mIGZvbGxvd2luZyBrZXlzOjxicj5cbiAgICAgICAgICogPGJyPjx0dD5Nb2JpbGUsIEJ1aWxkLCBWZXJzaW9uLCBWZW5kb3JJRCwgaVBhZCwgaVBob25lLCBpUG9kLCBLaW5kbGUsIENocm9tZSwgQ29hc3QsXG4gICAgICAgICAqIERvbGZpbiwgRmlyZWZveCwgRmVubmVjLCBFZGdlLCBJRSwgTmV0RnJvbnQsIE5va2lhQnJvd3NlciwgT3BlcmEsIE9wZXJhIE1pbmksXG4gICAgICAgICAqIE9wZXJhIE1vYmksIFVDQnJvd3NlciwgTVFRQnJvd3NlciwgTWljcm9NZXNzZW5nZXIsIGJhaWR1Ym94YXBwLCBiYWlkdWJyb3dzZXIsXG4gICAgICAgICAqIFNhbXN1bmdCcm93c2VyLCBJcm9uLCBTYWZhcmksIFNreWZpcmUsIFRpemVuLCBXZWJraXQsIFBhbGVNb29uLCBHZWNrbywgVHJpZGVudCxcbiAgICAgICAgICogUHJlc3RvLCBHb2FubmEsIGlPUywgQW5kcm9pZCwgQmxhY2tCZXJyeSwgQlJFVywgSmF2YSwgV2luZG93cyBQaG9uZSBPUywgV2luZG93c1xuICAgICAgICAgKiBQaG9uZSwgV2luZG93cyBDRSwgV2luZG93cyBOVCwgU3ltYmlhbiwgd2ViT1M8L3R0Pjxicj5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gdGhlIHZlcnNpb24gYXMgZmxvYXQgb3IgPHR0Pk5hTjwvdHQ+IGlmIFVzZXItQWdlbnQgZG9lc24ndCBjb250YWluIHRoaXMgdmVyc2lvbi5cbiAgICAgICAgICogICAgICAgICAgQmUgY2FyZWZ1bCB3aGVuIGNvbXBhcmluZyB0aGlzIHZhbHVlIHdpdGggJz09JyBvcGVyYXRvciFcbiAgICAgICAgICogQGZ1bmN0aW9uIE1vYmlsZURldGVjdCN2ZXJzaW9uXG4gICAgICAgICAqL1xuICAgICAgICB2ZXJzaW9uOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW1wbC5nZXRWZXJzaW9uKGtleSwgdGhpcy51YSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdmVyc2lvbiAoYXMgU3RyaW5nKSBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaW4gdGhlIFVzZXItQWdlbnQuXG4gICAgICAgICAqIDxicj5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBhIGtleSBkZWZpbmluZyBhIHRoaW5nIHdoaWNoIGhhcyBhIHZlcnNpb24uPGJyPlxuICAgICAgICAgKiAgICAgICAgWW91IGNhbiB1c2Ugb25lIG9mIGZvbGxvd2luZyBrZXlzOjxicj5cbiAgICAgICAgICogPGJyPjx0dD5Nb2JpbGUsIEJ1aWxkLCBWZXJzaW9uLCBWZW5kb3JJRCwgaVBhZCwgaVBob25lLCBpUG9kLCBLaW5kbGUsIENocm9tZSwgQ29hc3QsXG4gICAgICAgICAqIERvbGZpbiwgRmlyZWZveCwgRmVubmVjLCBFZGdlLCBJRSwgTmV0RnJvbnQsIE5va2lhQnJvd3NlciwgT3BlcmEsIE9wZXJhIE1pbmksXG4gICAgICAgICAqIE9wZXJhIE1vYmksIFVDQnJvd3NlciwgTVFRQnJvd3NlciwgTWljcm9NZXNzZW5nZXIsIGJhaWR1Ym94YXBwLCBiYWlkdWJyb3dzZXIsXG4gICAgICAgICAqIFNhbXN1bmdCcm93c2VyLCBJcm9uLCBTYWZhcmksIFNreWZpcmUsIFRpemVuLCBXZWJraXQsIFBhbGVNb29uLCBHZWNrbywgVHJpZGVudCxcbiAgICAgICAgICogUHJlc3RvLCBHb2FubmEsIGlPUywgQW5kcm9pZCwgQmxhY2tCZXJyeSwgQlJFVywgSmF2YSwgV2luZG93cyBQaG9uZSBPUywgV2luZG93c1xuICAgICAgICAgKiBQaG9uZSwgV2luZG93cyBDRSwgV2luZG93cyBOVCwgU3ltYmlhbiwgd2ViT1M8L3R0Pjxicj5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIFwicmF3XCIgdmVyc2lvbiBhcyBTdHJpbmcgb3IgPHR0Pm51bGw8L3R0PiBpZiBVc2VyLUFnZW50IGRvZXNuJ3QgY29udGFpbiB0aGlzIHZlcnNpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBmdW5jdGlvbiBNb2JpbGVEZXRlY3QjdmVyc2lvblN0clxuICAgICAgICAgKi9cbiAgICAgICAgdmVyc2lvblN0cjogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGltcGwuZ2V0VmVyc2lvblN0cihrZXksIHRoaXMudWEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHbG9iYWwgdGVzdCBrZXkgYWdhaW5zdCB1c2VyQWdlbnQsIG9zLCBwaG9uZSwgdGFibGV0IGFuZCBzb21lIG90aGVyIHByb3BlcnRpZXMgb2YgdXNlckFnZW50IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IChjYXNlLWluc2Vuc2l0aXZlKSBvZiBhIHVzZXJBZ2VudCwgYW4gb3BlcmF0aW5nIHN5c3RlbSwgcGhvbmUgb3JcbiAgICAgICAgICogICAgICAgIHRhYmxldCBmYW1pbHkuPGJyPlxuICAgICAgICAgKiAgICAgICAgRm9yIGEgY29tcGxldGUgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMsIHNlZSB7QGxpbmsgTW9iaWxlRGV0ZWN0I3VzZXJBZ2VudH0sXG4gICAgICAgICAqICAgICAgICB7QGxpbmsgTW9iaWxlRGV0ZWN0I29zfSwge0BsaW5rIE1vYmlsZURldGVjdCNwaG9uZX0sIHtAbGluayBNb2JpbGVEZXRlY3QjdGFibGV0fS48YnI+XG4gICAgICAgICAqICAgICAgICBBZGRpdGlvbmFsbHkgeW91IGhhdmUgZm9sbG93aW5nIGtleXM6PGJyPlxuICAgICAgICAgKiA8YnI+PHR0PkJvdCwgTW9iaWxlQm90LCBEZXNrdG9wTW9kZSwgVFYsIFdlYktpdCwgQ29uc29sZSwgV2F0Y2g8L3R0Pjxicj5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IDx0dD50cnVlPC90dD4gd2hlbiB0aGUgZ2l2ZW4ga2V5IGlzIG9uZSBvZiB0aGUgZGVmaW5lZCBrZXlzIG9mIHVzZXJBZ2VudCwgb3MsIHBob25lLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgdGFibGV0IG9yIG9uZSBvZiB0aGUgbGlzdGVkIGFkZGl0aW9uYWwga2V5cywgb3RoZXJ3aXNlIDx0dD5mYWxzZTwvdHQ+XG4gICAgICAgICAqIEBmdW5jdGlvbiBNb2JpbGVEZXRlY3QjaXNcbiAgICAgICAgICovXG4gICAgICAgIGlzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNJQyh0aGlzLnVzZXJBZ2VudHMoKSwga2V5KSB8fFxuICAgICAgICAgICAgICAgICAgIGVxdWFsSUMoa2V5LCB0aGlzLm9zKCkpIHx8XG4gICAgICAgICAgICAgICAgICAgZXF1YWxJQyhrZXksIHRoaXMucGhvbmUoKSkgfHxcbiAgICAgICAgICAgICAgICAgICBlcXVhbElDKGtleSwgdGhpcy50YWJsZXQoKSkgfHxcbiAgICAgICAgICAgICAgICAgICBjb250YWluc0lDKGltcGwuZmluZE1hdGNoZXMoaW1wbC5tb2JpbGVEZXRlY3RSdWxlcy51dGlscywgdGhpcy51YSksIGtleSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvIGEgcXVpY2sgdGVzdCBhZ2FpbnN0IG5hdmlnYXRvcjo6dXNlckFnZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHBhdHRlcm4gdGhlIHBhdHRlcm4sIGVpdGhlciBhcyBTdHJpbmcgb3IgUmVnRXhwXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgKGEgc3RyaW5nIHdpbGwgYmUgY29udmVydGVkIHRvIGEgY2FzZS1pbnNlbnNpdGl2ZSBSZWdFeHApLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gPHR0PnRydWU8L3R0PiB3aGVuIHRoZSBwYXR0ZXJuIG1hdGNoZXMsIG90aGVyd2lzZSA8dHQ+ZmFsc2U8L3R0PlxuICAgICAgICAgKiBAZnVuY3Rpb24gTW9iaWxlRGV0ZWN0I21hdGNoXG4gICAgICAgICAqL1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmICghKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodGhpcy51YSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBtb2JpbGUgZGV2aWNlIGNhbiBiZSBjb25zaWRlcmVkIGFzIHBob25lIHJlZ2FyZGluZyA8Y29kZT5zY3JlZW4ud2lkdGg8L2NvZGU+LlxuICAgICAgICAgKiA8YnI+XG4gICAgICAgICAqIE9idmlvdXNseSB0aGlzIG1ldGhvZCBtYWtlcyBzZW5zZSBpbiBicm93c2VyIGVudmlyb25tZW50cyBvbmx5IChub3QgZm9yIE5vZGUuanMpIVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFBob25lV2lkdGhdIHRoZSBtYXhpbXVtIGxvZ2ljYWwgcGl4ZWxzIChha2EuIENTUy1waXhlbHMpIHRvIGJlIGNvbnNpZGVyZWQgYXMgcGhvbmUuPGJyPlxuICAgICAgICAgKiAgICAgICAgVGhlIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGFuZCBpZiBub3QgcHJlc2VudCBvciBmYWxzeSwgdGhlIHZhbHVlIG9mIHRoZSBjb25zdHJ1Y3RvciBpcyB0YWtlbi5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfSA8Y29kZT51bmRlZmluZWQ8L2NvZGU+IGlmIHNjcmVlbiBzaXplIHdhc24ndCBkZXRlY3RhYmxlLCBlbHNlIDxjb2RlPnRydWU8L2NvZGU+XG4gICAgICAgICAqICAgICAgICAgIHdoZW4gc2NyZWVuLndpZHRoIGlzIGxlc3Mgb3IgZXF1YWwgdG8gbWF4UGhvbmVXaWR0aCwgb3RoZXJ3aXNlIDxjb2RlPmZhbHNlPC9jb2RlPi48YnI+XG4gICAgICAgICAqICAgICAgICAgIFdpbGwgYWx3YXlzIHJldHVybiA8Y29kZT51bmRlZmluZWQ8L2NvZGU+IHNlcnZlci1zaWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNQaG9uZVNpemVkOiBmdW5jdGlvbiAobWF4UGhvbmVXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vYmlsZURldGVjdC5pc1Bob25lU2l6ZWQobWF4UGhvbmVXaWR0aCB8fCB0aGlzLm1heFBob25lV2lkdGgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtb2JpbGUgZ3JhZGUgKCdBJywgJ0InLCAnQycpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBvbmUgb2YgdGhlIG1vYmlsZSBncmFkZXMgKCdBJywgJ0InLCAnQycpLlxuICAgICAgICAgKiBAZnVuY3Rpb24gTW9iaWxlRGV0ZWN0I21vYmlsZUdyYWRlXG4gICAgICAgICAqL1xuICAgICAgICBtb2JpbGVHcmFkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmdyYWRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5ncmFkZSA9IGltcGwubW9iaWxlR3JhZGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ3JhZGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZW52aXJvbm1lbnQtZGVwZW5kZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5zY3JlZW4pIHtcbiAgICAgICAgTW9iaWxlRGV0ZWN0LmlzUGhvbmVTaXplZCA9IGZ1bmN0aW9uIChtYXhQaG9uZVdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4UGhvbmVXaWR0aCA8IDAgPyB1bmRlZmluZWQgOiBpbXBsLmdldERldmljZVNtYWxsZXJTaWRlKCkgPD0gbWF4UGhvbmVXaWR0aDtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBNb2JpbGVEZXRlY3QuaXNQaG9uZVNpemVkID0gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgLy8gc2hvdWxkIG5vdCBiZSByZXBsYWNlZCBieSBhIGNvbXBsZXRlbHkgbmV3IG9iamVjdCAtIGp1c3Qgb3ZlcndyaXRlIGV4aXN0aW5nIG1ldGhvZHNcbiAgICBNb2JpbGVEZXRlY3QuX2ltcGwgPSBpbXBsO1xuICAgIFxuICAgIE1vYmlsZURldGVjdC52ZXJzaW9uID0gJzEuNC4zIDIwMTgtMDktMDgnO1xuXG4gICAgcmV0dXJuIE1vYmlsZURldGVjdDtcbn0pOyAvLyBlbmQgb2YgY2FsbCBvZiBkZWZpbmUoKVxufSkoKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZhY3RvcnkpIHsgd2luZG93Lk1vYmlsZURldGVjdCA9IGZhY3RvcnkoKTsgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwbGVhc2UgZmlsZSBhIGJ1ZyBpZiB5b3UgZ2V0IHRoaXMgZXJyb3IhXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBlbnZpcm9ubWVudCcpO1xuICAgIH1cbn0pKCkpOyIsImltcG9ydCBJbnB1dE1vZHVsZSBmcm9tICcuL0lucHV0TW9kdWxlJztcblxuLyoqXG4gKiBgRE9NRXZlbnRTdWJtb2R1bGVgIGNsYXNzLlxuICogVGhlIGBET01FdmVudFN1Ym1vZHVsZWAgY2xhc3MgYWxsb3dzIHRvIGluc3RhbnRpYXRlIG1vZHVsZXMgdGhhdCBwcm92aWRlXG4gKiB1bmlmaWVkIHZhbHVlcyAoc3VjaCBhcyBgQWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAsIGBBY2NlbGVyYXRpb25gLFxuICogYFJvdGF0aW9uUmF0ZWAsIGBPcmllbnRhdGlvbmAsIGBPcmllbnRhdGlvbkFsdCkgZnJvbSB0aGUgYGRldmljZW1vdGlvbmBcbiAqIG9yIGBkZXZpY2VvcmllbnRhdGlvbmAgRE9NIGV2ZW50cy5cbiAqXG4gKiBAY2xhc3MgRE9NRXZlbnRTdWJtb2R1bGVcbiAqIEBleHRlbmRzIElucHV0TW9kdWxlXG4gKi9cbmNsYXNzIERPTUV2ZW50U3VibW9kdWxlIGV4dGVuZHMgSW5wdXRNb2R1bGUge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYERPTUV2ZW50U3VibW9kdWxlYCBtb2R1bGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0RldmljZU1vdGlvbk1vZHVsZXxEZXZpY2VPcmllbnRhdGlvbk1vZHVsZX0gRE9NRXZlbnRNb2R1bGUgLSBUaGUgcGFyZW50IERPTSBldmVudCBtb2R1bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgc3VibW9kdWxlIC8gZXZlbnQgKCplLmcuKiAnYWNjZWxlcmF0aW9uJyBvciAnb3JpZW50YXRpb25BbHQnKS5cbiAgICogQHNlZSBEZXZpY2VNb3Rpb25Nb2R1bGVcbiAgICogQHNlZSBEZXZpY2VPcmllbnRhdGlvbk1vZHVsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoRE9NRXZlbnRNb2R1bGUsIGV2ZW50VHlwZSkge1xuICAgIHN1cGVyKGV2ZW50VHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIGV2ZW50IHBhcmVudCBtb2R1bGUgZnJvbSB3aGljaCB0aGlzIG1vZHVsZSBnZXRzIHRoZSByYXcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHRoaXMgRE9NRXZlbnRTdWJtb2R1bGVcbiAgICAgKiBAdHlwZSB7RGV2aWNlTW90aW9uTW9kdWxlfERldmljZU9yaWVudGF0aW9uTW9kdWxlfVxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIHRoaXMuRE9NRXZlbnRNb2R1bGUgPSBET01FdmVudE1vZHVsZTtcblxuICAgIC8qKlxuICAgICAqIFJhdyB2YWx1ZXMgY29taW5nIGZyb20gdGhlIGBkZXZpY2Vtb3Rpb25gIGV2ZW50IHNlbnQgYnkgdGhpcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAdGhpcyBET01FdmVudFN1Ym1vZHVsZVxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgKiBAZGVmYXVsdCBbMCwgMCwgMF1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50ID0gWzAsIDAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQ29tcGFzcyBoZWFkaW5nIHJlZmVyZW5jZSAoaU9TIGRldmljZXMgb25seSwgYE9yaWVudGF0aW9uYCBhbmQgYE9yaWVudGF0aW9uQWx0YCBzdWJtb2R1bGVzIG9ubHkpLlxuICAgICAqXG4gICAgICogQHRoaXMgRE9NRXZlbnRTdWJtb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0aGlzLl93ZWJraXRDb21wYXNzSGVhZGluZ1JlZmVyZW5jZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgb2YgdGhlIG1vZHVsZS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGluaXQoKSB7XG4gICAgLy8gSW5kaWNhdGUgdG8gdGhlIHBhcmVudCBtb2R1bGUgdGhhdCB0aGlzIGV2ZW50IGlzIHJlcXVpcmVkXG4gICAgdGhpcy5ET01FdmVudE1vZHVsZS5yZXF1aXJlZFt0aGlzLmV2ZW50VHlwZV0gPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHBhcmVudCBldmVudCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LCBpbml0aWFsaXplIGl0XG4gICAgbGV0IERPTUV2ZW50UHJvbWlzZSA9IHRoaXMuRE9NRXZlbnRNb2R1bGUucHJvbWlzZTtcbiAgICBpZiAoIURPTUV2ZW50UHJvbWlzZSlcbiAgICAgIERPTUV2ZW50UHJvbWlzZSA9IHRoaXMuRE9NRXZlbnRNb2R1bGUuaW5pdCgpO1xuXG4gICAgcmV0dXJuIERPTUV2ZW50UHJvbWlzZS50aGVuKChtb2R1bGUpID0+IHRoaXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERPTUV2ZW50U3VibW9kdWxlO1xuIiwiaW1wb3J0IElucHV0TW9kdWxlIGZyb20gJy4vSW5wdXRNb2R1bGUnO1xuaW1wb3J0IERPTUV2ZW50U3VibW9kdWxlIGZyb20gJy4vRE9NRXZlbnRTdWJtb2R1bGUnO1xuaW1wb3J0IE1vdGlvbklucHV0IGZyb20gJy4vTW90aW9uSW5wdXQnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ3BsYXRmb3JtJztcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IGxvY2FsIHRpbWUgaW4gc2Vjb25kcy5cbiAqIFVzZXMgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgaWYgYXZhaWxhYmxlLCBhbmQgYERhdGUubm93KClgIG90aGVyd2lzZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsVGltZSgpIHtcbiAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSlcbiAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC8gMTAwMDtcbiAgcmV0dXJuIERhdGUubm93KCkgLyAxMDAwO1xufVxuXG5jb25zdCBjaHJvbWVSZWdFeHAgPSAvQ2hyb21lLztcbmNvbnN0IHRvRGVnID0gMTgwIC8gTWF0aC5QSTtcblxuLyoqXG4gKiBgRGV2aWNlTW90aW9uYCBtb2R1bGUgc2luZ2xldG9uLlxuICogVGhlIGBEZXZpY2VNb3Rpb25Nb2R1bGVgIHNpbmdsZXRvbiBwcm92aWRlcyB0aGUgcmF3IHZhbHVlc1xuICogb2YgdGhlIGFjY2VsZXJhdGlvbiBpbmNsdWRpbmcgZ3Jhdml0eSwgYWNjZWxlcmF0aW9uLCBhbmQgcm90YXRpb25cbiAqIHJhdGUgcHJvdmlkZWQgYnkgdGhlIGBEZXZpY2VNb3Rpb25gIGV2ZW50LlxuICogSXQgYWxzbyBpbnN0YW50aWF0ZSB0aGUgYEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgLFxuICogYEFjY2VsZXJhdGlvbmAgYW5kIGBSb3RhdGlvblJhdGVgIHN1Ym1vZHVsZXMgdGhhdCB1bmlmeSB0aG9zZSB2YWx1ZXNcbiAqIGFjcm9zcyBwbGF0Zm9ybXMgYnkgbWFraW5nIHRoZW0gY29tcGxpYW50IHdpdGgge0BsaW5rXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9vcmllbnRhdGlvbi1ldmVudC98dGhlIFczQyBzdGFuZGFyZH0uXG4gKiBXaGVuIHJhdyB2YWx1ZXMgYXJlIG5vdCBwcm92aWRlZCBieSB0aGUgc2Vuc29ycywgdGhpcyBtb2R1bGVzIHRyaWVzXG4gKiB0byByZWNhbGN1bGF0ZSB0aGVtIGZyb20gYXZhaWxhYmxlIHZhbHVlczpcbiAqIC0gYGFjY2VsZXJhdGlvbmAgaXMgY2FsY3VsYXRlZCBmcm9tIGBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5YFxuICogICB3aXRoIGEgaGlnaC1wYXNzIGZpbHRlcjtcbiAqIC0gKGNvbWluZyBzb29uIOKAlCB3YWl0aW5nIGZvciBhIGJ1ZyBvbiBDaHJvbWUgdG8gYmUgcmVzb2x2ZWQpXG4gKiAgIGByb3RhdGlvblJhdGVgIGlzIGNhbGN1bGF0ZWQgZnJvbSBgb3JpZW50YXRpb25gLlxuICpcbiAqIEBjbGFzcyBEZXZpY2VNb3Rpb25Nb2R1bGVcbiAqIEBleHRlbmRzIElucHV0TW9kdWxlXG4gKi9cbmNsYXNzIERldmljZU1vdGlvbk1vZHVsZSBleHRlbmRzIElucHV0TW9kdWxlIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgYERldmljZU1vdGlvbmAgbW9kdWxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdkZXZpY2Vtb3Rpb24nKTtcblxuICAgIC8qKlxuICAgICAqIFJhdyB2YWx1ZXMgY29taW5nIGZyb20gdGhlIGBkZXZpY2Vtb3Rpb25gIGV2ZW50IHNlbnQgYnkgdGhpcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAdGhpcyBEZXZpY2VNb3Rpb25Nb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICogQGRlZmF1bHQgW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdXG4gICAgICovXG4gICAgdGhpcy5ldmVudCA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgQWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgbW9kdWxlLlxuICAgICAqIFByb3ZpZGVzIHVuaWZpZWQgdmFsdWVzIG9mIHRoZSBhY2NlbGVyYXRpb24gaW5jbHVkaW5nIGdyYXZpdHkuXG4gICAgICpcbiAgICAgKiBAdGhpcyBEZXZpY2VNb3Rpb25Nb2R1bGVcbiAgICAgKiBAdHlwZSB7RE9NRXZlbnRTdWJtb2R1bGV9XG4gICAgICovXG4gICAgdGhpcy5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5ID0gbmV3IERPTUV2ZW50U3VibW9kdWxlKHRoaXMsICdhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYEFjY2VsZXJhdGlvbmAgc3VibW9kdWxlLlxuICAgICAqIFByb3ZpZGVzIHVuaWZpZWQgdmFsdWVzIG9mIHRoZSBhY2NlbGVyYXRpb24uXG4gICAgICogRXN0aW1hdGVzIHRoZSBhY2NlbGVyYXRpb24gdmFsdWVzIGZyb20gYGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgXG4gICAgICogcmF3IHZhbHVlcyBpZiB0aGUgYWNjZWxlcmF0aW9uIHJhdyB2YWx1ZXMgYXJlIG5vdCBhdmFpbGFibGUgb24gdGhlXG4gICAgICogZGV2aWNlLlxuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlTW90aW9uTW9kdWxlXG4gICAgICogQHR5cGUge0RPTUV2ZW50U3VibW9kdWxlfVxuICAgICAqL1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IERPTUV2ZW50U3VibW9kdWxlKHRoaXMsICdhY2NlbGVyYXRpb24nKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgUm90YXRpb25SYXRlYCBzdWJtb2R1bGUuXG4gICAgICogUHJvdmlkZXMgdW5pZmllZCB2YWx1ZXMgb2YgdGhlIHJvdGF0aW9uIHJhdGUuXG4gICAgICogKGNvbWluZyBzb29uLCB3YWl0aW5nIGZvciBhIGJ1ZyBvbiBDaHJvbWUgdG8gYmUgcmVzb2x2ZWQpXG4gICAgICogRXN0aW1hdGVzIHRoZSByb3RhdGlvbiByYXRlIHZhbHVlcyBmcm9tIGBvcmllbnRhdGlvbmAgdmFsdWVzIGlmXG4gICAgICogdGhlIHJvdGF0aW9uIHJhdGUgcmF3IHZhbHVlcyBhcmUgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGV2aWNlLlxuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlTW90aW9uTW9kdWxlXG4gICAgICogQHR5cGUge0RPTUV2ZW50U3VibW9kdWxlfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25SYXRlID0gbmV3IERPTUV2ZW50U3VibW9kdWxlKHRoaXMsICdyb3RhdGlvblJhdGUnKTtcblxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIHN1Ym1vZHVsZXMgLyBldmVudHMuXG4gICAgICpcbiAgICAgKiBAdGhpcyBEZXZpY2VNb3Rpb25Nb2R1bGVcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbH0gYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgdW5pZmllZCB2YWx1ZXMgYXJlIHJlcXVpcmVkIG9yIG5vdCAoZGVmYXVsdHMgdG8gYGZhbHNlYCkuXG4gICAgICogQHByb3BlcnR5IHtib29sfSBhY2NlbGVyYXRpb24gLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYGFjY2VsZXJhdGlvbmAgdW5pZmllZCB2YWx1ZXMgYXJlIHJlcXVpcmVkIG9yIG5vdCAoZGVmYXVsdHMgdG8gYGZhbHNlYCkuXG4gICAgICogQHByb3BlcnR5IHtib29sfSByb3RhdGlvblJhdGUgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYHJvdGF0aW9uUmF0ZWAgdW5pZmllZCB2YWx1ZXMgYXJlIHJlcXVpcmVkIG9yIG5vdCAoZGVmYXVsdHMgdG8gYGZhbHNlYCkuXG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlZCA9IHtcbiAgICAgIGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHk6IGZhbHNlLFxuICAgICAgYWNjZWxlcmF0aW9uOiBmYWxzZSxcbiAgICAgIHJvdGF0aW9uUmF0ZTogZmFsc2VcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBmdW5jdGlvbiBvZiB0aGUgbW9kdWxlJ3MgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU1vdGlvbk1vZHVsZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQHNlZSBEZXZpY2VNb3Rpb25Nb2R1bGUjaW5pdFxuICAgICAqL1xuICAgIHRoaXMuX3Byb21pc2VSZXNvbHZlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFVuaWZ5aW5nIGZhY3RvciBvZiB0aGUgbW90aW9uIGRhdGEgdmFsdWVzIChgMWAgb24gQW5kcm9pZCwgYC0xYCBvbiBpT1MpLlxuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlTW90aW9uTW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl91bmlmeU1vdGlvbkRhdGEgPSAocGxhdGZvcm0ub3MuZmFtaWx5ID09PSAnaU9TJykgPyAtMSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBVbmlmeWluZyBmYWN0b3Igb2YgdGhlIHBlcmlvZCAoYDFgIG9uIEFuZHJvaWQsIGAxYCBvbiBpT1MpLiBpbiBzZWNcbiAgICAgKiBAdG9kbyAtIHVuaWZ5IHdpdGggZS5pbnRlcnZhbCBzcGVjaWZpY2F0aW9uIChpbiBtcykgP1xuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlTW90aW9uTW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl91bmlmeVBlcmlvZCA9IChwbGF0Zm9ybS5vcy5mYW1pbHkgPT09ICdBbmRyb2lkJykgPyAwLjAwMSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBBY2NlbGVyYXRpb24gY2FsY3VsYXRlZCBmcm9tIHRoZSBgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgcmF3IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU1vdGlvbk1vZHVsZVxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgKiBAZGVmYXVsdCBbMCwgMCwgMF1cbiAgICAgKi9cbiAgICB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uID0gWzAsIDAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogVGltZSBjb25zdGFudCAoaGFsZi1saWZlKSBvZiB0aGUgaGlnaC1wYXNzIGZpbHRlciB1c2VkIHRvIHNtb290aCB0aGUgYWNjZWxlcmF0aW9uIHZhbHVlcyBjYWxjdWxhdGVkIGZyb20gdGhlIGFjY2VsZXJhdGlvbiBpbmNsdWRpbmcgZ3Jhdml0eSByYXcgdmFsdWVzIChpbiBzZWNvbmRzKS5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU1vdGlvbk1vZHVsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgdGhpcy5fY2FsY3VsYXRlZEFjY2VsZXJhdGlvblRpbWVDb25zdGFudCA9IDAuMTtcblxuICAgIC8qKlxuICAgICAqIExhdGVzdCBgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgcmF3IHZhbHVlLCB1c2VkIGluIHRoZSBoaWdoLXBhc3MgZmlsdGVyIHRvIGNhbGN1bGF0ZSB0aGUgYWNjZWxlcmF0aW9uIChpZiB0aGUgYGFjY2VsZXJhdGlvbmAgdmFsdWVzIGFyZSBub3QgcHJvdmlkZWQgYnkgYCdkZXZpY2Vtb3Rpb24nYCkuXG4gICAgICpcbiAgICAgKiBAdGhpcyBEZXZpY2VNb3Rpb25Nb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICogQGRlZmF1bHQgWzAsIDAsIDBdXG4gICAgICovXG4gICAgdGhpcy5fbGFzdEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgPSBbMCwgMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGlvbiByYXRlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgb3JpZW50YXRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlTW90aW9uTW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IFswLCAwLCAwXVxuICAgICAqL1xuICAgIHRoaXMuX2NhbGN1bGF0ZWRSb3RhdGlvblJhdGUgPSBbMCwgMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBMYXRlc3Qgb3JpZW50YXRpb24gdmFsdWUsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSByb3RhdGlvbiByYXRlICAoaWYgdGhlIGByb3RhdGlvblJhdGVgIHZhbHVlcyBhcmUgbm90IHByb3ZpZGVkIGJ5IGAnZGV2aWNlbW90aW9uJ2ApLlxuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlTW90aW9uTW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IFswLCAwLCAwXVxuICAgICAqL1xuICAgIHRoaXMuX2xhc3RPcmllbnRhdGlvbiA9IFswLCAwLCAwXTtcblxuICAgIC8qKlxuICAgICAqIExhdGVzdCBvcmllbnRhdGlvbiB0aW1lc3RhbXBzLCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gcmF0ZSAoaWYgdGhlIGByb3RhdGlvblJhdGVgIHZhbHVlcyBhcmUgbm90IHByb3ZpZGVkIGJ5IGAnZGV2aWNlbW90aW9uJ2ApLlxuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlTW90aW9uTW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IFswLCAwLCAwXVxuICAgICAqL1xuICAgIHRoaXMuX2xhc3RPcmllbnRhdGlvblRpbWVzdGFtcCA9IG51bGw7XG5cbiAgICB0aGlzLl9wcm9jZXNzRnVuY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuX3Byb2Nlc3MgPSB0aGlzLl9wcm9jZXNzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZGV2aWNlbW90aW9uQ2hlY2sgPSB0aGlzLl9kZXZpY2Vtb3Rpb25DaGVjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2RldmljZW1vdGlvbkxpc3RlbmVyID0gdGhpcy5fZGV2aWNlbW90aW9uTGlzdGVuZXIuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2NoZWNrQ291bnRlciA9IDA7XG4gIH1cblxuICAvKipcbiAgICogRGVjYXkgZmFjdG9yIG9mIHRoZSBoaWdoLXBhc3MgZmlsdGVyIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBhY2NlbGVyYXRpb24gZnJvbSB0aGUgYGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgIHJhdyB2YWx1ZXMuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IF9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uRGVjYXkoKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0yICogTWF0aC5QSSAqIHRoaXMuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS5wZXJpb2QgLyB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uVGltZUNvbnN0YW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5zb3IgY2hlY2sgb24gaW5pdGlhbGl6YXRpb24gb2YgdGhlIG1vZHVsZS5cbiAgICogVGhpcyBtZXRob2Q6XG4gICAqIC0gY2hlY2tzIHdoZXRoZXIgdGhlIGBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5YCwgdGhlIGBhY2NlbGVyYXRpb25gLFxuICAgKiAgIGFuZCB0aGUgYHJvdGF0aW9uUmF0ZWAgdmFsdWVzIGFyZSB2YWxpZCBvciBub3Q7XG4gICAqIC0gZ2V0cyB0aGUgcGVyaW9kIG9mIHRoZSBgJ2RldmljZW1vdGlvbidgIGV2ZW50IGFuZCBzZXRzIHRoZSBwZXJpb2Qgb2ZcbiAgICogICB0aGUgYEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgLCBgQWNjZWxlcmF0aW9uYCwgYW5kIGBSb3RhdGlvblJhdGVgXG4gICAqICAgc3VibW9kdWxlcztcbiAgICogLSAoaW4gdGhlIGNhc2Ugd2hlcmUgYWNjZWxlcmF0aW9uIHJhdyB2YWx1ZXMgYXJlIG5vdCBwcm92aWRlZClcbiAgICogICBpbmRpY2F0ZXMgd2hldGhlciB0aGUgYWNjZWxlcmF0aW9uIGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gdGhlXG4gICAqICAgYGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgIHVuaWZpZWQgdmFsdWVzIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtEZXZpY2VNb3Rpb25FdmVudH0gZSAtIFRoZSBmaXJzdCBgJ2RldmljZW1vdGlvbidgIGV2ZW50IGNhdWdodC5cbiAgICovXG4gIF9kZXZpY2Vtb3Rpb25DaGVjayhlKSB7XG4gICAgLy8gY2xlYXIgdGltZW91dCAoYW50aS1GaXJlZm94IGJ1ZyBzb2x1dGlvbiwgd2luZG93IGV2ZW50IGRldmljZW9yaWVudGF0aW9uIGJlaW5nIG52ZXIgY2FsbGVkKVxuICAgIC8vIHNldCB0aGUgc2V0IHRpbWVvdXQgaW4gaW5pdCgpIGZ1bmN0aW9uXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NoZWNrVGltZW91dElkKTtcblxuICAgIHRoaXMuaXNQcm92aWRlZCA9IHRydWU7XG4gICAgdGhpcy5wZXJpb2QgPSBlLmludGVydmFsIC8gMTAwMDtcbiAgICB0aGlzLmludGVydmFsID0gZS5pbnRlcnZhbDtcblxuICAgIC8vIFNlbnNvciBhdmFpbGFiaWxpdHkgZm9yIHRoZSBhY2NlbGVyYXRpb24gaW5jbHVkaW5nIGdyYXZpdHlcbiAgICB0aGlzLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkuaXNQcm92aWRlZCA9IChcbiAgICAgIGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSAmJlxuICAgICAgKHR5cGVvZiBlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkueCA9PT0gJ251bWJlcicpICYmXG4gICAgICAodHlwZW9mIGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS55ID09PSAnbnVtYmVyJykgJiZcbiAgICAgICh0eXBlb2YgZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnogPT09ICdudW1iZXInKVxuICAgICk7XG4gICAgdGhpcy5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnBlcmlvZCA9IGUuaW50ZXJ2YWwgKiB0aGlzLl91bmlmeVBlcmlvZDtcblxuICAgIC8vIFNlbnNvciBhdmFpbGFiaWxpdHkgZm9yIHRoZSBhY2NlbGVyYXRpb25cbiAgICB0aGlzLmFjY2VsZXJhdGlvbi5pc1Byb3ZpZGVkID0gKFxuICAgICAgZS5hY2NlbGVyYXRpb24gJiZcbiAgICAgICh0eXBlb2YgZS5hY2NlbGVyYXRpb24ueCA9PT0gJ251bWJlcicpICYmXG4gICAgICAodHlwZW9mIGUuYWNjZWxlcmF0aW9uLnkgPT09ICdudW1iZXInKSAmJlxuICAgICAgKHR5cGVvZiBlLmFjY2VsZXJhdGlvbi56ID09PSAnbnVtYmVyJylcbiAgICApO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uLnBlcmlvZCA9IGUuaW50ZXJ2YWwgKiB0aGlzLl91bmlmeVBlcmlvZDtcblxuICAgIC8vIFNlbnNvciBhdmFpbGFiaWxpdHkgZm9yIHRoZSByb3RhdGlvbiByYXRlXG4gICAgdGhpcy5yb3RhdGlvblJhdGUuaXNQcm92aWRlZCA9IChcbiAgICAgIGUucm90YXRpb25SYXRlICYmXG4gICAgICAodHlwZW9mIGUucm90YXRpb25SYXRlLmFscGhhID09PSAnbnVtYmVyJykgJiZcbiAgICAgICh0eXBlb2YgZS5yb3RhdGlvblJhdGUuYmV0YSAgPT09ICdudW1iZXInKSAmJlxuICAgICAgKHR5cGVvZiBlLnJvdGF0aW9uUmF0ZS5nYW1tYSA9PT0gJ251bWJlcicpXG4gICAgKTtcbiAgICB0aGlzLnJvdGF0aW9uUmF0ZS5wZXJpb2QgPSBlLmludGVydmFsICogdGhpcy5fdW5pZnlQZXJpb2Q7XG5cbiAgICAvLyBpbiBmaXJlZm94IGFuZHJvaWQsIGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgcmV0cmlldmUgbnVsbCB2YWx1ZXNcbiAgICAvLyBvbiB0aGUgZmlyc3QgY2FsbGJhY2suIHNvIHdhaXQgYSBzZWNvbmQgY2FsbCB0byBiZSBzdXJlLlxuICAgIGlmIChcbiAgICAgIHBsYXRmb3JtLm9zLmZhbWlseSA9PT0gJ0FuZHJvaWQnICYmXG4gICAgICAvRmlyZWZveC8udGVzdChwbGF0Zm9ybS5uYW1lKSAmJlxuICAgICAgdGhpcy5fY2hlY2tDb3VudGVyIDwgMVxuICAgICkge1xuICAgICAgdGhpcy5fY2hlY2tDb3VudGVyKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdyB0aGF0IHRoZSBzZW5zb3JzIGFyZSBjaGVja2VkLCByZXBsYWNlIHRoZSBwcm9jZXNzIGZ1bmN0aW9uIHdpdGhcbiAgICAgIC8vIHRoZSBmaW5hbCBsaXN0ZW5lclxuICAgICAgdGhpcy5fcHJvY2Vzc0Z1bmN0aW9uID0gdGhpcy5fZGV2aWNlbW90aW9uTGlzdGVuZXI7XG5cbiAgICAgIC8vIGlmIGFjY2VsZXJhdGlvbiBpcyBub3QgcHJvdmlkZWQgYnkgcmF3IHNlbnNvcnMsIGluZGljYXRlIHdoZXRoZXIgaXRcbiAgICAgIC8vIGNhbiBiZSBjYWxjdWxhdGVkIHdpdGggYGFjY2VsZXJhdGlvbmluY2x1ZGluZ2dyYXZpdHlgIG9yIG5vdFxuICAgICAgaWYgKCF0aGlzLmFjY2VsZXJhdGlvbi5pc1Byb3ZpZGVkKVxuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbi5pc0NhbGN1bGF0ZWQgPSB0aGlzLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkuaXNQcm92aWRlZDtcblxuICAgICAgLy8gV0FSTklOR1xuICAgICAgLy8gVGhlIGxpbmVzIG9mIGNvZGUgYmVsb3cgYXJlIGNvbW1lbnRlZCBiZWNhdXNlIG9mIGEgYnVnIG9mIENocm9tZVxuICAgICAgLy8gb24gc29tZSBBbmRyb2lkIGRldmljZXMsIHdoZXJlICdkZXZpY2Vtb3Rpb24nIGV2ZW50cyBhcmUgbm90IHNlbnRcbiAgICAgIC8vIG9yIGNhdWdodCBpZiB0aGUgbGlzdGVuZXIgaXMgc2V0IHVwIGFmdGVyIGEgJ2RldmljZW9yaWVudGF0aW9uJ1xuICAgICAgLy8gbGlzdGVuZXIuIEhlcmUsIHRoZSBfdHJ5T3JpZW50YXRpb25GYWxsYmFjayBtZXRob2Qgd291bGQgYWRkIGFcbiAgICAgIC8vICdkZXZpY2VvcmllbnRhdGlvbicgbGlzdGVuZXIgYW5kIGJsb2NrIGFsbCBzdWJzZXF1ZW50ICdkZXZpY2Vtb3Rpb24nXG4gICAgICAvLyBldmVudHMgb24gdGhlc2UgZGV2aWNlcy4gQ29tbWVudHMgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIGJ1ZyBvZlxuICAgICAgLy8gQ2hyb21lIGlzIGNvcnJlY3RlZC5cblxuICAgICAgLy8gaWYgKHRoaXMucmVxdWlyZWQucm90YXRpb25SYXRlICYmICF0aGlzLnJvdGF0aW9uUmF0ZS5pc1Byb3ZpZGVkKVxuICAgICAgLy8gICB0aGlzLl90cnlPcmllbnRhdGlvbkZhbGxiYWNrKCk7XG4gICAgICAvLyBlbHNlXG4gICAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYCdkZXZpY2Vtb3Rpb24nYCBldmVudCBjYWxsYmFjay5cbiAgICogVGhpcyBtZXRob2QgZW1pdHMgYW4gZXZlbnQgd2l0aCB0aGUgcmF3IGAnZGV2aWNlbW90aW9uJ2AgdmFsdWVzLCBhbmQgZW1pdHNcbiAgICogZXZlbnRzIHdpdGggdGhlIHVuaWZpZWQgYGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgLCBgYWNjZWxlcmF0aW9uYCxcbiAgICogYW5kIC8gb3IgYHJvdGF0aW9uUmF0ZWAgdmFsdWVzIGlmIHRoZXkgYXJlIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RldmljZU1vdGlvbkV2ZW50fSBlIC0gYCdkZXZpY2Vtb3Rpb24nYCBldmVudCB0aGUgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20uXG4gICAqL1xuICBfZGV2aWNlbW90aW9uTGlzdGVuZXIoZSkge1xuICAgIC8vICdkZXZpY2Vtb3Rpb24nIGV2ZW50IChyYXcgdmFsdWVzKVxuICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID4gMClcbiAgICAgIHRoaXMuX2VtaXREZXZpY2VNb3Rpb25FdmVudChlKTtcblxuICAgIC8vIGFsZXJ0KGAke3RoaXMuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS5saXN0ZW5lcnMuc2l6ZX0gLVxuICAgIC8vICAgICAke3RoaXMucmVxdWlyZWQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eX0gLVxuICAgIC8vICAgICAke3RoaXMuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS5pc1ZhbGlkfVxuICAgIC8vIGApO1xuXG4gICAgLy8gJ2FjY2VsZXJhdGlvbicgZXZlbnQgKHVuaWZpZWQgdmFsdWVzKVxuICAgIGlmICh0aGlzLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkubGlzdGVuZXJzLnNpemUgPiAwICYmXG4gICAgICAgIHRoaXMucmVxdWlyZWQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSAmJlxuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkuaXNWYWxpZFxuICAgICkge1xuICAgICAgdGhpcy5fZW1pdEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlFdmVudChlKTtcbiAgICB9XG5cbiAgICAvLyAnYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eScgZXZlbnQgKHVuaWZpZWQgdmFsdWVzKVxuICAgIC8vIHRoZSBmYWxsYmFjayBjYWxjdWxhdGlvbiBvZiB0aGUgYWNjZWxlcmF0aW9uIGhhcHBlbnMgaW4gdGhlXG4gICAgLy8gIGBfZW1pdEFjY2VsZXJhdGlvbmAgbWV0aG9kLCBzbyB3ZSBjaGVjayBpZiB0aGlzLmFjY2VsZXJhdGlvbi5pc1ZhbGlkXG4gICAgaWYgKHRoaXMuYWNjZWxlcmF0aW9uLmxpc3RlbmVycy5zaXplID4gMCAmJlxuICAgICAgICB0aGlzLnJlcXVpcmVkLmFjY2VsZXJhdGlvbiAmJlxuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbi5pc1ZhbGlkXG4gICAgKSB7XG4gICAgICB0aGlzLl9lbWl0QWNjZWxlcmF0aW9uRXZlbnQoZSk7XG4gICAgfVxuXG4gICAgLy8gJ3JvdGF0aW9uUmF0ZScgZXZlbnQgKHVuaWZpZWQgdmFsdWVzKVxuICAgIC8vIHRoZSBmYWxsYmFjayBjYWxjdWxhdGlvbiBvZiB0aGUgcm90YXRpb24gcmF0ZSBkb2VzIE5PVCBoYXBwZW4gaW4gdGhlXG4gICAgLy8gYF9lbWl0Um90YXRpb25SYXRlYCBtZXRob2QsIHNvIHdlIG9ubHkgY2hlY2sgaWYgdGhpcy5yb3RhdGlvblJhdGUuaXNQcm92aWRlZFxuICAgIGlmICh0aGlzLnJvdGF0aW9uUmF0ZS5saXN0ZW5lcnMuc2l6ZSA+IDAgJiZcbiAgICAgICAgdGhpcy5yZXF1aXJlZC5yb3RhdGlvblJhdGUgJiZcbiAgICAgICAgdGhpcy5yb3RhdGlvblJhdGUuaXNQcm92aWRlZFxuICAgICkge1xuICAgICAgdGhpcy5fZW1pdFJvdGF0aW9uUmF0ZUV2ZW50KGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgYCdkZXZpY2Vtb3Rpb24nYCByYXcgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0RldmljZU1vdGlvbkV2ZW50fSBlIC0gYCdkZXZpY2Vtb3Rpb24nYCBldmVudCB0aGUgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20uXG4gICAqL1xuICBfZW1pdERldmljZU1vdGlvbkV2ZW50KGUpIHtcbiAgICBsZXQgb3V0RXZlbnQgPSB0aGlzLmV2ZW50O1xuXG4gICAgaWYgKGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSkge1xuICAgICAgb3V0RXZlbnRbMF0gPSBlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkueDtcbiAgICAgIG91dEV2ZW50WzFdID0gZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5Lnk7XG4gICAgICBvdXRFdmVudFsyXSA9IGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS56O1xuICAgIH1cblxuICAgIGlmIChlLmFjY2VsZXJhdGlvbikge1xuICAgICAgb3V0RXZlbnRbM10gPSBlLmFjY2VsZXJhdGlvbi54O1xuICAgICAgb3V0RXZlbnRbNF0gPSBlLmFjY2VsZXJhdGlvbi55O1xuICAgICAgb3V0RXZlbnRbNV0gPSBlLmFjY2VsZXJhdGlvbi56O1xuICAgIH1cblxuICAgIGlmIChlLnJvdGF0aW9uUmF0ZSkge1xuICAgICAgb3V0RXZlbnRbNl0gPSBlLnJvdGF0aW9uUmF0ZS5hbHBoYTtcbiAgICAgIG91dEV2ZW50WzddID0gZS5yb3RhdGlvblJhdGUuYmV0YTtcbiAgICAgIG91dEV2ZW50WzhdID0gZS5yb3RhdGlvblJhdGUuZ2FtbWE7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KG91dEV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgYGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgIHVuaWZpZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0RldmljZU1vdGlvbkV2ZW50fSBlIC0gYCdkZXZpY2Vtb3Rpb24nYCBldmVudCB0aGUgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20uXG4gICAqL1xuICBfZW1pdEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlFdmVudChlKSB7XG4gICAgbGV0IG91dEV2ZW50ID0gdGhpcy5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LmV2ZW50O1xuXG4gICAgb3V0RXZlbnRbMF0gPSBlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkueCAqIHRoaXMuX3VuaWZ5TW90aW9uRGF0YTtcbiAgICBvdXRFdmVudFsxXSA9IGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS55ICogdGhpcy5fdW5pZnlNb3Rpb25EYXRhO1xuICAgIG91dEV2ZW50WzJdID0gZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnogKiB0aGlzLl91bmlmeU1vdGlvbkRhdGE7XG5cbiAgICB0aGlzLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkuZW1pdChvdXRFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgdGhlIGBhY2NlbGVyYXRpb25gIHVuaWZpZWQgdmFsdWVzLlxuICAgKiBXaGVuIHRoZSBgYWNjZWxlcmF0aW9uYCByYXcgdmFsdWVzIGFyZSBub3QgYXZhaWxhYmxlLCB0aGUgbWV0aG9kXG4gICAqIGFsc28gY2FsY3VsYXRlcyB0aGUgYWNjZWxlcmF0aW9uIGZyb20gdGhlXG4gICAqIGBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5YCByYXcgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0RldmljZU1vdGlvbkV2ZW50fSBlIC0gVGhlIGAnZGV2aWNlbW90aW9uJ2AgZXZlbnQuXG4gICAqL1xuICBfZW1pdEFjY2VsZXJhdGlvbkV2ZW50KGUpIHtcbiAgICBsZXQgb3V0RXZlbnQgPSB0aGlzLmFjY2VsZXJhdGlvbi5ldmVudDtcblxuICAgIGlmICh0aGlzLmFjY2VsZXJhdGlvbi5pc1Byb3ZpZGVkKSB7XG4gICAgICAvLyBJZiByYXcgYWNjZWxlcmF0aW9uIHZhbHVlcyBhcmUgcHJvdmlkZWRcbiAgICAgIG91dEV2ZW50WzBdID0gZS5hY2NlbGVyYXRpb24ueCAqIHRoaXMuX3VuaWZ5TW90aW9uRGF0YTtcbiAgICAgIG91dEV2ZW50WzFdID0gZS5hY2NlbGVyYXRpb24ueSAqIHRoaXMuX3VuaWZ5TW90aW9uRGF0YTtcbiAgICAgIG91dEV2ZW50WzJdID0gZS5hY2NlbGVyYXRpb24ueiAqIHRoaXMuX3VuaWZ5TW90aW9uRGF0YTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS5pc1ZhbGlkKSB7XG4gICAgICAvLyBPdGhlcndpc2UsIGlmIGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgdmFsdWVzIGFyZSBwcm92aWRlZCxcbiAgICAgIC8vIGVzdGltYXRlIHRoZSBhY2NlbGVyYXRpb24gd2l0aCBhIGhpZ2gtcGFzcyBmaWx0ZXJcbiAgICAgIGNvbnN0IGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgPSBbXG4gICAgICAgIGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS54ICogdGhpcy5fdW5pZnlNb3Rpb25EYXRhLFxuICAgICAgICBlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkueSAqIHRoaXMuX3VuaWZ5TW90aW9uRGF0YSxcbiAgICAgICAgZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnogKiB0aGlzLl91bmlmeU1vdGlvbkRhdGFcbiAgICAgIF07XG4gICAgICBjb25zdCBrID0gdGhpcy5fY2FsY3VsYXRlZEFjY2VsZXJhdGlvbkRlY2F5O1xuXG4gICAgICAvLyBIaWdoLXBhc3MgZmlsdGVyIHRvIGVzdGltYXRlIHRoZSBhY2NlbGVyYXRpb24gKHdpdGhvdXQgdGhlIGdyYXZpdHkpXG4gICAgICB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uWzBdID0gKDEgKyBrKSAqIDAuNSAqIChhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5WzBdIC0gdGhpcy5fbGFzdEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlbMF0pICsgayAqIHRoaXMuX2NhbGN1bGF0ZWRBY2NlbGVyYXRpb25bMF07XG4gICAgICB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uWzFdID0gKDEgKyBrKSAqIDAuNSAqIChhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5WzFdIC0gdGhpcy5fbGFzdEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlbMV0pICsgayAqIHRoaXMuX2NhbGN1bGF0ZWRBY2NlbGVyYXRpb25bMV07XG4gICAgICB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uWzJdID0gKDEgKyBrKSAqIDAuNSAqIChhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5WzJdIC0gdGhpcy5fbGFzdEFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlbMl0pICsgayAqIHRoaXMuX2NhbGN1bGF0ZWRBY2NlbGVyYXRpb25bMl07XG5cbiAgICAgIHRoaXMuX2xhc3RBY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5WzBdID0gYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVswXTtcbiAgICAgIHRoaXMuX2xhc3RBY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5WzFdID0gYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVsxXTtcbiAgICAgIHRoaXMuX2xhc3RBY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5WzJdID0gYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVsyXTtcblxuICAgICAgb3V0RXZlbnRbMF0gPSB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uWzBdO1xuICAgICAgb3V0RXZlbnRbMV0gPSB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uWzFdO1xuICAgICAgb3V0RXZlbnRbMl0gPSB0aGlzLl9jYWxjdWxhdGVkQWNjZWxlcmF0aW9uWzJdO1xuICAgIH1cblxuICAgIHRoaXMuYWNjZWxlcmF0aW9uLmVtaXQob3V0RXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBgcm90YXRpb25SYXRlYCB1bmlmaWVkIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtEZXZpY2VNb3Rpb25FdmVudH0gZSAtIGAnZGV2aWNlbW90aW9uJ2AgZXZlbnQgdGhlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tLlxuICAgKi9cbiAgX2VtaXRSb3RhdGlvblJhdGVFdmVudChlKSB7XG4gICAgbGV0IG91dEV2ZW50ID0gdGhpcy5yb3RhdGlvblJhdGUuZXZlbnQ7XG5cbiAgICAvLyBJbiBhbGwgcGxhdGZvcm1zLCByb3RhdGlvbiBheGVzIGFyZSBtZXNzZWQgdXAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2RldmljZW9yaWVudGF0aW9uL3NwZWMtc291cmNlLW9yaWVudGF0aW9uLmh0bWxcbiAgICAvL1xuICAgIC8vIGdhbW1hIHNob3VsZCBiZSBhbHBoYVxuICAgIC8vIGFscGhhIHNob3VsZCBiZSBiZXRhXG4gICAgLy8gYmV0YSBzaG91bGQgYmUgZ2FtbWFcblxuICAgIG91dEV2ZW50WzBdID0gZS5yb3RhdGlvblJhdGUuZ2FtbWE7XG4gICAgb3V0RXZlbnRbMV0gPSBlLnJvdGF0aW9uUmF0ZS5hbHBoYSxcbiAgICBvdXRFdmVudFsyXSA9IGUucm90YXRpb25SYXRlLmJldGE7XG5cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCByZXRyaWV2ZSB2YWx1ZXMgdGhhdCBhcmUgaW4gcmFkL3NcbiAgICAvLyBjZi4gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTQxNjA3XG4gICAgLy9cbiAgICAvLyBGcm9tIHNwZWM6IFwiVGhlIHJvdGF0aW9uUmF0ZSBhdHRyaWJ1dGUgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIHRoZSByYXRlXG4gICAgLy8gb2Ygcm90YXRpb24gb2YgdGhlIGhvc3RpbmcgZGV2aWNlIGluIHNwYWNlLiBJdCBtdXN0IGJlIGV4cHJlc3NlZCBhcyB0aGVcbiAgICAvLyByYXRlIG9mIGNoYW5nZSBvZiB0aGUgYW5nbGVzIGRlZmluZWQgaW4gc2VjdGlvbiA0LjEgYW5kIG11c3QgYmUgZXhwcmVzc2VkXG4gICAgLy8gaW4gZGVncmVlcyBwZXIgc2Vjb25kIChkZWcvcykuXCJcbiAgICAvL1xuICAgIC8vIGZpeGVkIHNpbmNlIENocm9tZSA2NVxuICAgIC8vIGNmLiBodHRwczovL2dpdGh1Yi5jb20vaW1tZXJzaXZlLXdlYi93ZWJ2ci1wb2x5ZmlsbC9pc3N1ZXMvMzA3XG4gICAgaWYgKFxuICAgICAgcGxhdGZvcm0ub3MuZmFtaWx5ID09PSAnQW5kcm9pZCcgJiZcbiAgICAgIGNocm9tZVJlZ0V4cC50ZXN0KHBsYXRmb3JtLm5hbWUpICYmXG4gICAgICBwYXJzZUludChwbGF0Zm9ybS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pIDwgNjVcbiAgICApIHtcbiAgICAgIG91dEV2ZW50WzBdICo9IHRvRGVnO1xuICAgICAgb3V0RXZlbnRbMV0gKj0gdG9EZWcsXG4gICAgICBvdXRFdmVudFsyXSAqPSB0b0RlZztcbiAgICB9XG5cbiAgICB0aGlzLnJvdGF0aW9uUmF0ZS5lbWl0KG91dEV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGFuZCBlbWl0cyB0aGUgYHJvdGF0aW9uUmF0ZWAgdW5pZmllZCB2YWx1ZXMgZnJvbSB0aGUgYG9yaWVudGF0aW9uYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IG9yaWVudGF0aW9uIC0gTGF0ZXN0IGBvcmllbnRhdGlvbmAgcmF3IHZhbHVlcy5cbiAgICovXG4gIF9jYWxjdWxhdGVSb3RhdGlvblJhdGVGcm9tT3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICBjb25zdCBub3cgPSBnZXRMb2NhbFRpbWUoKTtcbiAgICBjb25zdCBrID0gMC44OyAvLyBUT0RPOiBpbXByb3ZlIGxvdyBwYXNzIGZpbHRlciAoZnJhbWVzIGFyZSBub3QgcmVndWxhcilcbiAgICBjb25zdCBhbHBoYUlzVmFsaWQgPSAodHlwZW9mIG9yaWVudGF0aW9uWzBdID09PSAnbnVtYmVyJyk7XG5cbiAgICBpZiAodGhpcy5fbGFzdE9yaWVudGF0aW9uVGltZXN0YW1wKSB7XG4gICAgICBsZXQgckFscGhhID0gbnVsbDtcbiAgICAgIGxldCByQmV0YTtcbiAgICAgIGxldCByR2FtbWE7XG5cbiAgICAgIGxldCBhbHBoYURpc2NvbnRpbnVpdHlGYWN0b3IgPSAwO1xuICAgICAgbGV0IGJldGFEaXNjb250aW51aXR5RmFjdG9yID0gMDtcbiAgICAgIGxldCBnYW1tYURpc2NvbnRpbnVpdHlGYWN0b3IgPSAwO1xuXG4gICAgICBjb25zdCBkZWx0YVQgPSBub3cgLSB0aGlzLl9sYXN0T3JpZW50YXRpb25UaW1lc3RhbXA7XG5cbiAgICAgIGlmIChhbHBoYUlzVmFsaWQpIHtcbiAgICAgICAgLy8gYWxwaGEgZGlzY29udGludWl0eSAoKzM2MCAtPiAwIG9yIDAgLT4gKzM2MClcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RPcmllbnRhdGlvblswXSA+IDMyMCAmJiBvcmllbnRhdGlvblswXSA8IDQwKVxuICAgICAgICAgIGFscGhhRGlzY29udGludWl0eUZhY3RvciA9IDM2MDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbGFzdE9yaWVudGF0aW9uWzBdIDwgNDAgJiYgb3JpZW50YXRpb25bMF0gPiAzMjApXG4gICAgICAgICAgYWxwaGFEaXNjb250aW51aXR5RmFjdG9yID0gLTM2MDtcbiAgICAgIH1cblxuICAgICAgLy8gYmV0YSBkaXNjb250aW51aXR5ICgrMTgwIC0+IC0xODAgb3IgLTE4MCAtPiArMTgwKVxuICAgICAgaWYgKHRoaXMuX2xhc3RPcmllbnRhdGlvblsxXSA+IDE0MCAmJiBvcmllbnRhdGlvblsxXSA8IC0xNDApXG4gICAgICAgIGJldGFEaXNjb250aW51aXR5RmFjdG9yID0gMzYwO1xuICAgICAgZWxzZSBpZiAodGhpcy5fbGFzdE9yaWVudGF0aW9uWzFdIDwgLTE0MCAmJiBvcmllbnRhdGlvblsxXSA+IDE0MClcbiAgICAgICAgYmV0YURpc2NvbnRpbnVpdHlGYWN0b3IgPSAtMzYwO1xuXG4gICAgICAvLyBnYW1tYSBkaXNjb250aW51aXRpZXMgKCsxODAgLT4gLTE4MCBvciAtMTgwIC0+ICsxODApXG4gICAgICBpZiAodGhpcy5fbGFzdE9yaWVudGF0aW9uWzJdID4gNTAgJiYgb3JpZW50YXRpb25bMl0gPCAtNTApXG4gICAgICAgIGdhbW1hRGlzY29udGludWl0eUZhY3RvciA9IDE4MDtcbiAgICAgIGVsc2UgaWYgKHRoaXMuX2xhc3RPcmllbnRhdGlvblsyXSA8IC01MCAmJiBvcmllbnRhdGlvblsyXSA+IDUwKVxuICAgICAgICBnYW1tYURpc2NvbnRpbnVpdHlGYWN0b3IgPSAtMTgwO1xuXG4gICAgICBpZiAoZGVsdGFUID4gMCkge1xuICAgICAgICAvLyBMb3cgcGFzcyBmaWx0ZXIgdG8gc21vb3RoIHRoZSBkYXRhXG4gICAgICAgIGlmIChhbHBoYUlzVmFsaWQpXG4gICAgICAgICAgckFscGhhID0gayAqIHRoaXMuX2NhbGN1bGF0ZWRSb3RhdGlvblJhdGVbMF0gKyAoMSAtIGspICogKG9yaWVudGF0aW9uWzBdIC0gdGhpcy5fbGFzdE9yaWVudGF0aW9uWzBdICsgYWxwaGFEaXNjb250aW51aXR5RmFjdG9yKSAvIGRlbHRhVDtcblxuICAgICAgICByQmV0YSA9IGsgKiB0aGlzLl9jYWxjdWxhdGVkUm90YXRpb25SYXRlWzFdICsgKDEgLSBrKSAqIChvcmllbnRhdGlvblsxXSAtIHRoaXMuX2xhc3RPcmllbnRhdGlvblsxXSArIGJldGFEaXNjb250aW51aXR5RmFjdG9yKSAvIGRlbHRhVDtcbiAgICAgICAgckdhbW1hID0gayAqIHRoaXMuX2NhbGN1bGF0ZWRSb3RhdGlvblJhdGVbMl0gKyAoMSAtIGspICogKG9yaWVudGF0aW9uWzJdIC0gdGhpcy5fbGFzdE9yaWVudGF0aW9uWzJdICsgZ2FtbWFEaXNjb250aW51aXR5RmFjdG9yKSAvIGRlbHRhVDtcblxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVkUm90YXRpb25SYXRlWzBdID0gckFscGhhO1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVkUm90YXRpb25SYXRlWzFdID0gckJldGE7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZWRSb3RhdGlvblJhdGVbMl0gPSByR2FtbWE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHJlc2FtcGxlIHRoZSBlbWlzc2lvbiByYXRlIHRvIG1hdGNoIHRoZSBkZXZpY2Vtb3Rpb24gcmF0ZVxuICAgICAgdGhpcy5yb3RhdGlvblJhdGUuZW1pdCh0aGlzLl9jYWxjdWxhdGVkUm90YXRpb25SYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0T3JpZW50YXRpb25UaW1lc3RhbXAgPSBub3c7XG4gICAgdGhpcy5fbGFzdE9yaWVudGF0aW9uWzBdID0gb3JpZW50YXRpb25bMF07XG4gICAgdGhpcy5fbGFzdE9yaWVudGF0aW9uWzFdID0gb3JpZW50YXRpb25bMV07XG4gICAgdGhpcy5fbGFzdE9yaWVudGF0aW9uWzJdID0gb3JpZW50YXRpb25bMl07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHJvdGF0aW9uIHJhdGUgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgYG9yaWVudGF0aW9uYCB2YWx1ZXMgb3Igbm90LlxuICAgKlxuICAgKiBAdG9kbyAtIHRoaXMgc2hvdWxkIGJlIHJldmlld2VkIHRvIGNvbXBseSB3aXRoIHRoZSBheGlzIG9yZGVyIGRlZmluZWRcbiAgICogIGluIHRoZSBzcGVjXG4gICAqL1xuICAvLyBXQVJOSU5HXG4gIC8vIFRoZSBsaW5lcyBvZiBjb2RlIGJlbG93IGFyZSBjb21tZW50ZWQgYmVjYXVzZSBvZiBhIGJ1ZyBvZiBDaHJvbWVcbiAgLy8gb24gc29tZSBBbmRyb2lkIGRldmljZXMsIHdoZXJlICdkZXZpY2Vtb3Rpb24nIGV2ZW50cyBhcmUgbm90IHNlbnRcbiAgLy8gb3IgY2F1Z2h0IGlmIHRoZSBsaXN0ZW5lciBpcyBzZXQgdXAgYWZ0ZXIgYSAnZGV2aWNlb3JpZW50YXRpb24nXG4gIC8vIGxpc3RlbmVyLiBIZXJlLCB0aGUgX3RyeU9yaWVudGF0aW9uRmFsbGJhY2sgbWV0aG9kIHdvdWxkIGFkZCBhXG4gIC8vICdkZXZpY2VvcmllbnRhdGlvbicgbGlzdGVuZXIgYW5kIGJsb2NrIGFsbCBzdWJzZXF1ZW50ICdkZXZpY2Vtb3Rpb24nXG4gIC8vIGV2ZW50cyBvbiB0aGVzZSBkZXZpY2VzLiBDb21tZW50cyB3aWxsIGJlIHJlbW92ZWQgb25jZSB0aGUgYnVnIG9mXG4gIC8vIENocm9tZSBpcyBjb3JyZWN0ZWQuXG4gIC8vIF90cnlPcmllbnRhdGlvbkZhbGxiYWNrKCkge1xuICAvLyAgIE1vdGlvbklucHV0LnJlcXVpcmVNb2R1bGUoJ29yaWVudGF0aW9uJylcbiAgLy8gICAgIC50aGVuKChvcmllbnRhdGlvbikgPT4ge1xuICAvLyAgICAgICBpZiAob3JpZW50YXRpb24uaXNWYWxpZCkge1xuICAvLyAgICAgICAgIGNvbnNvbGUubG9nKGBcbiAgLy8gICAgICAgICAgIFdBUk5JTkcgKG1vdGlvbi1pbnB1dCk6IFRoZSAnZGV2aWNlbW90aW9uJyBldmVudCBkb2VzIG5vdCBleGlzdHMgb3JcbiAgLy8gICAgICAgICAgIGRvZXMgbm90IHByb3ZpZGUgcm90YXRpb24gcmF0ZSB2YWx1ZXMgaW4geW91ciBicm93c2VyLCBzbyB0aGUgcm90YXRpb25cbiAgLy8gICAgICAgICAgIHJhdGUgb2YgdGhlIGRldmljZSBpcyBlc3RpbWF0ZWQgZnJvbSB0aGUgJ29yaWVudGF0aW9uJywgY2FsY3VsYXRlZFxuICAvLyAgICAgICAgICAgZnJvbSB0aGUgJ2RldmljZW9yaWVudGF0aW9uJyBldmVudC4gU2luY2UgdGhlIGNvbXBhc3MgbWlnaHQgbm90XG4gIC8vICAgICAgICAgICBiZSBhdmFpbGFibGUsIG9ubHkgXFxgYmV0YVxcYCBhbmQgXFxgZ2FtbWFcXGAgYW5nbGVzIG1heSBiZSBwcm92aWRlZFxuICAvLyAgICAgICAgICAgKFxcYGFscGhhXFxgIHdvdWxkIGJlIG51bGwpLmBcbiAgLy8gICAgICAgICApO1xuXG4gIC8vICAgICAgICAgdGhpcy5yb3RhdGlvblJhdGUuaXNDYWxjdWxhdGVkID0gdHJ1ZTtcblxuICAvLyAgICAgICAgIE1vdGlvbklucHV0LmFkZExpc3RlbmVyKCdvcmllbnRhdGlvbicsIChvcmllbnRhdGlvbikgPT4ge1xuICAvLyAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlUm90YXRpb25SYXRlRnJvbU9yaWVudGF0aW9uKG9yaWVudGF0aW9uKTtcbiAgLy8gICAgICAgICB9KTtcbiAgLy8gICAgICAgfVxuXG4gIC8vICAgICAgIHRoaXMuX3Byb21pc2VSZXNvbHZlKHRoaXMpO1xuICAvLyAgICAgfSk7XG4gIC8vIH1cblxuICBfcHJvY2VzcyhkYXRhKSB7XG4gICAgdGhpcy5fcHJvY2Vzc0Z1bmN0aW9uKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIG9mIHRoZSBtb2R1bGUuXG4gICAqXG4gICAqIEByZXR1cm4ge3Byb21pc2V9XG4gICAqL1xuICBpbml0KCkge1xuICAgIHJldHVybiBzdXBlci5pbml0KChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG5cbiAgICAgIGlmICh3aW5kb3cuRGV2aWNlTW90aW9uRXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0Z1bmN0aW9uID0gdGhpcy5fZGV2aWNlbW90aW9uQ2hlY2s7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2Vtb3Rpb24nLCB0aGlzLl9wcm9jZXNzKTtcblxuICAgICAgICAvLyBzZXQgZmFsbGJhY2sgdGltZW91dCBmb3IgRmlyZWZveCBkZXNrdG9wIChpdHMgd2luZG93IG5ldmVyIGNhbGxpbmcgdGhlIERldmljZU9yaWVudGF0aW9uIGV2ZW50LCBhXG4gICAgICAgIC8vIHJlcXVpcmUgb2YgdGhlIERldmljZU9yaWVudGF0aW9uIHNlcnZpY2Ugd2lsbCByZXN1bHQgaW4gdGhlIHJlcXVpcmUgcHJvbWlzZSBuZXZlciBiZWluZyByZXNvbHZlZFxuICAgICAgICAvLyBoZW5jZSB0aGUgRXhwZXJpbWVudCBzdGFydCgpIG1ldGhvZCBuZXZlciBjYWxsZWQpXG4gICAgICAgIC8vID4gbm90ZSAwMi8wMi8yMDE4OiB0aGlzIHNlZW1zIHRvIGNyZWF0ZSBwcm9ibGVtcyB3aXRoIGlwb2RzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSBlbm91Z2ggdGltZSB0byBzdGFydCAoc29tZXRpbWVzKSwgaGVuY2UgY3JlYXRpbmcgZmFsc2VcbiAgICAgICAgLy8gbmVnYXRpdmUuIFNvIHdlIG9ubHkgYXBwbHkgdG8gRmlyZWZveCBkZXNrdG9wIGFuZCBwdXQgYSByZWFsbHlcbiAgICAgICAgLy8gbGFyZ2UgdmFsdWUgKDRzZWMpIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgaWYgKHBsYXRmb3JtLm5hbWUgPT09ICdGaXJlZm94JyAmJlxuICAgICAgICAgIHBsYXRmb3JtLm9zLmZhbWlseSAhPT0gJ0FuZHJvaWQnICYmXG4gICAgICAgICAgcGxhdGZvcm0ub3MuZmFtaWx5ICE9PSAnaU9TJ1xuICAgICAgICApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1ttb3Rpb24taW5wdXRdIHJlZ2lzdGVyIHRpbWVyIGZvciBGaXJlZm94IGRlc2t0b3AnKTtcbiAgICAgICAgICB0aGlzLl9jaGVja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh0aGlzKSwgNCAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFdBUk5JTkdcbiAgICAgIC8vIFRoZSBsaW5lcyBvZiBjb2RlIGJlbG93IGFyZSBjb21tZW50ZWQgYmVjYXVzZSBvZiBhIGJ1ZyBvZiBDaHJvbWVcbiAgICAgIC8vIG9uIHNvbWUgQW5kcm9pZCBkZXZpY2VzLCB3aGVyZSAnZGV2aWNlbW90aW9uJyBldmVudHMgYXJlIG5vdCBzZW50XG4gICAgICAvLyBvciBjYXVnaHQgaWYgdGhlIGxpc3RlbmVyIGlzIHNldCB1cCBhZnRlciBhICdkZXZpY2VvcmllbnRhdGlvbidcbiAgICAgIC8vIGxpc3RlbmVyLiBIZXJlLCB0aGUgX3RyeU9yaWVudGF0aW9uRmFsbGJhY2sgbWV0aG9kIHdvdWxkIGFkZCBhXG4gICAgICAvLyAnZGV2aWNlb3JpZW50YXRpb24nIGxpc3RlbmVyIGFuZCBibG9jayBhbGwgc3Vic2VxdWVudCAnZGV2aWNlbW90aW9uJ1xuICAgICAgLy8gZXZlbnRzIG9uIHRoZXNlIGRldmljZXMuIENvbW1lbnRzIHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSBidWcgb2ZcbiAgICAgIC8vIENocm9tZSBpcyBjb3JyZWN0ZWQuXG5cbiAgICAgIC8vIGVsc2UgaWYgKHRoaXMucmVxdWlyZWQucm90YXRpb25SYXRlKVxuICAgICAgLy8gdGhpcy5fdHJ5T3JpZW50YXRpb25GYWxsYmFjaygpO1xuXG4gICAgICBlbHNlXG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IERldmljZU1vdGlvbk1vZHVsZSgpO1xuIiwiaW1wb3J0IERPTUV2ZW50U3VibW9kdWxlIGZyb20gJy4vRE9NRXZlbnRTdWJtb2R1bGUnO1xuaW1wb3J0IElucHV0TW9kdWxlIGZyb20gJy4vSW5wdXRNb2R1bGUnO1xuaW1wb3J0IE1vdGlvbklucHV0IGZyb20gJy4vTW90aW9uSW5wdXQnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ3BsYXRmb3JtJztcblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZyAtIEFuZ2xlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlZ1RvUmFkKGRlZykge1xuICByZXR1cm4gZGVnICogTWF0aC5QSSAvIDE4MDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCAtIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZCkge1xuICByZXR1cm4gcmFkICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgMyB4IDMgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IG0gLSBNYXRyaXggdG8gbm9ybWFsaXplLCByZXByZXNlbnRlZCBieSBhbiBhcnJheSBvZiBsZW5ndGggOS5cbiAqIEByZXR1cm4ge251bWJlcltdfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUobSkge1xuICBjb25zdCBkZXQgPSBtWzBdICogbVs0XSAqIG1bOF0gKyBtWzFdICogbVs1XSAqIG1bNl0gKyBtWzJdICogbVszXSAqIG1bN10gLSBtWzBdICogbVs1XSAqIG1bN10gLSBtWzFdICogbVszXSAqIG1bOF0gLSBtWzJdICogbVs0XSAqIG1bNl07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKVxuICAgIG1baV0gLz0gZGV0O1xuXG4gIHJldHVybiBtO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgRXVsZXIgYW5nbGUgYFthbHBoYSwgYmV0YSwgZ2FtbWFdYCB0byB0aGUgVzNDIHNwZWNpZmljYXRpb24sIHdoZXJlOlxuICogLSBgYWxwaGFgIGlzIGluIFswOyArMzYwWztcbiAqIC0gYGJldGFgIGlzIGluIFstMTgwOyArMTgwWztcbiAqIC0gYGdhbW1hYCBpcyBpbiBbLTkwOyArOTBbLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IGV1bGVyQW5nbGUgLSBFdWxlciBhbmdsZSB0byB1bmlmeSwgcmVwcmVzZW50ZWQgYnkgYW4gYXJyYXkgb2YgbGVuZ3RoIDMgKGBbYWxwaGEsIGJldGEsIGdhbW1hXWApLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvb3JpZW50YXRpb24tZXZlbnQvfVxuICovXG5mdW5jdGlvbiB1bmlmeShldWxlckFuZ2xlKSB7XG4gIC8vIENmLiBXM0Mgc3BlY2lmaWNhdGlvbiAoaHR0cDovL3czYy5naXRodWIuaW8vZGV2aWNlb3JpZW50YXRpb24vc3BlYy1zb3VyY2Utb3JpZW50YXRpb24uaHRtbClcbiAgLy8gYW5kIEV1bGVyIGFuZ2xlcyBXaWtpcGVkaWEgcGFnZSAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWxlcl9hbmdsZXMpLlxuICAvL1xuICAvLyBXM0MgY29udmVudGlvbjogVGFpdOKAk0JyeWFuIGFuZ2xlcyBaLVgnLVknJywgd2hlcmU6XG4gIC8vICAgYWxwaGEgaXMgaW4gWzA7ICszNjBbLFxuICAvLyAgIGJldGEgaXMgaW4gWy0xODA7ICsxODBbLFxuICAvLyAgIGdhbW1hIGlzIGluIFstOTA7ICs5MFsuXG5cbiAgY29uc3QgYWxwaGFJc1ZhbGlkID0gKHR5cGVvZiBldWxlckFuZ2xlWzBdID09PSAnbnVtYmVyJyk7XG5cbiAgY29uc3QgX2FscGhhID0gKGFscGhhSXNWYWxpZCA/IGRlZ1RvUmFkKGV1bGVyQW5nbGVbMF0pIDogMCk7XG4gIGNvbnN0IF9iZXRhID0gZGVnVG9SYWQoZXVsZXJBbmdsZVsxXSk7XG4gIGNvbnN0IF9nYW1tYSA9IGRlZ1RvUmFkKGV1bGVyQW5nbGVbMl0pO1xuXG4gIGNvbnN0IGNBID0gTWF0aC5jb3MoX2FscGhhKTtcbiAgY29uc3QgY0IgPSBNYXRoLmNvcyhfYmV0YSk7XG4gIGNvbnN0IGNHID0gTWF0aC5jb3MoX2dhbW1hKTtcbiAgY29uc3Qgc0EgPSBNYXRoLnNpbihfYWxwaGEpO1xuICBjb25zdCBzQiA9IE1hdGguc2luKF9iZXRhKTtcbiAgY29uc3Qgc0cgPSBNYXRoLnNpbihfZ2FtbWEpO1xuXG4gIGxldCBhbHBoYSwgYmV0YSwgZ2FtbWE7XG5cbiAgbGV0IG0gPSBbXG4gICAgY0EgKiBjRyAtIHNBICogc0IgKiBzRyxcbiAgICAtY0IgKiBzQSxcbiAgICBjQSAqIHNHICsgY0cgKiBzQSAqIHNCLFxuICAgIGNHICogc0EgKyBjQSAqIHNCICogc0csXG4gICAgY0EgKiBjQixcbiAgICBzQSAqIHNHIC0gY0EgKiBjRyAqIHNCLFxuICAgIC1jQiAqIHNHLFxuICAgIHNCLFxuICAgIGNCICogY0dcbiAgXTtcbiAgbm9ybWFsaXplKG0pO1xuXG4gIC8vIFNpbmNlIHdlIHdhbnQgZ2FtbWEgaW4gWy05MDsgKzkwWywgY0cgPj0gMC5cbiAgaWYgKG1bOF0gPiAwKSB7XG4gICAgLy8gQ2FzZSAxOiBtWzhdID4gMCA8PT4gY0IgPiAwICAgICAgICAgICAgICAgICAoYW5kIGNHICE9IDApXG4gICAgLy8gICAgICAgICAgICAgICAgICA8PT4gYmV0YSBpbiBdLXBpLzI7ICtwaS8yWyAoYW5kIGNHICE9IDApXG4gICAgYWxwaGEgPSBNYXRoLmF0YW4yKC1tWzFdLCBtWzRdKTtcbiAgICBiZXRhID0gTWF0aC5hc2luKG1bN10pOyAvLyBhc2luIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAtcGkvMiBhbmQgK3BpLzIgPT4gT0tcbiAgICBnYW1tYSA9IE1hdGguYXRhbjIoLW1bNl0sIG1bOF0pO1xuICB9IGVsc2UgaWYgKG1bOF0gPCAwKSB7XG4gICAgLy8gQ2FzZSAyOiBtWzhdIDwgMCA8PT4gY0IgPCAwICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhbmQgY0cgIT0gMClcbiAgICAvLyAgICAgICAgICAgICAgICAgIDw9PiBiZXRhIGluIFstcGk7IC1waS8yWyBVIF0rcGkvMjsgK3BpXSAoYW5kIGNHICE9IDApXG5cbiAgICAvLyBTaW5jZSBjQiA8IDAgYW5kIGNCIGlzIGluIG1bMV0gYW5kIG1bNF0sIHRoZSBwb2ludCBpcyBmbGlwcGVkIGJ5IDE4MCBkZWdyZWVzLlxuICAgIC8vIEhlbmNlLCB3ZSBoYXZlIHRvIG11bHRpcGx5IGJvdGggYXJndW1lbnRzIG9mIGF0YW4yIGJ5IC0xIGluIG9yZGVyIHRvIHJldmVydFxuICAgIC8vIHRoZSBwb2ludCBpbiBpdHMgb3JpZ2luYWwgcG9zaXRpb24gKD0+IGFub3RoZXIgZmxpcCBieSAxODAgZGVncmVlcykuXG4gICAgYWxwaGEgPSBNYXRoLmF0YW4yKG1bMV0sIC1tWzRdKTtcbiAgICBiZXRhID0gLU1hdGguYXNpbihtWzddKTtcbiAgICBiZXRhICs9IChiZXRhID49IDApID8gLU1hdGguUEkgOiBNYXRoLlBJOyAvLyBhc2luIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAtcGkvMiBhbmQgcGkvMiA9PiBtYWtlIHN1cmUgYmV0YSBpbiBbLXBpOyAtcGkvMlsgVSBdK3BpLzI7ICtwaV1cbiAgICBnYW1tYSA9IE1hdGguYXRhbjIobVs2XSwgLW1bOF0pOyAvLyBzYW1lIHJlbWFyayBhcyBmb3IgYWxwaGEsIG11bHRpcGxpY2F0aW9uIGJ5IC0xXG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZSAzOiBtWzhdID0gMCA8PT4gY0IgPSAwIG9yIGNHID0gMFxuICAgIGlmIChtWzZdID4gMCkge1xuICAgICAgLy8gU3ViY2FzZSAxOiBjRyA9IDAgYW5kIGNCID4gMFxuICAgICAgLy8gICAgICAgICAgICBjRyA9IDAgPD0+IHNHID0gLTEgPD0+IGdhbW1hID0gLXBpLzIgPT4gbVs2XSA9IGNCXG4gICAgICAvLyAgICAgICAgICAgIEhlbmNlLCBtWzZdID4gMCA8PT4gY0IgPiAwIDw9PiBiZXRhIGluIF0tcGkvMjsgK3BpLzJbXG4gICAgICBhbHBoYSA9IE1hdGguYXRhbjIoLW1bMV0sIG1bNF0pO1xuICAgICAgYmV0YSA9IE1hdGguYXNpbihtWzddKTsgLy8gYXNpbiByZXR1cm5zIGEgbnVtYmVyIGJldHdlZW4gLXBpLzIgYW5kICtwaS8yID0+IE9LXG4gICAgICBnYW1tYSA9IC1NYXRoLlBJIC8gMjtcbiAgICB9IGVsc2UgaWYgKG1bNl0gPCAwKSB7XG4gICAgICAvLyBTdWJjYXNlIDI6IGNHID0gMCBhbmQgY0IgPCAwXG4gICAgICAvLyAgICAgICAgICAgIGNHID0gMCA8PT4gc0cgPSAtMSA8PT4gZ2FtbWEgPSAtcGkvMiA9PiBtWzZdID0gY0JcbiAgICAgIC8vICAgICAgICAgICAgSGVuY2UsIG1bNl0gPCAwIDw9PiBjQiA8IDAgPD0+IGJldGEgaW4gWy1waTsgLXBpLzJbIFUgXStwaS8yOyArcGldXG4gICAgICBhbHBoYSA9IE1hdGguYXRhbjIobVsxXSwgLW1bNF0pOyAvLyBzYW1lIHJlbWFyayBhcyBmb3IgYWxwaGEgaW4gYSBjYXNlIGFib3ZlXG4gICAgICBiZXRhID0gLU1hdGguYXNpbihtWzddKTtcbiAgICAgIGJldGEgKz0gKGJldGEgPj0gMCkgPyAtTWF0aC5QSSA6IE1hdGguUEk7IC8vIGFzaW4gcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIC1waS8yIGFuZCArcGkvMiA9PiBtYWtlIHN1cmUgYmV0YSBpbiBbLXBpOyAtcGkvMlsgVSBdK3BpLzI7ICtwaV1cbiAgICAgIGdhbW1hID0gLU1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdWJjYXNlIDM6IGNCID0gMFxuICAgICAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgY29zKGJldGEpID0gMCAoaS5lLiBiZXRhID0gLXBpLzIgb3IgYmV0YSA9IHBpLzIpLFxuICAgICAgLy8gd2UgaGF2ZSB0aGUgZ2ltYmFsIGxvY2sgcHJvYmxlbTogaW4gdGhhdCBjb25maWd1cmF0aW9uLCBvbmx5IHRoZSBhbmdsZVxuICAgICAgLy8gYWxwaGEgKyBnYW1tYSAoaWYgYmV0YSA9ICtwaS8yKSBvciBhbHBoYSAtIGdhbW1hIChpZiBiZXRhID0gLXBpLzIpXG4gICAgICAvLyBhcmUgdW5pcXVlbHkgZGVmaW5lZDogYWxwaGEgYW5kIGdhbW1hIGNhbiB0YWtlIGFuIGluZmluaXR5IG9mIHZhbHVlcy5cbiAgICAgIC8vIEZvciBjb252ZW5pZW5jZSwgbGV0J3Mgc2V0IGdhbW1hID0gMCAoYW5kIHRodXMgc2luKGdhbW1hKSA9IDApLlxuICAgICAgLy8gKEFzIGEgY29uc2VxdWVuY2Ugb2YgdGhlIGdpbWJhbCBsb2NrIHByb2JsZW0sIHRoZXJlIGlzIGEgZGlzY29udGludWl0eVxuICAgICAgLy8gaW4gYWxwaGEgYW5kIGdhbW1hLilcbiAgICAgIGFscGhhID0gTWF0aC5hdGFuMihtWzNdLCBtWzBdKTtcbiAgICAgIGJldGEgPSAobVs3XSA+IDApID8gTWF0aC5QSSAvIDIgOiAtTWF0aC5QSSAvIDI7XG4gICAgICBnYW1tYSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gYXRhbjIgcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIC1waSBhbmQgcGkgPT4gbWFrZSBzdXJlIHRoYXQgYWxwaGEgaXMgaW4gWzAsIDIqcGlbLlxuICBhbHBoYSArPSAoYWxwaGEgPCAwKSA/IDIgKiBNYXRoLlBJIDogMDtcblxuICBldWxlckFuZ2xlWzBdID0gKGFscGhhSXNWYWxpZCA/IHJhZFRvRGVnKGFscGhhKSA6IG51bGwpO1xuICBldWxlckFuZ2xlWzFdID0gcmFkVG9EZWcoYmV0YSk7XG4gIGV1bGVyQW5nbGVbMl0gPSByYWRUb0RlZyhnYW1tYSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBFdWxlciBhbmdsZSBgW2FscGhhLCBiZXRhLCBnYW1tYV1gIHRvIGEgRXVsZXIgYW5nbGUgd2hlcmU6XG4gKiAtIGBhbHBoYWAgaXMgaW4gWzA7ICszNjBbO1xuICogLSBgYmV0YWAgaXMgaW4gWy05MDsgKzkwWztcbiAqIC0gYGdhbW1hYCBpcyBpbiBbLTE4MDsgKzE4MFsuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gZXVsZXJBbmdsZSAtIEV1bGVyIGFuZ2xlIHRvIGNvbnZlcnQsIHJlcHJlc2VudGVkIGJ5IGFuIGFycmF5IG9mIGxlbmd0aCAzIChgW2FscGhhLCBiZXRhLCBnYW1tYV1gKS5cbiAqL1xuZnVuY3Rpb24gdW5pZnlBbHQoZXVsZXJBbmdsZSkge1xuICAvLyBDb252ZW50aW9uIGhlcmU6IFRhaXTigJNCcnlhbiBhbmdsZXMgWi1YJy1ZJycsIHdoZXJlOlxuICAvLyAgIGFscGhhIGlzIGluIFswOyArMzYwWyxcbiAgLy8gICBiZXRhIGlzIGluIFstOTA7ICs5MFssXG4gIC8vICAgZ2FtbWEgaXMgaW4gWy0xODA7ICsxODBbLlxuXG4gIGNvbnN0IGFscGhhSXNWYWxpZCA9ICh0eXBlb2YgZXVsZXJBbmdsZVswXSA9PT0gJ251bWJlcicpO1xuXG4gIGNvbnN0IF9hbHBoYSA9IChhbHBoYUlzVmFsaWQgPyBkZWdUb1JhZChldWxlckFuZ2xlWzBdKSA6IDApO1xuICBjb25zdCBfYmV0YSA9IGRlZ1RvUmFkKGV1bGVyQW5nbGVbMV0pO1xuICBjb25zdCBfZ2FtbWEgPSBkZWdUb1JhZChldWxlckFuZ2xlWzJdKTtcblxuICBjb25zdCBjQSA9IE1hdGguY29zKF9hbHBoYSk7XG4gIGNvbnN0IGNCID0gTWF0aC5jb3MoX2JldGEpO1xuICBjb25zdCBjRyA9IE1hdGguY29zKF9nYW1tYSk7XG4gIGNvbnN0IHNBID0gTWF0aC5zaW4oX2FscGhhKTtcbiAgY29uc3Qgc0IgPSBNYXRoLnNpbihfYmV0YSk7XG4gIGNvbnN0IHNHID0gTWF0aC5zaW4oX2dhbW1hKTtcblxuICBsZXQgYWxwaGEsIGJldGEsIGdhbW1hO1xuXG4gIGxldCBtID0gW1xuICAgIGNBICogY0cgLSBzQSAqIHNCICogc0csXG4gICAgLWNCICogc0EsXG4gICAgY0EgKiBzRyArIGNHICogc0EgKiBzQixcbiAgICBjRyAqIHNBICsgY0EgKiBzQiAqIHNHLFxuICAgIGNBICogY0IsXG4gICAgc0EgKiBzRyAtIGNBICogY0cgKiBzQixcbiAgICAtY0IgKiBzRyxcbiAgICBzQixcbiAgICBjQiAqIGNHXG4gIF07XG4gIG5vcm1hbGl6ZShtKTtcblxuICBhbHBoYSA9IE1hdGguYXRhbjIoLW1bMV0sIG1bNF0pO1xuICBhbHBoYSArPSAoYWxwaGEgPCAwKSA/IDIgKiBNYXRoLlBJIDogMDsgLy8gYXRhbjIgcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIC1waSBhbmQgK3BpID0+IG1ha2Ugc3VyZSBhbHBoYSBpcyBpbiBbMCwgMipwaVsuXG4gIGJldGEgPSBNYXRoLmFzaW4obVs3XSk7IC8vIGFzaW4gcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIC1waS8yIGFuZCBwaS8yID0+IE9LXG4gIGdhbW1hID0gTWF0aC5hdGFuMigtbVs2XSwgbVs4XSk7IC8vIGF0YW4yIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAtcGkgYW5kICtwaSA9PiBPS1xuXG4gIGV1bGVyQW5nbGVbMF0gPSAoYWxwaGFJc1ZhbGlkID8gcmFkVG9EZWcoYWxwaGEpIDogbnVsbCk7XG4gIGV1bGVyQW5nbGVbMV0gPSByYWRUb0RlZyhiZXRhKTtcbiAgZXVsZXJBbmdsZVsyXSA9IHJhZFRvRGVnKGdhbW1hKTtcbn1cblxuLyoqXG4gKiBgRGV2aWNlT3JpZW50YXRpb25Nb2R1bGVgIHNpbmdsZXRvbi5cbiAqIFRoZSBgRGV2aWNlT3JpZW50YXRpb25Nb2R1bGVgIHNpbmdsZXRvbiBwcm92aWRlcyB0aGUgcmF3IHZhbHVlc1xuICogb2YgdGhlIG9yaWVudGF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBgRGV2aWNlTW90aW9uYCBldmVudC5cbiAqIEl0IGFsc28gaW5zdGFudGlhdGUgdGhlIGBPcmllbnRhdGlvbmAgc3VibW9kdWxlIHRoYXQgdW5pZmllcyB0aG9zZVxuICogdmFsdWVzIGFjcm9zcyBwbGF0Zm9ybXMgYnkgbWFraW5nIHRoZW0gY29tcGxpYW50IHdpdGgge0BsaW5rXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9vcmllbnRhdGlvbi1ldmVudC98dGhlIFczQyBzdGFuZGFyZH0gKCppLmUuKlxuICogdGhlIGBhbHBoYWAgYW5nbGUgYmV0d2VlbiBgMGAgYW5kIGAzNjBgIGRlZ3JlZXMsIHRoZSBgYmV0YWAgYW5nbGVcbiAqIGJldHdlZW4gYC0xODBgIGFuZCBgMTgwYCBkZWdyZWVzLCBhbmQgYGdhbW1hYCBiZXR3ZWVuIGAtOTBgIGFuZFxuICogYDkwYCBkZWdyZWVzKSwgYXMgd2VsbCBhcyB0aGUgYE9yaWVudGF0aW9uQWx0YCBzdWJtb2R1bGVzICh3aXRoXG4gKiB0aGUgYGFscGhhYCBhbmdsZSBiZXR3ZWVuIGAwYCBhbmQgYDM2MGAgZGVncmVlcywgdGhlIGBiZXRhYCBhbmdsZVxuICogYmV0d2VlbiBgLTkwYCBhbmQgYDkwYCBkZWdyZWVzLCBhbmQgYGdhbW1hYCBiZXR3ZWVuIGAtMTgwYCBhbmRcbiAqIGAxODBgIGRlZ3JlZXMpLlxuICogV2hlbiB0aGUgYG9yaWVudGF0aW9uYCByYXcgdmFsdWVzIGFyZSBub3QgcHJvdmlkZWQgYnkgdGhlIHNlbnNvcnMsXG4gKiB0aGlzIG1vZHVsZXMgdHJpZXMgdG8gcmVjYWxjdWxhdGUgYGJldGFgIGFuZCBgZ2FtbWFgIGZyb20gdGhlXG4gKiBgQWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgbW9kdWxlLCBpZiBhdmFpbGFibGUgKGluIHRoYXQgY2FzZSxcbiAqIHRoZSBgYWxwaGFgIGFuZ2xlIGlzIGltcG9zc2libGUgdG8gcmV0cmlldmUgc2luY2UgdGhlIGNvbXBhc3MgaXNcbiAqIG5vdCBhdmFpbGFibGUpLlxuICpcbiAqIEBjbGFzcyBEZXZpY2VNb3Rpb25Nb2R1bGVcbiAqIEBleHRlbmRzIElucHV0TW9kdWxlXG4gKi9cbmNsYXNzIERldmljZU9yaWVudGF0aW9uTW9kdWxlIGV4dGVuZHMgSW5wdXRNb2R1bGUge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBgRGV2aWNlT3JpZW50YXRpb25gIG1vZHVsZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignZGV2aWNlb3JpZW50YXRpb24nKTtcblxuICAgIC8qKlxuICAgICAqIFJhdyB2YWx1ZXMgY29taW5nIGZyb20gdGhlIGBkZXZpY2VvcmllbnRhdGlvbmAgZXZlbnQgc2VudCBieSB0aGlzIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU9yaWVudGF0aW9uTW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IFtudWxsLCBudWxsLCBudWxsXVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYE9yaWVudGF0aW9uYCBtb2R1bGUuXG4gICAgICogUHJvdmlkZXMgdW5pZmllZCB2YWx1ZXMgb2YgdGhlIG9yaWVudGF0aW9uIGNvbXBsaWFudCB3aXRoIHtAbGlua1xuICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL29yaWVudGF0aW9uLWV2ZW50L3x0aGUgVzNDIHN0YW5kYXJkfVxuICAgICAqIChgYWxwaGFgIGluIGBbMCwgMzYwXWAsIGJldGEgaW4gYFstMTgwLCArMTgwXWAsIGBnYW1tYWAgaW4gYFstOTAsICs5MF1gKS5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU9yaWVudGF0aW9uTW9kdWxlXG4gICAgICogQHR5cGUge0RPTUV2ZW50U3VibW9kdWxlfVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBuZXcgRE9NRXZlbnRTdWJtb2R1bGUodGhpcywgJ29yaWVudGF0aW9uJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYE9yaWVudGF0aW9uQWx0YCBtb2R1bGUuXG4gICAgICogUHJvdmlkZXMgYWx0ZXJuYXRpdmUgdmFsdWVzIG9mIHRoZSBvcmllbnRhdGlvblxuICAgICAqIChgYWxwaGFgIGluIGBbMCwgMzYwXWAsIGJldGEgaW4gYFstOTAsICs5MF1gLCBgZ2FtbWFgIGluIGBbLTE4MCwgKzE4MF1gKS5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU9yaWVudGF0aW9uTW9kdWxlXG4gICAgICogQHR5cGUge0RPTUV2ZW50U3VibW9kdWxlfVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50YXRpb25BbHQgPSBuZXcgRE9NRXZlbnRTdWJtb2R1bGUodGhpcywgJ29yaWVudGF0aW9uQWx0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBzdWJtb2R1bGVzIC8gZXZlbnRzLlxuICAgICAqXG4gICAgICogQHRoaXMgRGV2aWNlT3JpZW50YXRpb25Nb2R1bGVcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbH0gb3JpZW50YXRpb24gLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYG9yaWVudGF0aW9uYCB1bmlmaWVkIHZhbHVlcyBhcmUgcmVxdWlyZWQgb3Igbm90IChkZWZhdWx0cyB0byBgZmFsc2VgKS5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2x9IG9yaWVudGF0aW9uQWx0IC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGBvcmllbnRhdGlvbkFsdGAgdmFsdWVzIGFyZSByZXF1aXJlZCBvciBub3QgKGRlZmF1bHRzIHRvIGBmYWxzZWApLlxuICAgICAqL1xuICAgIHRoaXMucmVxdWlyZWQgPSB7XG4gICAgICBvcmllbnRhdGlvbjogZmFsc2UsXG4gICAgICBvcmllbnRhdGlvbkFsdDogZmFsc2VcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBmdW5jdGlvbiBvZiB0aGUgbW9kdWxlJ3MgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU9yaWVudGF0aW9uTW9kdWxlXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAc2VlIERldmljZU9yaWVudGF0aW9uTW9kdWxlI2luaXRcbiAgICAgKi9cbiAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBHcmF2aXR5IHZlY3RvciBjYWxjdWxhdGVkIGZyb20gdGhlIGBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5YCB1bmlmaWVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEB0aGlzIERldmljZU9yaWVudGF0aW9uTW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IFswLCAwLCAwXVxuICAgICAqL1xuICAgIHRoaXMuX2VzdGltYXRlZEdyYXZpdHkgPSBbMCwgMCwgMF07XG5cbiAgICB0aGlzLl9wcm9jZXNzRnVuY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuX3Byb2Nlc3MgPSB0aGlzLl9wcm9jZXNzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZGV2aWNlb3JpZW50YXRpb25DaGVjayA9IHRoaXMuX2RldmljZW9yaWVudGF0aW9uQ2hlY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9kZXZpY2VvcmllbnRhdGlvbkxpc3RlbmVyID0gdGhpcy5fZGV2aWNlb3JpZW50YXRpb25MaXN0ZW5lci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbnNvciBjaGVjayBvbiBpbml0aWFsaXphdGlvbiBvZiB0aGUgbW9kdWxlLlxuICAgKiBUaGlzIG1ldGhvZDpcbiAgICogLSBjaGVja3Mgd2hldGhlciB0aGUgYG9yaWVudGF0aW9uYCB2YWx1ZXMgYXJlIHZhbGlkIG9yIG5vdDtcbiAgICogLSAoaW4gdGhlIGNhc2Ugd2hlcmUgb3JpZW50YXRpb24gcmF3IHZhbHVlcyBhcmUgbm90IHByb3ZpZGVkKVxuICAgKiAgIHRyaWVzIHRvIGNhbGN1bGF0ZSB0aGUgb3JpZW50YXRpb24gZnJvbSB0aGVcbiAgICogICBgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgdW5pZmllZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RGV2aWNlTW90aW9uRXZlbnR9IGUgLSBGaXJzdCBgJ2RldmljZW1vdGlvbidgIGV2ZW50IGNhdWdodCwgb24gd2hpY2ggdGhlIGNoZWNrIGlzIGRvbmUuXG4gICAqL1xuICBfZGV2aWNlb3JpZW50YXRpb25DaGVjayhlKSB7XG4gICAgLy8gY2xlYXIgdGltZW91dCAoYW50aS1GaXJlZm94IGJ1ZyBzb2x1dGlvbiwgd2luZG93IGV2ZW50IGRldmljZW9yaWVudGF0aW9uIGJlaW5nIG52ZXIgY2FsbGVkKVxuICAgIC8vIHNldCB0aGUgc2V0IHRpbWVvdXQgaW4gaW5pdCgpIGZ1bmN0aW9uXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NoZWNrVGltZW91dElkKTtcblxuICAgIHRoaXMuaXNQcm92aWRlZCA9IHRydWU7XG5cbiAgICAvLyBTZW5zb3IgYXZhaWxhYmlsaXR5IGZvciB0aGUgb3JpZW50YXRpb24gYW5kIGFsdGVybmF0aXZlIG9yaWVudGF0aW9uXG4gICAgY29uc3QgcmF3VmFsdWVzUHJvdmlkZWQgPSAoKHR5cGVvZiBlLmFscGhhID09PSAnbnVtYmVyJykgJiYgKHR5cGVvZiBlLmJldGEgPT09ICdudW1iZXInKSAmJiAodHlwZW9mIGUuZ2FtbWEgPT09ICdudW1iZXInKSk7XG4gICAgdGhpcy5vcmllbnRhdGlvbi5pc1Byb3ZpZGVkID0gcmF3VmFsdWVzUHJvdmlkZWQ7XG4gICAgdGhpcy5vcmllbnRhdGlvbkFsdC5pc1Byb3ZpZGVkID0gcmF3VmFsdWVzUHJvdmlkZWQ7XG5cbiAgICAvLyBUT0RPKD8pOiBnZXQgcHNldWRvLXBlcmlvZFxuXG4gICAgLy8gc3dhcCB0aGUgcHJvY2VzcyBmdW5jdGlvbiB0byB0aGVcbiAgICB0aGlzLl9wcm9jZXNzRnVuY3Rpb24gPSB0aGlzLl9kZXZpY2VvcmllbnRhdGlvbkxpc3RlbmVyO1xuXG4gICAgLy8gSWYgb3JpZW50YXRpb24gb3IgYWx0ZXJuYXRpdmUgb3JpZW50YXRpb24gYXJlIG5vdCBwcm92aWRlZCBieSByYXcgc2Vuc29ycyBidXQgcmVxdWlyZWQsXG4gICAgLy8gdHJ5IHRvIGNhbGN1bGF0ZSB0aGVtIHdpdGggYGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlgIHVuaWZpZWQgdmFsdWVzXG4gICAgaWYgKCh0aGlzLnJlcXVpcmVkLm9yaWVudGF0aW9uICYmICF0aGlzLm9yaWVudGF0aW9uLmlzUHJvdmlkZWQpIHx8ICh0aGlzLnJlcXVpcmVkLm9yaWVudGF0aW9uQWx0ICYmICF0aGlzLm9yaWVudGF0aW9uQWx0LmlzUHJvdmlkZWQpKVxuICAgICAgdGhpcy5fdHJ5QWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eUZhbGxiYWNrKCk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5fcHJvbWlzZVJlc29sdmUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogYCdkZXZpY2VvcmllbnRhdGlvbidgIGV2ZW50IGNhbGxiYWNrLlxuICAgKiBUaGlzIG1ldGhvZCBlbWl0cyBhbiBldmVudCB3aXRoIHRoZSByYXcgYCdkZXZpY2VvcmllbnRhdGlvbidgIHZhbHVlcyxcbiAgICogYW5kIGVtaXRzIGV2ZW50cyB3aXRoIHRoZSB1bmlmaWVkIGBvcmllbnRhdGlvbmAgYW5kIC8gb3IgdGhlXG4gICAqIGBvcmllbnRhdGlvbkFsdGAgdmFsdWVzIGlmIHRoZXkgYXJlIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RldmljZU9yaWVudGF0aW9uRXZlbnR9IGUgLSBgJ2RldmljZW9yaWVudGF0aW9uJ2AgZXZlbnQgdGhlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tLlxuICAgKi9cbiAgX2RldmljZW9yaWVudGF0aW9uTGlzdGVuZXIoZSkge1xuICAgIC8vICdkZXZpY2VvcmllbnRhdGlvbicgZXZlbnQgKHJhdyB2YWx1ZXMpXG4gICAgbGV0IG91dEV2ZW50ID0gdGhpcy5ldmVudDtcblxuICAgIG91dEV2ZW50WzBdID0gZS5hbHBoYTtcbiAgICBvdXRFdmVudFsxXSA9IGUuYmV0YTtcbiAgICBvdXRFdmVudFsyXSA9IGUuZ2FtbWE7XG5cbiAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDApXG4gICAgICB0aGlzLmVtaXQob3V0RXZlbnQpO1xuXG4gICAgLy8gJ29yaWVudGF0aW9uJyBldmVudCAodW5pZmllZCB2YWx1ZXMpXG4gICAgaWYgKHRoaXMub3JpZW50YXRpb24ubGlzdGVuZXJzLnNpemUgPiAwICYmXG4gICAgICAgIHRoaXMucmVxdWlyZWQub3JpZW50YXRpb24gJiZcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbi5pc1Byb3ZpZGVkXG4gICAgKSB7XG4gICAgICAvLyBPbiBpT1MsIHRoZSBgYWxwaGFgIHZhbHVlIGlzIGluaXRpYWxpemVkIGF0IGAwYCBvbiB0aGUgZmlyc3QgYGRldmljZW9yaWVudGF0aW9uYCBldmVudFxuICAgICAgLy8gc28gd2Uga2VlcCB0aGF0IHJlZmVyZW5jZSBpbiBtZW1vcnkgdG8gY2FsY3VsYXRlIHRoZSBOb3J0aCBsYXRlciBvblxuICAgICAgaWYgKCF0aGlzLm9yaWVudGF0aW9uLl93ZWJraXRDb21wYXNzSGVhZGluZ1JlZmVyZW5jZSAmJiBlLndlYmtpdENvbXBhc3NIZWFkaW5nICYmIHBsYXRmb3JtLm9zLmZhbWlseSA9PT0gJ2lPUycpXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24uX3dlYmtpdENvbXBhc3NIZWFkaW5nUmVmZXJlbmNlID0gZS53ZWJraXRDb21wYXNzSGVhZGluZztcblxuICAgICAgbGV0IG91dEV2ZW50ID0gdGhpcy5vcmllbnRhdGlvbi5ldmVudDtcblxuICAgICAgb3V0RXZlbnRbMF0gPSBlLmFscGhhO1xuICAgICAgb3V0RXZlbnRbMV0gPSBlLmJldGE7XG4gICAgICBvdXRFdmVudFsyXSA9IGUuZ2FtbWE7XG5cbiAgICAgIC8vIE9uIGlPUywgcmVwbGFjZSB0aGUgYGFscGhhYCB2YWx1ZSBieSB0aGUgTm9ydGggdmFsdWUgYW5kIHVuaWZ5IHRoZSBhbmdsZXNcbiAgICAgIC8vICh0aGUgZGVmYXVsdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYW5nbGVzIG9uIGlPUyBpcyBub3QgY29tcGxpYW50IHdpdGggdGhlIFczQyBzcGVjaWZpY2F0aW9uKVxuICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24uX3dlYmtpdENvbXBhc3NIZWFkaW5nUmVmZXJlbmNlICYmIHBsYXRmb3JtLm9zLmZhbWlseSA9PT0gJ2lPUycpIHtcbiAgICAgICAgb3V0RXZlbnRbMF0gKz0gMzYwIC0gdGhpcy5vcmllbnRhdGlvbi5fd2Via2l0Q29tcGFzc0hlYWRpbmdSZWZlcmVuY2U7XG4gICAgICAgIHVuaWZ5KG91dEV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmllbnRhdGlvbi5lbWl0KG91dEV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyAnb3JpZW50YXRpb25BbHQnIGV2ZW50XG4gICAgaWYgKHRoaXMub3JpZW50YXRpb25BbHQubGlzdGVuZXJzLnNpemUgPiAwICYmXG4gICAgICAgIHRoaXMucmVxdWlyZWQub3JpZW50YXRpb25BbHQgJiZcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkFsdC5pc1Byb3ZpZGVkXG4gICAgKSB7XG4gICAgICAvLyBPbiBpT1MsIHRoZSBgYWxwaGFgIHZhbHVlIGlzIGluaXRpYWxpemVkIGF0IGAwYCBvbiB0aGUgZmlyc3QgYGRldmljZW9yaWVudGF0aW9uYCBldmVudFxuICAgICAgLy8gc28gd2Uga2VlcCB0aGF0IHJlZmVyZW5jZSBpbiBtZW1vcnkgdG8gY2FsY3VsYXRlIHRoZSBOb3J0aCBsYXRlciBvblxuICAgICAgaWYgKCF0aGlzLm9yaWVudGF0aW9uQWx0Ll93ZWJraXRDb21wYXNzSGVhZGluZ1JlZmVyZW5jZSAmJiBlLndlYmtpdENvbXBhc3NIZWFkaW5nICYmIHBsYXRmb3JtLm9zLmZhbWlseSA9PT0gJ2lPUycpXG4gICAgICAgIHRoaXMub3JpZW50YXRpb25BbHQuX3dlYmtpdENvbXBhc3NIZWFkaW5nUmVmZXJlbmNlID0gZS53ZWJraXRDb21wYXNzSGVhZGluZztcblxuICAgICAgbGV0IG91dEV2ZW50ID0gdGhpcy5vcmllbnRhdGlvbkFsdC5ldmVudDtcblxuICAgICAgb3V0RXZlbnRbMF0gPSBlLmFscGhhO1xuICAgICAgb3V0RXZlbnRbMV0gPSBlLmJldGE7XG4gICAgICBvdXRFdmVudFsyXSA9IGUuZ2FtbWE7XG5cbiAgICAgIC8vIE9uIGlPUywgcmVwbGFjZSB0aGUgYGFscGhhYCB2YWx1ZSBieSB0aGUgTm9ydGggdmFsdWUgYnV0IGRvIG5vdCBjb252ZXJ0IHRoZSBhbmdsZXNcbiAgICAgIC8vICh0aGUgZGVmYXVsdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYW5nbGVzIG9uIGlPUyBpcyBjb21wbGlhbnQgd2l0aCB0aGUgYWx0ZXJuYXRpdmUgcmVwcmVzZW50YXRpb24pXG4gICAgICBpZiAodGhpcy5vcmllbnRhdGlvbkFsdC5fd2Via2l0Q29tcGFzc0hlYWRpbmdSZWZlcmVuY2UgJiYgcGxhdGZvcm0ub3MuZmFtaWx5ID09PSAnaU9TJyl7XG4gICAgICAgIG91dEV2ZW50WzBdIC09IHRoaXMub3JpZW50YXRpb25BbHQuX3dlYmtpdENvbXBhc3NIZWFkaW5nUmVmZXJlbmNlO1xuICAgICAgICBvdXRFdmVudFswXSArPSAob3V0RXZlbnRbMF0gPCAwKSA/IDM2MCA6IDA7IC8vIG1ha2Ugc3VyZSBgYWxwaGFgIGlzIGluIFswLCArMzYwW1xuICAgICAgfVxuXG4gICAgICAvLyBPbiBBbmRyb2lkLCB0cmFuc2Zvcm0gdGhlIGFuZ2xlcyB0byB0aGUgYWx0ZXJuYXRpdmUgcmVwcmVzZW50YXRpb25cbiAgICAgIC8vICh0aGUgZGVmYXVsdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYW5nbGVzIG9uIEFuZHJvaWQgaXMgY29tcGxpYW50IHdpdGggdGhlIFczQyBzcGVjaWZpY2F0aW9uKVxuICAgICAgaWYgKHBsYXRmb3JtLm9zLmZhbWlseSA9PT0gJ0FuZHJvaWQnKVxuICAgICAgICB1bmlmeUFsdChvdXRFdmVudCk7XG5cbiAgICAgIHRoaXMub3JpZW50YXRpb25BbHQuZW1pdChvdXRFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGBiZXRhYCBhbmQgYGdhbW1hYCBjYW4gYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgdmFsdWVzIG9yIG5vdC5cbiAgICovXG4gIF90cnlBY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5RmFsbGJhY2soKSB7XG4gICAgTW90aW9uSW5wdXQucmVxdWlyZU1vZHVsZSgnYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eScpXG4gICAgICAudGhlbigoYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSkgPT4ge1xuICAgICAgICBpZiAoYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS5pc1ZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOSU5HIChtb3Rpb24taW5wdXQpOiBUaGUgJ2RldmljZW9yaWVudGF0aW9uJyBldmVudCBkb2VzIG5vdCBleGlzdCBvciBkb2VzIG5vdCBwcm92aWRlIHZhbHVlcyBpbiB5b3VyIGJyb3dzZXIsIHNvIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgZGV2aWNlIGlzIGVzdGltYXRlZCBmcm9tIERldmljZU1vdGlvbidzICdhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5JyBldmVudC4gU2luY2UgdGhlIGNvbXBhc3MgaXMgbm90IGF2YWlsYWJsZSwgb25seSB0aGUgYGJldGFgIGFuZCBgZ2FtbWFgIGFuZ2xlcyBhcmUgcHJvdmlkZWQgKGBhbHBoYWAgaXMgbnVsbCkuXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMub3JpZW50YXRpb24uaXNDYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub3JpZW50YXRpb24ucGVyaW9kID0gYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS5wZXJpb2Q7XG5cbiAgICAgICAgICAgIE1vdGlvbklucHV0LmFkZExpc3RlbmVyKCdhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5JywgKGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlQmV0YUFuZEdhbW1hRnJvbUFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkoYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlZC5vcmllbnRhdGlvbkFsdCkge1xuICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbkFsdC5pc0NhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbkFsdC5wZXJpb2QgPSBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnBlcmlvZDtcblxuICAgICAgICAgICAgTW90aW9uSW5wdXQuYWRkTGlzdGVuZXIoJ2FjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHknLCAoYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVCZXRhQW5kR2FtbWFGcm9tQWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eShhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb21pc2VSZXNvbHZlKHRoaXMpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhbmQgZW1pdHMgYGJldGFgIGFuZCBgZ2FtbWFgIHZhbHVlcyBhcyBhIGZhbGxiYWNrIG9mIHRoZSBgb3JpZW50YXRpb25gIGFuZCAvIG9yIGBvcmllbnRhdGlvbkFsdGAgZXZlbnRzLCBmcm9tIHRoZSBgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eWAgdW5pZmllZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgLSBMYXRlc3QgYGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgcmF3IHZhbHVlcy5cbiAgICogQHBhcmFtIHtib29sfSBbYWx0PWZhbHNlXSAtIEluZGljYXRlcyB3aGV0aGVyIHdlIG5lZWQgdGhlIGFsdGVybmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgYW5nbGVzIG9yIG5vdC5cbiAgICovXG4gIF9jYWxjdWxhdGVCZXRhQW5kR2FtbWFGcm9tQWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eShhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LCBhbHQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGsgPSAwLjg7XG5cbiAgICAvLyBMb3cgcGFzcyBmaWx0ZXIgdG8gZXN0aW1hdGUgdGhlIGdyYXZpdHlcbiAgICB0aGlzLl9lc3RpbWF0ZWRHcmF2aXR5WzBdID0gayAqIHRoaXMuX2VzdGltYXRlZEdyYXZpdHlbMF0gKyAoMSAtIGspICogYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVswXTtcbiAgICB0aGlzLl9lc3RpbWF0ZWRHcmF2aXR5WzFdID0gayAqIHRoaXMuX2VzdGltYXRlZEdyYXZpdHlbMV0gKyAoMSAtIGspICogYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVsxXTtcbiAgICB0aGlzLl9lc3RpbWF0ZWRHcmF2aXR5WzJdID0gayAqIHRoaXMuX2VzdGltYXRlZEdyYXZpdHlbMl0gKyAoMSAtIGspICogYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVsyXTtcblxuICAgIGxldCBfZ1ggPSB0aGlzLl9lc3RpbWF0ZWRHcmF2aXR5WzBdO1xuICAgIGxldCBfZ1kgPSB0aGlzLl9lc3RpbWF0ZWRHcmF2aXR5WzFdO1xuICAgIGxldCBfZ1ogPSB0aGlzLl9lc3RpbWF0ZWRHcmF2aXR5WzJdO1xuXG4gICAgY29uc3Qgbm9ybSA9IE1hdGguc3FydChfZ1ggKiBfZ1ggKyBfZ1kgKiBfZ1kgKyBfZ1ogKiBfZ1opO1xuXG4gICAgX2dYIC89IG5vcm07XG4gICAgX2dZIC89IG5vcm07XG4gICAgX2daIC89IG5vcm07XG5cbiAgICAvLyBBZG9wdGluZyB0aGUgZm9sbG93aW5nIGNvbnZlbnRpb25zOlxuICAgIC8vIC0gZWFjaCBtYXRyaXggb3BlcmF0ZXMgYnkgcHJlLW11bHRpcGx5aW5nIGNvbHVtbiB2ZWN0b3JzLFxuICAgIC8vIC0gZWFjaCBtYXRyaXggcmVwcmVzZW50cyBhbiBhY3RpdmUgcm90YXRpb24sXG4gICAgLy8gLSBlYWNoIG1hdHJpeCByZXByZXNlbnRzIHRoZSBjb21wb3NpdGlvbiBvZiBpbnRyaW5zaWMgcm90YXRpb25zLFxuICAgIC8vIHRoZSByb3RhdGlvbiBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSBjb21wb3NpdGlvbiBvZiBhIHJvdGF0aW9uXG4gICAgLy8gYWJvdXQgdGhlIHgtYXhpcyBieSBhbiBhbmdsZSBiZXRhIGFuZCBhIHJvdGF0aW9uIGFib3V0IHRoZSB5LWF4aXNcbiAgICAvLyBieSBhbiBhbmdsZSBnYW1tYSBpczpcbiAgICAvL1xuICAgIC8vIFsgY29zKGdhbW1hKSAgICAgICAgICAgICAgICwgIDAgICAgICAgICAgLCAgc2luKGdhbW1hKSAgICAgICAgICAgICAgLFxuICAgIC8vICAgc2luKGJldGEpICogc2luKGdhbW1hKSAgICwgIGNvcyhiZXRhKSAgLCAgLWNvcyhnYW1tYSkgKiBzaW4oYmV0YSkgLFxuICAgIC8vICAgLWNvcyhiZXRhKSAqIHNpbihnYW1tYSkgICwgIHNpbihiZXRhKSAgLCAgY29zKGJldGEpICogY29zKGdhbW1hKSAgXS5cbiAgICAvL1xuICAgIC8vIEhlbmNlLCB0aGUgcHJvamVjdGlvbiBvZiB0aGUgbm9ybWFsaXplZCBncmF2aXR5IGcgPSBbMCwgMCwgMV1cbiAgICAvLyBpbiB0aGUgZGV2aWNlJ3MgcmVmZXJlbmNlIGZyYW1lIGNvcnJlc3BvbmRzIHRvOlxuICAgIC8vXG4gICAgLy8gZ1ggPSAtY29zKGJldGEpICogc2luKGdhbW1hKSxcbiAgICAvLyBnWSA9IHNpbihiZXRhKSxcbiAgICAvLyBnWiA9IGNvcyhiZXRhKSAqIGNvcyhnYW1tYSksXG4gICAgLy9cbiAgICAvLyBzbyBiZXRhID0gYXNpbihnWSkgYW5kIGdhbW1hID0gYXRhbjIoLWdYLCBnWikuXG5cbiAgICAvLyBCZXRhICYgZ2FtbWEgZXF1YXRpb25zICh3ZSBhcHByb3hpbWF0ZSBbZ1gsIGdZLCBnWl0gYnkgW19nWCwgX2dZLCBfZ1pdKVxuICAgIGxldCBiZXRhID0gcmFkVG9EZWcoTWF0aC5hc2luKF9nWSkpOyAvLyBiZXRhIGlzIGluIFstcGkvMjsgcGkvMltcbiAgICBsZXQgZ2FtbWEgPSByYWRUb0RlZyhNYXRoLmF0YW4yKC1fZ1gsIF9nWikpOyAvLyBnYW1tYSBpcyBpbiBbLXBpOyBwaVtcblxuICAgIGlmIChhbHQpIHtcbiAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlcmUgaXMgbm90aGluZyB0byBkbyBzaW5jZSB0aGUgY2FsY3VsYXRpb25zIGFib3ZlIGdhdmUgdGhlIGFuZ2xlIGluIHRoZSByaWdodCByYW5nZXNcbiAgICAgIGxldCBvdXRFdmVudCA9IHRoaXMub3JpZW50YXRpb25BbHQuZXZlbnQ7XG4gICAgICBvdXRFdmVudFswXSA9IG51bGw7XG4gICAgICBvdXRFdmVudFsxXSA9IGJldGE7XG4gICAgICBvdXRFdmVudFsyXSA9IGdhbW1hO1xuXG4gICAgICB0aGlzLm9yaWVudGF0aW9uQWx0LmVtaXQob3V0RXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIZXJlIHdlIGhhdmUgdG8gdW5pZnkgdGhlIGFuZ2xlcyB0byBnZXQgdGhlIHJhbmdlcyBjb21wbGlhbnQgd2l0aCB0aGUgVzNDIHNwZWNpZmljYXRpb25cbiAgICAgIGxldCBvdXRFdmVudCA9IHRoaXMub3JpZW50YXRpb24uZXZlbnQ7XG4gICAgICBvdXRFdmVudFswXSA9IG51bGw7XG4gICAgICBvdXRFdmVudFsxXSA9IGJldGE7XG4gICAgICBvdXRFdmVudFsyXSA9IGdhbW1hO1xuICAgICAgdW5pZnkob3V0RXZlbnQpO1xuXG4gICAgICB0aGlzLm9yaWVudGF0aW9uLmVtaXQob3V0RXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIF9wcm9jZXNzKGRhdGEpIHtcbiAgICB0aGlzLl9wcm9jZXNzRnVuY3Rpb24oZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgb2YgdGhlIG1vZHVsZS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGluaXQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmluaXQoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3Byb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcblxuICAgICAgaWYgKHdpbmRvdy5EZXZpY2VPcmllbnRhdGlvbkV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGdW5jdGlvbiA9IHRoaXMuX2RldmljZW9yaWVudGF0aW9uQ2hlY2s7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VvcmllbnRhdGlvbicsIHRoaXMuX3Byb2Nlc3MsIGZhbHNlKTtcbiAgICAgICAgLy8gc2V0IGZhbGxiYWNrIHRpbWVvdXQgZm9yIEZpcmVmb3ggKGl0cyB3aW5kb3cgbmV2ZXIgY2FsbGluZyB0aGUgRGV2aWNlT3JpZW50YXRpb24gZXZlbnQsIGEgXG4gICAgICAgIC8vIHJlcXVpcmUgb2YgdGhlIERldmljZU9yaWVudGF0aW9uIHNlcnZpY2Ugd2lsbCByZXN1bHQgaW4gdGhlIHJlcXVpcmUgcHJvbWlzZSBuZXZlciBiZWluZyByZXNvbHZlZFxuICAgICAgICAvLyBoZW5jZSB0aGUgRXhwZXJpbWVudCBzdGFydCgpIG1ldGhvZCBuZXZlciBjYWxsZWQpXG4gICAgICAgIHRoaXMuX2NoZWNrVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHRoaXMpLCA1MDApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVpcmVkLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIHRoaXMuX3RyeUFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlGYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgRGV2aWNlT3JpZW50YXRpb25Nb2R1bGUoKTtcbiIsImltcG9ydCBJbnB1dE1vZHVsZSBmcm9tICcuL0lucHV0TW9kdWxlJztcbmltcG9ydCBtb3Rpb25JbnB1dCBmcm9tICcuL01vdGlvbklucHV0JztcblxuLyoqXG4gKiBFbmVyZ3kgbW9kdWxlIHNpbmdsZXRvbi5cbiAqIFRoZSBlbmVyZ3kgbW9kdWxlIHNpbmdsZXRvbiBwcm92aWRlcyBlbmVyZ3kgdmFsdWVzIChiZXR3ZWVuIDAgYW5kIDEpXG4gKiBiYXNlZCBvbiB0aGUgYWNjZWxlcmF0aW9uIGFuZCB0aGUgcm90YXRpb24gcmF0ZSBvZiB0aGUgZGV2aWNlLlxuICogVGhlIHBlcmlvZCBvZiB0aGUgZW5lcmd5IHZhbHVlcyBpcyB0aGUgc2FtZSBhcyB0aGUgcGVyaW9kIG9mIHRoZVxuICogYWNjZWxlcmF0aW9uIGFuZCB0aGUgcm90YXRpb24gcmF0ZSB2YWx1ZXMuXG4gKlxuICogQGNsYXNzIEVuZXJneU1vZHVsZVxuICogQGV4dGVuZHMgSW5wdXRNb2R1bGVcbiAqL1xuY2xhc3MgRW5lcmd5TW9kdWxlIGV4dGVuZHMgSW5wdXRNb2R1bGUge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBlbmVyZ3kgbW9kdWxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdlbmVyZ3knKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGNvbnRhaW5pbmcgdGhlIHZhbHVlIG9mIHRoZSBlbmVyZ3ksIHNlbnQgYnkgdGhlIGVuZXJneSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAdGhpcyBFbmVyZ3lNb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhY2NlbGVyYXRpb24gbW9kdWxlLCB1c2VkIGluIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgZW5lcmd5LlxuICAgICAqXG4gICAgICogQHRoaXMgRW5lcmd5TW9kdWxlXG4gICAgICogQHR5cGUge0RPTUV2ZW50U3VibW9kdWxlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAc2VlIERldmljZW1vdGlvbk1vZHVsZVxuICAgICAqL1xuICAgIHRoaXMuX2FjY2VsZXJhdGlvbk1vZHVsZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMYXRlc3QgYWNjZWxlcmF0aW9uIHZhbHVlIHNlbnQgYnkgdGhlIGFjY2VsZXJhdGlvbiBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAdGhpcyBFbmVyZ3lNb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRoaXMuX2FjY2VsZXJhdGlvblZhbHVlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHZhbHVlIHJlYWNoZWQgYnkgdGhlIGFjY2VsZXJhdGlvbiBtYWduaXR1ZGUsIGNsaXBwZWQgYXQgYHRoaXMuX2FjY2VsZXJhdGlvbk1hZ25pdHVkZVRocmVzaG9sZGAuXG4gICAgICpcbiAgICAgKiBAdGhpcyBFbmVyZ3lNb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDkuODFcbiAgICAgKi9cbiAgICB0aGlzLl9hY2NlbGVyYXRpb25NYWduaXR1ZGVDdXJyZW50TWF4ID0gMSAqIDkuODE7XG5cbiAgICAvKipcbiAgICAgKiBDbGlwcGluZyB2YWx1ZSBvZiB0aGUgYWNjZWxlcmF0aW9uIG1hZ25pdHVkZS5cbiAgICAgKlxuICAgICAqIEB0aGlzIEVuZXJneU1vZHVsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMjBcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICB0aGlzLl9hY2NlbGVyYXRpb25NYWduaXR1ZGVUaHJlc2hvbGQgPSA0ICogOS44MTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb3RhdGlvbiByYXRlIG1vZHVsZSwgdXNlZCBpbiB0aGUgY2FsY3VsYXRpb24gb2YgdGhlIGVuZXJneS5cbiAgICAgKlxuICAgICAqIEB0aGlzIEVuZXJneU1vZHVsZVxuICAgICAqIEB0eXBlIHtET01FdmVudFN1Ym1vZHVsZX1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQHNlZSBEZXZpY2Vtb3Rpb25Nb2R1bGVcbiAgICAgKi9cbiAgICB0aGlzLl9yb3RhdGlvblJhdGVNb2R1bGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogTGF0ZXN0IHJvdGF0aW9uIHJhdGUgdmFsdWUgc2VudCBieSB0aGUgcm90YXRpb24gcmF0ZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAdGhpcyBFbmVyZ3lNb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRoaXMuX3JvdGF0aW9uUmF0ZVZhbHVlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHZhbHVlIHJlYWNoZWQgYnkgdGhlIHJvdGF0aW9uIHJhdGUgbWFnbml0dWRlLCBjbGlwcGVkIGF0IGB0aGlzLl9yb3RhdGlvblJhdGVNYWduaXR1ZGVUaHJlc2hvbGRgLlxuICAgICAqXG4gICAgICogQHRoaXMgRW5lcmd5TW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA0MDBcbiAgICAgKi9cbiAgICB0aGlzLl9yb3RhdGlvblJhdGVNYWduaXR1ZGVDdXJyZW50TWF4ID0gNDAwO1xuXG4gICAgLyoqXG4gICAgICogQ2xpcHBpbmcgdmFsdWUgb2YgdGhlIHJvdGF0aW9uIHJhdGUgbWFnbml0dWRlLlxuICAgICAqXG4gICAgICogQHRoaXMgRW5lcmd5TW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICB0aGlzLl9yb3RhdGlvblJhdGVNYWduaXR1ZGVUaHJlc2hvbGQgPSA2MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaW1lIGNvbnN0YW50IChoYWxmLWxpZmUpIG9mIHRoZSBsb3ctcGFzcyBmaWx0ZXIgdXNlZCB0byBzbW9vdGggdGhlIGVuZXJneSB2YWx1ZXMgKGluIHNlY29uZHMpLlxuICAgICAqXG4gICAgICogQHRoaXMgRW5lcmd5TW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICB0aGlzLl9lbmVyZ3lUaW1lQ29uc3RhbnQgPSAwLjE7XG5cbiAgICB0aGlzLl9vbkFjY2VsZXJhdGlvbiA9IHRoaXMuX29uQWNjZWxlcmF0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Sb3RhdGlvblJhdGUgPSB0aGlzLl9vblJvdGF0aW9uUmF0ZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY2F5IGZhY3RvciBvZiB0aGUgbG93LXBhc3MgZmlsdGVyIHVzZWQgdG8gc21vb3RoIHRoZSBlbmVyZ3kgdmFsdWVzLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBfZW5lcmd5RGVjYXkoKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0yICogTWF0aC5QSSAqIHRoaXMucGVyaW9kIC8gdGhpcy5fZW5lcmd5VGltZUNvbnN0YW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBvZiB0aGUgbW9kdWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICByZXR1cm4gc3VwZXIuaW5pdCgocmVzb2x2ZSkgPT4ge1xuICAgICAgLy8gVGhlIGVuZXJneSBtb2R1bGUgcmVxdWlyZXMgdGhlIGFjY2VsZXJhdGlvbiBhbmQgdGhlIHJvdGF0aW9uIHJhdGUgbW9kdWxlc1xuICAgICAgUHJvbWlzZS5hbGwoW21vdGlvbklucHV0LnJlcXVpcmVNb2R1bGUoJ2FjY2VsZXJhdGlvbicpLCBtb3Rpb25JbnB1dC5yZXF1aXJlTW9kdWxlKCdyb3RhdGlvblJhdGUnKV0pXG4gICAgICAgIC50aGVuKChtb2R1bGVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgW2FjY2VsZXJhdGlvbiwgcm90YXRpb25SYXRlXSA9IG1vZHVsZXM7XG5cbiAgICAgICAgICB0aGlzLl9hY2NlbGVyYXRpb25Nb2R1bGUgPSBhY2NlbGVyYXRpb247XG4gICAgICAgICAgdGhpcy5fcm90YXRpb25SYXRlTW9kdWxlID0gcm90YXRpb25SYXRlO1xuICAgICAgICAgIHRoaXMuaXNDYWxjdWxhdGVkID0gdGhpcy5fYWNjZWxlcmF0aW9uTW9kdWxlLmlzVmFsaWQgfHwgdGhpcy5fcm90YXRpb25SYXRlTW9kdWxlLmlzVmFsaWQ7XG5cbiAgICAgICAgICBpZiAodGhpcy5fYWNjZWxlcmF0aW9uTW9kdWxlLmlzVmFsaWQpXG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IHRoaXMuX2FjY2VsZXJhdGlvbk1vZHVsZS5wZXJpb2Q7XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5fcm90YXRpb25SYXRlTW9kdWxlLmlzVmFsaWQpXG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IHRoaXMuX3JvdGF0aW9uUmF0ZU1vZHVsZS5wZXJpb2Q7XG5cbiAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9hY2NlbGVyYXRpb25Nb2R1bGUuaXNWYWxpZClcbiAgICAgICAgdGhpcy5fYWNjZWxlcmF0aW9uTW9kdWxlLmFkZExpc3RlbmVyKHRoaXMuX29uQWNjZWxlcmF0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9yb3RhdGlvblJhdGVNb2R1bGUuaXNWYWxpZClcbiAgICAgICAgdGhpcy5fcm90YXRpb25SYXRlTW9kdWxlLmFkZExpc3RlbmVyKHRoaXMuX29uUm90YXRpb25SYXRlKTtcbiAgICB9XG5cbiAgICBzdXBlci5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5fYWNjZWxlcmF0aW9uTW9kdWxlLmlzVmFsaWQpXG4gICAgICAgIHRoaXMuX2FjY2VsZXJhdGlvbk1vZHVsZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9vbkFjY2VsZXJhdGlvbik7XG4gICAgICBpZiAodGhpcy5fcm90YXRpb25SYXRlTW9kdWxlLmlzVmFsaWQpXG4gICAgICAgIHRoaXMuX3JvdGF0aW9uUmF0ZU1vZHVsZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9vblJvdGF0aW9uUmF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VsZXJhdGlvbiB2YWx1ZXMgaGFuZGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYWNjZWxlcmF0aW9uIC0gTGF0ZXN0IGFjY2VsZXJhdGlvbiB2YWx1ZS5cbiAgICovXG4gIF9vbkFjY2VsZXJhdGlvbihhY2NlbGVyYXRpb24pIHtcbiAgICB0aGlzLl9hY2NlbGVyYXRpb25WYWx1ZXMgPSBhY2NlbGVyYXRpb247XG5cbiAgICAvLyBJZiB0aGUgcm90YXRpb24gcmF0ZSB2YWx1ZXMgYXJlIG5vdCBhdmFpbGFibGUsIHdlIGNhbGN1bGF0ZSB0aGUgZW5lcmd5IHJpZ2h0IGF3YXkuXG4gICAgaWYgKCF0aGlzLl9yb3RhdGlvblJhdGVNb2R1bGUuaXNWYWxpZClcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUVuZXJneSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0aW9uIHJhdGUgdmFsdWVzIGhhbmRsZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHJvdGF0aW9uUmF0ZSAtIExhdGVzdCByb3RhdGlvbiByYXRlIHZhbHVlLlxuICAgKi9cbiAgX29uUm90YXRpb25SYXRlKHJvdGF0aW9uUmF0ZSkge1xuICAgIHRoaXMuX3JvdGF0aW9uUmF0ZVZhbHVlcyA9IHJvdGF0aW9uUmF0ZTtcblxuICAgIC8vIFdlIGtub3cgdGhhdCB0aGUgYWNjZWxlcmF0aW9uIGFuZCByb3RhdGlvbiByYXRlIHZhbHVlcyBjb21pbmcgZnJvbSB0aGVcbiAgICAvLyBzYW1lIGBkZXZpY2Vtb3Rpb25gIGV2ZW50IGFyZSBzZW50IGluIHRoYXQgb3JkZXIgKGFjY2VsZXJhdGlvbiA+IHJvdGF0aW9uIHJhdGUpXG4gICAgLy8gc28gd2hlbiB0aGUgcm90YXRpb24gcmF0ZSBpcyBwcm92aWRlZCwgd2UgY2FsY3VsYXRlIHRoZSBlbmVyZ3kgdmFsdWUgb2YgdGhlXG4gICAgLy8gbGF0ZXN0IGBkZXZpY2Vtb3Rpb25gIGV2ZW50IHdoZW4gd2UgcmVjZWl2ZSB0aGUgcm90YXRpb24gcmF0ZSB2YWx1ZXMuXG4gICAgdGhpcy5fY2FsY3VsYXRlRW5lcmd5KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5lcmd5IGNhbGN1bGF0aW9uOiBlbWl0cyBhbiBlbmVyZ3kgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgdGhlIGFjY2VsZXJhdGlvbiBtb2R1bGVzIGlzIHZhbGlkLiBJZiB0aGF0IGlzIHRoZSBjYXNlLFxuICAgKiBpdCBjYWxjdWxhdGVzIGFuIGVzdGltYXRpb24gb2YgdGhlIGVuZXJneSAoYmV0d2VlbiAwIGFuZCAxKSBiYXNlZCBvbiB0aGUgcmF0aW9cbiAgICogb2YgdGhlIGN1cnJlbnQgYWNjZWxlcmF0aW9uIG1hZ25pdHVkZSBhbmQgdGhlIG1heGltdW0gYWNjZWxlcmF0aW9uIG1hZ25pdHVkZVxuICAgKiByZWFjaGVkIHNvIGZhciAoY2xpcHBlZCBhdCB0aGUgYHRoaXMuX2FjY2VsZXJhdGlvbk1hZ25pdHVkZVRocmVzaG9sZGAgdmFsdWUpLlxuICAgKiAoV2UgdXNlIHRoaXMgdHJpY2sgdG8gZ2V0IHVuaWZvcm0gYmVoYXZpb3JzIGFtb25nIGRldmljZXMuIElmIHdlIGNhbGN1bGF0ZWRcbiAgICogdGhlIHJhdGlvIGJhc2VkIG9uIGEgZml4ZWQgdmFsdWUgaW5kZXBlbmRlbnQgb2Ygd2hhdCB0aGUgZGV2aWNlIGlzIGNhcGFibGUgb2ZcbiAgICogcHJvdmlkaW5nLCB3ZSBjb3VsZCBnZXQgaW5jb25zaXN0ZW50IGJlaGF2aW9ycy4gRm9yIGluc3RhbmNlLCB0aGUgZGV2aWNlc1xuICAgKiB3aG9zZSBhY2NlbGVyb21ldGVycyBhcmUgbGltaXRlZCBhdCAyZyB3b3VsZCBhbHdheXMgcHJvdmlkZSB2ZXJ5IGxvdyB2YWx1ZXNcbiAgICogY29tcGFyZWQgdG8gZGV2aWNlcyB3aXRoIGFjY2VsZXJvbWV0ZXJzIGNhcGFibGUgb2YgbWVhc3VyaW5nIDRnIGFjY2VsZXJhdGlvbnMuKVxuICAgKiBUaGUgc2FtZSBjaGVja3MgYW5kIGNhbGN1bGF0aW9ucyBhcmUgbWFkZSBvbiB0aGUgcm90YXRpb24gcmF0ZSBtb2R1bGUuXG4gICAqIEZpbmFsbHksIHRoZSBlbmVyZ3kgdmFsdWUgaXMgdGhlIG1heGltdW0gYmV0d2VlbiB0aGUgZW5lcmd5IHZhbHVlIGVzdGltYXRlZFxuICAgKiBmcm9tIHRoZSBhY2NlbGVyYXRpb24sIGFuZCB0aGUgb25lIGVzdGltYXRlZCBmcm9tIHRoZSByb3RhdGlvbiByYXRlLiBJdCBpc1xuICAgKiBzbW9vdGhlZCB0aHJvdWdoIGEgbG93LXBhc3MgZmlsdGVyLlxuICAgKi9cbiAgX2NhbGN1bGF0ZUVuZXJneSgpIHtcbiAgICBsZXQgYWNjZWxlcmF0aW9uRW5lcmd5ID0gMDtcbiAgICBsZXQgcm90YXRpb25SYXRlRW5lcmd5ID0gMDtcblxuICAgIC8vIENoZWNrIHRoZSBhY2NlbGVyYXRpb24gbW9kdWxlIGFuZCBjYWxjdWxhdGUgYW4gZXN0aW1hdGlvbiBvZiB0aGUgZW5lcmd5IHZhbHVlIGZyb20gdGhlIGxhdGVzdCBhY2NlbGVyYXRpb24gdmFsdWVcbiAgICBpZiAodGhpcy5fYWNjZWxlcmF0aW9uTW9kdWxlLmlzVmFsaWQpIHtcbiAgICAgIGxldCBhWCA9IHRoaXMuX2FjY2VsZXJhdGlvblZhbHVlc1swXTtcbiAgICAgIGxldCBhWSA9IHRoaXMuX2FjY2VsZXJhdGlvblZhbHVlc1sxXTtcbiAgICAgIGxldCBhWiA9IHRoaXMuX2FjY2VsZXJhdGlvblZhbHVlc1syXTtcbiAgICAgIGxldCBhY2NlbGVyYXRpb25NYWduaXR1ZGUgPSBNYXRoLnNxcnQoYVggKiBhWCArIGFZICogYVkgKyBhWiAqIGFaKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIG1heGltdW0gYWNjZWxlcmF0aW9uIG1hZ25pdHVkZSByZWFjaGVkIHNvIGZhciwgY2xpcHBlZCBhdCBgdGhpcy5fYWNjZWxlcmF0aW9uTWFnbml0dWRlVGhyZXNob2xkYFxuICAgICAgaWYgKHRoaXMuX2FjY2VsZXJhdGlvbk1hZ25pdHVkZUN1cnJlbnRNYXggPCBhY2NlbGVyYXRpb25NYWduaXR1ZGUpXG4gICAgICAgIHRoaXMuX2FjY2VsZXJhdGlvbk1hZ25pdHVkZUN1cnJlbnRNYXggPSBNYXRoLm1pbihhY2NlbGVyYXRpb25NYWduaXR1ZGUsIHRoaXMuX2FjY2VsZXJhdGlvbk1hZ25pdHVkZVRocmVzaG9sZCk7XG4gICAgICAvLyBUT0RPKD8pOiByZW1vdmUgb3VsaWVycyAtLS0gb24gc29tZSBBbmRyb2lkIGRldmljZXMsIHRoZSBtYWduaXR1ZGUgaXMgdmVyeSBoaWdoIG9uIGEgZmV3IGlzb2xhdGVkIGRhdGFwb2ludHMsXG4gICAgICAvLyB3aGljaCBtYWtlIHRoZSB0aHJlc2hvbGQgdmVyeSBoaWdoIGFzIHdlbGwgPT4gdGhlIGVuZXJneSByZW1haW5zIGFyb3VuZCAwLjUsIGV2ZW4gd2hlbiB5b3Ugc2hha2UgdmVyeSBoYXJkLlxuXG4gICAgICBhY2NlbGVyYXRpb25FbmVyZ3kgPSBNYXRoLm1pbihhY2NlbGVyYXRpb25NYWduaXR1ZGUgLyB0aGlzLl9hY2NlbGVyYXRpb25NYWduaXR1ZGVDdXJyZW50TWF4LCAxKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgcm90YXRpb24gcmF0ZSBtb2R1bGUgYW5kIGNhbGN1bGF0ZSBhbiBlc3RpbWF0aW9uIG9mIHRoZSBlbmVyZ3kgdmFsdWUgZnJvbSB0aGUgbGF0ZXN0IHJvdGF0aW9uIHJhdGUgdmFsdWVcbiAgICBpZiAodGhpcy5fcm90YXRpb25SYXRlTW9kdWxlLmlzVmFsaWQpIHtcbiAgICAgIGxldCByQSA9IHRoaXMuX3JvdGF0aW9uUmF0ZVZhbHVlc1swXTtcbiAgICAgIGxldCByQiA9IHRoaXMuX3JvdGF0aW9uUmF0ZVZhbHVlc1sxXTtcbiAgICAgIGxldCByRyA9IHRoaXMuX3JvdGF0aW9uUmF0ZVZhbHVlc1syXTtcbiAgICAgIGxldCByb3RhdGlvblJhdGVNYWduaXR1ZGUgPSBNYXRoLnNxcnQockEgKiByQSArIHJCICogckIgKyByRyAqIHJHKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIG1heGltdW0gcm90YXRpb24gcmF0ZSBtYWduaXR1ZGUgcmVhY2hlZCBzbyBmYXIsIGNsaXBwZWQgYXQgYHRoaXMuX3JvdGF0aW9uUmF0ZU1hZ25pdHVkZVRocmVzaG9sZGBcbiAgICAgIGlmICh0aGlzLl9yb3RhdGlvblJhdGVNYWduaXR1ZGVDdXJyZW50TWF4IDwgcm90YXRpb25SYXRlTWFnbml0dWRlKVxuICAgICAgICB0aGlzLl9yb3RhdGlvblJhdGVNYWduaXR1ZGVDdXJyZW50TWF4ID0gTWF0aC5taW4ocm90YXRpb25SYXRlTWFnbml0dWRlLCB0aGlzLl9yb3RhdGlvblJhdGVNYWduaXR1ZGVUaHJlc2hvbGQpO1xuXG4gICAgICByb3RhdGlvblJhdGVFbmVyZ3kgPSBNYXRoLm1pbihyb3RhdGlvblJhdGVNYWduaXR1ZGUgLyB0aGlzLl9yb3RhdGlvblJhdGVNYWduaXR1ZGVDdXJyZW50TWF4LCAxKTtcbiAgICB9XG5cbiAgICBsZXQgZW5lcmd5ID0gTWF0aC5tYXgoYWNjZWxlcmF0aW9uRW5lcmd5LCByb3RhdGlvblJhdGVFbmVyZ3kpO1xuXG4gICAgLy8gTG93LXBhc3MgZmlsdGVyIHRvIHNtb290aCB0aGUgZW5lcmd5IHZhbHVlc1xuICAgIGNvbnN0IGsgPSB0aGlzLl9lbmVyZ3lEZWNheTtcbiAgICB0aGlzLmV2ZW50ID0gayAqIHRoaXMuZXZlbnQgKyAoMSAtIGspICogZW5lcmd5O1xuXG4gICAgLy8gRW1pdCB0aGUgZW5lcmd5IHZhbHVlXG4gICAgdGhpcy5lbWl0KHRoaXMuZXZlbnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBFbmVyZ3lNb2R1bGUoKTtcbiIsIi8qKlxuICogYElucHV0TW9kdWxlYCBjbGFzcy5cbiAqIFRoZSBgSW5wdXRNb2R1bGVgIGNsYXNzIGFsbG93cyB0byBpbnN0YW50aWF0ZSBtb2R1bGVzIHRoYXQgYXJlIHBhcnQgb2YgdGhlXG4gKiBtb3Rpb24gaW5wdXQgbW9kdWxlLCBhbmQgdGhhdCBwcm92aWRlIHZhbHVlcyAoZm9yIGluc3RhbmNlLCBgZGV2aWNlb3JpZW50YXRpb25gLFxuICogYGFjY2VsZXJhdGlvbmAsIGBlbmVyZ3lgKS5cbiAqXG4gKiBAY2xhc3MgSW5wdXRNb2R1bGVcbiAqL1xuY2xhc3MgSW5wdXRNb2R1bGUge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGBJbnB1dE1vZHVsZWAgbW9kdWxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIE5hbWUgb2YgdGhlIG1vZHVsZSAvIGV2ZW50ICgqZS5nLiogYGRldmljZW9yaWVudGF0aW9uLCAnYWNjZWxlcmF0aW9uJywgJ2VuZXJneScpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZXZlbnRUeXBlKSB7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0eXBlIG9mIHRoZSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAdGhpcyBJbnB1dE1vZHVsZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhpcyBtb2R1bGUgLyBldmVudC5cbiAgICAgKlxuICAgICAqIEB0aGlzIElucHV0TW9kdWxlXG4gICAgICogQHR5cGUge1NldDxGdW5jdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBzZW50IGJ5IHRoaXMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHRoaXMgSW5wdXRNb2R1bGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfG51bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE1vZHVsZSBwcm9taXNlIChyZXNvbHZlZCB3aGVuIHRoZSBtb2R1bGUgaXMgaW5pdGlhbGl6ZWQpLlxuICAgICAqXG4gICAgICogQHRoaXMgSW5wdXRNb2R1bGVcbiAgICAgKiBAdHlwZSB7UHJvbWlzZX1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdGhpcy5wcm9taXNlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgbW9kdWxlJ3MgZXZlbnQgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gcGFyZW50IG1vZHVsZXMgLyBldmVudHMuXG4gICAgICpcbiAgICAgKiBAdGhpcyBJbnB1dE1vZHVsZVxuICAgICAqIEB0eXBlIHtib29sfVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgdGhpcy5pc0NhbGN1bGF0ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgbW9kdWxlJ3MgZXZlbnQgdmFsdWVzIGFyZSBwcm92aWRlZCBieSB0aGUgZGV2aWNlJ3Mgc2Vuc29ycy5cbiAgICAgKiAoKkkuZS4qIGluZGljYXRlcyBpZiB0aGUgYCdkZXZpY2Vtb3Rpb24nYCBvciBgJ2RldmljZW9yaWVudGF0aW9uJ2AgZXZlbnRzIHByb3ZpZGUgdGhlIHJlcXVpcmVkIHJhdyB2YWx1ZXMuKVxuICAgICAqXG4gICAgICogQHRoaXMgSW5wdXRNb2R1bGVcbiAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuaXNQcm92aWRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUGVyaW9kIGF0IHdoaWNoIHRoZSBtb2R1bGUncyBldmVudHMgYXJlIHNlbnQgKGB1bmRlZmluZWRgIGlmIHRoZSBldmVudHMgYXJlIG5vdCBzZW50IGF0IHJlZ3VsYXIgaW50ZXJ2YWxzKS5cbiAgICAgKlxuICAgICAqIEB0aGlzIElucHV0TW9kdWxlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZCA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZW1pdCA9IHRoaXMuZW1pdC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtb2R1bGUgY2FuIHByb3ZpZGUgdmFsdWVzIG9yIG5vdC5cbiAgICpcbiAgICogQHR5cGUge2Jvb2x9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmlzUHJvdmlkZWQgfHwgdGhpcy5pc0NhbGN1bGF0ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb21pc2VGdW4gLSBQcm9taXNlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zIGFzIGFyZ3VtZW50cy5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGluaXQocHJvbWlzZUZ1bikge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKHByb21pc2VGdW4pO1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gTGlzdGVuZXIgdG8gYWRkLlxuICAgKi9cbiAgYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gTGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgYW4gZXZlbnQgdG8gYWxsIHRoZSBtb2R1bGUncyBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbZXZlbnQ9dGhpcy5ldmVudF0gLSBFdmVudCB2YWx1ZXMgdG8gcHJvcGFnYXRlIHRvIHRoZSBtb2R1bGUncyBsaXN0ZW5lcnMuXG4gICAqL1xuICBlbWl0KGV2ZW50ID0gdGhpcy5ldmVudCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZXZlbnQpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dE1vZHVsZTtcbiIsIi8qKlxuICogYE1vdGlvbklucHV0YCBzaW5nbGV0b24uXG4gKiBUaGUgYE1vdGlvbklucHV0YCBzaW5nbGV0b24gYWxsb3dzIHRvIGluaXRpYWxpemUgbW90aW9uIGV2ZW50c1xuICogYW5kIHRvIGxpc3RlbiB0byB0aGVtLlxuICpcbiAqIEBjbGFzcyBNb3Rpb25JbnB1dFxuICovXG5jbGFzcyBNb3Rpb25JbnB1dCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGBNb3Rpb25JbnB1dGAgbW9kdWxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgLyoqXG4gICAgICogUG9vbCBvZiBhbGwgYXZhaWxhYmxlIG1vZHVsZXMuXG4gICAgICpcbiAgICAgKiBAdGhpcyBNb3Rpb25JbnB1dFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQGRlZmF1bHQge31cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbW9kdWxlIHRvIHRoZSBgTW90aW9uSW5wdXRgIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7SW5wdXRNb2R1bGV9IG1vZHVsZSAtIE1vZHVsZSB0byBhZGQgdG8gdGhlIGBNb3Rpb25JbnB1dGAgbW9kdWxlLlxuICAgKi9cbiAgYWRkTW9kdWxlKGV2ZW50VHlwZSwgbW9kdWxlKSB7XG4gICAgdGhpcy5tb2R1bGVzW2V2ZW50VHlwZV0gPSBtb2R1bGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHR5cGUgKG1vZHVsZSkgdG8gcmV0cmlldmUuXG4gICAqIEByZXR1cm4ge0lucHV0TW9kdWxlfVxuICAgKi9cbiAgZ2V0TW9kdWxlKGV2ZW50VHlwZSkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZXNbZXZlbnRUeXBlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1aXJlcyBhIG1vZHVsZS5cbiAgICogSWYgdGhlIG1vZHVsZSBoYXMgYmVlbiBpbml0aWFsaXplZCBhbHJlYWR5LCByZXR1cm5zIGl0cyBwcm9taXNlLiBPdGhlcndpc2UsXG4gICAqIGluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBOYW1lIG9mIHRoZSBldmVudCB0eXBlIChtb2R1bGUpIHRvIHJlcXVpcmUuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZXF1aXJlTW9kdWxlKGV2ZW50VHlwZSkge1xuICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMuZ2V0TW9kdWxlKGV2ZW50VHlwZSk7XG5cbiAgICBpZiAobW9kdWxlLnByb21pc2UpXG4gICAgICByZXR1cm4gbW9kdWxlLnByb21pc2U7XG5cbiAgICByZXR1cm4gbW9kdWxlLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYE1vdGlvbklucHV0YCBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gZXZlbnRUeXBlcyAtIEFycmF5IG9mIHRoZSBldmVudCB0eXBlcyB0byBpbml0aWFsaXplLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgaW5pdCguLi5ldmVudFR5cGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnRUeXBlc1swXSkpXG4gICAgICBldmVudFR5cGVzID0gZXZlbnRUeXBlc1swXVxuXG4gICAgY29uc3QgbW9kdWxlUHJvbWlzZXMgPSBldmVudFR5cGVzLm1hcCgodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMuZ2V0TW9kdWxlKHZhbHVlKTtcbiAgICAgIHJldHVybiBtb2R1bGUuaW5pdCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKG1vZHVsZVByb21pc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBOYW1lIG9mIHRoZSBldmVudCB0eXBlIChtb2R1bGUpIHRvIGFkZCBhIGxpc3RlbmVyIHRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIExpc3RlbmVyIHRvIGFkZC5cbiAgICovXG4gIGFkZExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBtb2R1bGUgPSB0aGlzLmdldE1vZHVsZShldmVudFR5cGUpO1xuICAgIG1vZHVsZS5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gTmFtZSBvZiB0aGUgZXZlbnQgdHlwZSAobW9kdWxlKSB0byBhZGQgYSBsaXN0ZW5lciB0by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBMaXN0ZW5lciB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbW9kdWxlID0gdGhpcy5nZXRNb2R1bGUoZXZlbnRUeXBlKTtcbiAgICBtb2R1bGUucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBNb3Rpb25JbnB1dCgpO1xuIiwiLyoqXG4gKiBUaGUgbW90aW9uIGlucHV0IG1vZHVsZSBjYW4gYmUgdXNlZCBhcyBmb2xsb3dzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBtb3Rpb25JbnB1dCBmcm9tICdtb3Rpb24taW5wdXQnO1xuICogY29uc3QgcmVxdWlyZWRFdmVudHMgPSA7XG4gKlxuICogbW90aW9uSW5wdXRcbiAqICAuaW5pdChbJ2FjY2VsZXJhdGlvbicsICdvcmllbnRhdGlvbicsICdlbmVyZ3knXSlcbiAqICAudGhlbigoW2FjY2VsZXJhdGlvbiwgb3JpZW50YXRpb24sIGVuZXJneV0pID0+IHtcbiAqICAgIGlmIChhY2NlbGVyYXRpb24uaXNWYWxpZCkge1xuICogICAgICBhY2NlbGVyYXRpb24uYWRkTGlzdGVuZXIoKGRhdGEpID0+IHtcbiAqICAgICAgICBjb25zb2xlLmxvZygnYWNjZWxlcmF0aW9uJywgZGF0YSk7XG4gKiAgICAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGFjY2VsZXJhdGlvbiB2YWx1ZXNcbiAqICAgICAgfSk7XG4gKiAgICB9XG4gKlxuICogICAgLy8gLi4uXG4gKiAgfSk7XG4gKi9cbmltcG9ydCBtb3Rpb25JbnB1dCBmcm9tICcuL01vdGlvbklucHV0JztcbmltcG9ydCBkZXZpY2VvcmllbnRhdGlvbk1vZHVsZSBmcm9tICcuL0RldmljZU9yaWVudGF0aW9uTW9kdWxlJztcbmltcG9ydCBkZXZpY2Vtb3Rpb25Nb2R1bGUgZnJvbSAnLi9EZXZpY2VNb3Rpb25Nb2R1bGUnO1xuaW1wb3J0IGVuZXJneSBmcm9tICcuL0VuZXJneU1vZHVsZSc7XG5cbm1vdGlvbklucHV0LmFkZE1vZHVsZSgnZGV2aWNlbW90aW9uJywgZGV2aWNlbW90aW9uTW9kdWxlKTtcbm1vdGlvbklucHV0LmFkZE1vZHVsZSgnZGV2aWNlb3JpZW50YXRpb24nLCBkZXZpY2VvcmllbnRhdGlvbk1vZHVsZSk7XG5tb3Rpb25JbnB1dC5hZGRNb2R1bGUoJ2FjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHknLCBkZXZpY2Vtb3Rpb25Nb2R1bGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSk7XG5tb3Rpb25JbnB1dC5hZGRNb2R1bGUoJ2FjY2VsZXJhdGlvbicsIGRldmljZW1vdGlvbk1vZHVsZS5hY2NlbGVyYXRpb24pO1xubW90aW9uSW5wdXQuYWRkTW9kdWxlKCdyb3RhdGlvblJhdGUnLCBkZXZpY2Vtb3Rpb25Nb2R1bGUucm90YXRpb25SYXRlKTtcbm1vdGlvbklucHV0LmFkZE1vZHVsZSgnb3JpZW50YXRpb24nLCBkZXZpY2VvcmllbnRhdGlvbk1vZHVsZS5vcmllbnRhdGlvbik7XG5tb3Rpb25JbnB1dC5hZGRNb2R1bGUoJ29yaWVudGF0aW9uQWx0JywgZGV2aWNlb3JpZW50YXRpb25Nb2R1bGUub3JpZW50YXRpb25BbHQpO1xubW90aW9uSW5wdXQuYWRkTW9kdWxlKCdlbmVyZ3knLCBlbmVyZ3kpO1xuXG5leHBvcnQgZGVmYXVsdCBtb3Rpb25JbnB1dDtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIi8qISBOb1NsZWVwLm1pbi5qcyB2MC43LjAgLSBnaXQuaW8vdmZuMDEgLSBSaWNoIFRpYmJldHQgLSBNSVQgbGljZW5zZSAqL1xuIWZ1bmN0aW9uKEEsQil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9QigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sQik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5Ob1NsZWVwPUIoKTpBLk5vU2xlZXA9QigpfSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKEEpe2Z1bmN0aW9uIEIoZSl7aWYoUVtlXSlyZXR1cm4gUVtlXS5leHBvcnRzO3ZhciBvPVFbZV09e2k6ZSxsOiExLGV4cG9ydHM6e319O3JldHVybiBBW2VdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLEIpLG8ubD0hMCxvLmV4cG9ydHN9dmFyIFE9e307cmV0dXJuIEIubT1BLEIuYz1RLEIuZD1mdW5jdGlvbihBLFEsZSl7Qi5vKEEsUSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFEse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDplfSl9LEIubj1mdW5jdGlvbihBKXt2YXIgUT1BJiZBLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gQS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBBfTtyZXR1cm4gQi5kKFEsXCJhXCIsUSksUX0sQi5vPWZ1bmN0aW9uKEEsQil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLEIpfSxCLnA9XCJcIixCKEIucz0wKX0oW2Z1bmN0aW9uKEEsQixRKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKEEsQil7aWYoIShBIGluc3RhbmNlb2YgQikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX12YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIEEoQSxCKXtmb3IodmFyIFE9MDtRPEIubGVuZ3RoO1ErKyl7dmFyIGU9QltRXTtlLmVudW1lcmFibGU9ZS5lbnVtZXJhYmxlfHwhMSxlLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBlJiYoZS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsZS5rZXksZSl9fXJldHVybiBmdW5jdGlvbihCLFEsZSl7cmV0dXJuIFEmJkEoQi5wcm90b3R5cGUsUSksZSYmQShCLGUpLEJ9fSgpLHQ9USgxKSxuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJnBhcnNlRmxvYXQoKFwiXCIrKC9DUFUuKk9TIChbMC05X117Myw0fSlbMC05X117MCwxfXwoQ1BVIGxpa2UpLipBcHBsZVdlYktpdC4qTW9iaWxlL2kuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KXx8WzAsXCJcIl0pWzFdKS5yZXBsYWNlKFwidW5kZWZpbmVkXCIsXCIzXzJcIikucmVwbGFjZShcIl9cIixcIi5cIikucmVwbGFjZShcIl9cIixcIlwiKSk8MTAmJiF3aW5kb3cuTVNTdHJlYW0sRT1mdW5jdGlvbigpe2Z1bmN0aW9uIEEoKXtlKHRoaXMsQSksbj90aGlzLm5vU2xlZXBUaW1lcj1udWxsOih0aGlzLm5vU2xlZXBWaWRlbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiksdGhpcy5ub1NsZWVwVmlkZW8uc2V0QXR0cmlidXRlKFwicGxheXNpbmxpbmVcIixcIlwiKSx0aGlzLm5vU2xlZXBWaWRlby5zZXRBdHRyaWJ1dGUoXCJzcmNcIix0KSx0aGlzLm5vU2xlZXBWaWRlby5hZGRFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLGZ1bmN0aW9uKEEpe3RoaXMubm9TbGVlcFZpZGVvLmN1cnJlbnRUaW1lPi41JiYodGhpcy5ub1NsZWVwVmlkZW8uY3VycmVudFRpbWU9TWF0aC5yYW5kb20oKSl9LmJpbmQodGhpcykpKX1yZXR1cm4gbyhBLFt7a2V5OlwiZW5hYmxlXCIsdmFsdWU6ZnVuY3Rpb24oKXtuPyh0aGlzLmRpc2FibGUoKSx0aGlzLm5vU2xlZXBUaW1lcj13aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXt3aW5kb3cubG9jYXRpb24uaHJlZj1cIi9cIix3aW5kb3cuc2V0VGltZW91dCh3aW5kb3cuc3RvcCwwKX0sMTVlMykpOnRoaXMubm9TbGVlcFZpZGVvLnBsYXkoKX19LHtrZXk6XCJkaXNhYmxlXCIsdmFsdWU6ZnVuY3Rpb24oKXtuP3RoaXMubm9TbGVlcFRpbWVyJiYod2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5ub1NsZWVwVGltZXIpLHRoaXMubm9TbGVlcFRpbWVyPW51bGwpOnRoaXMubm9TbGVlcFZpZGVvLnBhdXNlKCl9fV0pLEF9KCk7QS5leHBvcnRzPUV9LGZ1bmN0aW9uKEEsQixRKXtcInVzZSBzdHJpY3RcIjtBLmV4cG9ydHM9XCJkYXRhOnZpZGVvL21wNDtiYXNlNjQsQUFBQUlHWjBlWEJ0Y0RReUFBQUNBR2x6YjIxcGMyOHlZWFpqTVcxd05ERUFBQUFJWm5KbFpRQUFDS0J0WkdGMEFBQUM4d1lGLy8vdjNFWHB2ZWJaU0xlV0xOZ2cyU1B1NzNneU5qUWdMU0JqYjNKbElERTBNaUJ5TWpRM09TQmtaRGM1WVRZeElDMGdTQzR5TmpRdlRWQkZSeTAwSUVGV1F5QmpiMlJsWXlBdElFTnZjSGxzWldaMElESXdNRE10TWpBeE5DQXRJR2gwZEhBNkx5OTNkM2N1ZG1sa1pXOXNZVzR1YjNKbkwzZ3lOalF1YUhSdGJDQXRJRzl3ZEdsdmJuTTZJR05oWW1GalBURWdjbVZtUFRFZ1pHVmliRzlqYXoweE9qQTZNQ0JoYm1Gc2VYTmxQVEI0TVRvd2VERXhNU0J0WlQxb1pYZ2djM1ZpYldVOU1pQndjM2s5TVNCd2MzbGZjbVE5TVM0d01Eb3dMakF3SUcxcGVHVmtYM0psWmowd0lHMWxYM0poYm1kbFBURTJJR05vY205dFlWOXRaVDB4SUhSeVpXeHNhWE05TUNBNGVEaGtZM1E5TUNCamNXMDlNQ0JrWldGa2VtOXVaVDB5TVN3eE1TQm1ZWE4wWDNCemEybHdQVEVnWTJoeWIyMWhYM0Z3WDI5bVpuTmxkRDB3SUhSb2NtVmhaSE05TmlCc2IyOXJZV2hsWVdSZmRHaHlaV0ZrY3oweElITnNhV05sWkY5MGFISmxZV1J6UFRBZ2JuSTlNQ0JrWldOcGJXRjBaVDB4SUdsdWRHVnliR0ZqWldROU1DQmliSFZ5WVhsZlkyOXRjR0YwUFRBZ1kyOXVjM1J5WVdsdVpXUmZhVzUwY21FOU1DQmlabkpoYldWelBUTWdZbDl3ZVhKaGJXbGtQVElnWWw5aFpHRndkRDB4SUdKZlltbGhjejB3SUdScGNtVmpkRDB4SUhkbGFXZG9kR0k5TVNCdmNHVnVYMmR2Y0Qwd0lIZGxhV2RvZEhBOU1TQnJaWGxwYm5ROU16QXdJR3RsZVdsdWRGOXRhVzQ5TXpBZ2MyTmxibVZqZFhROU5EQWdhVzUwY21GZmNtVm1jbVZ6YUQwd0lISmpYMnh2YjJ0aGFHVmhaRDB4TUNCeVl6MWpjbVlnYldKMGNtVmxQVEVnWTNKbVBUSXdMakFnY1dOdmJYQTlNQzQyTUNCeGNHMXBiajB3SUhGd2JXRjRQVFk1SUhGd2MzUmxjRDAwSUhaaWRsOXRZWGh5WVhSbFBUSXdNREF3SUhaaWRsOWlkV1p6YVhwbFBUSTFNREF3SUdOeVpsOXRZWGc5TUM0d0lHNWhiRjlvY21ROWJtOXVaU0JtYVd4c1pYSTlNQ0JwY0Y5eVlYUnBiejB4TGpRd0lHRnhQVEU2TVM0d01BQ0FBQUFBT1dXSWhBQTMvL3ArQzd2OHRERFNUamY5N3c1NWkzU2JSUE80WlkraGtqRDVoYmtBa0wzenBKNmgvTFIxQ0FBQnpnQjFrcXF6VW9ybGhRQUFBQXhCbWlRWWhuLytxWllBRExnQUFBQUpRWjVDUWhYL0FBajVJUUFEUUdnY0lRQURRR2djQUFBQUNRR2VZVVFuL3dBTEtDRUFBMEJvSEFBQUFBa0JubU5FSi84QUN5a2hBQU5BYUJ3aEFBTkFhQndBQUFBTlFacG9ORXhEUC82cGxnQU11U0VBQTBCb0hBQUFBQXRCbm9aRkVTd3Ivd0FJK1NFQUEwQm9IQ0VBQTBCb0hBQUFBQWtCbnFWRUovOEFDeWtoQUFOQWFCd0FBQUFKQVo2blJDZi9BQXNvSVFBRFFHZ2NJUUFEUUdnY0FBQUFEVUdhckRSTVF6LytxWllBRExnaEFBTkFhQndBQUFBTFFaN0tSUlVzSy84QUNQa2hBQU5BYUJ3QUFBQUpBWjdwUkNmL0FBc29JUUFEUUdnY0lRQURRR2djQUFBQUNRR2U2MFFuL3dBTEtDRUFBMEJvSEFBQUFBMUJtdkEwVEVNLy9xbVdBQXk1SVFBRFFHZ2NJUUFEUUdnY0FBQUFDMEdmRGtVVkxDdi9BQWo1SVFBRFFHZ2NBQUFBQ1FHZkxVUW4vd0FMS1NFQUEwQm9IQ0VBQTBCb0hBQUFBQWtCbnk5RUovOEFDeWdoQUFOQWFCd0FBQUFOUVpzME5FeERQLzZwbGdBTXVDRUFBMEJvSEFBQUFBdEJuMUpGRlN3ci93QUkrU0VBQTBCb0hDRUFBMEJvSEFBQUFBa0JuM0ZFSi84QUN5Z2hBQU5BYUJ3QUFBQUpBWjl6UkNmL0FBc29JUUFEUUdnY0lRQURRR2djQUFBQURVR2JlRFJNUXovK3FaWUFETGtoQUFOQWFCd0FBQUFMUVorV1JSVXNLLzhBQ1BnaEFBTkFhQndoQUFOQWFCd0FBQUFKQVorMVJDZi9BQXNwSVFBRFFHZ2NBQUFBQ1FHZnQwUW4vd0FMS1NFQUEwQm9IQ0VBQTBCb0hBQUFBQTFCbTd3MFRFTS8vcW1XQUF5NElRQURRR2djQUFBQUMwR2Yya1VWTEN2L0FBajVJUUFEUUdnY0FBQUFDUUdmK1VRbi93QUxLQ0VBQTBCb0hDRUFBMEJvSEFBQUFBa0JuL3RFSi84QUN5a2hBQU5BYUJ3QUFBQU5RWnZnTkV4RFAvNnBsZ0FNdVNFQUEwQm9IQ0VBQTBCb0hBQUFBQXRCbmg1RkZTd3Ivd0FJK0NFQUEwQm9IQUFBQUFrQm5qMUVKLzhBQ3lnaEFBTkFhQndoQUFOQWFCd0FBQUFKQVo0L1JDZi9BQXNwSVFBRFFHZ2NBQUFBRFVHYUpEUk1Rei8rcVpZQURMZ2hBQU5BYUJ3QUFBQUxRWjVDUlJVc0svOEFDUGtoQUFOQWFCd2hBQU5BYUJ3QUFBQUpBWjVoUkNmL0FBc29JUUFEUUdnY0FBQUFDUUdlWTBRbi93QUxLU0VBQTBCb0hDRUFBMEJvSEFBQUFBMUJtbWcwVEVNLy9xbVdBQXk1SVFBRFFHZ2NBQUFBQzBHZWhrVVZMQ3YvQUFqNUlRQURRR2djSVFBRFFHZ2NBQUFBQ1FHZXBVUW4vd0FMS1NFQUEwQm9IQUFBQUFrQm5xZEVKLzhBQ3lnaEFBTkFhQndBQUFBTlFacXNORXhEUC82cGxnQU11Q0VBQTBCb0hDRUFBMEJvSEFBQUFBdEJuc3BGRlN3ci93QUkrU0VBQTBCb0hBQUFBQWtCbnVsRUovOEFDeWdoQUFOQWFCd2hBQU5BYUJ3QUFBQUpBWjdyUkNmL0FBc29JUUFEUUdnY0FBQUFEVUdhOERSTVF6LytxWllBRExraEFBTkFhQndoQUFOQWFCd0FBQUFMUVo4T1JSVXNLLzhBQ1BraEFBTkFhQndBQUFBSkFaOHRSQ2YvQUFzcElRQURRR2djSVFBRFFHZ2NBQUFBQ1FHZkwwUW4vd0FMS0NFQUEwQm9IQUFBQUExQm16UTBURU0vL3FtV0FBeTRJUUFEUUdnY0FBQUFDMEdmVWtVVkxDdi9BQWo1SVFBRFFHZ2NJUUFEUUdnY0FBQUFDUUdmY1VRbi93QUxLQ0VBQTBCb0hBQUFBQWtCbjNORUovOEFDeWdoQUFOQWFCd2hBQU5BYUJ3QUFBQU5RWnQ0TkV4Qy8vNnBsZ0FNdVNFQUEwQm9IQUFBQUF0Qm41WkZGU3dyL3dBSStDRUFBMEJvSENFQUEwQm9IQUFBQUFrQm43VkVKLzhBQ3lraEFBTkFhQndBQUFBSkFaKzNSQ2YvQUFzcElRQURRR2djQUFBQURVR2J1elJNUW4vK25oQUFZc0FoQUFOQWFCd2hBQU5BYUJ3QUFBQUpRWi9hUWhQL0FBc3BJUUFEUUdnY0FBQUFDUUdmK1VRbi93QUxLQ0VBQTBCb0hDRUFBMEJvSENFQUEwQm9IQ0VBQTBCb0hDRUFBMEJvSENFQUEwQm9IQUFBQ2lGdGIyOTJBQUFBYkcxMmFHUUFBQUFBMVlDQ1g5V0FnbDhBQUFQb0FBQUgvQUFCQUFBQkFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURBQUFBR0dsdlpITUFBQUFBRUlDQWdBY0FULy8vL3Y3L0FBQUYrWFJ5WVdzQUFBQmNkR3RvWkFBQUFBUFZnSUpmMVlDQ1h3QUFBQUVBQUFBQUFBQUgwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUF5Z0FBQU1vQUFBQUFBQ1JsWkhSekFBQUFIR1ZzYzNRQUFBQUFBQUFBQVFBQUI5QUFBQmR3QUFFQUFBQUFCWEZ0WkdsaEFBQUFJRzFrYUdRQUFBQUExWUNDWDlXQWdsOEFBVitRQUFLL0lGWEVBQUFBQUFBdGFHUnNjZ0FBQUFBQUFBQUFkbWxrWlFBQUFBQUFBQUFBQUFBQUFGWnBaR1Z2U0dGdVpHeGxjZ0FBQUFVY2JXbHVaZ0FBQUJSMmJXaGtBQUFBQVFBQUFBQUFBQUFBQUFBQUpHUnBibVlBQUFBY1pISmxaZ0FBQUFBQUFBQUJBQUFBREhWeWJDQUFBQUFCQUFBRTNITjBZbXdBQUFDWWMzUnpaQUFBQUFBQUFBQUJBQUFBaUdGMll6RUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXlnREtBRWdBQUFCSUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFZLy84QUFBQXlZWFpqUXdGTlFDai80UUFiWjAxQUtPeWhvM3lTVFVCQVFGQUFBQU1BRUFBcjhnRHhneGxnQVFBRWFPK0c4Z0FBQUJoemRIUnpBQUFBQUFBQUFBRUFBQUE4QUFBTHVBQUFBQlJ6ZEhOekFBQUFBQUFBQUFFQUFBQUJBQUFCOEdOMGRITUFBQUFBQUFBQVBBQUFBQUVBQUJkd0FBQUFBUUFBT3BnQUFBQUJBQUFYY0FBQUFBRUFBQUFBQUFBQUFRQUFDN2dBQUFBQkFBQTZtQUFBQUFFQUFCZHdBQUFBQVFBQUFBQUFBQUFCQUFBTHVBQUFBQUVBQURxWUFBQUFBUUFBRjNBQUFBQUJBQUFBQUFBQUFBRUFBQXU0QUFBQUFRQUFPcGdBQUFBQkFBQVhjQUFBQUFFQUFBQUFBQUFBQVFBQUM3Z0FBQUFCQUFBNm1BQUFBQUVBQUJkd0FBQUFBUUFBQUFBQUFBQUJBQUFMdUFBQUFBRUFBRHFZQUFBQUFRQUFGM0FBQUFBQkFBQUFBQUFBQUFFQUFBdTRBQUFBQVFBQU9wZ0FBQUFCQUFBWGNBQUFBQUVBQUFBQUFBQUFBUUFBQzdnQUFBQUJBQUE2bUFBQUFBRUFBQmR3QUFBQUFRQUFBQUFBQUFBQkFBQUx1QUFBQUFFQUFEcVlBQUFBQVFBQUYzQUFBQUFCQUFBQUFBQUFBQUVBQUF1NEFBQUFBUUFBT3BnQUFBQUJBQUFYY0FBQUFBRUFBQUFBQUFBQUFRQUFDN2dBQUFBQkFBQTZtQUFBQUFFQUFCZHdBQUFBQVFBQUFBQUFBQUFCQUFBTHVBQUFBQUVBQURxWUFBQUFBUUFBRjNBQUFBQUJBQUFBQUFBQUFBRUFBQXU0QUFBQUFRQUFPcGdBQUFBQkFBQVhjQUFBQUFFQUFBQUFBQUFBQVFBQUM3Z0FBQUFCQUFBNm1BQUFBQUVBQUJkd0FBQUFBUUFBQUFBQUFBQUJBQUFMdUFBQUFBRUFBQzdnQUFBQUFRQUFGM0FBQUFBQkFBQUFBQUFBQUJ4emRITmpBQUFBQUFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFFRWMzUnplZ0FBQUFBQUFBQUFBQUFBUEFBQUF6UUFBQUFRQUFBQURRQUFBQTBBQUFBTkFBQUFFUUFBQUE4QUFBQU5BQUFBRFFBQUFCRUFBQUFQQUFBQURRQUFBQTBBQUFBUkFBQUFEd0FBQUEwQUFBQU5BQUFBRVFBQUFBOEFBQUFOQUFBQURRQUFBQkVBQUFBUEFBQUFEUUFBQUEwQUFBQVJBQUFBRHdBQUFBMEFBQUFOQUFBQUVRQUFBQThBQUFBTkFBQUFEUUFBQUJFQUFBQVBBQUFBRFFBQUFBMEFBQUFSQUFBQUR3QUFBQTBBQUFBTkFBQUFFUUFBQUE4QUFBQU5BQUFBRFFBQUFCRUFBQUFQQUFBQURRQUFBQTBBQUFBUkFBQUFEd0FBQUEwQUFBQU5BQUFBRVFBQUFBOEFBQUFOQUFBQURRQUFBQkVBQUFBTkFBQUFEUUFBQVFCemRHTnZBQUFBQUFBQUFEd0FBQUF3QUFBRFpBQUFBM1FBQUFPTkFBQURvQUFBQTdrQUFBUFFBQUFENndBQUEvNEFBQVFYQUFBRUxnQUFCRU1BQUFSY0FBQUVid0FBQkl3QUFBU2hBQUFFdWdBQUJNMEFBQVRrQUFBRS93QUFCUklBQUFVckFBQUZRZ0FBQlYwQUFBVndBQUFGaVFBQUJhQUFBQVcxQUFBRnpnQUFCZUVBQUFYK0FBQUdFd0FBQml3QUFBWS9BQUFHVmdBQUJuRUFBQWFFQUFBR25RQUFCclFBQUFiUEFBQUc0Z0FBQnZVQUFBY1NBQUFISndBQUIwQUFBQWRUQUFBSGNBQUFCNFVBQUFlZUFBQUhzUUFBQjhnQUFBZmpBQUFIOWdBQUNBOEFBQWdtQUFBSVFRQUFDRlFBQUFobkFBQUloQUFBQ0pjQUFBTXNkSEpoYXdBQUFGeDBhMmhrQUFBQUE5V0FnbC9WZ0lKZkFBQUFBZ0FBQUFBQUFBZjhBQUFBQUFBQUFBQUFBQUFCQVFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUNzbTFrYVdFQUFBQWdiV1JvWkFBQUFBRFZnSUpmMVlDQ1h3QUFyRVFBQVdBQVZjUUFBQUFBQUNkb1pHeHlBQUFBQUFBQUFBQnpiM1Z1QUFBQUFBQUFBQUFBQUFBQVUzUmxjbVZ2QUFBQUFtTnRhVzVtQUFBQUVITnRhR1FBQUFBQUFBQUFBQUFBQUNSa2FXNW1BQUFBSEdSeVpXWUFBQUFBQUFBQUFRQUFBQXgxY213Z0FBQUFBUUFBQWlkemRHSnNBQUFBWjNOMGMyUUFBQUFBQUFBQUFRQUFBRmR0Y0RSaEFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQ0FCQUFBQUFBckVRQUFBQUFBRE5sYzJSekFBQUFBQU9BZ0lBaUFBSUFCSUNBZ0JSQUZRQUFBQUFERFVBQUFBQUFCWUNBZ0FJU0VBYUFnSUFCQWdBQUFCaHpkSFJ6QUFBQUFBQUFBQUVBQUFCWUFBQUVBQUFBQUJ4emRITmpBQUFBQUFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBVWMzUnplZ0FBQUFBQUFBQUdBQUFBV0FBQUFYQnpkR052QUFBQUFBQUFBRmdBQUFPQkFBQURod0FBQTVvQUFBT3RBQUFEc3dBQUE4b0FBQVBmQUFBRDVRQUFBL2dBQUFRTEFBQUVFUUFBQkNnQUFBUTlBQUFFVUFBQUJGWUFBQVJwQUFBRWdBQUFCSVlBQUFTYkFBQUVyZ0FBQkxRQUFBVEhBQUFFM2dBQUJQTUFBQVQ1QUFBRkRBQUFCUjhBQUFVbEFBQUZQQUFBQlZFQUFBVlhBQUFGYWdBQUJYMEFBQVdEQUFBRm1nQUFCYThBQUFYQ0FBQUZ5QUFBQmRzQUFBWHlBQUFGK0FBQUJnMEFBQVlnQUFBR0pnQUFCamtBQUFaUUFBQUdaUUFBQm1zQUFBWitBQUFHa1FBQUJwY0FBQWF1QUFBR3d3QUFCc2tBQUFiY0FBQUc3d0FBQndZQUFBY01BQUFISVFBQUJ6UUFBQWM2QUFBSFRRQUFCMlFBQUFkcUFBQUhmd0FBQjVJQUFBZVlBQUFIcXdBQUI4SUFBQWZYQUFBSDNRQUFCL0FBQUFnREFBQUlDUUFBQ0NBQUFBZzFBQUFJT3dBQUNFNEFBQWhoQUFBSWVBQUFDSDRBQUFpUkFBQUlwQUFBQ0tvQUFBaXdBQUFJdGdBQUNMd0FBQWpDQUFBQUZuVmtkR0VBQUFBT2JtRnRaVk4wWlhKbGJ3QUFBSEIxWkhSaEFBQUFhRzFsZEdFQUFBQUFBQUFBSVdoa2JISUFBQUFBQUFBQUFHMWthWEpoY0hCc0FBQUFBQUFBQUFBQUFBQUFPMmxzYzNRQUFBQXpxWFJ2YndBQUFDdGtZWFJoQUFBQUFRQUFBQUJJWVc1a1FuSmhhMlVnTUM0eE1DNHlJREl3TVRVd05qRXhNREE9XCJ9XSl9KTsiLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG4iLCIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG4iLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLyohXG4gKiBQbGF0Zm9ybS5qcyA8aHR0cHM6Ly9tdGhzLmJlL3BsYXRmb3JtPlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNiBCZW5qYW1pbiBUYW4gPGh0dHBzOi8vZGVtb25lYXV4LmdpdGh1Yi5pby8+XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDEzIEpvaG4tRGF2aWQgRGFsdG9uIDxodHRwOi8vYWxseW91Y2FubGVldC5jb20vPlxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL210aHMuYmUvbWl0PlxuICovXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogQmFja3VwIHBvc3NpYmxlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciBvbGRSb290ID0gcm9vdDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUgYW5kIHVzZSBpdCBhcyBgcm9vdGAuICovXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIG9iamVjdC5cbiAgICogU2VlIHRoZSBbRVM2IHNwZWNdKGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAvKiogUmVndWxhciBleHByZXNzaW9uIHRvIGRldGVjdCBPcGVyYS4gKi9cbiAgdmFyIHJlT3BlcmEgPSAvXFxiT3BlcmEvO1xuXG4gIC8qKiBQb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgdGhpc0JpbmRpbmcgPSB0aGlzO1xuXG4gIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgZm9yIG93biBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgYFtbQ2xhc3NdXWAgb2YgdmFsdWVzLiAqL1xuICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmcgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSBTdHJpbmcoc3RyaW5nKTtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgT1MgbmFtZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9zIFRoZSBPUyBuYW1lIHRvIGNsZWFuIHVwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdHRlcm5dIEEgYFJlZ0V4cGAgcGF0dGVybiBtYXRjaGluZyB0aGUgT1MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF0gQSBsYWJlbCBmb3IgdGhlIE9TLlxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYW51cE9TKG9zLCBwYXR0ZXJuLCBsYWJlbCkge1xuICAgIC8vIFBsYXRmb3JtIHRva2VucyBhcmUgZGVmaW5lZCBhdDpcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcbiAgICAvLyBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDA4MTEyMjA1Mzk1MC9odHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICcxMC4wJzogJzEwJyxcbiAgICAgICc2LjQnOiAgJzEwIFRlY2huaWNhbCBQcmV2aWV3JyxcbiAgICAgICc2LjMnOiAgJzguMScsXG4gICAgICAnNi4yJzogICc4JyxcbiAgICAgICc2LjEnOiAgJ1NlcnZlciAyMDA4IFIyIC8gNycsXG4gICAgICAnNi4wJzogICdTZXJ2ZXIgMjAwOCAvIFZpc3RhJyxcbiAgICAgICc1LjInOiAgJ1NlcnZlciAyMDAzIC8gWFAgNjQtYml0JyxcbiAgICAgICc1LjEnOiAgJ1hQJyxcbiAgICAgICc1LjAxJzogJzIwMDAgU1AxJyxcbiAgICAgICc1LjAnOiAgJzIwMDAnLFxuICAgICAgJzQuMCc6ICAnTlQnLFxuICAgICAgJzQuOTAnOiAnTUUnXG4gICAgfTtcbiAgICAvLyBEZXRlY3QgV2luZG93cyB2ZXJzaW9uIGZyb20gcGxhdGZvcm0gdG9rZW5zLlxuICAgIGlmIChwYXR0ZXJuICYmIGxhYmVsICYmIC9eV2luL2kudGVzdChvcykgJiYgIS9eV2luZG93cyBQaG9uZSAvaS50ZXN0KG9zKSAmJlxuICAgICAgICAoZGF0YSA9IGRhdGFbL1tcXGQuXSskLy5leGVjKG9zKV0pKSB7XG4gICAgICBvcyA9ICdXaW5kb3dzICcgKyBkYXRhO1xuICAgIH1cbiAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cbiAgICBvcyA9IFN0cmluZyhvcyk7XG5cbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCkge1xuICAgICAgb3MgPSBvcy5yZXBsYWNlKFJlZ0V4cChwYXR0ZXJuLCAnaScpLCBsYWJlbCk7XG4gICAgfVxuXG4gICAgb3MgPSBmb3JtYXQoXG4gICAgICBvcy5yZXBsYWNlKC8gY2UkL2ksICcgQ0UnKVxuICAgICAgICAucmVwbGFjZSgvXFxiaHB3L2ksICd3ZWInKVxuICAgICAgICAucmVwbGFjZSgvXFxiTWFjaW50b3NoXFxiLywgJ01hYyBPUycpXG4gICAgICAgIC5yZXBsYWNlKC9fUG93ZXJQQ1xcYi9pLCAnIE9TJylcbiAgICAgICAgLnJlcGxhY2UoL1xcYihPUyBYKSBbXiBcXGRdKy9pLCAnJDEnKVxuICAgICAgICAucmVwbGFjZSgvXFxiTWFjIChPUyBYKVxcYi8sICckMScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC8oXFxkKS8sICcgJDEnKVxuICAgICAgICAucmVwbGFjZSgvXy9nLCAnLicpXG4gICAgICAgIC5yZXBsYWNlKC8oPzogQmVQQ3xbIC5dKmZjWyBcXGQuXSspJC9pLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcYng4NlxcLjY0XFxiL2dpLCAneDg2XzY0JylcbiAgICAgICAgLnJlcGxhY2UoL1xcYihXaW5kb3dzIFBob25lKSBPU1xcYi8sICckMScpXG4gICAgICAgIC5yZXBsYWNlKC9cXGIoQ2hyb21lIE9TIFxcdyspIFtcXGQuXStcXGIvLCAnJDEnKVxuICAgICAgICAuc3BsaXQoJyBvbiAnKVswXVxuICAgICk7XG5cbiAgICByZXR1cm4gb3M7XG4gIH1cblxuICAvKipcbiAgICogQW4gaXRlcmF0aW9uIHV0aWxpdHkgZm9yIGFycmF5cyBhbmQgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuXG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID4gLTEgJiYgbGVuZ3RoIDw9IG1heFNhZmVJbnRlZ2VyKSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3RbaW5kZXhdLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT3duKG9iamVjdCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmltIGFuZCBjb25kaXRpb25hbGx5IGNhcGl0YWxpemUgc3RyaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JtYXQoc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdHJpbShzdHJpbmcpO1xuICAgIHJldHVybiAvXig/OndlYk9TfGkoPzpPU3xQKSkvLnRlc3Qoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdcbiAgICAgIDogY2FwaXRhbGl6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMsIGV4ZWN1dGluZyB0aGUgYGNhbGxiYWNrYCBmb3IgZWFjaC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGV4ZWN1dGVkIHBlciBvd24gcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCBgW1tDbGFzc11dYCBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGBbW0NsYXNzXV1gLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NPZih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgICA/IGNhcGl0YWxpemUodmFsdWUpXG4gICAgICA6IHRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIb3N0IG9iamVjdHMgY2FuIHJldHVybiB0eXBlIHZhbHVlcyB0aGF0IGFyZSBkaWZmZXJlbnQgZnJvbSB0aGVpciBhY3R1YWxcbiAgICogZGF0YSB0eXBlLiBUaGUgb2JqZWN0cyB3ZSBhcmUgY29uY2VybmVkIHdpdGggdXN1YWxseSByZXR1cm4gbm9uLXByaW1pdGl2ZVxuICAgKiB0eXBlcyBvZiBcIm9iamVjdFwiLCBcImZ1bmN0aW9uXCIsIG9yIFwidW5rbm93blwiLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb3duZXIgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGEgbm9uLXByaW1pdGl2ZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNIb3N0VHlwZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgdmFyIHR5cGUgPSBvYmplY3QgIT0gbnVsbCA/IHR5cGVvZiBvYmplY3RbcHJvcGVydHldIDogJ251bWJlcic7XG4gICAgcmV0dXJuICEvXig/OmJvb2xlYW58bnVtYmVyfHN0cmluZ3x1bmRlZmluZWQpJC8udGVzdCh0eXBlKSAmJlxuICAgICAgKHR5cGUgPT0gJ29iamVjdCcgPyAhIW9iamVjdFtwcm9wZXJ0eV0gOiB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhIHN0cmluZyBmb3IgdXNlIGluIGEgYFJlZ0V4cGAgYnkgbWFraW5nIGh5cGhlbnMgYW5kIHNwYWNlcyBvcHRpb25hbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHF1YWxpZnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBxdWFsaWZpZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcXVhbGlmeShzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvKFsgLV0pKD8hJCkvZywgJyQxPycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgYmFyZS1ib25lcyBgQXJyYXkjcmVkdWNlYCBsaWtlIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMgeyp9IFRoZSBhY2N1bXVsYXRlZCByZXN1bHQuXG4gICAqL1xuICBmdW5jdGlvbiByZWR1Y2UoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFjY3VtdWxhdG9yID0gbnVsbDtcbiAgICBlYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBhIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmltbWVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL14gK3wgKyQvZywgJycpO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcGxhdGZvcm0gb2JqZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbdWE9bmF2aWdhdG9yLnVzZXJBZ2VudF0gVGhlIHVzZXIgYWdlbnQgc3RyaW5nIG9yXG4gICAqICBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge09iamVjdH0gQSBwbGF0Zm9ybSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZSh1YSkge1xuXG4gICAgLyoqIFRoZSBlbnZpcm9ubWVudCBjb250ZXh0IG9iamVjdC4gKi9cbiAgICB2YXIgY29udGV4dCA9IHJvb3Q7XG5cbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYSBjdXN0b20gY29udGV4dCBpcyBwcm92aWRlZC4gKi9cbiAgICB2YXIgaXNDdXN0b21Db250ZXh0ID0gdWEgJiYgdHlwZW9mIHVhID09ICdvYmplY3QnICYmIGdldENsYXNzT2YodWEpICE9ICdTdHJpbmcnO1xuXG4gICAgLy8gSnVnZ2xlIGFyZ3VtZW50cy5cbiAgICBpZiAoaXNDdXN0b21Db250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gdWE7XG4gICAgICB1YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqIEJyb3dzZXIgbmF2aWdhdG9yIG9iamVjdC4gKi9cbiAgICB2YXIgbmF2ID0gY29udGV4dC5uYXZpZ2F0b3IgfHwge307XG5cbiAgICAvKiogQnJvd3NlciB1c2VyIGFnZW50IHN0cmluZy4gKi9cbiAgICB2YXIgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudCB8fCAnJztcblxuICAgIHVhIHx8ICh1YSA9IHVzZXJBZ2VudCk7XG5cbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYHRoaXNCaW5kaW5nYCBpcyB0aGUgW01vZHVsZVNjb3BlXS4gKi9cbiAgICB2YXIgaXNNb2R1bGVTY29wZSA9IGlzQ3VzdG9tQ29udGV4dCB8fCB0aGlzQmluZGluZyA9PSBvbGRSb290O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGJyb3dzZXIgaXMgbGlrZSBDaHJvbWUuICovXG4gICAgdmFyIGxpa2VDaHJvbWUgPSBpc0N1c3RvbUNvbnRleHRcbiAgICAgID8gISFuYXYubGlrZUNocm9tZVxuICAgICAgOiAvXFxiQ2hyb21lXFxiLy50ZXN0KHVhKSAmJiAhL2ludGVybmFsfFxcbi9pLnRlc3QodG9TdHJpbmcudG9TdHJpbmcoKSk7XG5cbiAgICAvKiogSW50ZXJuYWwgYFtbQ2xhc3NdXWAgdmFsdWUgc2hvcnRjdXRzLiAqL1xuICAgIHZhciBvYmplY3RDbGFzcyA9ICdPYmplY3QnLFxuICAgICAgICBhaXJSdW50aW1lQ2xhc3MgPSBpc0N1c3RvbUNvbnRleHQgPyBvYmplY3RDbGFzcyA6ICdTY3JpcHRCcmlkZ2luZ1Byb3h5T2JqZWN0JyxcbiAgICAgICAgZW52aXJvQ2xhc3MgPSBpc0N1c3RvbUNvbnRleHQgPyBvYmplY3RDbGFzcyA6ICdFbnZpcm9ubWVudCcsXG4gICAgICAgIGphdmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgY29udGV4dC5qYXZhKSA/ICdKYXZhUGFja2FnZScgOiBnZXRDbGFzc09mKGNvbnRleHQuamF2YSksXG4gICAgICAgIHBoYW50b21DbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1J1bnRpbWVPYmplY3QnO1xuXG4gICAgLyoqIERldGVjdCBKYXZhIGVudmlyb25tZW50cy4gKi9cbiAgICB2YXIgamF2YSA9IC9cXGJKYXZhLy50ZXN0KGphdmFDbGFzcykgJiYgY29udGV4dC5qYXZhO1xuXG4gICAgLyoqIERldGVjdCBSaGluby4gKi9cbiAgICB2YXIgcmhpbm8gPSBqYXZhICYmIGdldENsYXNzT2YoY29udGV4dC5lbnZpcm9ubWVudCkgPT0gZW52aXJvQ2xhc3M7XG5cbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGFscGhhLiAqL1xuICAgIHZhciBhbHBoYSA9IGphdmEgPyAnYScgOiAnXFx1MDNiMSc7XG5cbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGJldGEuICovXG4gICAgdmFyIGJldGEgPSBqYXZhID8gJ2InIDogJ1xcdTAzYjInO1xuXG4gICAgLyoqIEJyb3dzZXIgZG9jdW1lbnQgb2JqZWN0LiAqL1xuICAgIHZhciBkb2MgPSBjb250ZXh0LmRvY3VtZW50IHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IE9wZXJhIGJyb3dzZXIgKFByZXN0by1iYXNlZCkuXG4gICAgICogaHR0cDovL3d3dy5ob3d0b2NyZWF0ZS5jby51ay9vcGVyYVN0dWZmL29wZXJhT2JqZWN0Lmh0bWxcbiAgICAgKiBodHRwOi8vZGV2Lm9wZXJhLmNvbS9hcnRpY2xlcy92aWV3L29wZXJhLW1pbmktd2ViLWNvbnRlbnQtYXV0aG9yaW5nLWd1aWRlbGluZXMvI29wZXJhbWluaVxuICAgICAqL1xuICAgIHZhciBvcGVyYSA9IGNvbnRleHQub3BlcmFtaW5pIHx8IGNvbnRleHQub3BlcmE7XG5cbiAgICAvKiogT3BlcmEgYFtbQ2xhc3NdXWAuICovXG4gICAgdmFyIG9wZXJhQ2xhc3MgPSByZU9wZXJhLnRlc3Qob3BlcmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgb3BlcmEpID8gb3BlcmFbJ1tbQ2xhc3NdXSddIDogZ2V0Q2xhc3NPZihvcGVyYSkpXG4gICAgICA/IG9wZXJhQ2xhc3NcbiAgICAgIDogKG9wZXJhID0gbnVsbCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKiogVGVtcG9yYXJ5IHZhcmlhYmxlIHVzZWQgb3ZlciB0aGUgc2NyaXB0J3MgbGlmZXRpbWUuICovXG4gICAgdmFyIGRhdGE7XG5cbiAgICAvKiogVGhlIENQVSBhcmNoaXRlY3R1cmUuICovXG4gICAgdmFyIGFyY2ggPSB1YTtcblxuICAgIC8qKiBQbGF0Zm9ybSBkZXNjcmlwdGlvbiBhcnJheS4gKi9cbiAgICB2YXIgZGVzY3JpcHRpb24gPSBbXTtcblxuICAgIC8qKiBQbGF0Zm9ybSBhbHBoYS9iZXRhIGluZGljYXRvci4gKi9cbiAgICB2YXIgcHJlcmVsZWFzZSA9IG51bGw7XG5cbiAgICAvKiogQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgZW52aXJvbm1lbnQgZmVhdHVyZXMgc2hvdWxkIGJlIHVzZWQgdG8gcmVzb2x2ZSB0aGUgcGxhdGZvcm0uICovXG4gICAgdmFyIHVzZUZlYXR1cmVzID0gdWEgPT0gdXNlckFnZW50O1xuXG4gICAgLyoqIFRoZSBicm93c2VyL2Vudmlyb25tZW50IHZlcnNpb24uICovXG4gICAgdmFyIHZlcnNpb24gPSB1c2VGZWF0dXJlcyAmJiBvcGVyYSAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PSAnZnVuY3Rpb24nICYmIG9wZXJhLnZlcnNpb24oKTtcblxuICAgIC8qKiBBIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIE9TIGVuZHMgd2l0aCBcIi8gVmVyc2lvblwiICovXG4gICAgdmFyIGlzU3BlY2lhbENhc2VkT1M7XG5cbiAgICAvKiBEZXRlY3RhYmxlIGxheW91dCBlbmdpbmVzIChvcmRlciBpcyBpbXBvcnRhbnQpLiAqL1xuICAgIHZhciBsYXlvdXQgPSBnZXRMYXlvdXQoW1xuICAgICAgeyAnbGFiZWwnOiAnRWRnZUhUTUwnLCAncGF0dGVybic6ICdFZGdlJyB9LFxuICAgICAgJ1RyaWRlbnQnLFxuICAgICAgeyAnbGFiZWwnOiAnV2ViS2l0JywgJ3BhdHRlcm4nOiAnQXBwbGVXZWJLaXQnIH0sXG4gICAgICAnaUNhYicsXG4gICAgICAnUHJlc3RvJyxcbiAgICAgICdOZXRGcm9udCcsXG4gICAgICAnVGFzbWFuJyxcbiAgICAgICdLSFRNTCcsXG4gICAgICAnR2Vja28nXG4gICAgXSk7XG5cbiAgICAvKiBEZXRlY3RhYmxlIGJyb3dzZXIgbmFtZXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXG4gICAgdmFyIG5hbWUgPSBnZXROYW1lKFtcbiAgICAgICdBZG9iZSBBSVInLFxuICAgICAgJ0Fyb3JhJyxcbiAgICAgICdBdmFudCBCcm93c2VyJyxcbiAgICAgICdCcmVhY2gnLFxuICAgICAgJ0NhbWlubycsXG4gICAgICAnRWxlY3Ryb24nLFxuICAgICAgJ0VwaXBoYW55JyxcbiAgICAgICdGZW5uZWMnLFxuICAgICAgJ0Zsb2NrJyxcbiAgICAgICdHYWxlb24nLFxuICAgICAgJ0dyZWVuQnJvd3NlcicsXG4gICAgICAnaUNhYicsXG4gICAgICAnSWNld2Vhc2VsJyxcbiAgICAgICdLLU1lbGVvbicsXG4gICAgICAnS29ucXVlcm9yJyxcbiAgICAgICdMdW5hc2NhcGUnLFxuICAgICAgJ01heHRob24nLFxuICAgICAgeyAnbGFiZWwnOiAnTWljcm9zb2Z0IEVkZ2UnLCAncGF0dGVybic6ICdFZGdlJyB9LFxuICAgICAgJ01pZG9yaScsXG4gICAgICAnTm9vayBCcm93c2VyJyxcbiAgICAgICdQYWxlTW9vbicsXG4gICAgICAnUGhhbnRvbUpTJyxcbiAgICAgICdSYXZlbicsXG4gICAgICAnUmVrb25xJyxcbiAgICAgICdSb2NrTWVsdCcsXG4gICAgICB7ICdsYWJlbCc6ICdTYW1zdW5nIEludGVybmV0JywgJ3BhdHRlcm4nOiAnU2Ftc3VuZ0Jyb3dzZXInIH0sXG4gICAgICAnU2VhTW9ua2V5JyxcbiAgICAgIHsgJ2xhYmVsJzogJ1NpbGsnLCAncGF0dGVybic6ICcoPzpDbG91ZDl8U2lsay1BY2NlbGVyYXRlZCknIH0sXG4gICAgICAnU2xlaXBuaXInLFxuICAgICAgJ1NsaW1Ccm93c2VyJyxcbiAgICAgIHsgJ2xhYmVsJzogJ1NSV2FyZSBJcm9uJywgJ3BhdHRlcm4nOiAnSXJvbicgfSxcbiAgICAgICdTdW5yaXNlJyxcbiAgICAgICdTd2lmdGZveCcsXG4gICAgICAnV2F0ZXJmb3gnLFxuICAgICAgJ1dlYlBvc2l0aXZlJyxcbiAgICAgICdPcGVyYSBNaW5pJyxcbiAgICAgIHsgJ2xhYmVsJzogJ09wZXJhIE1pbmknLCAncGF0dGVybic6ICdPUGlPUycgfSxcbiAgICAgICdPcGVyYScsXG4gICAgICB7ICdsYWJlbCc6ICdPcGVyYScsICdwYXR0ZXJuJzogJ09QUicgfSxcbiAgICAgICdDaHJvbWUnLFxuICAgICAgeyAnbGFiZWwnOiAnQ2hyb21lIE1vYmlsZScsICdwYXR0ZXJuJzogJyg/OkNyaU9TfENyTW8pJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCcsICdwYXR0ZXJuJzogJyg/OkZpcmVmb3h8TWluZWZpZWxkKScgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0ZpcmVmb3ggZm9yIGlPUycsICdwYXR0ZXJuJzogJ0Z4aU9TJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnSUUnLCAncGF0dGVybic6ICdJRU1vYmlsZScgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnTVNJRScgfSxcbiAgICAgICdTYWZhcmknXG4gICAgXSk7XG5cbiAgICAvKiBEZXRlY3RhYmxlIHByb2R1Y3RzIChvcmRlciBpcyBpbXBvcnRhbnQpLiAqL1xuICAgIHZhciBwcm9kdWN0ID0gZ2V0UHJvZHVjdChbXG4gICAgICB7ICdsYWJlbCc6ICdCbGFja0JlcnJ5JywgJ3BhdHRlcm4nOiAnQkIxMCcgfSxcbiAgICAgICdCbGFja0JlcnJ5JyxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTJywgJ3BhdHRlcm4nOiAnR1QtSTkwMDAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzInLCAncGF0dGVybic6ICdHVC1JOTEwMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTMycsICdwYXR0ZXJuJzogJ0dULUk5MzAwJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFM0JywgJ3BhdHRlcm4nOiAnR1QtSTk1MDAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzUnLCAncGF0dGVybic6ICdTTS1HOTAwJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFM2JywgJ3BhdHRlcm4nOiAnU00tRzkyMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNiBFZGdlJywgJ3BhdHRlcm4nOiAnU00tRzkyNScgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNycsICdwYXR0ZXJuJzogJ1NNLUc5MzAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzcgRWRnZScsICdwYXR0ZXJuJzogJ1NNLUc5MzUnIH0sXG4gICAgICAnR29vZ2xlIFRWJyxcbiAgICAgICdMdW1pYScsXG4gICAgICAnaVBhZCcsXG4gICAgICAnaVBvZCcsXG4gICAgICAnaVBob25lJyxcbiAgICAgICdLaW5kbGUnLFxuICAgICAgeyAnbGFiZWwnOiAnS2luZGxlIEZpcmUnLCAncGF0dGVybic6ICcoPzpDbG91ZDl8U2lsay1BY2NlbGVyYXRlZCknIH0sXG4gICAgICAnTmV4dXMnLFxuICAgICAgJ05vb2snLFxuICAgICAgJ1BsYXlCb29rJyxcbiAgICAgICdQbGF5U3RhdGlvbiBWaXRhJyxcbiAgICAgICdQbGF5U3RhdGlvbicsXG4gICAgICAnVG91Y2hQYWQnLFxuICAgICAgJ1RyYW5zZm9ybWVyJyxcbiAgICAgIHsgJ2xhYmVsJzogJ1dpaSBVJywgJ3BhdHRlcm4nOiAnV2lpVScgfSxcbiAgICAgICdXaWknLFxuICAgICAgJ1hib3ggT25lJyxcbiAgICAgIHsgJ2xhYmVsJzogJ1hib3ggMzYwJywgJ3BhdHRlcm4nOiAnWGJveCcgfSxcbiAgICAgICdYb29tJ1xuICAgIF0pO1xuXG4gICAgLyogRGV0ZWN0YWJsZSBtYW51ZmFjdHVyZXJzLiAqL1xuICAgIHZhciBtYW51ZmFjdHVyZXIgPSBnZXRNYW51ZmFjdHVyZXIoe1xuICAgICAgJ0FwcGxlJzogeyAnaVBhZCc6IDEsICdpUGhvbmUnOiAxLCAnaVBvZCc6IDEgfSxcbiAgICAgICdBcmNob3MnOiB7fSxcbiAgICAgICdBbWF6b24nOiB7ICdLaW5kbGUnOiAxLCAnS2luZGxlIEZpcmUnOiAxIH0sXG4gICAgICAnQXN1cyc6IHsgJ1RyYW5zZm9ybWVyJzogMSB9LFxuICAgICAgJ0Jhcm5lcyAmIE5vYmxlJzogeyAnTm9vayc6IDEgfSxcbiAgICAgICdCbGFja0JlcnJ5JzogeyAnUGxheUJvb2snOiAxIH0sXG4gICAgICAnR29vZ2xlJzogeyAnR29vZ2xlIFRWJzogMSwgJ05leHVzJzogMSB9LFxuICAgICAgJ0hQJzogeyAnVG91Y2hQYWQnOiAxIH0sXG4gICAgICAnSFRDJzoge30sXG4gICAgICAnTEcnOiB7fSxcbiAgICAgICdNaWNyb3NvZnQnOiB7ICdYYm94JzogMSwgJ1hib3ggT25lJzogMSB9LFxuICAgICAgJ01vdG9yb2xhJzogeyAnWG9vbSc6IDEgfSxcbiAgICAgICdOaW50ZW5kbyc6IHsgJ1dpaSBVJzogMSwgICdXaWknOiAxIH0sXG4gICAgICAnTm9raWEnOiB7ICdMdW1pYSc6IDEgfSxcbiAgICAgICdTYW1zdW5nJzogeyAnR2FsYXh5IFMnOiAxLCAnR2FsYXh5IFMyJzogMSwgJ0dhbGF4eSBTMyc6IDEsICdHYWxheHkgUzQnOiAxIH0sXG4gICAgICAnU29ueSc6IHsgJ1BsYXlTdGF0aW9uJzogMSwgJ1BsYXlTdGF0aW9uIFZpdGEnOiAxIH1cbiAgICB9KTtcblxuICAgIC8qIERldGVjdGFibGUgb3BlcmF0aW5nIHN5c3RlbXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXG4gICAgdmFyIG9zID0gZ2V0T1MoW1xuICAgICAgJ1dpbmRvd3MgUGhvbmUnLFxuICAgICAgJ0FuZHJvaWQnLFxuICAgICAgJ0NlbnRPUycsXG4gICAgICB7ICdsYWJlbCc6ICdDaHJvbWUgT1MnLCAncGF0dGVybic6ICdDck9TJyB9LFxuICAgICAgJ0RlYmlhbicsXG4gICAgICAnRmVkb3JhJyxcbiAgICAgICdGcmVlQlNEJyxcbiAgICAgICdHZW50b28nLFxuICAgICAgJ0hhaWt1JyxcbiAgICAgICdLdWJ1bnR1JyxcbiAgICAgICdMaW51eCBNaW50JyxcbiAgICAgICdPcGVuQlNEJyxcbiAgICAgICdSZWQgSGF0JyxcbiAgICAgICdTdVNFJyxcbiAgICAgICdVYnVudHUnLFxuICAgICAgJ1h1YnVudHUnLFxuICAgICAgJ0N5Z3dpbicsXG4gICAgICAnU3ltYmlhbiBPUycsXG4gICAgICAnaHB3T1MnLFxuICAgICAgJ3dlYk9TICcsXG4gICAgICAnd2ViT1MnLFxuICAgICAgJ1RhYmxldCBPUycsXG4gICAgICAnVGl6ZW4nLFxuICAgICAgJ0xpbnV4JyxcbiAgICAgICdNYWMgT1MgWCcsXG4gICAgICAnTWFjaW50b3NoJyxcbiAgICAgICdNYWMnLFxuICAgICAgJ1dpbmRvd3MgOTg7JyxcbiAgICAgICdXaW5kb3dzICdcbiAgICBdKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFBpY2tzIHRoZSBsYXlvdXQgZW5naW5lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIGxheW91dCBlbmdpbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TGF5b3V0KGd1ZXNzZXMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IFJlZ0V4cCgnXFxcXGInICsgKFxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcbiAgICAgICAgKSArICdcXFxcYicsICdpJykuZXhlYyh1YSkgJiYgKGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2tzIHRoZSBtYW51ZmFjdHVyZXIgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIG9iamVjdCBvZiBndWVzc2VzLlxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIG1hbnVmYWN0dXJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYW51ZmFjdHVyZXIoZ3Vlc3Nlcykge1xuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBtYW51ZmFjdHVyZXIgYnkgcHJvZHVjdCBvciBzY2FuIHRoZSBVQSBmb3IgdGhlIG1hbnVmYWN0dXJlci5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoXG4gICAgICAgICAgdmFsdWVbcHJvZHVjdF0gfHxcbiAgICAgICAgICB2YWx1ZVsvXlthLXpdKyg/OiArW2Etel0rXFxiKSovaS5leGVjKHByb2R1Y3QpXSB8fFxuICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcXVhbGlmeShrZXkpICsgJyg/OlxcXFxifFxcXFx3KlxcXFxkKScsICdpJykuZXhlYyh1YSlcbiAgICAgICAgKSAmJiBrZXk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaWNrcyB0aGUgYnJvd3NlciBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIGJyb3dzZXIgbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYW1lKGd1ZXNzZXMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IFJlZ0V4cCgnXFxcXGInICsgKFxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcbiAgICAgICAgKSArICdcXFxcYicsICdpJykuZXhlYyh1YSkgJiYgKGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2tzIHRoZSBPUyBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIE9TIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T1MoZ3Vlc3Nlcykge1xuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gZ3Vlc3MucGF0dGVybiB8fCBxdWFsaWZ5KGd1ZXNzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgKHJlc3VsdCA9XG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcoPzovW1xcXFxkLl0rfFsgXFxcXHcuXSopJywgJ2knKS5leGVjKHVhKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGNsZWFudXBPUyhyZXN1bHQsIHBhdHRlcm4sIGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIHByb2R1Y3QgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCBwcm9kdWN0IG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHJvZHVjdChndWVzc2VzKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpO1xuICAgICAgICBpZiAoIXJlc3VsdCAmJiAocmVzdWx0ID1cbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyAqXFxcXGQrWy5cXFxcd19dKicsICdpJykuZXhlYyh1YSkgfHxcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyAqXFxcXHcrLVtcXFxcd10qJywgJ2knKS5leGVjKHVhKSB8fFxuICAgICAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHBhdHRlcm4gKyAnKD86OyAqKD86W2Etel0rW18tXSk/W2Etel0rXFxcXGQrfFteICgpOy1dKiknLCAnaScpLmV4ZWModWEpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgLy8gU3BsaXQgYnkgZm9yd2FyZCBzbGFzaCBhbmQgYXBwZW5kIHByb2R1Y3QgdmVyc2lvbiBpZiBuZWVkZWQuXG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBTdHJpbmcoKGd1ZXNzLmxhYmVsICYmICFSZWdFeHAocGF0dGVybiwgJ2knKS50ZXN0KGd1ZXNzLmxhYmVsKSkgPyBndWVzcy5sYWJlbCA6IHJlc3VsdCkuc3BsaXQoJy8nKSlbMV0gJiYgIS9bXFxkLl0rLy50ZXN0KHJlc3VsdFswXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFswXSArPSAnICcgKyByZXN1bHRbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvcnJlY3QgY2hhcmFjdGVyIGNhc2UgYW5kIGNsZWFudXAgc3RyaW5nLlxuICAgICAgICAgIGd1ZXNzID0gZ3Vlc3MubGFiZWwgfHwgZ3Vlc3M7XG4gICAgICAgICAgcmVzdWx0ID0gZm9ybWF0KHJlc3VsdFswXVxuICAgICAgICAgICAgLnJlcGxhY2UoUmVnRXhwKHBhdHRlcm4sICdpJyksIGd1ZXNzKVxuICAgICAgICAgICAgLnJlcGxhY2UoUmVnRXhwKCc7ICooPzonICsgZ3Vlc3MgKyAnW18tXSk/JywgJ2knKSwgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoUmVnRXhwKCcoJyArIGd1ZXNzICsgJylbLV8uXT8oXFxcXHcpJywgJ2knKSwgJyQxICQyJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmVyc2lvbiB1c2luZyBhbiBhcnJheSBvZiBVQSBwYXR0ZXJucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0dGVybnMgQW4gYXJyYXkgb2YgVUEgcGF0dGVybnMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWZXJzaW9uKHBhdHRlcm5zKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKHBhdHRlcm5zLCBmdW5jdGlvbihyZXN1bHQsIHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoUmVnRXhwKHBhdHRlcm4gK1xuICAgICAgICAgICcoPzotW1xcXFxkLl0rL3woPzogZm9yIFtcXFxcdy1dKyk/WyAvLV0pKFtcXFxcZC5dK1teICgpOy9fLV0qKScsICdpJykuZXhlYyh1YSkgfHwgMClbMV0gfHwgbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHBsYXRmb3JtLmRlc2NyaXB0aW9uYCB3aGVuIHRoZSBwbGF0Zm9ybSBvYmplY3QgaXMgY29lcmNlZCB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBuYW1lIHRvU3RyaW5nXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBgcGxhdGZvcm0uZGVzY3JpcHRpb25gIGlmIGF2YWlsYWJsZSwgZWxzZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmdQbGF0Zm9ybSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uIHx8ICcnO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIENvbnZlcnQgbGF5b3V0IHRvIGFuIGFycmF5IHNvIHdlIGNhbiBhZGQgZXh0cmEgZGV0YWlscy5cbiAgICBsYXlvdXQgJiYgKGxheW91dCA9IFtsYXlvdXRdKTtcblxuICAgIC8vIERldGVjdCBwcm9kdWN0IG5hbWVzIHRoYXQgY29udGFpbiB0aGVpciBtYW51ZmFjdHVyZXIncyBuYW1lLlxuICAgIGlmIChtYW51ZmFjdHVyZXIgJiYgIXByb2R1Y3QpIHtcbiAgICAgIHByb2R1Y3QgPSBnZXRQcm9kdWN0KFttYW51ZmFjdHVyZXJdKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgR29vZ2xlIFRWLlxuICAgIGlmICgoZGF0YSA9IC9cXGJHb29nbGUgVFZcXGIvLmV4ZWMocHJvZHVjdCkpKSB7XG4gICAgICBwcm9kdWN0ID0gZGF0YVswXTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IHNpbXVsYXRvcnMuXG4gICAgaWYgKC9cXGJTaW11bGF0b3JcXGIvaS50ZXN0KHVhKSkge1xuICAgICAgcHJvZHVjdCA9IChwcm9kdWN0ID8gcHJvZHVjdCArICcgJyA6ICcnKSArICdTaW11bGF0b3InO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgT3BlcmEgTWluaSA4KyBydW5uaW5nIGluIFR1cmJvL1VuY29tcHJlc3NlZCBtb2RlIG9uIGlPUy5cbiAgICBpZiAobmFtZSA9PSAnT3BlcmEgTWluaScgJiYgL1xcYk9QaU9TXFxiLy50ZXN0KHVhKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgncnVubmluZyBpbiBUdXJiby9VbmNvbXByZXNzZWQgbW9kZScpO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgSUUgTW9iaWxlIDExLlxuICAgIGlmIChuYW1lID09ICdJRScgJiYgL1xcYmxpa2UgaVBob25lIE9TXFxiLy50ZXN0KHVhKSkge1xuICAgICAgZGF0YSA9IHBhcnNlKHVhLnJlcGxhY2UoL2xpa2UgaVBob25lIE9TLywgJycpKTtcbiAgICAgIG1hbnVmYWN0dXJlciA9IGRhdGEubWFudWZhY3R1cmVyO1xuICAgICAgcHJvZHVjdCA9IGRhdGEucHJvZHVjdDtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IGlPUy5cbiAgICBlbHNlIGlmICgvXmlQLy50ZXN0KHByb2R1Y3QpKSB7XG4gICAgICBuYW1lIHx8IChuYW1lID0gJ1NhZmFyaScpO1xuICAgICAgb3MgPSAnaU9TJyArICgoZGF0YSA9IC8gT1MgKFtcXGRfXSspL2kuZXhlYyh1YSkpXG4gICAgICAgID8gJyAnICsgZGF0YVsxXS5yZXBsYWNlKC9fL2csICcuJylcbiAgICAgICAgOiAnJyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBLdWJ1bnR1LlxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0tvbnF1ZXJvcicgJiYgIS9idW50dS9pLnRlc3Qob3MpKSB7XG4gICAgICBvcyA9ICdLdWJ1bnR1JztcbiAgICB9XG4gICAgLy8gRGV0ZWN0IEFuZHJvaWQgYnJvd3NlcnMuXG4gICAgZWxzZSBpZiAoKG1hbnVmYWN0dXJlciAmJiBtYW51ZmFjdHVyZXIgIT0gJ0dvb2dsZScgJiZcbiAgICAgICAgKCgvQ2hyb21lLy50ZXN0KG5hbWUpICYmICEvXFxiTW9iaWxlIFNhZmFyaVxcYi9pLnRlc3QodWEpKSB8fCAvXFxiVml0YVxcYi8udGVzdChwcm9kdWN0KSkpIHx8XG4gICAgICAgICgvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgJiYgL15DaHJvbWUvLnRlc3QobmFtZSkgJiYgL1xcYlZlcnNpb25cXC8vaS50ZXN0KHVhKSkpIHtcbiAgICAgIG5hbWUgPSAnQW5kcm9pZCBCcm93c2VyJztcbiAgICAgIG9zID0gL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiAnQW5kcm9pZCc7XG4gICAgfVxuICAgIC8vIERldGVjdCBTaWxrIGRlc2t0b3AvYWNjZWxlcmF0ZWQgbW9kZXMuXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnU2lsaycpIHtcbiAgICAgIGlmICghL1xcYk1vYmkvaS50ZXN0KHVhKSkge1xuICAgICAgICBvcyA9ICdBbmRyb2lkJztcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICB9XG4gICAgICBpZiAoL0FjY2VsZXJhdGVkICo9ICp0cnVlL2kudGVzdCh1YSkpIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnYWNjZWxlcmF0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZWN0IFBhbGVNb29uIGlkZW50aWZ5aW5nIGFzIEZpcmVmb3guXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnUGFsZU1vb24nICYmIChkYXRhID0gL1xcYkZpcmVmb3hcXC8oW1xcZC5dKylcXGIvLmV4ZWModWEpKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnaWRlbnRpZnlpbmcgYXMgRmlyZWZveCAnICsgZGF0YVsxXSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBGaXJlZm94IE9TIGFuZCBwcm9kdWN0cyBydW5uaW5nIEZpcmVmb3guXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnRmlyZWZveCcgJiYgKGRhdGEgPSAvXFxiKE1vYmlsZXxUYWJsZXR8VFYpXFxiL2kuZXhlYyh1YSkpKSB7XG4gICAgICBvcyB8fCAob3MgPSAnRmlyZWZveCBPUycpO1xuICAgICAgcHJvZHVjdCB8fCAocHJvZHVjdCA9IGRhdGFbMV0pO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgZmFsc2UgcG9zaXRpdmVzIGZvciBGaXJlZm94L1NhZmFyaS5cbiAgICBlbHNlIGlmICghbmFtZSB8fCAoZGF0YSA9ICEvXFxiTWluZWZpZWxkXFxiL2kudGVzdCh1YSkgJiYgL1xcYig/OkZpcmVmb3h8U2FmYXJpKVxcYi8uZXhlYyhuYW1lKSkpIHtcbiAgICAgIC8vIEVzY2FwZSB0aGUgYC9gIGZvciBGaXJlZm94IDEuXG4gICAgICBpZiAobmFtZSAmJiAhcHJvZHVjdCAmJiAvW1xcLyxdfF5bXihdKz9cXCkvLnRlc3QodWEuc2xpY2UodWEuaW5kZXhPZihkYXRhICsgJy8nKSArIDgpKSkge1xuICAgICAgICAvLyBDbGVhciBuYW1lIG9mIGZhbHNlIHBvc2l0aXZlcy5cbiAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBSZWFzc2lnbiBhIGdlbmVyaWMgbmFtZS5cbiAgICAgIGlmICgoZGF0YSA9IHByb2R1Y3QgfHwgbWFudWZhY3R1cmVyIHx8IG9zKSAmJlxuICAgICAgICAgIChwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCAvXFxiKD86QW5kcm9pZHxTeW1iaWFuIE9TfFRhYmxldCBPU3x3ZWJPUylcXGIvLnRlc3Qob3MpKSkge1xuICAgICAgICBuYW1lID0gL1thLXpdKyg/OiBIYXQpPy9pLmV4ZWMoL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiBkYXRhKSArICcgQnJvd3Nlcic7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBDaHJvbWUgdmVyc2lvbiB0byBkZXNjcmlwdGlvbiBmb3IgRWxlY3Ryb24uXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnRWxlY3Ryb24nICYmIChkYXRhID0gKC9cXGJDaHJvbWVcXC8oW1xcZC5dKylcXGIvLmV4ZWModWEpIHx8IDApWzFdKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnQ2hyb21pdW0gJyArIGRhdGEpO1xuICAgIH1cbiAgICAvLyBEZXRlY3Qgbm9uLU9wZXJhIChQcmVzdG8tYmFzZWQpIHZlcnNpb25zIChvcmRlciBpcyBpbXBvcnRhbnQpLlxuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IGdldFZlcnNpb24oW1xuICAgICAgICAnKD86Q2xvdWQ5fENyaU9TfENyTW98RWRnZXxGeGlPU3xJRU1vYmlsZXxJcm9ufE9wZXJhID9NaW5pfE9QaU9TfE9QUnxSYXZlbnxTYW1zdW5nQnJvd3NlcnxTaWxrKD8hL1tcXFxcZC5dKyQpKScsXG4gICAgICAgICdWZXJzaW9uJyxcbiAgICAgICAgcXVhbGlmeShuYW1lKSxcbiAgICAgICAgJyg/OkZpcmVmb3h8TWluZWZpZWxkfE5ldEZyb250KSdcbiAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBEZXRlY3Qgc3R1YmJvcm4gbGF5b3V0IGVuZ2luZXMuXG4gICAgaWYgKChkYXRhID1cbiAgICAgICAgICBsYXlvdXQgPT0gJ2lDYWInICYmIHBhcnNlRmxvYXQodmVyc2lvbikgPiAzICYmICdXZWJLaXQnIHx8XG4gICAgICAgICAgL1xcYk9wZXJhXFxiLy50ZXN0KG5hbWUpICYmICgvXFxiT1BSXFxiLy50ZXN0KHVhKSA/ICdCbGluaycgOiAnUHJlc3RvJykgfHxcbiAgICAgICAgICAvXFxiKD86TWlkb3JpfE5vb2t8U2FmYXJpKVxcYi9pLnRlc3QodWEpICYmICEvXig/OlRyaWRlbnR8RWRnZUhUTUwpJC8udGVzdChsYXlvdXQpICYmICdXZWJLaXQnIHx8XG4gICAgICAgICAgIWxheW91dCAmJiAvXFxiTVNJRVxcYi9pLnRlc3QodWEpICYmIChvcyA9PSAnTWFjIE9TJyA/ICdUYXNtYW4nIDogJ1RyaWRlbnQnKSB8fFxuICAgICAgICAgIGxheW91dCA9PSAnV2ViS2l0JyAmJiAvXFxiUGxheVN0YXRpb25cXGIoPyEgVml0YVxcYikvaS50ZXN0KG5hbWUpICYmICdOZXRGcm9udCdcbiAgICAgICAgKSkge1xuICAgICAgbGF5b3V0ID0gW2RhdGFdO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgV2luZG93cyBQaG9uZSA3IGRlc2t0b3AgbW9kZS5cbiAgICBpZiAobmFtZSA9PSAnSUUnICYmIChkYXRhID0gKC87ICooPzpYQkxXUHxadW5lV1ApKFxcZCspL2kuZXhlYyh1YSkgfHwgMClbMV0pKSB7XG4gICAgICBuYW1lICs9ICcgTW9iaWxlJztcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgJyArICgvXFwrJC8udGVzdChkYXRhKSA/IGRhdGEgOiBkYXRhICsgJy54Jyk7XG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IFdpbmRvd3MgUGhvbmUgOC54IGRlc2t0b3AgbW9kZS5cbiAgICBlbHNlIGlmICgvXFxiV1BEZXNrdG9wXFxiL2kudGVzdCh1YSkpIHtcbiAgICAgIG5hbWUgPSAnSUUgTW9iaWxlJztcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgOC54JztcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xuICAgICAgdmVyc2lvbiB8fCAodmVyc2lvbiA9ICgvXFxicnY6KFtcXGQuXSspLy5leGVjKHVhKSB8fCAwKVsxXSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBJRSAxMSBpZGVudGlmeWluZyBhcyBvdGhlciBicm93c2Vycy5cbiAgICBlbHNlIGlmIChuYW1lICE9ICdJRScgJiYgbGF5b3V0ID09ICdUcmlkZW50JyAmJiAoZGF0YSA9IC9cXGJydjooW1xcZC5dKykvLmV4ZWModWEpKSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZGVzY3JpcHRpb24ucHVzaCgnaWRlbnRpZnlpbmcgYXMgJyArIG5hbWUgKyAodmVyc2lvbiA/ICcgJyArIHZlcnNpb24gOiAnJykpO1xuICAgICAgfVxuICAgICAgbmFtZSA9ICdJRSc7XG4gICAgICB2ZXJzaW9uID0gZGF0YVsxXTtcbiAgICB9XG4gICAgLy8gTGV2ZXJhZ2UgZW52aXJvbm1lbnQgZmVhdHVyZXMuXG4gICAgaWYgKHVzZUZlYXR1cmVzKSB7XG4gICAgICAvLyBEZXRlY3Qgc2VydmVyLXNpZGUgZW52aXJvbm1lbnRzLlxuICAgICAgLy8gUmhpbm8gaGFzIGEgZ2xvYmFsIGZ1bmN0aW9uIHdoaWxlIG90aGVycyBoYXZlIGEgZ2xvYmFsIG9iamVjdC5cbiAgICAgIGlmIChpc0hvc3RUeXBlKGNvbnRleHQsICdnbG9iYWwnKSkge1xuICAgICAgICBpZiAoamF2YSkge1xuICAgICAgICAgIGRhdGEgPSBqYXZhLmxhbmcuU3lzdGVtO1xuICAgICAgICAgIGFyY2ggPSBkYXRhLmdldFByb3BlcnR5KCdvcy5hcmNoJyk7XG4gICAgICAgICAgb3MgPSBvcyB8fCBkYXRhLmdldFByb3BlcnR5KCdvcy5uYW1lJykgKyAnICcgKyBkYXRhLmdldFByb3BlcnR5KCdvcy52ZXJzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW9kdWxlU2NvcGUgJiYgaXNIb3N0VHlwZShjb250ZXh0LCAnc3lzdGVtJykgJiYgKGRhdGEgPSBbY29udGV4dC5zeXN0ZW1dKVswXSkge1xuICAgICAgICAgIG9zIHx8IChvcyA9IGRhdGFbMF0ub3MgfHwgbnVsbCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGFbMV0gPSBjb250ZXh0LnJlcXVpcmUoJ3JpbmdvL2VuZ2luZScpLnZlcnNpb247XG4gICAgICAgICAgICB2ZXJzaW9uID0gZGF0YVsxXS5qb2luKCcuJyk7XG4gICAgICAgICAgICBuYW1lID0gJ1JpbmdvSlMnO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0uZ2xvYmFsLnN5c3RlbSA9PSBjb250ZXh0LnN5c3RlbSkge1xuICAgICAgICAgICAgICBuYW1lID0gJ05hcndoYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgY29udGV4dC5wcm9jZXNzID09ICdvYmplY3QnICYmICFjb250ZXh0LnByb2Nlc3MuYnJvd3NlciAmJlxuICAgICAgICAgIChkYXRhID0gY29udGV4dC5wcm9jZXNzKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudmVyc2lvbnMgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS52ZXJzaW9ucy5lbGVjdHJvbiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdOb2RlICcgKyBkYXRhLnZlcnNpb25zLm5vZGUpO1xuICAgICAgICAgICAgICBuYW1lID0gJ0VsZWN0cm9uJztcbiAgICAgICAgICAgICAgdmVyc2lvbiA9IGRhdGEudmVyc2lvbnMuZWxlY3Ryb247XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLnZlcnNpb25zLm53ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ0Nocm9taXVtICcgKyB2ZXJzaW9uLCAnTm9kZSAnICsgZGF0YS52ZXJzaW9ucy5ub2RlKTtcbiAgICAgICAgICAgICAgbmFtZSA9ICdOVy5qcyc7XG4gICAgICAgICAgICAgIHZlcnNpb24gPSBkYXRhLnZlcnNpb25zLm53O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gJ05vZGUuanMnO1xuICAgICAgICAgICAgYXJjaCA9IGRhdGEuYXJjaDtcbiAgICAgICAgICAgIG9zID0gZGF0YS5wbGF0Zm9ybTtcbiAgICAgICAgICAgIHZlcnNpb24gPSAvW1xcZC5dKy8uZXhlYyhkYXRhLnZlcnNpb24pXG4gICAgICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbiA/IHZlcnNpb25bMF0gOiAndW5rbm93bic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJoaW5vKSB7XG4gICAgICAgICAgbmFtZSA9ICdSaGlubyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBBZG9iZSBBSVIuXG4gICAgICBlbHNlIGlmIChnZXRDbGFzc09mKChkYXRhID0gY29udGV4dC5ydW50aW1lKSkgPT0gYWlyUnVudGltZUNsYXNzKSB7XG4gICAgICAgIG5hbWUgPSAnQWRvYmUgQUlSJztcbiAgICAgICAgb3MgPSBkYXRhLmZsYXNoLnN5c3RlbS5DYXBhYmlsaXRpZXMub3M7XG4gICAgICB9XG4gICAgICAvLyBEZXRlY3QgUGhhbnRvbUpTLlxuICAgICAgZWxzZSBpZiAoZ2V0Q2xhc3NPZigoZGF0YSA9IGNvbnRleHQucGhhbnRvbSkpID09IHBoYW50b21DbGFzcykge1xuICAgICAgICBuYW1lID0gJ1BoYW50b21KUyc7XG4gICAgICAgIHZlcnNpb24gPSAoZGF0YSA9IGRhdGEudmVyc2lvbiB8fCBudWxsKSAmJiAoZGF0YS5tYWpvciArICcuJyArIGRhdGEubWlub3IgKyAnLicgKyBkYXRhLnBhdGNoKTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBJRSBjb21wYXRpYmlsaXR5IG1vZGVzLlxuICAgICAgZWxzZSBpZiAodHlwZW9mIGRvYy5kb2N1bWVudE1vZGUgPT0gJ251bWJlcicgJiYgKGRhdGEgPSAvXFxiVHJpZGVudFxcLyhcXGQrKS9pLmV4ZWModWEpKSkge1xuICAgICAgICAvLyBXZSdyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgd2hlbiB0aGUgVHJpZGVudCB2ZXJzaW9uICsgNCBkb2Vzbid0XG4gICAgICAgIC8vIGVxdWFsIHRoZSBkb2N1bWVudCBtb2RlLlxuICAgICAgICB2ZXJzaW9uID0gW3ZlcnNpb24sIGRvYy5kb2N1bWVudE1vZGVdO1xuICAgICAgICBpZiAoKGRhdGEgPSArZGF0YVsxXSArIDQpICE9IHZlcnNpb25bMV0pIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdJRSAnICsgdmVyc2lvblsxXSArICcgbW9kZScpO1xuICAgICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJycpO1xuICAgICAgICAgIHZlcnNpb25bMV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHZlcnNpb24gPSBuYW1lID09ICdJRScgPyBTdHJpbmcodmVyc2lvblsxXS50b0ZpeGVkKDEpKSA6IHZlcnNpb25bMF07XG4gICAgICB9XG4gICAgICAvLyBEZXRlY3QgSUUgMTEgbWFza2luZyBhcyBvdGhlciBicm93c2Vycy5cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2MuZG9jdW1lbnRNb2RlID09ICdudW1iZXInICYmIC9eKD86Q2hyb21lfEZpcmVmb3gpXFxiLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ21hc2tpbmcgYXMgJyArIG5hbWUgKyAnICcgKyB2ZXJzaW9uKTtcbiAgICAgICAgbmFtZSA9ICdJRSc7XG4gICAgICAgIHZlcnNpb24gPSAnMTEuMCc7XG4gICAgICAgIGxheW91dCA9IFsnVHJpZGVudCddO1xuICAgICAgICBvcyA9ICdXaW5kb3dzJztcbiAgICAgIH1cbiAgICAgIG9zID0gb3MgJiYgZm9ybWF0KG9zKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IHByZXJlbGVhc2UgcGhhc2VzLlxuICAgIGlmICh2ZXJzaW9uICYmIChkYXRhID1cbiAgICAgICAgICAvKD86W2FiXXxkcHxwcmV8W2FiXVxcZCtwcmUpKD86XFxkK1xcKz8pPyQvaS5leGVjKHZlcnNpb24pIHx8XG4gICAgICAgICAgLyg/OmFscGhhfGJldGEpKD86ID9cXGQpPy9pLmV4ZWModWEgKyAnOycgKyAodXNlRmVhdHVyZXMgJiYgbmF2LmFwcE1pbm9yVmVyc2lvbikpIHx8XG4gICAgICAgICAgL1xcYk1pbmVmaWVsZFxcYi9pLnRlc3QodWEpICYmICdhJ1xuICAgICAgICApKSB7XG4gICAgICBwcmVyZWxlYXNlID0gL2IvaS50ZXN0KGRhdGEpID8gJ2JldGEnIDogJ2FscGhhJztcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoUmVnRXhwKGRhdGEgKyAnXFxcXCs/JCcpLCAnJykgK1xuICAgICAgICAocHJlcmVsZWFzZSA9PSAnYmV0YScgPyBiZXRhIDogYWxwaGEpICsgKC9cXGQrXFwrPy8uZXhlYyhkYXRhKSB8fCAnJyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBGaXJlZm94IE1vYmlsZS5cbiAgICBpZiAobmFtZSA9PSAnRmVubmVjJyB8fCBuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiKD86QW5kcm9pZHxGaXJlZm94IE9TKVxcYi8udGVzdChvcykpIHtcbiAgICAgIG5hbWUgPSAnRmlyZWZveCBNb2JpbGUnO1xuICAgIH1cbiAgICAvLyBPYnNjdXJlIE1heHRob24ncyB1bnJlbGlhYmxlIHZlcnNpb24uXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnTWF4dGhvbicgJiYgdmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IHZlcnNpb24ucmVwbGFjZSgvXFwuW1xcZC5dKy8sICcueCcpO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgWGJveCAzNjAgYW5kIFhib3ggT25lLlxuICAgIGVsc2UgaWYgKC9cXGJYYm94XFxiL2kudGVzdChwcm9kdWN0KSkge1xuICAgICAgaWYgKHByb2R1Y3QgPT0gJ1hib3ggMzYwJykge1xuICAgICAgICBvcyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocHJvZHVjdCA9PSAnWGJveCAzNjAnICYmIC9cXGJJRU1vYmlsZVxcYi8udGVzdCh1YSkpIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnbW9iaWxlIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIG1vYmlsZSBwb3N0Zml4LlxuICAgIGVsc2UgaWYgKCgvXig/OkNocm9tZXxJRXxPcGVyYSkkLy50ZXN0KG5hbWUpIHx8IG5hbWUgJiYgIXByb2R1Y3QgJiYgIS9Ccm93c2VyfE1vYmkvLnRlc3QobmFtZSkpICYmXG4gICAgICAgIChvcyA9PSAnV2luZG93cyBDRScgfHwgL01vYmkvaS50ZXN0KHVhKSkpIHtcbiAgICAgIG5hbWUgKz0gJyBNb2JpbGUnO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgSUUgcGxhdGZvcm0gcHJldmlldy5cbiAgICBlbHNlIGlmIChuYW1lID09ICdJRScgJiYgdXNlRmVhdHVyZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjb250ZXh0LmV4dGVybmFsID09PSBudWxsKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgncGxhdGZvcm0gcHJldmlldycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZW1iZWRkZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZWN0IEJsYWNrQmVycnkgT1MgdmVyc2lvbi5cbiAgICAvLyBodHRwOi8vZG9jcy5ibGFja2JlcnJ5LmNvbS9lbi9kZXZlbG9wZXJzL2RlbGl2ZXJhYmxlcy8xODE2OS9IVFRQX2hlYWRlcnNfc2VudF9ieV9CQl9Ccm93c2VyXzEyMzQ5MTFfMTEuanNwXG4gICAgZWxzZSBpZiAoKC9cXGJCbGFja0JlcnJ5XFxiLy50ZXN0KHByb2R1Y3QpIHx8IC9cXGJCQjEwXFxiLy50ZXN0KHVhKSkgJiYgKGRhdGEgPVxuICAgICAgICAgIChSZWdFeHAocHJvZHVjdC5yZXBsYWNlKC8gKy9nLCAnIConKSArICcvKFsuXFxcXGRdKyknLCAnaScpLmV4ZWModWEpIHx8IDApWzFdIHx8XG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICApKSB7XG4gICAgICBkYXRhID0gW2RhdGEsIC9CQjEwLy50ZXN0KHVhKV07XG4gICAgICBvcyA9IChkYXRhWzFdID8gKHByb2R1Y3QgPSBudWxsLCBtYW51ZmFjdHVyZXIgPSAnQmxhY2tCZXJyeScpIDogJ0RldmljZSBTb2Z0d2FyZScpICsgJyAnICsgZGF0YVswXTtcbiAgICAgIHZlcnNpb24gPSBudWxsO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgT3BlcmEgaWRlbnRpZnlpbmcvbWFza2luZyBpdHNlbGYgYXMgYW5vdGhlciBicm93c2VyLlxuICAgIC8vIGh0dHA6Ly93d3cub3BlcmEuY29tL3N1cHBvcnQva2Ivdmlldy84NDMvXG4gICAgZWxzZSBpZiAodGhpcyAhPSBmb3JPd24gJiYgcHJvZHVjdCAhPSAnV2lpJyAmJiAoXG4gICAgICAgICAgKHVzZUZlYXR1cmVzICYmIG9wZXJhKSB8fFxuICAgICAgICAgICgvT3BlcmEvLnRlc3QobmFtZSkgJiYgL1xcYig/Ok1TSUV8RmlyZWZveClcXGIvaS50ZXN0KHVhKSkgfHxcbiAgICAgICAgICAobmFtZSA9PSAnRmlyZWZveCcgJiYgL1xcYk9TIFggKD86XFxkK1xcLil7Mix9Ly50ZXN0KG9zKSkgfHxcbiAgICAgICAgICAobmFtZSA9PSAnSUUnICYmIChcbiAgICAgICAgICAgIChvcyAmJiAhL15XaW4vLnRlc3Qob3MpICYmIHZlcnNpb24gPiA1LjUpIHx8XG4gICAgICAgICAgICAvXFxiV2luZG93cyBYUFxcYi8udGVzdChvcykgJiYgdmVyc2lvbiA+IDggfHxcbiAgICAgICAgICAgIHZlcnNpb24gPT0gOCAmJiAhL1xcYlRyaWRlbnRcXGIvLnRlc3QodWEpXG4gICAgICAgICAgKSlcbiAgICAgICAgKSAmJiAhcmVPcGVyYS50ZXN0KChkYXRhID0gcGFyc2UuY2FsbChmb3JPd24sIHVhLnJlcGxhY2UocmVPcGVyYSwgJycpICsgJzsnKSkpICYmIGRhdGEubmFtZSkge1xuICAgICAgLy8gV2hlbiBcImlkZW50aWZ5aW5nXCIsIHRoZSBVQSBjb250YWlucyBib3RoIE9wZXJhIGFuZCB0aGUgb3RoZXIgYnJvd3NlcidzIG5hbWUuXG4gICAgICBkYXRhID0gJ2luZyBhcyAnICsgZGF0YS5uYW1lICsgKChkYXRhID0gZGF0YS52ZXJzaW9uKSA/ICcgJyArIGRhdGEgOiAnJyk7XG4gICAgICBpZiAocmVPcGVyYS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICgvXFxiSUVcXGIvLnRlc3QoZGF0YSkgJiYgb3MgPT0gJ01hYyBPUycpIHtcbiAgICAgICAgICBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9ICdpZGVudGlmeScgKyBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gV2hlbiBcIm1hc2tpbmdcIiwgdGhlIFVBIGNvbnRhaW5zIG9ubHkgdGhlIG90aGVyIGJyb3dzZXIncyBuYW1lLlxuICAgICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSAnbWFzaycgKyBkYXRhO1xuICAgICAgICBpZiAob3BlcmFDbGFzcykge1xuICAgICAgICAgIG5hbWUgPSBmb3JtYXQob3BlcmFDbGFzcy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEgJDInKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9ICdPcGVyYSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9cXGJJRVxcYi8udGVzdChkYXRhKSkge1xuICAgICAgICAgIG9zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVzZUZlYXR1cmVzKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxheW91dCA9IFsnUHJlc3RvJ107XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgV2ViS2l0IE5pZ2h0bHkgYW5kIGFwcHJveGltYXRlIENocm9tZS9TYWZhcmkgdmVyc2lvbnMuXG4gICAgaWYgKChkYXRhID0gKC9cXGJBcHBsZVdlYktpdFxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcbiAgICAgIC8vIENvcnJlY3QgYnVpbGQgbnVtYmVyIGZvciBudW1lcmljIGNvbXBhcmlzb24uXG4gICAgICAvLyAoZS5nLiBcIjUzMi41XCIgYmVjb21lcyBcIjUzMi4wNVwiKVxuICAgICAgZGF0YSA9IFtwYXJzZUZsb2F0KGRhdGEucmVwbGFjZSgvXFwuKFxcZCkkLywgJy4wJDEnKSksIGRhdGFdO1xuICAgICAgLy8gTmlnaHRseSBidWlsZHMgYXJlIHBvc3RmaXhlZCB3aXRoIGEgXCIrXCIuXG4gICAgICBpZiAobmFtZSA9PSAnU2FmYXJpJyAmJiBkYXRhWzFdLnNsaWNlKC0xKSA9PSAnKycpIHtcbiAgICAgICAgbmFtZSA9ICdXZWJLaXQgTmlnaHRseSc7XG4gICAgICAgIHByZXJlbGVhc2UgPSAnYWxwaGEnO1xuICAgICAgICB2ZXJzaW9uID0gZGF0YVsxXS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICAvLyBDbGVhciBpbmNvcnJlY3QgYnJvd3NlciB2ZXJzaW9ucy5cbiAgICAgIGVsc2UgaWYgKHZlcnNpb24gPT0gZGF0YVsxXSB8fFxuICAgICAgICAgIHZlcnNpb24gPT0gKGRhdGFbMl0gPSAoL1xcYlNhZmFyaVxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcbiAgICAgICAgdmVyc2lvbiA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBVc2UgdGhlIGZ1bGwgQ2hyb21lIHZlcnNpb24gd2hlbiBhdmFpbGFibGUuXG4gICAgICBkYXRhWzFdID0gKC9cXGJDaHJvbWVcXC8oW1xcZC5dKykvaS5leGVjKHVhKSB8fCAwKVsxXTtcbiAgICAgIC8vIERldGVjdCBCbGluayBsYXlvdXQgZW5naW5lLlxuICAgICAgaWYgKGRhdGFbMF0gPT0gNTM3LjM2ICYmIGRhdGFbMl0gPT0gNTM3LjM2ICYmIHBhcnNlRmxvYXQoZGF0YVsxXSkgPj0gMjggJiYgbGF5b3V0ID09ICdXZWJLaXQnKSB7XG4gICAgICAgIGxheW91dCA9IFsnQmxpbmsnXTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBKYXZhU2NyaXB0Q29yZS5cbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc2ODQ3NC9ob3ctY2FuLWktZGV0ZWN0LXdoaWNoLWphdmFzY3JpcHQtZW5naW5lLXY4LW9yLWpzYy1pcy11c2VkLWF0LXJ1bnRpbWUtaW4tYW5kcm9pXG4gICAgICBpZiAoIXVzZUZlYXR1cmVzIHx8ICghbGlrZUNocm9tZSAmJiAhZGF0YVsxXSkpIHtcbiAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnbGlrZSBTYWZhcmknKTtcbiAgICAgICAgZGF0YSA9IChkYXRhID0gZGF0YVswXSwgZGF0YSA8IDQwMCA/IDEgOiBkYXRhIDwgNTAwID8gMiA6IGRhdGEgPCA1MjYgPyAzIDogZGF0YSA8IDUzMyA/IDQgOiBkYXRhIDwgNTM0ID8gJzQrJyA6IGRhdGEgPCA1MzUgPyA1IDogZGF0YSA8IDUzNyA/IDYgOiBkYXRhIDwgNTM4ID8gNyA6IGRhdGEgPCA2MDEgPyA4IDogJzgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJ2xpa2UgQ2hyb21lJyk7XG4gICAgICAgIGRhdGEgPSBkYXRhWzFdIHx8IChkYXRhID0gZGF0YVswXSwgZGF0YSA8IDUzMCA/IDEgOiBkYXRhIDwgNTMyID8gMiA6IGRhdGEgPCA1MzIuMDUgPyAzIDogZGF0YSA8IDUzMyA/IDQgOiBkYXRhIDwgNTM0LjAzID8gNSA6IGRhdGEgPCA1MzQuMDcgPyA2IDogZGF0YSA8IDUzNC4xMCA/IDcgOiBkYXRhIDwgNTM0LjEzID8gOCA6IGRhdGEgPCA1MzQuMTYgPyA5IDogZGF0YSA8IDUzNC4yNCA/IDEwIDogZGF0YSA8IDUzNC4zMCA/IDExIDogZGF0YSA8IDUzNS4wMSA/IDEyIDogZGF0YSA8IDUzNS4wMiA/ICcxMysnIDogZGF0YSA8IDUzNS4wNyA/IDE1IDogZGF0YSA8IDUzNS4xMSA/IDE2IDogZGF0YSA8IDUzNS4xOSA/IDE3IDogZGF0YSA8IDUzNi4wNSA/IDE4IDogZGF0YSA8IDUzNi4xMCA/IDE5IDogZGF0YSA8IDUzNy4wMSA/IDIwIDogZGF0YSA8IDUzNy4xMSA/ICcyMSsnIDogZGF0YSA8IDUzNy4xMyA/IDIzIDogZGF0YSA8IDUzNy4xOCA/IDI0IDogZGF0YSA8IDUzNy4yNCA/IDI1IDogZGF0YSA8IDUzNy4zNiA/IDI2IDogbGF5b3V0ICE9ICdCbGluaycgPyAnMjcnIDogJzI4Jyk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHBvc3RmaXggb2YgXCIueFwiIG9yIFwiK1wiIGZvciBhcHByb3hpbWF0ZSB2ZXJzaW9ucy5cbiAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdICs9ICcgJyArIChkYXRhICs9IHR5cGVvZiBkYXRhID09ICdudW1iZXInID8gJy54JyA6IC9bLitdLy50ZXN0KGRhdGEpID8gJycgOiAnKycpKTtcbiAgICAgIC8vIE9ic2N1cmUgdmVyc2lvbiBmb3Igc29tZSBTYWZhcmkgMS0yIHJlbGVhc2VzLlxuICAgICAgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgKCF2ZXJzaW9uIHx8IHBhcnNlSW50KHZlcnNpb24pID4gNDUpKSB7XG4gICAgICAgIHZlcnNpb24gPSBkYXRhO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlY3QgT3BlcmEgZGVza3RvcCBtb2Rlcy5cbiAgICBpZiAobmFtZSA9PSAnT3BlcmEnICYmICAoZGF0YSA9IC9cXGJ6Ym92fHp2YXYkLy5leGVjKG9zKSkpIHtcbiAgICAgIG5hbWUgKz0gJyAnO1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICBpZiAoZGF0YSA9PSAnenZhdicpIHtcbiAgICAgICAgbmFtZSArPSAnTWluaSc7XG4gICAgICAgIHZlcnNpb24gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSArPSAnTW9iaWxlJztcbiAgICAgIH1cbiAgICAgIG9zID0gb3MucmVwbGFjZShSZWdFeHAoJyAqJyArIGRhdGEgKyAnJCcpLCAnJyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBDaHJvbWUgZGVza3RvcCBtb2RlLlxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgL1xcYkNocm9tZVxcYi8uZXhlYyhsYXlvdXQgJiYgbGF5b3V0WzFdKSkge1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICBuYW1lID0gJ0Nocm9tZSBNb2JpbGUnO1xuICAgICAgdmVyc2lvbiA9IG51bGw7XG5cbiAgICAgIGlmICgvXFxiT1MgWFxcYi8udGVzdChvcykpIHtcbiAgICAgICAgbWFudWZhY3R1cmVyID0gJ0FwcGxlJztcbiAgICAgICAgb3MgPSAnaU9TIDQuMysnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTdHJpcCBpbmNvcnJlY3QgT1MgdmVyc2lvbnMuXG4gICAgaWYgKHZlcnNpb24gJiYgdmVyc2lvbi5pbmRleE9mKChkYXRhID0gL1tcXGQuXSskLy5leGVjKG9zKSkpID09IDAgJiZcbiAgICAgICAgdWEuaW5kZXhPZignLycgKyBkYXRhICsgJy0nKSA+IC0xKSB7XG4gICAgICBvcyA9IHRyaW0ob3MucmVwbGFjZShkYXRhLCAnJykpO1xuICAgIH1cbiAgICAvLyBBZGQgbGF5b3V0IGVuZ2luZS5cbiAgICBpZiAobGF5b3V0ICYmICEvXFxiKD86QXZhbnR8Tm9vaylcXGIvLnRlc3QobmFtZSkgJiYgKFxuICAgICAgICAvQnJvd3NlcnxMdW5hc2NhcGV8TWF4dGhvbi8udGVzdChuYW1lKSB8fFxuICAgICAgICBuYW1lICE9ICdTYWZhcmknICYmIC9eaU9TLy50ZXN0KG9zKSAmJiAvXFxiU2FmYXJpXFxiLy50ZXN0KGxheW91dFsxXSkgfHxcbiAgICAgICAgL14oPzpBZG9iZXxBcm9yYXxCcmVhY2h8TWlkb3JpfE9wZXJhfFBoYW50b218UmVrb25xfFJvY2t8U2Ftc3VuZyBJbnRlcm5ldHxTbGVpcG5pcnxXZWIpLy50ZXN0KG5hbWUpICYmIGxheW91dFsxXSkpIHtcbiAgICAgIC8vIERvbid0IGFkZCBsYXlvdXQgZGV0YWlscyB0byBkZXNjcmlwdGlvbiBpZiB0aGV5IGFyZSBmYWxzZXkuXG4gICAgICAoZGF0YSA9IGxheW91dFtsYXlvdXQubGVuZ3RoIC0gMV0pICYmIGRlc2NyaXB0aW9uLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIC8vIENvbWJpbmUgY29udGV4dHVhbCBpbmZvcm1hdGlvbi5cbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IFsnKCcgKyBkZXNjcmlwdGlvbi5qb2luKCc7ICcpICsgJyknXTtcbiAgICB9XG4gICAgLy8gQXBwZW5kIG1hbnVmYWN0dXJlciB0byBkZXNjcmlwdGlvbi5cbiAgICBpZiAobWFudWZhY3R1cmVyICYmIHByb2R1Y3QgJiYgcHJvZHVjdC5pbmRleE9mKG1hbnVmYWN0dXJlcikgPCAwKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKCdvbiAnICsgbWFudWZhY3R1cmVyKTtcbiAgICB9XG4gICAgLy8gQXBwZW5kIHByb2R1Y3QgdG8gZGVzY3JpcHRpb24uXG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goKC9eb24gLy50ZXN0KGRlc2NyaXB0aW9uW2Rlc2NyaXB0aW9uLmxlbmd0aCAtIDFdKSA/ICcnIDogJ29uICcpICsgcHJvZHVjdCk7XG4gICAgfVxuICAgIC8vIFBhcnNlIHRoZSBPUyBpbnRvIGFuIG9iamVjdC5cbiAgICBpZiAob3MpIHtcbiAgICAgIGRhdGEgPSAvIChbXFxkLitdKykkLy5leGVjKG9zKTtcbiAgICAgIGlzU3BlY2lhbENhc2VkT1MgPSBkYXRhICYmIG9zLmNoYXJBdChvcy5sZW5ndGggLSBkYXRhWzBdLmxlbmd0aCAtIDEpID09ICcvJztcbiAgICAgIG9zID0ge1xuICAgICAgICAnYXJjaGl0ZWN0dXJlJzogMzIsXG4gICAgICAgICdmYW1pbHknOiAoZGF0YSAmJiAhaXNTcGVjaWFsQ2FzZWRPUykgPyBvcy5yZXBsYWNlKGRhdGFbMF0sICcnKSA6IG9zLFxuICAgICAgICAndmVyc2lvbic6IGRhdGEgPyBkYXRhWzFdIDogbnVsbCxcbiAgICAgICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZlcnNpb24gPSB0aGlzLnZlcnNpb247XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFtaWx5ICsgKCh2ZXJzaW9uICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/ICcgJyArIHZlcnNpb24gOiAnJykgKyAodGhpcy5hcmNoaXRlY3R1cmUgPT0gNjQgPyAnIDY0LWJpdCcgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEFkZCBicm93c2VyL09TIGFyY2hpdGVjdHVyZS5cbiAgICBpZiAoKGRhdGEgPSAvXFxiKD86QU1EfElBfFdpbnxXT1d8eDg2X3x4KTY0XFxiL2kuZXhlYyhhcmNoKSkgJiYgIS9cXGJpNjg2XFxiL2kudGVzdChhcmNoKSkge1xuICAgICAgaWYgKG9zKSB7XG4gICAgICAgIG9zLmFyY2hpdGVjdHVyZSA9IDY0O1xuICAgICAgICBvcy5mYW1pbHkgPSBvcy5mYW1pbHkucmVwbGFjZShSZWdFeHAoJyAqJyArIGRhdGEpLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgICAgbmFtZSAmJiAoL1xcYldPVzY0XFxiL2kudGVzdCh1YSkgfHxcbiAgICAgICAgICAodXNlRmVhdHVyZXMgJiYgL1xcdyg/Ojg2fDMyKSQvLnRlc3QobmF2LmNwdUNsYXNzIHx8IG5hdi5wbGF0Zm9ybSkgJiYgIS9cXGJXaW42NDsgeDY0XFxiL2kudGVzdCh1YSkpKVxuICAgICAgKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJzMyLWJpdCcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDaHJvbWUgMzkgYW5kIGFib3ZlIG9uIE9TIFggaXMgYWx3YXlzIDY0LWJpdC5cbiAgICBlbHNlIGlmIChcbiAgICAgICAgb3MgJiYgL15PUyBYLy50ZXN0KG9zLmZhbWlseSkgJiZcbiAgICAgICAgbmFtZSA9PSAnQ2hyb21lJyAmJiBwYXJzZUZsb2F0KHZlcnNpb24pID49IDM5XG4gICAgKSB7XG4gICAgICBvcy5hcmNoaXRlY3R1cmUgPSA2NDtcbiAgICB9XG5cbiAgICB1YSB8fCAodWEgPSBudWxsKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBwbGF0Zm9ybSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHZhciBwbGF0Zm9ybSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBsYXRmb3JtIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5kZXNjcmlwdGlvbiA9IHVhO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGJyb3dzZXIncyBsYXlvdXQgZW5naW5lLlxuICAgICAqXG4gICAgICogVGhlIGxpc3Qgb2YgY29tbW9uIGxheW91dCBlbmdpbmVzIGluY2x1ZGU6XG4gICAgICogXCJCbGlua1wiLCBcIkVkZ2VIVE1MXCIsIFwiR2Vja29cIiwgXCJUcmlkZW50XCIgYW5kIFwiV2ViS2l0XCJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0ubGF5b3V0ID0gbGF5b3V0ICYmIGxheW91dFswXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9kdWN0J3MgbWFudWZhY3R1cmVyLlxuICAgICAqXG4gICAgICogVGhlIGxpc3Qgb2YgbWFudWZhY3R1cmVycyBpbmNsdWRlOlxuICAgICAqIFwiQXBwbGVcIiwgXCJBcmNob3NcIiwgXCJBbWF6b25cIiwgXCJBc3VzXCIsIFwiQmFybmVzICYgTm9ibGVcIiwgXCJCbGFja0JlcnJ5XCIsXG4gICAgICogXCJHb29nbGVcIiwgXCJIUFwiLCBcIkhUQ1wiLCBcIkxHXCIsIFwiTWljcm9zb2Z0XCIsIFwiTW90b3JvbGFcIiwgXCJOaW50ZW5kb1wiLFxuICAgICAqIFwiTm9raWFcIiwgXCJTYW1zdW5nXCIgYW5kIFwiU29ueVwiXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLm1hbnVmYWN0dXJlciA9IG1hbnVmYWN0dXJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBicm93c2VyL2Vudmlyb25tZW50LlxuICAgICAqXG4gICAgICogVGhlIGxpc3Qgb2YgY29tbW9uIGJyb3dzZXIgbmFtZXMgaW5jbHVkZTpcbiAgICAgKiBcIkNocm9tZVwiLCBcIkVsZWN0cm9uXCIsIFwiRmlyZWZveFwiLCBcIkZpcmVmb3ggZm9yIGlPU1wiLCBcIklFXCIsXG4gICAgICogXCJNaWNyb3NvZnQgRWRnZVwiLCBcIlBoYW50b21KU1wiLCBcIlNhZmFyaVwiLCBcIlNlYU1vbmtleVwiLCBcIlNpbGtcIixcbiAgICAgKiBcIk9wZXJhIE1pbmlcIiBhbmQgXCJPcGVyYVwiXG4gICAgICpcbiAgICAgKiBNb2JpbGUgdmVyc2lvbnMgb2Ygc29tZSBicm93c2VycyBoYXZlIFwiTW9iaWxlXCIgYXBwZW5kZWQgdG8gdGhlaXIgbmFtZTpcbiAgICAgKiBlZy4gXCJDaHJvbWUgTW9iaWxlXCIsIFwiRmlyZWZveCBNb2JpbGVcIiwgXCJJRSBNb2JpbGVcIiBhbmQgXCJPcGVyYSBNb2JpbGVcIlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbHBoYS9iZXRhIHJlbGVhc2UgaW5kaWNhdG9yLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9kdWN0IGhvc3RpbmcgdGhlIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBjb21tb24gcHJvZHVjdHMgaW5jbHVkZTpcbiAgICAgKlxuICAgICAqIFwiQmxhY2tCZXJyeVwiLCBcIkdhbGF4eSBTNFwiLCBcIkx1bWlhXCIsIFwiaVBhZFwiLCBcImlQb2RcIiwgXCJpUGhvbmVcIiwgXCJLaW5kbGVcIixcbiAgICAgKiBcIktpbmRsZSBGaXJlXCIsIFwiTmV4dXNcIiwgXCJOb29rXCIsIFwiUGxheUJvb2tcIiwgXCJUb3VjaFBhZFwiIGFuZCBcIlRyYW5zZm9ybWVyXCJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0ucHJvZHVjdCA9IHByb2R1Y3Q7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvd3NlcidzIHVzZXIgYWdlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS51YSA9IHVhO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJyb3dzZXIvZW52aXJvbm1lbnQgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0udmVyc2lvbiA9IG5hbWUgJiYgdmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpbmcgc3lzdGVtLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgcGxhdGZvcm0ub3MgPSBvcyB8fCB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIENQVSBhcmNoaXRlY3R1cmUgdGhlIE9TIGlzIGJ1aWx0IGZvci5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcbiAgICAgICAqIEB0eXBlIG51bWJlcnxudWxsXG4gICAgICAgKi9cbiAgICAgICdhcmNoaXRlY3R1cmUnOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmYW1pbHkgb2YgdGhlIE9TLlxuICAgICAgICpcbiAgICAgICAqIENvbW1vbiB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgICAqIFwiV2luZG93c1wiLCBcIldpbmRvd3MgU2VydmVyIDIwMDggUjIgLyA3XCIsIFwiV2luZG93cyBTZXJ2ZXIgMjAwOCAvIFZpc3RhXCIsXG4gICAgICAgKiBcIldpbmRvd3MgWFBcIiwgXCJPUyBYXCIsIFwiVWJ1bnR1XCIsIFwiRGViaWFuXCIsIFwiRmVkb3JhXCIsIFwiUmVkIEhhdFwiLCBcIlN1U0VcIixcbiAgICAgICAqIFwiQW5kcm9pZFwiLCBcImlPU1wiIGFuZCBcIldpbmRvd3MgUGhvbmVcIlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xuICAgICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgICAqL1xuICAgICAgJ2ZhbWlseSc6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHZlcnNpb24gb2YgdGhlIE9TLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xuICAgICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgICAqL1xuICAgICAgJ3ZlcnNpb24nOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIE9TIHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBPUyBzdHJpbmcuXG4gICAgICAgKi9cbiAgICAgICd0b1N0cmluZyc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ251bGwnOyB9XG4gICAgfTtcblxuICAgIHBsYXRmb3JtLnBhcnNlID0gcGFyc2U7XG4gICAgcGxhdGZvcm0udG9TdHJpbmcgPSB0b1N0cmluZ1BsYXRmb3JtO1xuXG4gICAgaWYgKHBsYXRmb3JtLnZlcnNpb24pIHtcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQodmVyc2lvbik7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybS5uYW1lKSB7XG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KG5hbWUpO1xuICAgIH1cbiAgICBpZiAob3MgJiYgbmFtZSAmJiAhKG9zID09IFN0cmluZyhvcykuc3BsaXQoJyAnKVswXSAmJiAob3MgPT0gbmFtZS5zcGxpdCgnICcpWzBdIHx8IHByb2R1Y3QpKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaChwcm9kdWN0ID8gJygnICsgb3MgKyAnKScgOiAnb24gJyArIG9zKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0aW9uLmxlbmd0aCkge1xuICAgICAgcGxhdGZvcm0uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5qb2luKCcgJyk7XG4gICAgfVxuICAgIHJldHVybiBwbGF0Zm9ybTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBwbGF0Zm9ybS5cbiAgdmFyIHBsYXRmb3JtID0gcGFyc2UoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgcGxhdGZvcm0gb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBwbGF0Zm9ybSBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbyBwbGF0Zm9ybSBjYW4gYmUgYWxpYXNlZCB0aHJvdWdoIHBhdGggbWFwcGluZy5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGxhdGZvcm07XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdC5cbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmb3JPd24ocGxhdGZvcm0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGZyZWVFeHBvcnRzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qIVxuKiBzY3JlZW5mdWxsXG4qIHYzLjMuMyAtIDIwMTgtMDktMDRcbiogKGMpIFNpbmRyZSBTb3JodXM7IE1JVCBMaWNlbnNlXG4qL1xuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBkb2N1bWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRvY3VtZW50IDoge307XG5cdHZhciBpc0NvbW1vbmpzID0gdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHM7XG5cdHZhciBrZXlib2FyZEFsbG93ZWQgPSB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ0FMTE9XX0tFWUJPQVJEX0lOUFVUJyBpbiBFbGVtZW50O1xuXG5cdHZhciBmbiA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbDtcblxuXHRcdHZhciBmbk1hcCA9IFtcblx0XHRcdFtcblx0XHRcdFx0J3JlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0J2V4aXRGdWxsc2NyZWVuJyxcblx0XHRcdFx0J2Z1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J2Z1bGxzY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J2Z1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnZnVsbHNjcmVlbmVycm9yJ1xuXHRcdFx0XSxcblx0XHRcdC8vIE5ldyBXZWJLaXRcblx0XHRcdFtcblx0XHRcdFx0J3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdEV4aXRGdWxsc2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J3dlYmtpdEZ1bGxzY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuXG5cdFx0XHRdLFxuXHRcdFx0Ly8gT2xkIFdlYktpdCAoU2FmYXJpIDUuMSlcblx0XHRcdFtcblx0XHRcdFx0J3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsXG5cdFx0XHRcdCd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG5cblx0XHRcdF0sXG5cdFx0XHRbXG5cdFx0XHRcdCdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXG5cdFx0XHRcdCdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcblx0XHRcdFx0J21vekZ1bGxTY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J21vekZ1bGxTY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J21vemZ1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnbW96ZnVsbHNjcmVlbmVycm9yJ1xuXHRcdFx0XSxcblx0XHRcdFtcblx0XHRcdFx0J21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnbXNFeGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdCdtc0Z1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuXHRcdFx0XHQnTVNGdWxsc2NyZWVuQ2hhbmdlJyxcblx0XHRcdFx0J01TRnVsbHNjcmVlbkVycm9yJ1xuXHRcdFx0XVxuXHRcdF07XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGwgPSBmbk1hcC5sZW5ndGg7XG5cdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhbCA9IGZuTWFwW2ldO1xuXHRcdFx0aWYgKHZhbCAmJiB2YWxbMV0gaW4gZG9jdW1lbnQpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHJldFtmbk1hcFswXVtpXV0gPSB2YWxbaV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pKCk7XG5cblx0dmFyIGV2ZW50TmFtZU1hcCA9IHtcblx0XHRjaGFuZ2U6IGZuLmZ1bGxzY3JlZW5jaGFuZ2UsXG5cdFx0ZXJyb3I6IGZuLmZ1bGxzY3JlZW5lcnJvclxuXHR9O1xuXG5cdHZhciBzY3JlZW5mdWxsID0ge1xuXHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0XHR2YXIgcmVxdWVzdCA9IGZuLnJlcXVlc3RGdWxsc2NyZWVuO1xuXG5cdFx0XHRlbGVtID0gZWxlbSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdC8vIFdvcmsgYXJvdW5kIFNhZmFyaSA1LjEgYnVnOiByZXBvcnRzIHN1cHBvcnQgZm9yXG5cdFx0XHQvLyBrZXlib2FyZCBpbiBmdWxsc2NyZWVuIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3QuXG5cdFx0XHQvLyBCcm93c2VyIHNuaWZmaW5nLCBzaW5jZSB0aGUgYWx0ZXJuYXRpdmUgd2l0aFxuXHRcdFx0Ly8gc2V0VGltZW91dCBpcyBldmVuIHdvcnNlLlxuXHRcdFx0aWYgKC8gVmVyc2lvblxcLzVcXC4xKD86XFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHRcdFx0XHRlbGVtW3JlcXVlc3RdKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtW3JlcXVlc3RdKGtleWJvYXJkQWxsb3dlZCA/IEVsZW1lbnQuQUxMT1dfS0VZQk9BUkRfSU5QVVQgOiB7fSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleGl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRkb2N1bWVudFtmbi5leGl0RnVsbHNjcmVlbl0oKTtcblx0XHR9LFxuXHRcdHRvZ2dsZTogZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdGlmICh0aGlzLmlzRnVsbHNjcmVlbikge1xuXHRcdFx0XHR0aGlzLmV4aXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVxdWVzdChlbGVtKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uY2hhbmdlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMub24oJ2NoYW5nZScsIGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdG9uZXJyb3I6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRvbjogZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGV2ZW50TmFtZU1hcFtldmVudF07XG5cdFx0XHRpZiAoZXZlbnROYW1lKSB7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gZXZlbnROYW1lTWFwW2V2ZW50XTtcblx0XHRcdGlmIChldmVudE5hbWUpIHtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyYXc6IGZuXG5cdH07XG5cblx0aWYgKCFmbikge1xuXHRcdGlmIChpc0NvbW1vbmpzKSB7XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2NyZWVuZnVsbCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjcmVlbmZ1bGwsIHtcblx0XHRpc0Z1bGxzY3JlZW46IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gQm9vbGVhbihkb2N1bWVudFtmbi5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZWxlbWVudDoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnRbZm4uZnVsbHNjcmVlbkVsZW1lbnRdO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZW5hYmxlZDoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBDb2VyY2UgdG8gYm9vbGVhbiBpbiBjYXNlIG9mIG9sZCBXZWJLaXRcblx0XHRcdFx0cmV0dXJuIEJvb2xlYW4oZG9jdW1lbnRbZm4uZnVsbHNjcmVlbkVuYWJsZWRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGlmIChpc0NvbW1vbmpzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBzY3JlZW5mdWxsO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5zY3JlZW5mdWxsID0gc2NyZWVuZnVsbDtcblx0fVxufSkoKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwICh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG4gIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkLnF1ZXJ5O1xuICB9XG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgsIG9wdHMpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlciAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdmFyIF9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbnNwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKG5zcCkge1xuICByZXR1cm4gKG5zcCA9PT0gJy8nID8gJycgOiAobnNwICsgJyMnKSkgKyB0aGlzLmVuZ2luZS5pZDtcbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmZsYWdzID0ge307XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiAodGhpcy5mbGFncy5iaW5hcnkgIT09IHVuZGVmaW5lZCA/IHRoaXMuZmxhZ3MuYmluYXJ5IDogaGFzQmluKGFyZ3MpKSA/IHBhcnNlci5CSU5BUllfRVZFTlQgOiBwYXJzZXIuRVZFTlQsXG4gICAgZGF0YTogYXJnc1xuICB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgdGhpcy5mbGFncyA9IHt9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeSA9IHR5cGVvZiB0aGlzLnF1ZXJ5ID09PSAnb2JqZWN0JyA/IHBhcnNlcXMuZW5jb2RlKHRoaXMucXVlcnkpIDogdGhpcy5xdWVyeTtcbiAgICAgIGRlYnVnKCdzZW5kaW5nIGNvbm5lY3QgcGFja2V0IHdpdGggcXVlcnkgJXMnLCBxdWVyeSk7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBwYWNrZXQubnNwID09PSB0aGlzLm5zcDtcbiAgdmFyIHJvb3ROYW1lc3BhY2VFcnJvciA9IHBhY2tldC50eXBlID09PSBwYXJzZXIuRVJST1IgJiYgcGFja2V0Lm5zcCA9PT0gJy8nO1xuXG4gIGlmICghc2FtZU5hbWVzcGFjZSAmJiAhcm9vdE5hbWVzcGFjZUVycm9yKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYmluYXJ5IGZsYWdcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIGVtaXR0ZWQgZGF0YSBjb250YWlucyBiaW5hcnlcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcbiAgdGhpcy5mbGFncy5iaW5hcnkgPSBiaW5hcnk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uKTtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nKTtcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXScpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG52YXIgRVJST1JfUEFDS0VUID0gZXhwb3J0cy5FUlJPUiArICdcImVuY29kZSBlcnJvclwiJztcblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVN0cmluZ2lmeShvYmouZGF0YSk7XG4gICAgaWYgKHBheWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICBzdHIgKz0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG4gICAgcmV0dXJuIGVycm9yKCd1bmtub3duIHBhY2tldCB0eXBlICcgKyBwLnR5cGUpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuICAgIGlmIChpc1BheWxvYWRWYWxpZCkge1xuICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVycm9yKCdpbnZhbGlkIHBheWxvYWQnKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcjogJyArIG1zZ1xuICB9O1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG52YXIgd2l0aE5hdGl2ZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbnZhciB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgOiAob2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuICh3aXRoTmF0aXZlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSk7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiaW1wb3J0IFByb2Nlc3MgZnJvbSAnLi9Qcm9jZXNzJztcbmltcG9ydCBTaWduYWwgZnJvbSAnLi4vLi4vdXRpbHMvU2lnbmFsJztcbmltcG9ydCBTaWduYWxBbGwgZnJvbSAnLi4vLi4vdXRpbHMvU2lnbmFsQWxsJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi9zb2NrZXQnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi4vdmlld3MvVmlldyc7XG5pbXBvcnQgdmlld01hbmFnZXIgZnJvbSAnLi92aWV3TWFuYWdlcic7XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBiYXNlIGNsYXNzIGZvciBzZXJ2aWNlcyBhbmQgc2NlbmVzLiBCYXNpY2FsbHkgYSBwcm9jZXNzIHdpdGggdmlld1xuICogYW5kIG9wdGlvbm5hbCBuZXR3b3JrIGFiaWxpdGllcy5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXh0ZW5kcyBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUHJvY2Vzc1xuICovXG5jbGFzcyBBY3Rpdml0eSBleHRlbmRzIFByb2Nlc3Mge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gSWQgb2YgdGhlIGFjdGl2aXR5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc05ldHdvcmsgLSBEZWZpbmUgaWYgdGhlIGFjdGl2aXR5IG5lZWRzIGEgc29ja2V0XG4gICAqICBjb25uZWN0aW9uIG9yIG5vdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlkLCBoYXNOZXR3b3JrID0gdHJ1ZSkge1xuICAgIHN1cGVyKGlkKTtcblxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgZGVmaW5lcyBpZiB0aGUgYWN0aXZpdHkgaGFzIGFscmVhZHkgc3RhcnRlZCBvbmNlLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBuYW1lIGhhc1N0YXJ0ZWRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFjdGl2aXR5XG4gICAgICovXG4gICAgdGhpcy5oYXNTdGFydGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSBhY3Rpdml0eSBuZWVkcyBhIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAbmFtZSBoYXNOZXR3b3JrXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BY3Rpdml0eVxuICAgICAqL1xuICAgIHRoaXMuaGFzTmV0d29yayA9ICEhaGFzTmV0d29yaztcblxuICAgIC8vIHJlZ2lzdGVyIGFzIGEgbmV0d29ya2VkIHNlcnZpY2UsIHNldHVwIHRoZSBzb2NrZXQgY29ubmVjdGlvblxuICAgIGlmICh0aGlzLmhhc05ldHdvcmspXG4gICAgICBzb2NrZXQucmVxdWlyZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBvZiB0aGUgYWN0aXZpdHkuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbmFtZSBvcHRpb25zXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BY3Rpdml0eVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHsgdmlld1ByaW9yaXR5OiAwIH07XG5cbiAgICAvKipcbiAgICAgKiBWaWV3IG9mIHRoZSBhY3Rpdml0eS5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXd9XG4gICAgICogQG5hbWUgdmlld1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQWN0aXZpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZpZXcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHdoaWNoIHNpZ25hbCB0aGUgYEFjdGl2aXR5YCByZXF1aXJlcyB0byBzdGFydC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVxdWlyZWRTaWduYWxzID0gbmV3IFNpZ25hbEFsbCgpO1xuXG4gICAgdGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZW5kVm9sYXRpbGUgPSB0aGlzLnNlbmRWb2xhdGlsZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVjZWl2ZSA9IHRoaXMucmVjZWl2ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSB0aGlzLnJlbW92ZUxpc3RlbmVyLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBpbXBsZW1lbnQgaW4gY2hpbGQgY2xhc3Nlcy5cbiAgICogRGVmaW5lIHdoYXQgdG8gZG8gd2hlbiBhIHNlcnZpY2UgaXMgcmVxdWlyZWQgYnkgYW4gYEFjdGl2aXR5YC5cbiAgICovXG4gIHJlcXVpcmUoKSB7fVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzaWduYWwgdG8gdGhlIHJlcXVpcmVkIHNpZ25hbHMgaW4gb3JkZXIgZm9yIHRoZSBgU2NlbmVgIGluc3RhbmNlXG4gICAqIHRvIHN0YXJ0LlxuICAgKiBAcGFyYW0ge1NpZ25hbH0gc2lnbmFsIC0gVGhlIHNpZ25hbCB0aGF0IG11c3QgYmUgd2FpdGVkIGZvci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHdhaXRGb3Ioc2lnbmFsKSB7XG4gICAgdGhpcy5yZXF1aXJlZFNpZ25hbHMuYWRkKHNpZ25hbCk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBhY3Rpdml0eSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2aWV3IG9mIHNlcnZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3IC0gYW55IG9iamVjdCBjb21wbGlhbnQgd2l0aCB0aGUgdmlldyBpbnRlcmZhY2UuXG4gICAqL1xuICBzZXQgdmlldyh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXc7XG4gIH1cblxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRoZSB2aWV3IG1hbmFnZXIgdG8gZGlzcGxheSB0aGUgdmlldy4gVGhlIGNhbGwgb2YgdGhpcyBtZXRob2RcbiAgICogZG9lc24ndCBndWFyYW50ZWUgYSBzeW5jaHJvbml6ZWQgcmVuZGVyaW5nIG9yIGFueSByZW5kZXJpbmcgYXQgYWxsIGFzIHRoZVxuICAgKiB2aWV3IG1hbmFnZXIgZGVjaWRlcyB3aGljaCB2aWV3IHRvIGRpc3BsYXkgYmFzZWQgb24gdGhlaXIgcHJpb3JpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdmlldyBpcyBhY3R1YWxseVxuICAgKiAgZGlzcGxheWVkIGluIHRoZSBhcHBsaWNhdGlvbi5cbiAgICovXG4gIHNob3coKSB7XG4gICAgcmV0dXJuIHZpZXdNYW5hZ2VyLnJlZ2lzdGVyKHRoaXMuX3ZpZXcsIHRoaXMub3B0aW9ucy52aWV3UHJpb3JpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHZpZXcgb2YgdGhlIGFjdGl2aXR5IGlmIGl0IG93bnMgb25lLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB2aWV3TWFuYWdlci5yZW1vdmUodGhpcy5fdmlldyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHdlYiBzb2NrZXQgbWVzc2FnZSB0byB0aGUgc2VydmVyIG9uIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWwgLSBUaGUgY2hhbm5lbCBvZiB0aGUgbWVzc2FnZSAoaXMgYXV0b21hdGljYWxseVxuICAgKiAgbmFtZXNwYWNlZCB3aXRoIHRoZSBhY3Rpdml0eSdzIGlkOiBgJHt0aGlzLmlkfTpjaGFubmVsYCkuXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyAtIEFyZ3VtZW50cyBvZiB0aGUgbWVzc2FnZSAoYXMgbWFueSBhcyBuZWVkZWQsIG9mIGFueSB0eXBlKS5cbiAgICovXG4gIHNlbmQoY2hhbm5lbCwgLi4uYXJncykge1xuICAgIHNvY2tldC5zZW5kKGAke3RoaXMuaWR9OiR7Y2hhbm5lbH1gLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgd2ViIHNvY2tldCBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXIgb24gYSBnaXZlbiBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIFRoZSBjaGFubmVsIG9mIHRoZSBtZXNzYWdlIChpcyBhdXRvbWF0aWNhbGx5XG4gICAqICBuYW1lc3BhY2VkIHdpdGggdGhlIGFjdGl2aXR5J3MgaWQ6IGAke3RoaXMuaWR9OmNoYW5uZWxgKS5cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gQXJndW1lbnRzIG9mIHRoZSBtZXNzYWdlIChhcyBtYW55IGFzIG5lZWRlZCwgb2YgYW55IHR5cGUpLlxuICAgKi9cbiAgc2VuZFZvbGF0aWxlKGNoYW5uZWwsIC4uLmFyZ3MpIHtcbiAgICBzb2NrZXQuc2VuZFZvbGF0aWxlKGAke3RoaXMuaWR9OiR7Y2hhbm5lbH1gLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gd2ViIHNvY2tldCBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIgb24gYSBnaXZlbiBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIFRoZSBjaGFubmVsIG9mIHRoZSBtZXNzYWdlIChpcyBhdXRvbWF0aWNhbGx5XG4gICAqICBuYW1lc3BhY2VkIHdpdGggdGhlIGFjdGl2aXR5J3MgaWQ6IGAke3RoaXMuaWR9OmNoYW5uZWxgKS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICovXG4gIHJlY2VpdmUoY2hhbm5lbCwgY2FsbGJhY2spIHtcbiAgICBzb2NrZXQucmVjZWl2ZShgJHt0aGlzLmlkfToke2NoYW5uZWx9YCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIGZvciBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIgb24gYSBnaXZlbiBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIFRoZSBjaGFubmVsIG9mIHRoZSBtZXNzYWdlIChpcyBhdXRvbWF0aWNhbGx5XG4gICAqICBuYW1lc3BhY2VkIHdpdGggdGhlIGFjdGl2aXR5J3MgaWQ6IGAke3RoaXMuaWR9OmNoYW5uZWxgKS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gcmVtb3ZlIGZyb20gdGhlIHN0YWNrLlxuICAgKi9cbiAgc3RvcFJlY2VpdmluZyhjaGFubmVsLCBjYWxsYmFjaykge1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcihgJHt0aGlzLmlkfToke2NoYW5uZWx9YCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFjdGl2aXR5O1xuIiwiaW1wb3J0IEFjdGl2aXR5IGZyb20gJy4vQWN0aXZpdHknO1xuaW1wb3J0IHNlcnZpY2VNYW5hZ2VyIGZyb20gJy4vc2VydmljZU1hbmFnZXInO1xuXG5cbi8qKlxuICogQmFzZSBjbGFzcyB0byBiZSBleHRlbmRlZCBpbiBvcmRlciB0byBjcmVhdGUgdGhlIGNsaWVudC1zaWRlIG9mIGEgY3VzdG9tXG4gKiBleHBlcmllbmNlLlxuICpcbiAqIFRoZSB1c2VyIGRlZmluZWQgYEV4cGVyaWVuY2VgIGlzIHRoZSBtYWluIGNvbXBvbmVudCBvZiBhIHNvdW5kd29ya3MgYXBwbGljYXRpb24uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICogQGV4dGVuZHMgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFjdGl2aXR5XG4gKi9cbmNsYXNzIEV4cGVyaWVuY2UgZXh0ZW5kcyBBY3Rpdml0eSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtoYXNOZXR3b3JrPXRydWVdIC0gRGVmaW5lIGlmIHRoZSBleHBlcmllbmNlIHJlcXVpcmVzIGFcbiAgICogIHNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaGFzTmV0d29yayA9IHRydWUpIHtcbiAgICBzdXBlcignZXhwZXJpZW5jZScsIGhhc05ldHdvcmspO1xuXG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMucmVxdWlyZWRTaWduYWxzLmFkZE9ic2VydmVyKHRoaXMuc3RhcnQpO1xuICAgIHRoaXMud2FpdEZvcihzZXJ2aWNlTWFuYWdlci5zaWduYWxzLnJlYWR5KTtcblxuICAgIC8vIGlmIHRoZSBleHBlcmllbmNlIGhhcyBuZXR3b3JrLCByZXF1aXJlIGVycm9yUmVwb3J0ZXIgc2VydmljZSBieSBkZWZhdWx0XG4gICAgaWYgKGhhc05ldHdvcmspXG4gICAgICB0aGlzLl9lcnJvclJlcG9ydGVyID0gdGhpcy5yZXF1aXJlKCdlcnJvci1yZXBvcnRlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXJ2aWNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHNlcnZpY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBzZXJ2aWNlLlxuICAgKi9cbiAgcmVxdWlyZShpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBzZXJ2aWNlTWFuYWdlci5yZXF1aXJlKGlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgZXhwZXJpZW5jZS4gVGhpcyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGFsbCB0aGVcbiAgICogcmVxdWlyZWQgc2VydmljZXMgYXJlIGByZWFkeWAgYW5kIHRodXMgdGhlIGV4cGVyaWVuY2UgY2FuIGJlZ2luIHdpdGggYWxsXG4gICAqIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb25zIGFuZCBzZXJ2aWNlcyByZWFkeSB0byBiZSBjb25zdW1lZC5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG5cbiAgICBpZiAodGhpcy5oYXNOZXR3b3JrKVxuICAgICAgdGhpcy5zZW5kKCdlbnRlcicpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIC8vIGRvbmUoKSB7XG4gIC8vICAgaWYgKHRoaXMuaGFzTmV0d29yaylcbiAgLy8gICAgIHRoaXMuc2VuZCgnZXhpdCcpO1xuXG4gIC8vICAgc3VwZXIuZG9uZSgpO1xuICAvLyB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4cGVyaWVuY2U7XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uLy4uL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgU2lnbmFsIGZyb20gJy4uLy4uL3V0aWxzL1NpZ25hbCc7XG5cbi8qKlxuICogQSBwcm9jZXNzIGRlZmluZXMgdGhlIHNpbXBsaWVzdCB1bml0IG9mIHRoZSBmcmFtZXdvcmsuXG4gKiBJdCBpcyBkZWZpbmVkIGJ5IGEgc2lnbmFsIGBhY3RpdmVgIGFuZCAyIG1ldGhvZHM6IGBzdGFydGAgYW5kIGBzdG9wYC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKi9cbmNsYXNzIFByb2Nlc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAoaWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGlkIGZvciBwcm9jZXNzICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgcHJvY2Vzcy5cbiAgICAgKiBAbmFtZSBpZFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGluc3RhbmNlb2YgUHJvY2Vzc1xuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgZGVmaW5pbmcgdGhlIHByb2Nlc3Mgc3RhdGUuXG4gICAgICogQG5hbWUgc2lnbmFsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAaW5zdGFuY2VvZiBQcm9jZXNzXG4gICAgICovXG4gICAgdGhpcy5zaWduYWxzID0ge307XG4gICAgdGhpcy5zaWduYWxzLmFjdGl2ZSA9IG5ldyBTaWduYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgcHJvY2Vzcy5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc2lnbmFscy5hY3RpdmUuc2V0KHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHByb2Nlc3MuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuc2lnbmFscy5hY3RpdmUuc2V0KGZhbHNlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9jZXNzO1xuIiwiaW1wb3J0IEFjdGl2aXR5IGZyb20gJy4vQWN0aXZpdHknO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuL3NlcnZpY2VNYW5hZ2VyJztcbmltcG9ydCBTaWduYWwgZnJvbSAnLi4vLi4vdXRpbHMvU2lnbmFsJztcblxuY29uc3QgbG9nID0gZGVidWcoJ3NvdW5kd29ya3M6c2VydmljZXMnKTtcblxuXG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gYmUgZXh0ZW5kZWQgaW4gb3JkZXIgdG8gY3JlYXRlIGEgbmV3IHNlcnZpY2UuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICogQGV4dGVuZHMgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFjdGl2aXR5XG4gKi9cbmNsYXNzIFNlcnZpY2UgZXh0ZW5kcyBBY3Rpdml0eSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIHNlcnZpY2UgKHNob3VsZCBiZSBwcmVmaXhlZCB3aXRoIGAnc2VydmljZTonYCkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzTmV0d29yayAtIERlZmluZSBpZiB0aGUgc2VydmljZSBuZWVkcyBhbiBhY2Nlc3MgdG8gdGhlIHNvY2tldFxuICAgKiAgY29ubmVjdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlkLCBoYXNOZXR3b3JrKSB7XG4gICAgc3VwZXIoaWQsIGhhc05ldHdvcmspO1xuXG4gICAgdGhpcy5yZXF1aXJlZFNpZ25hbHMuYWRkT2JzZXJ2ZXIoKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB0aGlzLmhhc1N0YXJ0ZWQgPSB0cnVlOyAvLyBrZWVwIHRoaXMgZm9yIE9yYmUvTm9kYWwgY29tcGF0aWJpbGl0eVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJcyBzZXQgdG8gYHRydWVgIHdoZW4gYSBzaWduYWwgaXMgcmVhZHkgdG8gYmUgY29uc3VtZWQuXG4gICAgICogQHR5cGUge1NpZ25hbH1cbiAgICAgKi9cbiAgICB0aGlzLnNpZ25hbHMucmVhZHkgPSBuZXcgU2lnbmFsKCk7XG4gICAgLy8gYWRkIHRoZSBzZXJ2aWNlTWFuYWdlciBib290c3RhcnQgc2lnbmFsIHRvIHRoZSByZXF1aXJlZCBzaWduYWxzXG4gICAgdGhpcy53YWl0Rm9yKHNlcnZpY2VNYW5hZ2VyLnNpZ25hbHMuc3RhcnQpO1xuXG4gICAgdGhpcy5yZWFkeSA9IHRoaXMucmVhZHkuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyB0byByZXF1aXJlIGFub3RoZXIgc2VydmljZSBhcyBhIGRlcGVuZGVuY2llcy4gV2hlbiBhIHNlcnZpY2UgaXNcbiAgICogZGVwZW5kZW50IGZyb20gYW5vdGhlciBzZXJ2aWNlIGl0cyBgc3RhcnRgIG1ldGhvZCBpcyBkZWxheWVkIHVudGlsIGFsbFxuICAgKiBpdHMgZGVwZW5kZW5jaWVzIGFyZSB0aGVtc2VsdmVzIGByZWFkeWAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIGlkIG9mIHRoZSBzZXJ2aWNlIHRvIHJlcXVpcmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBzZXJ2aWNlLlxuICAgKi9cbiAgcmVxdWlyZShpZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBzZXJ2aWNlTWFuYWdlci5yZXF1aXJlKGlkLCBvcHRpb25zKTtcbiAgICBjb25zdCBzaWduYWwgPSBzZXJ2aWNlLnNpZ25hbHMucmVhZHk7XG5cbiAgICBpZiAoc2lnbmFsKVxuICAgICAgdGhpcy53YWl0Rm9yKHNpZ25hbCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYWwgXCJjb250aW51ZVwiIGRvZXNuJ3QgZXhpc3Qgb24gc2VydmljZSA6YCwgc2VydmljZSk7XG5cbiAgICByZXR1cm4gc2VydmljZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gY2FsbCBpbiB0aGUgc2VydmljZSBsaWZlY3ljbGUgd2hlbiBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhc1xuICAgKiBgcmVhZHlgIGFuZCB0aHVzIGFsbG93cyBhbGwgaXRzIGRlcGVuZGVudCBhY3Rpdml0aWVzIHRvIHN0YXJ0IHRoZW1zZWx2ZXMuXG4gICAqL1xuICByZWFkeSgpIHtcbiAgICBsb2coYFwiJHt0aGlzLmlkfVwiIHJlYWR5YCk7XG5cbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLnNpZ25hbHMucmVhZHkuc2V0KHRydWUpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHN0YXJ0KCkge1xuICAgIGxvZyhgXCIke3RoaXMuaWR9XCIgc3RhcnRlZGApO1xuICAgIHN1cGVyLnN0YXJ0KCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc3RvcCgpIHtcbiAgICBsb2coYFwiJHt0aGlzLmlkfVwiIHN0b3BwZWRgKTtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VydmljZTtcblxuIiwiaW1wb3J0IHNlcnZpY2VNYW5hZ2VyIGZyb20gJy4vc2VydmljZU1hbmFnZXInO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuL3NvY2tldCc7XG5pbXBvcnQgdmlld01hbmFnZXIgZnJvbSAnLi92aWV3TWFuYWdlcic7XG5pbXBvcnQgdmlld3BvcnQgZnJvbSAnLi4vdmlld3Mvdmlld3BvcnQnO1xuXG4vKipcbiAqIENsaWVudCBzaWRlIGVudHJ5IHBvaW50IGZvciBhIGBzb3VuZHdvcmtzYCBhcHBsaWNhdGlvbi5cbiAqXG4gKiBUaGlzIG9iamVjdCBob3N0cyBnZW5lcmFsIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgdXNlciwgYXMgd2VsbCBhcyBtZXRob2RzXG4gKiB0byBpbml0aWFsaXplIGFuZCBzdGFydCB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICogQG5hbWVzcGFjZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBzb3VuZHdvcmtzIGZyb20gJ3NvdW5kd29ya3MvY2xpZW50JztcbiAqIGltcG9ydCBNeUV4cGVyaWVuY2UgZnJvbSAnLi9NeUV4cGVyaWVuY2UnO1xuICpcbiAqIHNvdW5kd29ya3MuY2xpZW50LmluaXQoJ3BsYXllcicpO1xuICogY29uc3QgbXlFeHBlcmllbmNlID0gbmV3IE15RXhwZXJpZW5jZSgpO1xuICogc291bmR3b3Jrcy5jbGllbnQuc3RhcnQoKTtcbiAqL1xuY29uc3QgY2xpZW50ID0ge1xuICAvKipcbiAgICogVW5pcXVlIGlkIG9mIHRoZSBjbGllbnQsIGdlbmVyYXRlZCBhbmQgcmV0cmlldmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB1dWlkOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgY2xpZW50LCB0aGlzIGNhbiBnZW5lcmFsbHkgYmUgY29uc2lkZXJlZCBhcyB0aGUgcm9sZSBvZiB0aGVcbiAgICogY2xpZW50IGluIHRoZSBhcHBsaWNhdGlvbi4gVGhpcyB2YWx1ZSBpcyBkZWZpbmVkIGluIHRoZVxuICAgKiBbYGNsaWVudC5pbml0YF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3Mvc2VydmVyLnNlcnZlcn5zZXJ2ZXJDb25maWd9IG9iamVjdFxuICAgKiBhbmQgZGVmYXVsdHMgdG8gYCdwbGF5ZXInYC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHR5cGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25zIGZyb20gdGhlIHNlcnZlciBjb25maWd1cmF0aW9uIGlmIGFueS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LmNsaWVudH5pbml0fVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuU2hhcmVkQ29uZmlnfVxuICAgKi9cbiAgY29uZmlnOiB7fSxcblxuICAvKipcbiAgICogQXJyYXkgb2Ygb3B0aW9ubmFsIHBhcmFtZXRlcnMgcGFzc2VkIHRocm91Z2ggdGhlIHVybFxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB1cmxQYXJhbXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnQgcGxhdGZvcm0uIFRoZSBwcm9wZXJ0aWVzIGFyZSBzZXQgYnkgdGhlXG4gICAqIFtgcGxhdGZvcm1gXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhdGZvcm19IHNlcnZpY2UuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBvcyAtIE9wZXJhdGluZyBzeXN0ZW0uXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNNb2JpbGUgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2xpZW50IGlzIHJ1bm5pbmcgb24gYVxuICAgKiAgbW9iaWxlIHBsYXRmb3JtIG9yIG5vdC5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGF1ZGlvRmlsZUV4dCAtIEF1ZGlvIGZpbGUgZXh0ZW5zaW9uIHRvIHVzZSwgZGVwZW5kaW5nIG9uXG4gICAqICB0aGUgcGxhdGZvcm0uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpbnRlcmFjdGlvbiAtIFR5cGUgb2YgaW50ZXJhY3Rpb24gYWxsb3dlZCBieSB0aGVcbiAgICogIHZpZXdwb3J0LCBgdG91Y2hgIG9yIGBtb3VzZWBcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlBsYXRmb3JtfVxuICAgKi9cbiAgcGxhdGZvcm06IHtcbiAgICBvczogbnVsbCxcbiAgICBpc01vYmlsZTogbnVsbCxcbiAgICBhdWRpb0ZpbGVFeHQ6ICcnLFxuICAgIGludGVyYWN0aW9uOiBudWxsLFxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhlIHVzZXIncyBkZXZpY2UgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBhcHBsaWNhdGlvblxuICAgKiByZXF1aXJlbWVudHMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhdGZvcm19XG4gICAqL1xuICBjb21wYXRpYmxlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbmRleCAoaWYgYW55KSBnaXZlbiBieSBhIFtgcGxhY2VyYF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlBsYWNlcn1cbiAgICogb3IgW2BjaGVja2luYF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkNoZWNraW59IHNlcnZpY2UuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5DaGVja2lufVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhY2VyfVxuICAgKi9cbiAgaW5kZXg6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRpY2tldCBsYWJlbCAoaWYgYW55KSBnaXZlbiBieSBhIFtgcGxhY2VyYF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlBsYWNlcn1cbiAgICogb3IgW2BjaGVja2luYF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkNoZWNraW59IHNlcnZpY2UuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5DaGVja2lufVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhY2VyfVxuICAgKi9cbiAgbGFiZWw6IG51bGwsXG5cbiAgLyoqXG4gICAqIENsaWVudCBjb29yZGluYXRlcyAoaWYgYW55KSBnaXZlbiBieSBhXG4gICAqIFtgbG9jYXRvcmBde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5Mb2NhdG9yfSxcbiAgICogW2BwbGFjZXJgXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhY2VyfSBvclxuICAgKiBbYGNoZWNraW5gXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2hlY2tpbn0gc2VydmljZS5cbiAgICogKEZvcm1hdDogYFt4Ok51bWJlciwgeTpOdW1iZXJdYC4pXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxOdW1iZXI+fVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2hlY2tpbn1cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkxvY2F0b3J9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5QbGFjZXJ9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5HZW9sb2NhdGlvbn1cbiAgICovXG4gIGNvb3JkaW5hdGVzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBGdWxsIGBnZW9wb3NpdGlvbmAgb2JqZWN0IGFzIHJldHVybmVkIGJ5IGBuYXZpZ2F0b3IuZ2VvbG9jYXRpb25gLCB3aGVuXG4gICAqIHVzaW5nIHRoZSBgZ2VvbG9jYXRpb25gIHNlcnZpY2UuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5HZW9sb2NhdGlvbn1cbiAgICovXG4gIGdlb3Bvc2l0aW9uOiBudWxsLFxuXG4gIC8qKlxuICAgKiBTb2NrZXQgb2JqZWN0IHRoYXQgaGFuZGxlIGNvbW11bmljYXRpb25zIHdpdGggdGhlIHNlcnZlciwgaWYgYW55LlxuICAgKiBUaGlzIG9iamVjdCBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgaWYgdGhlIGV4cGVyaWVuY2UgcmVxdWlyZXMgYW55IHNlcnZpY2VcbiAgICogaGF2aW5nIGEgc2VydmVyLXNpZGUgY291bnRlcnBhcnQuXG4gICAqXG4gICAqIEB0eXBlIHttb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuc29ja2V0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc29ja2V0OiBzb2NrZXQsXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NsaWVudFR5cGU9J3BsYXllciddIC0gVGhlIHR5cGUgb2YgdGhlIGNsaWVudCwgZGVmaW5lcyB0aGVcbiAgICogIHNvY2tldCBjb25uZWN0aW9uIG5hbWVzcGFjZS4gU2hvdWxkIG1hdGNoIGEgY2xpZW50IHR5cGUgZGVmaW5lZCBzZXJ2ZXIgc2lkZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWc9e31dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmFwcENvbnRhaW5lcj0nI2NvbnRhaW5lciddIC0gQSBjc3Mgc2VsZWN0b3JcbiAgICogIG1hdGNoaW5nIGEgRE9NIGVsZW1lbnQgd2hlcmUgdGhlIHZpZXdzIHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcud2Vic29ja2V0cy51cmw9JyddIC0gVGhlIHVybCB3aGVyZSB0aGUgc29ja2V0IHNob3VsZFxuICAgKiAgY29ubmVjdCBfKHVuc3RhYmxlKV8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLndlYnNvY2tldHMudHJhbnNwb3J0cz1bJ3dlYnNvY2tldCddXSAtIFRoZSB0cmFuc3BvcnRcbiAgICogIHVzZWQgdG8gY3JlYXRlIHRoZSB1cmwgKG92ZXJyaWRlcyBkZWZhdWx0IHNvY2tldC5pbyBtZWNhbmlzbSkgXyh1bnN0YWJsZSlfLlxuICAgKi9cbiAgaW5pdChjbGllbnRUeXBlID0gJ3BsYXllcicsIGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gY2xpZW50VHlwZTtcblxuICAgIHRoaXMuX3BhcnNlVXJsUGFyYW1zKCk7XG4gICAgLy8gaWYgc29ja2V0IGNvbmZpZyBnaXZlbiwgbWl4IGl0IHdpdGggZGVmYXVsdHNcbiAgICBjb25zdCB3ZWJzb2NrZXRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICB1cmw6ICcnLFxuICAgICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnXSxcbiAgICAgIHBhdGg6ICcnLFxuICAgIH0sIGNvbmZpZy53ZWJzb2NrZXRzKTtcblxuICAgIC8vIG1peCBhbGwgb3RoZXIgY29uZmlnIGFuZCBvdmVycmlkZSB3aXRoIGRlZmluZWQgc29ja2V0IGNvbmZpZ1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGNvbmZpZywgeyB3ZWJzb2NrZXRzIH0pO1xuXG4gICAgc2VydmljZU1hbmFnZXIuaW5pdCgpO1xuICAgIHZpZXdwb3J0LmluaXQoKTtcblxuICAgIGNvbnN0IGVsID0gY29uZmlnLmFwcENvbnRhaW5lcjtcbiAgICBjb25zdCAkY29udGFpbmVyID0gZWwgaW5zdGFuY2VvZiBFbGVtZW50ID8gZWwgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICB2aWV3TWFuYWdlci5zZXRBcHBDb250YWluZXIoJGNvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBhIHNlcnZpY2UgaXMgaW5zdGFuY2lhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3NlcnZpY2VNYW5hZ2VyfnNlcnZpY2VJbnN0YW5jaWF0aW9uSG9va30gZnVuYyAtIEZ1bmN0aW9uIHRvXG4gICAqICByZWdpc3RlciBoYXMgYSBob29rIHRvIGJlIGV4ZWN1dGUgd2hlbiBhIHNlcnZpY2UgaXMgY3JlYXRlZC5cbiAgICovXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgc2VydmljZU1hbmFnZXJ+c2VydmljZUluc3RhbmNpYXRpb25Ib29rXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIGlkIG9mIHRoZSBpbnN0YW5jaWF0ZWQgc2VydmljZS5cbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBpbnN0YW5jZSAtIGluc3RhbmNlIG9mIHRoZSBzZXJ2aWNlLlxuICAgKi9cbiAgc2V0U2VydmljZUluc3RhbmNpYXRpb25Ib29rKGZ1bmMpIHtcbiAgICBzZXJ2aWNlTWFuYWdlci5zZXRTZXJ2aWNlSW5zdGFuY2lhdGlvbkhvb2soZnVuYyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBhcHBsaWNhdGlvbi5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmIChzb2NrZXQucmVxdWlyZWQpXG4gICAgICB0aGlzLl9pbml0U29ja2V0KCgpID0+IHNlcnZpY2VNYW5hZ2VyLnN0YXJ0KCkpO1xuICAgIGVsc2VcbiAgICAgIHNlcnZpY2VNYW5hZ2VyLnN0YXJ0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXJ2aWNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gSWRlbnRpZmllciBvZiB0aGUgc2VydmljZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgc2VydmljZS5cbiAgICovXG4gIHJlcXVpcmUoaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc2VydmljZU1hbmFnZXIucmVxdWlyZShpZCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGFuIGFycmF5IG9mIG9wdGlvbm5hbCBwYXJhbWV0ZXJzIGZyb20gdGhlIHVybCBleGNsdWRpbmcgdGhlIGNsaWVudCB0eXBlXG4gICAqIGFuZCBzdG9yZSBpdCBpbiBgdGhpcy51cmxQYXJhbXNgLlxuICAgKiBQYXJhbWV0ZXJzIGNhbiBiZSBkZWZpbmVkIGluIHR3byB3YXlzIDpcbiAgICogLSBhcyBhIHJlZ3VsYXIgcm91dGUgKGV4OiBgL3BsYXllci9wYXJhbTEvcGFyYW0yYClcbiAgICogLSBhcyBhIGhhc2ggKGV4OiBgL3BsYXllciNwYXJhbTEtcGFyYW0yYClcbiAgICogVGhlIHBhcmFtZXRlcnMgYXJlIHNlbmQgYWxvbmcgd2l0aCB0aGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LnNvY2tldH1cbiAgICogQHByaXZhdGVcbiAgICogQHRvZG8gLSBXaGVuIGhhbmRzaGFrZSBpbXBsZW1lbnRlZCwgZGVmaW5lIGlmIHRoZXNlIGluZm9ybWF0aW9ucyBzaG91bGQgYmUgcGFydCBvZiBpdFxuICAgKi9cbiAgX3BhcnNlVXJsUGFyYW1zKCkge1xuICAgIGxldCBwYXRoUGFyYW1zID0gbnVsbDtcbiAgICBsZXQgaGFzaFBhcmFtcyA9IG51bGw7XG4gICAgLy8gaGFuZGxlIHBhdGggbmFtZSBmaXJzdFxuICAgIGxldCBwYXRobmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAvLyBzYW5pdGl6ZVxuICAgIHBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgIC5yZXBsYWNlKC9eXFwvLywgJycpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgc2xhc2hcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgdGhpcy50eXBlICsgJy8/JyksICcnKSAgLy8gcmVtb3ZlIGNsaWVudFR5cGVcbiAgICAgIC5yZXBsYWNlKC9cXC8kLywgJycpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYWlsaW5nIHNsYXNoXG5cbiAgICBpZiAocGF0aG5hbWUubGVuZ3RoID4gMClcbiAgICAgIHBhdGhQYXJhbXMgPSBwYXRobmFtZS5zcGxpdCgnLycpO1xuXG4gICAgLy8gaGFuZGxlIGhhc2hcbiAgICBsZXQgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgIGhhc2ggPSBoYXNoLnJlcGxhY2UoL14jLywgJycpO1xuXG4gICAgaWYgKGhhc2gubGVuZ3RoID4gMClcbiAgICAgIGhhc2hQYXJhbXMgPSBoYXNoLnNwbGl0KCctJyk7XG5cbiAgICBpZiAocGF0aFBhcmFtcyB8fMKgaGFzaFBhcmFtcykge1xuICAgICAgdGhpcy51cmxQYXJhbXMgPSBbXTtcblxuICAgICAgaWYgKHBhdGhQYXJhbXMpXG4gICAgICAgIHBhdGhQYXJhbXMuZm9yRWFjaCgocGFyYW0pID0+IHRoaXMudXJsUGFyYW1zLnB1c2gocGFyYW0pKTtcblxuICAgICAgaWYgKGhhc2hQYXJhbXMpXG4gICAgICAgIGhhc2hQYXJhbXMuZm9yRWFjaCgocGFyYW0pID0+IHRoaXMudXJsUGFyYW1zLnB1c2gocGFyYW0pKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgc29ja2V0IGNvbm5lY3Rpb24gYW5kIHBlcmZvcm0gaGFuZHNoYWtlIHdpdGggdGhlIHNlcnZlci5cbiAgICogQHRvZG8gLSByZWZhY3RvciBoYW5kc2hha2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFNvY2tldChjYWxsYmFjaykge1xuICAgIHNvY2tldC5pbml0KHRoaXMudHlwZSwgdGhpcy5jb25maWcud2Vic29ja2V0cyk7XG5cbiAgICAvLyBzZWU6IGh0dHA6Ly9zb2NrZXQuaW8vZG9jcy9jbGllbnQtYXBpLyNzb2NrZXRcbiAgICB0aGlzLnNvY2tldC5hZGRTdGF0ZUxpc3RlbmVyKChldmVudE5hbWUpID0+IHtcbiAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IHVybFBhcmFtczogdGhpcy51cmxQYXJhbXMgfTtcblxuICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbnYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXlsb2FkLCB7XG4gICAgICAgICAgICAgIHJlcXVpcmVkU2VydmljZXM6IHNlcnZpY2VNYW5hZ2VyLmdldFJlcXVpcmVkU2VydmljZXMoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZCgnaGFuZHNoYWtlJywgcGF5bG9hZCk7XG4gICAgICAgICAgLy8gd2FpdCBmb3IgaGFuZHNoYWtlIHJlc3BvbnNlIHRvIG1hcmsgY2xpZW50IGFzIGByZWFkeWBcbiAgICAgICAgICB0aGlzLnNvY2tldC5yZWNlaXZlKCdjbGllbnQ6c3RhcnQnLCAodXVpZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51dWlkID0gdXVpZDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnNvY2tldC5yZWNlaXZlKCdjbGllbnQ6ZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyci50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3NlcnZpY2VzJzpcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBhcHBlbmQgaWYgZW52ICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2Vyci5kYXRhLmpvaW4oJywgJyl9XCIgcmVxdWlyZWQgY2xpZW50LXNpZGUgYnV0IG5vdCBzZXJ2ZXItc2lkZWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gY2FzZSAncmVjb25uZWN0JzpcbiAgICAgICAgICAvLyAgIC8vIHNlcnZpY2VNYW5hZ2VyLnN0YXJ0KCk7XG4gICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAvLyBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgICAgICAvLyAgIC8vIGNhbiByZWxhdW5jaCBzZXJ2aWNlTWFuYWdlciBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgICAvLyAgIC8vIHNlcnZpY2VNYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAvLyBjYXNlICdjb25uZWN0X2Vycm9yJzpcbiAgICAgICAgICAvLyBjYXNlICdyZWNvbm5lY3RfYXR0ZW1wdCc6XG4gICAgICAgICAgLy8gY2FzZSAncmVjb25uZWN0aW5nJzpcbiAgICAgICAgICAvLyBjYXNlICdyZWNvbm5lY3RfZXJyb3InOlxuICAgICAgICAgIC8vIGNhc2UgJ3JlY29ubmVjdF9mYWlsZWQnOlxuICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGllbnQ7XG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IFNpZ25hbCBmcm9tICcuLi8uLi91dGlscy9TaWduYWwnO1xuaW1wb3J0IFNpZ25hbEFsbCBmcm9tICcuLi8uLi91dGlscy9TaWduYWxBbGwnO1xuXG5jb25zdCBsb2cgPSBkZWJ1Zygnc291bmR3b3JrczpzZXJ2aWNlTWFuYWdlcicpO1xuXG5jb25zdCBfaW5zdGFuY2VzID0ge307XG5jb25zdCBfY3RvcnMgPSB7fTtcblxuLyoqXG4gKiBGYWN0b3J5IGFuZCBpbml0aWFsaXNhdGlvbiBtYW5hZ2VyIGZvciB0aGUgc2VydmljZXMuXG4gKiBMYXp5IGluc3RhbmNpYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCByZXRyaWV2ZSBpdCBvbiBlYWNoIGNhbGwuXG4gKi9cbmNvbnN0IHNlcnZpY2VNYW5hZ2VyID0ge1xuICBfc2VydmljZUluc3RhbmNpYXRpb25Ib29rOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBtYW5hZ2VyLlxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBsb2coJ2luaXQnKTtcbiAgICB0aGlzLl9yZXF1aXJlZFNpZ25hbHMgPSBuZXcgU2lnbmFsQWxsKCk7XG4gICAgdGhpcy5fcmVxdWlyZWRTaWduYWxzLmFkZE9ic2VydmVyKCgpID0+IHRoaXMucmVhZHkoKSk7XG5cbiAgICB0aGlzLnNpZ25hbHMgPSB7fTtcbiAgICB0aGlzLnNpZ25hbHMuc3RhcnQgPSBuZXcgU2lnbmFsKCk7XG4gICAgdGhpcy5zaWduYWxzLnJlYWR5ID0gbmV3IFNpZ25hbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgc2lnbmFsIHJlcXVpcmVkIGJ5IGFsbCBzZXJ2aWNlcyB0byBzdGFydC5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGxvZygnc3RhcnQnKTtcblxuICAgIGNvbnN0IG5ldHdvcmtlZFNlcnZpY2VzID0gW107XG5cbiAgICB0aGlzLnNpZ25hbHMuc3RhcnQuc2V0KHRydWUpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1aXJlZFNpZ25hbHMubGVuZ3RoKVxuICAgICAgdGhpcy5yZWFkeSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrIHRoZSBzZXJ2aWNlcyBhcyByZWFkeS4gVGhpcyBzaWduYWwgaXMgb2JzZXJ2ZWQgYnkge0BsaW5rIEV4cGVyaWVuY2V9XG4gICAqIGluc3RhbmNlcyBhbmQgdHJpZ2dlciB0aGVpciBgc3RhcnRgLlxuICAgKi9cbiAgcmVhZHkoKSB7XG4gICAgbG9nKCdyZWFkeScpO1xuICAgIHRoaXMuc2lnbmFscy5yZWFkeS5zZXQodHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYSBzZXJ2aWNlIHdpdGggb3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIGl0cyBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBzZXJ2aWNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc2VydmljZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIHJlcXVpcmUoaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlkID0gJ3NlcnZpY2U6JyArIGlkO1xuXG4gICAgaWYgKCFfY3RvcnNbaWRdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2aWNlIFwiJHtpZH1cIiBpcyBub3QgZGVmaW5lZGApO1xuXG4gICAgbGV0IGluc3RhbmNlID0gX2luc3RhbmNlc1tpZF07XG5cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBpZiBtYW5hZ2VyIGFscmVhZHkgc3RhcnRlZFxuICAgICAgaWYgKHRoaXMuc2lnbmFscy5zdGFydC5nZXQoKSA9PT0gdHJ1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2aWNlIFwiJHtpZH1cIiByZXF1aXJlZCBhZnRlciBzZXJ2aWNlTWFuYWdlciBzdGFydGApO1xuXG4gICAgICBpbnN0YW5jZSA9IG5ldyBfY3RvcnNbaWRdKCk7XG5cbiAgICAgIGlmICh0aGlzLl9zZXJ2aWNlSW5zdGFuY2lhdGlvbkhvb2sgIT09IG51bGwpXG4gICAgICAgIHRoaXMuX3NlcnZpY2VJbnN0YW5jaWF0aW9uSG9vayhpZCwgaW5zdGFuY2UpO1xuXG4gICAgICAvLyBhZGQgdGhlIGluc3RhbmNlIHJlYWR5IHNpZ25hbCBhcyByZXF1aXJlZCBmb3IgdGhlIG1hbmFnZXJcbiAgICAgIHRoaXMuX3JlcXVpcmVkU2lnbmFscy5hZGQoaW5zdGFuY2Uuc2lnbmFscy5yZWFkeSk7XG4gICAgICAvLyBzdG9yZSBpbnN0YW5jZVxuICAgICAgX2luc3RhbmNlc1tpZF0gPSBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5jb25maWd1cmUob3B0aW9ucyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gYSBzZXJ2aWNlIGlzIGluc3RhbmNpYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzZXJ2aWNlTWFuYWdlcn5zZXJ2aWNlSW5zdGFuY2lhdGlvbkhvb2t9IGZ1bmMgLSBGdW5jdGlvbiB0b1xuICAgKiAgcmVnaXN0ZXIgaGFzIGEgaG9vayB0byBiZSBleGVjdXRlIHdoZW4gYSBzZXJ2aWNlIGlzIGNyZWF0ZWQuXG4gICAqL1xuICAvKipcbiAgICogQGNhbGxiYWNrIHNlcnZpY2VNYW5hZ2VyfnNlcnZpY2VJbnN0YW5jaWF0aW9uSG9va1xuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBpZCBvZiB0aGUgaW5zdGFuY2lhdGVkIHNlcnZpY2UuXG4gICAqIEBwYXJhbSB7U2VydmljZX0gaW5zdGFuY2UgLSBpbnN0YW5jZSBvZiB0aGUgc2VydmljZS5cbiAgICovXG4gIHNldFNlcnZpY2VJbnN0YW5jaWF0aW9uSG9vayhmdW5jKSB7XG4gICAgdGhpcy5fc2VydmljZUluc3RhbmNpYXRpb25Ib29rID0gZnVuYztcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBzZXJ2aWNlIHdpdGggYSBnaXZlbiBpZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBzZXJ2aWNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzZXJ2aWNlLlxuICAgKi9cbiAgcmVnaXN0ZXIoaWQsIGN0b3IpIHtcbiAgICBfY3RvcnNbaWRdID0gY3RvcjtcbiAgfSxcblxuXG4gIGdldFJlcXVpcmVkU2VydmljZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKF9pbnN0YW5jZXMpO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VydmljZU1hbmFnZXI7XG5cbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgc2lvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuXG5jb25zdCBsb2cgPSBkZWJ1Zygnc291bmR3b3Jrczpzb2NrZXQnKTtcblxuY29uc3Qgc29ja2V0ID0ge1xuICAvKipcbiAgICogU3RvcmUgdGhlIGluc3RhbmNlIG9mIFNvY2tldC5pbyBNYW5hZ2VyLlxuICAgKi9cbiAgc29ja2V0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJcyBzZXQgdG8gYHRydWVgIHdoZW4gYSBgQWN0aXZpdHlgIHRoYXQgcmVxdWlyZXMgbmV0d29yayBpcyBpbnN0YW5jaWF0ZWQuXG4gICAqIElzIGNoZWNrZWQgYnkgdGhlIGBjbGllbnRgIHRvIGluaXRpYWxpemUgdGhlIGNvbm5lY3Rpb24gb3Igbm90LlxuICAgKi9cbiAgcmVxdWlyZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmFtZXNwYWNlZCBjb25uZWN0aW9uIHdpdGggZ2l2ZW4gb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIENvcnJlc3BvbmQgdG8gdGhlIGBjbGllbnQudHlwZWAge0BsaW5rIGNsaWVudH0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBvZiB0aGUgc29ja2V0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgLSBUaGUgdXJsIHdoZXJlIHRoZSBzb2NrZXQgc2hvdWxkIGNvbm5lY3QuXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gb3B0aW9ucy50cmFuc3BvcnRzIC0gVGhlIHRyYW5zcG9ydHMgdG8gdXNlIGZvciB0aGUgc29ja2V0IChjZi4gc29ja2V0LmlvKS5cbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBvcHRpb25zLnBhdGggLSBEZWZpbmVzIHdoZXJlIHNvY2tldCBzaG91bGQgZmluZCB0aGUgYHNvY2tldC5pb2AgZmlsZS5cbiAgICovXG4gIGluaXQobmFtZXNwYWNlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzaW8oYCR7b3B0aW9ucy51cmx9LyR7bmFtZXNwYWNlfWAsIHtcbiAgICAgIHRyYW5zcG9ydHM6IG9wdGlvbnMudHJhbnNwb3J0cyxcbiAgICAgIHBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICB9KTtcblxuICAgIGxvZyhgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAtIHVybDogJHtvcHRpb25zLnVybH0vJHtuYW1lc3BhY2V9XG4gICAgICAgICAgLSB0cmFuc3BvcnRzOiAke29wdGlvbnMudHJhbnNwb3J0c31cbiAgICAgICAgICAtIHBhdGg6ICR7b3B0aW9ucy5wYXRofVxuICAgIGApO1xuXG4gICAgdGhpcy5fc3RhdGVMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5fbGlzdGVuU29ja2V0U3RhdGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIHRoZSBkaWZmZXJlbnQgc3RhdGVzIG9mIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZVxuICAgKiAgb2YgdGhlIHNvY2tldCBjaGFuZ2VzLCB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIG5hbWUgb2YgdGhlXG4gICAqICBldmVudCBhcyBhcmd1bWVudC5cbiAgICogQHNlZSB7aHR0cDovL3NvY2tldC5pby9kb2NzL2NsaWVudC1hcGkvI3NvY2tldH1cbiAgICovXG4gIGFkZFN0YXRlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9zdGF0ZUxpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBudWxsKVxuICAgICAgY2FsbGJhY2sodGhpcy5fc3RhdGUpO1xuICB9LFxuXG4gIF9saXN0ZW5Tb2NrZXRTdGF0ZSgpIHtcbiAgICAvLyBzZWU6IGh0dHA6Ly9zb2NrZXQuaW8vZG9jcy9jbGllbnQtYXBpLyNzb2NrZXRcbiAgICBbICdjb25uZWN0JyxcbiAgICAgICdyZWNvbm5lY3QnLFxuICAgICAgJ2Rpc2Nvbm5lY3QnLFxuICAgICAgJ2Nvbm5lY3RfZXJyb3InLFxuICAgICAgJ3JlY29ubmVjdF9hdHRlbXB0JyxcbiAgICAgICdyZWNvbm5lY3RpbmcnLFxuICAgICAgJ3JlY29ubmVjdF9lcnJvcicsXG4gICAgICAncmVjb25uZWN0X2ZhaWxlZCdcbiAgICBdLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgdGhpcy5zb2NrZXQub24oZXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLl9zdGF0ZUxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5fc3RhdGUpKTtcbiAgICAgICAgbG9nKGBzdGF0ZSAtICR7dGhpcy5fc3RhdGV9YCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZHMgYSBXZWJTb2NrZXQgbWVzc2FnZSB0byB0aGUgc2VydmVyIHNpZGUgc29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIFRoZSBjaGFubmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgLSBBcmd1bWVudHMgb2YgdGhlIG1lc3NhZ2UgKGFzIG1hbnkgYXMgbmVlZGVkLCBvZiBhbnkgdHlwZSkuXG4gICAqL1xuICBzZW5kKGNoYW5uZWwsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLnNvY2tldC5lbWl0KGNoYW5uZWwsIC4uLmFyZ3MpO1xuICAgIGxvZyhgc2VuZCAtIGNoYW5uZWw6IFwiJHtjaGFubmVsfVwiYCwgLi4uYXJncyk7XG4gIH0sXG5cbiAgc2VuZFZvbGF0aWxlKGNoYW5uZWwsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLnNvY2tldC52b2xhdGlsZS5lbWl0KGNoYW5uZWwsIC4uLmFyZ3MpO1xuICAgIGxvZyhgc2VuZFZvbGF0aWxlIC0gY2hhbm5lbDogXCIke2NoYW5uZWx9XCJgLCAuLi5hcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIGEgV2ViU29ja2V0IG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIFRoZSBjaGFubmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0gey4uLip9IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuXG4gICAqL1xuICByZWNlaXZlKGNoYW5uZWwsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoY2hhbm5lbCwgY2FsbGJhY2spO1xuICAgIHRoaXMuc29ja2V0Lm9uKGNoYW5uZWwsIGNhbGxiYWNrKTtcbiAgICBsb2coYHJlY2VpdmUgbGlzdGVuZXIgLSBjaGFubmVsOiBcIiR7Y2hhbm5lbH1cImApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIFRoZSBjaGFubmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0gey4uLip9IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGNhbmNlbC5cbiAgICovXG4gIHJlbW92ZUxpc3RlbmVyKGNoYW5uZWwsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoY2hhbm5lbCwgY2FsbGJhY2spO1xuICAgIGxvZyhgcmVtb3ZlIGxpc3RlbmVyIC0gY2hhbm5lbDogXCIke2NoYW5uZWx9XCJgKTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNvY2tldDtcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdzb3VuZHdvcmtzOnZpZXdNYW5hZ2VyJyk7XG5jb25zdCB2aWV3SW5mb3NNYXAgPSBuZXcgTWFwKCk7XG5cbmxldCAkY29udGFpbmVyID0gbnVsbDtcblxuLyoqXG4gKiBIYW5kbGUgYWN0aXZpdGllcycgKHNlcnZpY2VzIGFuZCBzY2VuZXMpIHZpZXdzIGFjY29yZGluZyB0byB0aGVpciBwcmlvcml0aWVzLlxuICovXG5jb25zdCB2aWV3TWFuYWdlciA9IHtcbiAgX3RpbWVvdXRJZDogbnVsbCxcblxuICBfdmlzaWJsZVZpZXc6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRhaW5lciBvZiB0aGUgdmlld3MgZm9yIGFsbCBgQWN0aXZpdHlgIGluc3RhbmNlcy4gSXMgY2FsbGVkIGJ5XG4gICAqIHtAbGluayBzcmMvY2xpZW50L2NvcmUvY2xpZW50LmpzfmNsaWVudH0pIGR1cmluZyBhcHBsaWNhdGlvbiBib290c3RyYXAuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGVsIC0gVGhlIGVsZW1lbnQgdG8gdXNlIGFzIGEgY29udGFpbmVyIGZvciB0aGUgdmlldy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldEFwcENvbnRhaW5lcigkZWwpIHtcbiAgICAkY29udGFpbmVyID0gJGVsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHZpZXcgaW50byB0aGUgc3RhY2sgb2Ygdmlld3MgdG8gZGlzcGxheS4gVGhlIGZhY3QgdGhhdCB0aGUgdmlldyBpc1xuICAgKiBhY3R1YWxseSBkaXNwbGF5ZWQgaXMgZGVmaW5lZCBieSBpdHMgcHJpb3JpdHkgYW5kIGFjdGl2aXRpZXMgbGlmZWN5Y2xlLlxuICAgKiBAcGFyYW0ge1ZpZXd9IHZpZXcgLSBBIHZpZXcgdG8gYWRkIHRvIHRoZSBzdGFjay5cbiAgICovXG4gIHJlZ2lzdGVyKHZpZXcsIHByaW9yaXR5KSB7XG4gICAgbG9nKGByZWdpc3RlciAtIGlkOiBcIiR7dmlldy5vcHRpb25zLmlkfVwiIC0gcHJpb3JpdHk6ICR7cHJpb3JpdHl9YCk7XG5cbiAgICBjb25zdCBpbmZvcyA9IHt9O1xuICAgIGluZm9zLiRlbCA9IHZpZXcucmVuZGVyKCk7XG4gICAgaW5mb3MucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gaW5mb3MucHJvbWlzZSA9IHJlc29sdmUpO1xuXG4gICAgdmlld0luZm9zTWFwLnNldCh2aWV3LCBpbmZvcyk7XG5cbiAgICAvLyB0cmlnZ2VyIGBfdXBkYXRlVmlld2Agb25seSBvbmNlIHdoZW4gc2V2ZXJhbCB2aWV3IGFyZSByZWdpc3RlcmVkIGF0IG9uY2UuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl91cGRhdGVWaWV3KCksIDApO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSB2aWV3IGZyb20gdGhlIHN0YWNrIG9mIHZpZXdzIHRvIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7Vmlld30gdmlldyAtIEEgdmlldyB0byByZW1vdmUgZnJvbSB0aGUgc3RhY2suXG4gICAqL1xuICByZW1vdmUodmlldykge1xuICAgIGxvZyhgcmVtb3ZlIC0gaWQ6IFwiJHt2aWV3Lm9wdGlvbnMuaWR9XCJgKTtcblxuICAgIC8vIGNsZWFuIGRpY3Rpb25uYXJ5XG4gICAgdmlld0luZm9zTWFwLmRlbGV0ZSh2aWV3KTtcblxuICAgIGlmICh0aGlzLl92aXNpYmxlVmlldyA9PT0gdmlldykge1xuICAgICAgdGhpcy5fdmlzaWJsZVZpZXcucmVtb3ZlKCk7XG4gICAgICB0aGlzLl92aXNpYmxlVmlldyA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl91cGRhdGVWaWV3KCksIDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhlIHZpZXcgc2hvdWxkIGJlIHVwZGF0ZWQgYWNjb3JkaW5nIHRvIGRlZmluZWQgcHJpb3JpdGllcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVWaWV3KCkge1xuICAgIGNvbnN0IHZpc2libGVWaWV3ID0gdGhpcy5fdmlzaWJsZVZpZXc7XG4gICAgbGV0IG5leHRWaWV3UHJpb3JpdHkgPSAtSW5maW5pdHk7XG4gICAgbGV0IG5leHRWaWV3ID0gbnVsbDtcblxuICAgIHZpZXdJbmZvc01hcC5mb3JFYWNoKChpbmZvcywgdmlldykgPT4ge1xuICAgICAgaWYgKGluZm9zLnByaW9yaXR5ID4gbmV4dFZpZXdQcmlvcml0eSkge1xuICAgICAgICBuZXh0Vmlld1ByaW9yaXR5ID0gaW5mb3MucHJpb3JpdHk7XG4gICAgICAgIG5leHRWaWV3ID0gdmlldztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChuZXh0Vmlldykge1xuICAgICAgbG9nKGB1cGRhdGUgdmlldyAtIG5leHQ6IFwiJHtuZXh0Vmlldy5vcHRpb25zLmlkfVwiYCk7XG5cbiAgICAgIGlmICh2aXNpYmxlVmlldyA9PT0gbnVsbCkge1xuICAgICAgICAkY29udGFpbmVyLmFwcGVuZENoaWxkKHZpZXdJbmZvc01hcC5nZXQobmV4dFZpZXcpLiRlbCk7XG4gICAgICAgIG5leHRWaWV3LnNob3coKTtcbiAgICAgICAgLy8gcmVzb2x2ZSB0aGUgcHJvbWlzZSBjcmVhdGVkIHdoZW4gdGhlIHZpZXcgd2VyZSByZWdpc3RlcmVkXG4gICAgICAgIHZpZXdJbmZvc01hcC5nZXQobmV4dFZpZXcpLnByb21pc2UoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXcgPSBuZXh0VmlldztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZpc2libGVWaWV3UHJpb3JpdHkgPSB2aWV3SW5mb3NNYXAuZ2V0KHRoaXMuX3Zpc2libGVWaWV3KS5wcmlvcml0eTtcblxuICAgICAgICBpZiAodmlzaWJsZVZpZXdQcmlvcml0eSA8IG5leHRWaWV3UHJpb3JpdHkpIHtcbiAgICAgICAgICB2aXNpYmxlVmlldy5yZW1vdmUoKTsgLy8gaGlkZSBidXQga2VlcCBpbiBzdGFja1xuXG4gICAgICAgICAgJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWV3SW5mb3NNYXAuZ2V0KG5leHRWaWV3KS4kZWwpO1xuICAgICAgICAgIG5leHRWaWV3LnNob3coKTtcblxuICAgICAgICAgIHZpZXdJbmZvc01hcC5nZXQobmV4dFZpZXcpLnByb21pc2UoKTtcbiAgICAgICAgICB0aGlzLl92aXNpYmxlVmlldyA9IG5leHRWaWV3O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdmlld01hbmFnZXI7XG4iLCIvKipcbiAqIENsaWVudC1zaWRlIGVudHJ5IHBvaW50IG9mIHRoZSAqc291bmR3b3JrcyogZnJhbWV3b3JrLlxuICpcbiAqIEBtb2R1bGUgc291bmR3b3Jrcy9jbGllbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBzb3VuZHdvcmtzIGZyb20gJ3NvdW5kd29ya3MvY2xpZW50JztcbiAqL1xuXG4vLyBleHBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG5pbXBvcnQgKiBhcyBfYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuZXhwb3J0IGNvbnN0IGF1ZGlvID0gX2F1ZGlvO1xuZXhwb3J0IHsgYXVkaW9Db250ZXh0IH0gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuXG4vLyB2ZXJzaW9uIChjZi4gYmluL2phdmFzY3JpcHRzKVxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnJXZlcnNpb24lJztcblxuLy8gY29yZVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBBY3Rpdml0eSB9IGZyb20gJy4vY29yZS9BY3Rpdml0eSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNsaWVudCB9IGZyb20gJy4vY29yZS9jbGllbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeHBlcmllbmNlIH0gZnJvbSAnLi9jb3JlL0V4cGVyaWVuY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcm9jZXNzIH0gZnJvbSAnLi9jb3JlL1Byb2Nlc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZXJ2aWNlIH0gZnJvbSAnLi9jb3JlL1NlcnZpY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzZXJ2aWNlTWFuYWdlciB9IGZyb20gJy4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5cbi8vIHNlcnZpY2VzXG5leHBvcnQgeyBkZWZhdWx0IGFzIEF1ZGlvQnVmZmVyTWFuYWdlciB9IGZyb20gJy4vc2VydmljZXMvQXVkaW9CdWZmZXJNYW5hZ2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXVkaW9TdHJlYW1NYW5hZ2VyIH0gZnJvbSAnLi9zZXJ2aWNlcy9BdWRpb1N0cmVhbU1hbmFnZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdWRpb1NjaGVkdWxlciB9IGZyb20gJy4vc2VydmljZXMvQXVkaW9TY2hlZHVsZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdXRoIH0gZnJvbSAnLi9zZXJ2aWNlcy9BdXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlY2tpbiB9IGZyb20gJy4vc2VydmljZXMvQ2hlY2tpbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVycm9yUmVwb3J0ZXIgfSBmcm9tICcuL3NlcnZpY2VzL0Vycm9yUmVwb3J0ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxlU3lzdGVtIH0gZnJvbSAnLi9zZXJ2aWNlcy9GaWxlU3lzdGVtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR2VvbG9jYXRpb24gfSBmcm9tICcuL3NlcnZpY2VzL0dlb2xvY2F0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGFuZ3VhZ2UgfSBmcm9tICcuL3NlcnZpY2VzL0xhbmd1YWdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9jYXRvciB9IGZyb20gJy4vc2VydmljZXMvTG9jYXRvcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1ldHJpY1NjaGVkdWxlciB9IGZyb20gJy4vc2VydmljZXMvTWV0cmljU2NoZWR1bGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTW90aW9uSW5wdXQgfSBmcm9tICcuL3NlcnZpY2VzL01vdGlvbklucHV0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTmV0d29yayB9IGZyb20gJy4vc2VydmljZXMvTmV0d29yayc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYWNlciB9IGZyb20gJy4vc2VydmljZXMvUGxhY2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGxhdGZvcm0gfSBmcm9tICcuL3NlcnZpY2VzL1BsYXRmb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmF3U29ja2V0IH0gZnJvbSAnLi9zZXJ2aWNlcy9SYXdTb2NrZXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaGFyZWRDb25maWcgfSBmcm9tICcuL3NlcnZpY2VzL1NoYXJlZENvbmZpZyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNoYXJlZFBhcmFtcyB9IGZyb20gJy4vc2VydmljZXMvU2hhcmVkUGFyYW1zJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2hhcmVkUmVjb3JkZXIgfSBmcm9tICcuL3NlcnZpY2VzL1NoYXJlZFJlY29yZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3luYyB9IGZyb20gJy4vc2VydmljZXMvU3luYyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN5bmNTY2hlZHVsZXIgfSBmcm9tICcuL3NlcnZpY2VzL1N5bmNTY2hlZHVsZXInO1xuXG4vLyB2aWV3c1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYW52YXMyZFJlbmRlcmVyIH0gZnJvbSAnLi92aWV3cy9DYW52YXMyZFJlbmRlcmVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FudmFzUmVuZGVyaW5nR3JvdXAgfSBmcm9tICcuL3ZpZXdzL0NhbnZhc1JlbmRlcmluZ0dyb3VwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FudmFzVmlldyB9IGZyb20gJy4vdmlld3MvQ2FudmFzVmlldyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlZ21lbnRlZFZpZXcgfSBmcm9tICcuL3ZpZXdzL1NlZ21lbnRlZFZpZXcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb3VjaFN1cmZhY2UgfSBmcm9tICcuL3ZpZXdzL1RvdWNoU3VyZmFjZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFZpZXcgfSBmcm9tICcuL3ZpZXdzL1ZpZXcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2aWV3cG9ydCB9IGZyb20gJy4vdmlld3Mvdmlld3BvcnQnO1xuXG4vLyBwcmVmYWJzXG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbnRyb2xsZXJTY2VuZSB9IGZyb20gJy4vcHJlZmFicy9Db250cm9sbGVyU2NlbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb250cm9sbGVyRXhwZXJpZW5jZSB9IGZyb20gJy4vcHJlZmFicy9Db250cm9sbGVyRXhwZXJpZW5jZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlbGVjdFZpZXcgfSBmcm9tICcuL3ByZWZhYnMvU2VsZWN0Vmlldyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNwYWNlVmlldyB9IGZyb20gJy4vcHJlZmFicy9TcGFjZVZpZXcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTcXVhcmVkVmlldyB9IGZyb20gJy4vcHJlZmFicy9TcXVhcmVkVmlldyc7XG4iLCJpbXBvcnQgRXhwZXJpZW5jZSBmcm9tICcuLi9jb3JlL0V4cGVyaWVuY2UnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi4vdmlld3MvVmlldyc7XG5pbXBvcnQgQ29udHJvbGxlclNjZW5lIGZyb20gJy4vQ29udHJvbGxlclNjZW5lJztcblxuXG4vKipcbiAqIFByZWRlZmluZWQgZXhwZXJpZW5jZSB0byBjcmVhdGUgYSAxIGxpbmUgc2hhcmVkIGNvbnRyb2xsZXJcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKi9cbmNsYXNzIENvbnRyb2xsZXJFeHBlcmllbmNlIGV4dGVuZHMgRXhwZXJpZW5jZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnNoYXJlZFBhcmFtcyA9IHRoaXMucmVxdWlyZSgnc2hhcmVkLXBhcmFtcycpO1xuICAgIHRoaXMuY29udHJvbGxlclNjZW5lID0gbmV3IENvbnRyb2xsZXJTY2VuZSh0aGlzLCB0aGlzLnNoYXJlZFBhcmFtcyk7XG5cbiAgICBpZiAob3B0aW9ucy5hdXRoKVxuICAgICAgdGhpcy5hdXRoID0gdGhpcy5yZXF1aXJlKCdhdXRoJyk7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgdGhpcy52aWV3ID0gbmV3IFZpZXcoKTtcbiAgICB0aGlzLnNob3coKTtcblxuICAgIHRoaXMuY29udHJvbGxlclNjZW5lLmVudGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBHVUkgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyLCB0aGlzIG1ldGhvZCBvbmx5IG1ha2VzIHNlbnMgaWZcbiAgICogYG9wdGlvbnMuaGFzR1VJPXRydWVgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlciB0byBjb25maWd1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHBhcmFtZXRlciBHVUkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnR5cGUgLSBUeXBlIG9mIEdVSSB0byB1c2UuIEVhY2ggdHlwZSBvZiBwYXJhbWV0ZXIgY2FuXG4gICAqICB1c2VkIHdpdGggZGlmZmVyZW50IEdVSSBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZSBhbmQgY29tZXMgd2l0aCBhY2NlcHRhYmxlXG4gICAqICBkZWZhdWx0IHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaG93PXRydWVdIC0gRGlzcGxheSBvciBub3QgdGhlIEdVSSBmb3IgdGhpcyBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29uZmlybT1mYWxzZV0gLSBBc2sgZm9yIGNvbmZpcm1hdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgKi9cbiAgc2V0R3VpT3B0aW9ucyhuYW1lLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jb250cm9sbGVyU2NlbmUuc2V0R3VpT3B0aW9ucyhuYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy4kZWw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbGxlckV4cGVyaWVuY2U7XG4iLCJpbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICdiYXNpYy1jb250cm9sbGVycyc7XG5pbXBvcnQgVmlldyBmcm9tICcuLi92aWV3cy9WaWV3JztcblxuY29udHJvbGxlcnMuc2V0VGhlbWUoJ2RhcmsnKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vKiBHVUlzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqIEBwcml2YXRlICovXG5jbGFzcyBfQm9vbGVhbkd1aSB7XG4gIGNvbnN0cnVjdG9yKCRjb250YWluZXIsIHBhcmFtLCBndWlPcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgdmFsdWUgfSA9IHBhcmFtO1xuXG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IGNvbnRyb2xsZXJzLlRvZ2dsZSh7XG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICBkZWZhdWx0OiB2YWx1ZSxcbiAgICAgIGNvbnRhaW5lcjogJGNvbnRhaW5lcixcbiAgICAgIGNhbGxiYWNrOiAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGd1aU9wdGlvbnMuY29uZmlybSkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIFwiJHtwYXJhbS5uYW1lfToke3ZhbHVlfVwiYDtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5jb25maXJtKG1zZykpIHsgcmV0dXJuOyB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbS51cGRhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0KHZhbCkge1xuICAgIHRoaXMuY29udHJvbGxlci52YWx1ZSA9IHZhbDtcbiAgfVxufVxuXG4vKiogQHByaXZhdGUgKi9cbmNsYXNzIF9FbnVtR3VpIHtcbiAgY29uc3RydWN0b3IoJGNvbnRhaW5lciwgcGFyYW0sIGd1aU9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBvcHRpb25zLCB2YWx1ZSB9ID0gcGFyYW07XG5cbiAgICBjb25zdCBjdG9yID0gZ3VpT3B0aW9ucy50eXBlID09PSAnYnV0dG9ucycgP1xuICAgICAgY29udHJvbGxlcnMuU2VsZWN0QnV0dG9ucyA6IGNvbnRyb2xsZXJzLlNlbGVjdExpc3RcblxuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBjdG9yKHtcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBkZWZhdWx0OiB2YWx1ZSxcbiAgICAgIGNvbnRhaW5lcjogJGNvbnRhaW5lcixcbiAgICAgIGNhbGxiYWNrOiAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGd1aU9wdGlvbnMuY29uZmlybSkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIFwiJHtwYXJhbS5uYW1lfToke3ZhbHVlfVwiYDtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5jb25maXJtKG1zZykpIHsgcmV0dXJuOyB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbS51cGRhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0KHZhbCkge1xuICAgIHRoaXMuY29udHJvbGxlci52YWx1ZSA9IHZhbDtcbiAgfVxufVxuXG4vKiogQHByaXZhdGUgKi9cbmNsYXNzIF9OdW1iZXJHdWkge1xuICBjb25zdHJ1Y3RvcigkY29udGFpbmVyLCBwYXJhbSwgZ3VpT3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGFiZWwsIG1pbiwgbWF4LCBzdGVwLCB2YWx1ZSB9ID0gcGFyYW07XG5cbiAgICBpZiAoZ3VpT3B0aW9ucy50eXBlID09PSAnc2xpZGVyJykge1xuICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IGNvbnRyb2xsZXJzLlNsaWRlcih7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4LFxuICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICBkZWZhdWx0OiB2YWx1ZSxcbiAgICAgICAgdW5pdDogZ3VpT3B0aW9ucy5wYXJhbSA/IGd1aU9wdGlvbnMucGFyYW0gOiAnJyxcbiAgICAgICAgc2l6ZTogZ3VpT3B0aW9ucy5zaXplLFxuICAgICAgICBjb250YWluZXI6ICRjb250YWluZXIsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IGNvbnRyb2xsZXJzLk51bWJlckJveCh7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4LFxuICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICBkZWZhdWx0OiB2YWx1ZSxcbiAgICAgICAgY29udGFpbmVyOiAkY29udGFpbmVyLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmFkZExpc3RlbmVyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGd1aU9wdGlvbnMuY29uZmlybSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSBcIiR7cGFyYW0ubmFtZX06JHt2YWx1ZX1cImA7XG4gICAgICAgIGlmICghd2luZG93LmNvbmZpcm0obXNnKSkgeyByZXR1cm47IH1cbiAgICAgIH1cblxuICAgICAgcGFyYW0udXBkYXRlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldCh2YWwpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIudmFsdWUgPSB2YWw7XG4gIH1cbn1cblxuLyoqIEBwcml2YXRlICovXG5jbGFzcyBfVGV4dEd1aSB7XG4gIGNvbnN0cnVjdG9yKCRjb250YWluZXIsIHBhcmFtLCBndWlPcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgdmFsdWUgfSA9IHBhcmFtO1xuXG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IGNvbnRyb2xsZXJzLlRleHQoe1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgZGVmYXVsdDogdmFsdWUsXG4gICAgICByZWFkb25seTogZ3VpT3B0aW9ucy5yZWFkb25seSxcbiAgICAgIGNvbnRhaW5lcjogJGNvbnRhaW5lcixcbiAgICB9KTtcblxuICAgIGlmICghZ3VpT3B0aW9ucy5yZWFkb25seSkge1xuICAgICAgdGhpcy5jb250cm9sbGVyLmFkZExpc3RlbmVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoZ3VpT3B0aW9ucy5jb25maXJtKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgXCIke3BhcmFtLm5hbWV9XCJgO1xuICAgICAgICAgIGlmICghd2luZG93LmNvbmZpcm0obXNnKSkgeyByZXR1cm47IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzZXQodmFsKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLnZhbHVlID0gdmFsO1xuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgX1RyaWdnZXJHdWkge1xuICBjb25zdHJ1Y3RvcigkY29udGFpbmVyLCBwYXJhbSwgZ3VpT3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHBhcmFtO1xuXG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IGNvbnRyb2xsZXJzLlRyaWdnZXJCdXR0b25zKHtcbiAgICAgIG9wdGlvbnM6IFtsYWJlbF0sXG4gICAgICBjb250YWluZXI6ICRjb250YWluZXIsXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICBpZiAoZ3VpT3B0aW9ucy5jb25maXJtKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgXCIke3BhcmFtLm5hbWV9XCJgO1xuICAgICAgICAgIGlmICghd2luZG93LmNvbmZpcm0obXNnKSkgeyByZXR1cm47IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0KHZhbCkgeyAvKiBub3RoaW5nIHRvIHNldCBoZXJlICovIH1cbn1cblxuY29uc3QgU0NFTkVfSUQgPSAnYmFzaWMtc2hhcmVkLWNvbnRyb2xsZXInO1xuXG4vKipcbiAqIFRoZSBgQ29udHJvbGxlclNjZW5lYCBzY2VuZSBwcm9wb3NlIGEgc2ltcGxlIC8gZGVmYXVsdCB3YXkgdG8gY3JlYXRlXG4gKiBhIGNvbnRyb2xsZXIgdmlldyBmb3IgdGhlIGBzaGFyZWQtcGFyYW1zYCBzZXJ2aWNlLlxuICpcbiAqIEVhY2ggY29udHJvbGxlciBjb21lcyB3aXRoIGEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZVxuICogY29uc3RydWN0b3IuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICogQHNlZSBbYHNoYXJlZC1wYXJhbXNgIHNlcnZpY2Vde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5TaGFyZWRQYXJhbXN9XG4gKi9cbmNsYXNzIENvbnRyb2xsZXJTY2VuZSB7XG4gIC8qKlxuICAgKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgQVBJIGlzIHVuc3RhYmxlLCBhbmRcbiAgICogc3ViamVjdCB0byBjaGFuZ2UgaW4gZnVydGhlciB2ZXJzaW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4cGVyaWVuY2UsIHNoYXJlZFBhcmFtcykge1xuICAgIGlmICghc2hhcmVkUGFyYW1zKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNlcnZpY2UgcmVxdWlyZXMgdGhlIFwic2hhcmVkIHBhcmFtc1wiIHNlcnZpY2UnKTtcblxuICAgIHRoaXMuX2d1aU9wdGlvbnMgPSB7fTtcblxuICAgIHRoaXMuZXhwZXJpZW5jZSA9IGV4cGVyaWVuY2U7XG4gICAgdGhpcy5zaGFyZWRQYXJhbXMgPSBzaGFyZWRQYXJhbXM7XG4gIH1cblxuICBlbnRlcigpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgVmlldygpO1xuICAgIHRoaXMudmlldy5vcHRpb25zLmlkID0gJ2Jhc2ljLXNoYXJlZC1jb250cm9sbGVyJztcblxuICAgIHRoaXMudmlldy5yZW5kZXIoKTtcbiAgICB0aGlzLnZpZXcuYXBwZW5kVG8odGhpcy5leHBlcmllbmNlLmNvbnRhaW5lcik7XG5cbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuc2hhcmVkUGFyYW1zLnBhcmFtcykge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNoYXJlZFBhcmFtcy5wYXJhbXNbbmFtZV07XG4gICAgICBjb25zdCBndWkgPSB0aGlzLl9jcmVhdGVHdWkocGFyYW0pO1xuXG4gICAgICBwYXJhbS5hZGRMaXN0ZW5lcigndXBkYXRlJywgKHZhbCkgPT4gZ3VpLnNldCh2YWwpKTtcbiAgICB9XG4gIH1cblxuICBleGl0KCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5zaGFyZWRQYXJhbXMucGFyYW1zKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2hhcmVkUGFyYW1zLnBhcmFtc1tuYW1lXTtcbiAgICAgIHBhcmFtLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnZpZXcucmVtb3ZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBHVUkgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyLCB0aGlzIG1ldGhvZCBvbmx5IG1ha2VzIHNlbnMgaWZcbiAgICogYG9wdGlvbnMuaGFzR1VJPXRydWVgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlciB0byBjb25maWd1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHBhcmFtZXRlciBHVUkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnR5cGUgLSBUeXBlIG9mIEdVSSB0byB1c2UuIEVhY2ggdHlwZSBvZiBwYXJhbWV0ZXIgY2FuXG4gICAqICB1c2VkIHdpdGggZGlmZmVyZW50IEdVSSBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZSBhbmQgY29tZXMgd2l0aCBhY2NlcHRhYmxlXG4gICAqICBkZWZhdWx0IHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaG93PXRydWVdIC0gRGlzcGxheSBvciBub3QgdGhlIEdVSSBmb3IgdGhpcyBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29uZmlybT1mYWxzZV0gLSBBc2sgZm9yIGNvbmZpcm1hdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgKi9cbiAgc2V0R3VpT3B0aW9ucyhuYW1lLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fZ3VpT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnM7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2NyZWF0ZUd1aShwYXJhbSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIGNvbmZpcm06IGZhbHNlLFxuICAgIH0sIHRoaXMuX2d1aU9wdGlvbnNbcGFyYW0ubmFtZV0pO1xuXG4gICAgaWYgKGNvbmZpZy5zaG93ID09PSBmYWxzZSkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgZ3VpID0gbnVsbDtcbiAgICBjb25zdCAkY29udGFpbmVyID0gdGhpcy52aWV3LiRlbDtcblxuICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGd1aSA9IG5ldyBfQm9vbGVhbkd1aSgkY29udGFpbmVyLCBwYXJhbSwgY29uZmlnKTsgLy8gYFRvZ2dsZWBcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgZ3VpID0gbmV3IF9FbnVtR3VpKCRjb250YWluZXIsIHBhcmFtLCBjb25maWcpOyAvLyBgU2VsZWN0TGlzdGAgb3IgYFNlbGVjdEJ1dHRvbnNgXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgZ3VpID0gbmV3IF9OdW1iZXJHdWkoJGNvbnRhaW5lciwgcGFyYW0sIGNvbmZpZyk7IC8vIGBOdW1iZXJCb3hgIG9yIGBTbGlkZXJgXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGd1aSA9IG5ldyBfVGV4dEd1aSgkY29udGFpbmVyLCBwYXJhbSwgY29uZmlnKTsgLy8gYFRleHRgXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJpZ2dlcic6XG4gICAgICAgIGd1aSA9IG5ldyBfVHJpZ2dlckd1aSgkY29udGFpbmVyLCBwYXJhbSwgY29uZmlnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGd1aTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sbGVyU2NlbmU7XG4iLCJpbXBvcnQgVmlldyBmcm9tICcuLi92aWV3cy9WaWV3JztcblxuY29uc3QgZGVmYXVsdFRlbXBsYXRlID0gYFxuICA8b3B0aW9uIGNsYXNzPVwic21hbGxcIj48JT0gaW5zdHJ1Y3Rpb25zICU+PC9vcHRpb24+XG4gIDwlIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkgeyAlPlxuICAgIDxvcHRpb24gdmFsdWU9XCI8JT0gZW50cnkuaW5kZXggJT5cIj48JT0gZW50cnkubGFiZWwgJT48L29wdGlvbj5cbiAgPCUgfSk7ICU+XG5gO1xuXG5cbi8qKlxuICogVmlldyB3aXRoIGEgZHJvcCBkb3duIGxpc3QuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICovXG5jbGFzcyBTZWxlY3RWaWV3IGV4dGVuZHMgVmlldyB7XG4gIGNvbnN0cnVjdG9yKGNvbnRlbnQsIGV2ZW50cyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGVsOiAnc2VsZWN0JywgY2xhc3NOYW1lOiAnc2VsZWN0JyB9LCBvcHRpb25zKTtcbiAgICBzdXBlcihkZWZhdWx0VGVtcGxhdGUsIGNvbnRlbnQsIGV2ZW50cywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmVudHJpZXMgPSBjb250ZW50LmVudHJpZXM7XG4gIH1cblxuICAvKipcbiAgICogd2h5IG5vb3AgP1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25SZXNpemUoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGVudHJ5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNlbGVjdGVkIGl0ZW0uXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludCh0aGlzLiRlbC52YWx1ZSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLmVudHJpZXMuZmluZChlbnRyeSA9PiBlbnRyeS5pbmRleCA9PT0gaW5kZXgpO1xuICAgIHJldHVybiBlbnRyeSB8fMKgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgc2VsZWN0aW9uIG9mIGEgc3BlY2lmaWMgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIGVudHJ5LlxuICAgKi9cbiAgZW5hYmxlSW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCAkb3B0aW9uID0gdGhpcy4kZWwucXVlcnlTZWxlY3Rvcihgb3B0aW9uW3ZhbHVlPVwiJHtpbmRleH1cIl1gKTtcbiAgICBpZiAoJG9wdGlvbilcbiAgICAgICRvcHRpb24ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgc2VsZWN0aW9uIG9mIGEgc3BlY2lmaWMgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIGVudHJ5LlxuICAgKi9cbiAgZGlzYWJsZUluZGV4KGluZGV4KSB7XG4gICAgY29uc3QgJG9wdGlvbiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoYG9wdGlvblt2YWx1ZT1cIiR7aW5kZXh9XCJdYCk7XG4gICAgaWYgKCRvcHRpb24pXG4gICAgICAkb3B0aW9uLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RWaWV3O1xuIiwiaW1wb3J0IFZpZXcgZnJvbSAnLi4vdmlld3MvVmlldyc7XG5cbmNvbnN0IHN2Z1RlbXBsYXRlID0gYFxuPGRpdiBjbGFzcz1cInN2Zy1jb250YWluZXJcIj5cbiAgPHN2Zz48L3N2Zz5cbjwvZGl2PmA7XG5cbmNvbnN0IG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuLyoqXG4gKiBBIHZpZXcgdGhhdCByZW5kZXIgYW4gYGFyZWFgIG9iamVjdCAoYXMgZGVmaW5lZCBpbiBzZXJ2ZXIgY29uZmlndXJhdGlvbikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlIC0gVGVtcGxhdGUgb2YgdGhlIHZpZXcuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGVudCAtIE9iamVjdCBjb250YWluaW5nIHRoZSB2YXJpYWJsZXMgdXNlZCB0byBwb3B1bGF0ZVxuICogIHRoZSB0ZW1wbGF0ZS4ge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3I2NvbnRlbnR9LlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50cyAtIExpc3RlbmVycyB0byBpbnN0YWxsIGluIHRoZSB2aWV3XG4gKiAge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3I2V2ZW50c30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgb2YgdGhlIHZpZXcuXG4gKiAge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3I29wdGlvbnN9LlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqL1xuY2xhc3MgU3BhY2VWaWV3IGV4dGVuZHMgVmlldyB7XG4gIGNvbnN0cnVjdG9yKHRlbXBsYXRlID0gc3ZnVGVtcGxhdGUsIGNvbnRlbnQgPSB7fSwgZXZlbnRzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiAnc3BhY2UnIH0sIG9wdGlvbnMpO1xuICAgIHN1cGVyKHRlbXBsYXRlLCBjb250ZW50LCBldmVudHMsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFyZWEgdG8gZGlzcGxheS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFyZWEud2lkdGggLSBXaWR0aCBvZiB0aGUgYXJlYS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYXJlYS5oZWlnaHQgLSBIZWlnaHQgb2YgdGhlIGFyZWEuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGFyZWEuYmFja2dyb3VuZCAtIE9wdGlvbm5hbCBiYWNrZ3JvdW5kIGltYWdlIHRvXG4gICAgICogIGRpc3BsYXkgaW4gYmFja2dyb3VuZC5cbiAgICAgKiBAbmFtZSBhcmVhXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5TcGFjZVZpZXdcbiAgICAgKi9cbiAgICB0aGlzLmFyZWEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIHJlbmRlcmVkIGFyZWEgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBhcmVhV2lkdGhcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlNwYWNlVmlld1xuICAgICAqL1xuICAgIHRoaXMuYXJlYVdpZHRoID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEhlaWdodCBvZiB0aGUgcmVuZGVyZWQgYXJlYSBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGFyZWFIZWlnaHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlNwYWNlVmlld1xuICAgICAqL1xuICAgIHRoaXMuYXJlYUhlaWdodCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBNYXAgYXNzb2NpYXRpbmcgYCRzaGFwZXNgIGFuZCB0aGVpciByZWxhdGl2ZSBgcG9pbnRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICogQG5hbWUgc2hhcGVQb2ludE1hcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuU3BhY2VWaWV3XG4gICAgICovXG4gICAgdGhpcy5zaGFwZVBvaW50TWFwID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlIGEgTWFwIG9mIHRoZSAkc2hhcGVzIGFuZCB0aGVpciByZWxhdGl2ZSBsaW5lIG9iamVjdC5cbiAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUxpbmVNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLl9yZW5kZXJlZFBvaW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZW5kZXJlZExpbmVzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYGFyZWFgIHRvIGJlIHJlbmRlcmVyZWQuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9IGFyZWEgLSBPYmplY3QgZGVzY3JpYmluZyB0aGUgYXJlYSwgZ2VuZXJhbGx5IGRlZmluZWQgaW5cbiAgICogIHNlcnZlciBjb25maWd1cmF0aW9uLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYXJlYS53aWR0aCAtIFdpZHRoIG9mIHRoZSBhcmVhLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYXJlYS5oZWlnaHQgLSBIZWlnaHQgb2YgdGhlIGFyZWEuXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBhcmVhLmJhY2tncm91bmQgLSBPcHRpb25uYWwgYmFja2dyb3VuZCBpbWFnZSB0b1xuICAgICAqICBkaXNwbGF5IGluIGJhY2tncm91bmQuXG4gICAqL1xuICBzZXRBcmVhKGFyZWEpIHtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIG9uUmVuZGVyKCkge1xuICAgIHRoaXMuJHN2Z0NvbnRhaW5lciA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5zdmctY29udGFpbmVyJyk7XG4gICAgdGhpcy4kc3ZnID0gdGhpcy4kZWwucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG4gICAgdGhpcy5hZGREZWZpbml0aW9ucygpO1xuICAgIHRoaXMucmVuZGVyQXJlYSgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIG9uUmVzaXplKHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0LCBvcmllbnRhdGlvbikge1xuICAgIHN1cGVyLm9uUmVzaXplKHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0LCBvcmllbnRhdGlvbik7XG4gICAgLy8gb3ZlcnJpZGUgc2l6ZSB0byBtYXRjaCBwYXJlbnQgc2l6ZSBpZiBjb21wb25lbnQgb2YgYW5vdGhlciB2aWV3XG4gICAgdGhpcy4kZWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy4kZWwuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgdGhpcy5yZW5kZXJBcmVhKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHN2ZyBkZWZpbml0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZERlZmluaXRpb25zKCkge1xuICAgIHRoaXMuJGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdkZWZzJyk7XG5cbiAgICBjb25zdCBtYXJrZXJBcnJvdyA9IGBcbiAgICAgIDxtYXJrZXIgaWQ9XCJtYXJrZXItYXJyb3dcIiBtYXJrZXJXaWR0aD1cIjEwXCIgbWFya2VySGVpZ2h0PVwiMTBcIiByZWZYPVwiNVwiIHJlZlk9XCI1XCIgb3JpZW50PVwiYXV0b1wiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCwwIEwwLDEwIEwxMCw1IEwwLDBcIiBjbGFzcz1cIm1hcmtlci1hcnJvd1wiIC8+XG4gICAgICA8L21hcmtlcj5cbiAgICBgO1xuXG4gICAgdGhpcy4kZGVmcy5pbm5lckhUTUwgPSBtYXJrZXJBcnJvdztcbiAgICB0aGlzLiRzdmcuaW5zZXJ0QmVmb3JlKHRoaXMuJGRlZnMsIHRoaXMuJHN2Zy5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRpc3BsYXllZCBhcmVhLCBhY2NvcmRpbmcgdG8gY2hhbmdlcyBpbiBgYXJlYWAgZGVmaW5pdGlvbiBvclxuICAgKiBpZiBhIGByZXNpemVgIGV2ZW50IGhhcyBiZWVuIHRyaWdlcnJlZC5cbiAgICovXG4gIHJlbmRlckFyZWEoKSB7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuYXJlYTtcbiAgICAvLyB1c2UgYHRoaXMuJGVsYCBzaXplIGluc3RlYWQgb2YgYHRoaXMuJHBhcmVudGAgc2l6ZSB0byBpZ25vcmUgcGFyZW50IHBhZGRpbmdcbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aDtcbiAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0O1xuXG4gICAgdGhpcy5yYXRpbyA9IE1hdGgubWluKGNvbnRhaW5lcldpZHRoIC8gYXJlYS53aWR0aCwgY29udGFpbmVySGVpZ2h0IC8gYXJlYS5oZWlnaHQpO1xuICAgIGNvbnN0IHN2Z1dpZHRoID0gYXJlYS53aWR0aCAqIHRoaXMucmF0aW87XG4gICAgY29uc3Qgc3ZnSGVpZ2h0ID0gYXJlYS5oZWlnaHQgKiB0aGlzLnJhdGlvO1xuXG4gICAgY29uc3QgdG9wID0gKGNvbnRhaW5lckhlaWdodCAtIHN2Z0hlaWdodCkgLyAyO1xuICAgIGNvbnN0IGxlZnQgPSAoY29udGFpbmVyV2lkdGggLSBzdmdXaWR0aCkgLyAyO1xuXG4gICAgdGhpcy4kc3ZnQ29udGFpbmVyLnN0eWxlLndpZHRoID0gc3ZnV2lkdGggKyAncHgnO1xuICAgIHRoaXMuJHN2Z0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzdmdIZWlnaHQgKyAncHgnO1xuICAgIHRoaXMuJHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc3ZnV2lkdGgpO1xuICAgIHRoaXMuJHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHN2Z0hlaWdodCk7XG4gICAgLy8gY2VudGVyIHRoZSBzdmcgaW50byB0aGUgcGFyZW50XG4gICAgdGhpcy4kc3ZnQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLiRzdmdDb250YWluZXIuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcbiAgICB0aGlzLiRzdmdDb250YWluZXIuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuXG4gICAgdGhpcy4kc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLiRzdmcuc3R5bGUudG9wID0gYDBweGA7XG4gICAgdGhpcy4kc3ZnLnN0eWxlLmxlZnQgPSBgMHB4YDtcblxuICAgIC8vIGRpc3BsYXkgYmFja2dyb3VuZCBpZiBhbnlcbiAgICBpZiAoYXJlYS5iYWNrZ3JvdW5kKSB7XG4gICAgICB0aGlzLiRlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7YXJlYS5iYWNrZ3JvdW5kfSlgO1xuICAgICAgdGhpcy4kZWwuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJzUwJSA1MCUnO1xuICAgICAgdGhpcy4kZWwuc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9ICduby1yZXBlYXQnO1xuICAgICAgdGhpcy4kZWwuc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY29udGFpbic7XG4gICAgICAvLyBmb3JjZSAkc3ZnIHRvIGJlIHRyYW5zcGFyZW50XG4gICAgICB0aGlzLiRzdmcuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcG9pbnRzIHBvc2l0aW9uXG4gICAgZm9yIChsZXQgWyRzaGFwZSwgcG9pbnRdIG9mIHRoaXMuc2hhcGVQb2ludE1hcClcbiAgICAgIHRoaXMudXBkYXRlUG9pbnQocG9pbnQpO1xuXG4gICAgLy8gZXhwb3NlIHRoZSBzaXplIG9mIHRoZSBhcmVhIGluIHBpeGVsXG4gICAgdGhpcy5hcmVhV2lkdGggPSBzdmdXaWR0aDtcbiAgICB0aGlzLmFyZWFIZWlnaHQgPSBzdmdIZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyIGEgc3BlY2lmaWMgcG9pbnQuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRpc3BsYXlcbiAgICogcG9pbnRzIHdpdGggdXNlciBkZWZpbmVkIHNoYXBlcy4gVGhlIHNoYXBlIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGlzXG4gICAqIGluc2VydGVkIGludG8gdGhlIGBzdmdgIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAtIFBvaW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb2ludC5pZCAtIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludC54IC0gVmFsdWUgaW4gdGhlIHggYXhpcyBpbiB0aGUgYXJlYSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50LnkgLSBWYWx1ZSBpbiB0aGUgeSBheGlzIGluIHRoZSBhcmVhIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BvaW50LnJhZGl1cz0wLjNdIC0gUmFkaXVzIG9mIHRoZSBwb2ludCAocmVsYXRpdmUgdG8gdGhlXG4gICAqICBhcmVhIHdpZHRoIGFuZCBoZWlnaHQpLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BvaW50LmNvbG9yPXVuZGVmaW5lZF0gLSBPcHRpb25uYWwgY29sb3Igb2YgdGhlIHBvaW50LlxuICAgKi9cbiAgcmVuZGVyUG9pbnQocG9pbnQsICRzaGFwZSA9IG51bGwpIHtcbiAgICBpZiAoJHNoYXBlID09PSBudWxsKSB7XG4gICAgICAkc2hhcGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdjaXJjbGUnKTtcbiAgICAgICRzaGFwZS5jbGFzc0xpc3QuYWRkKCdwb2ludCcpO1xuICAgIH1cblxuICAgICRzaGFwZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCBwb2ludC5pZCk7XG4gICAgJHNoYXBlLnNldEF0dHJpYnV0ZSgnY3gnLCBgJHtwb2ludC54ICogdGhpcy5yYXRpb31gKTtcbiAgICAkc2hhcGUuc2V0QXR0cmlidXRlKCdjeScsIGAke3BvaW50LnkgKiB0aGlzLnJhdGlvfWApO1xuICAgICRzaGFwZS5zZXRBdHRyaWJ1dGUoJ3InLCBwb2ludC5yYWRpdXMgfHzCoDgpOyAvLyByYWRpdXMgaXMgcmVsYXRpdmUgdG8gYXJlYSBzaXplXG5cbiAgICBpZiAocG9pbnQuY29sb3IpXG4gICAgICAkc2hhcGUuc3R5bGUuZmlsbCA9IHBvaW50LmNvbG9yO1xuXG4gICAgY29uc3QgbWV0aG9kID0gcG9pbnQuc2VsZWN0ZWQgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICAgICRzaGFwZS5jbGFzc0xpc3RbbWV0aG9kXSgnc2VsZWN0ZWQnKTtcblxuICAgIHJldHVybiAkc2hhcGU7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSBhbGwgdGhlIGV4aXN0aW5nIHBvaW50cyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIC0gUG9pbnRzIHRvIHJlbmRlci5cbiAgICovXG4gIHNldFBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLmNsZWFyUG9pbnRzKCk7XG4gICAgdGhpcy5hZGRQb2ludHMocG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIHBvaW50cy5cbiAgICovXG4gIGNsZWFyUG9pbnRzKCkge1xuICAgIGZvciAobGV0IGlkIG9mIHRoaXMuX3JlbmRlcmVkUG9pbnRzLmtleXMoKSlcbiAgICAgIHRoaXMuZGVsZXRlUG9pbnQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgcG9pbnRzIHRvIHRoZSBhcmVhLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvaW50cyAtIE5ldyBwb2ludHMgdG8gYWRkIHRvIHRoZSB2aWV3LlxuICAgKi9cbiAgYWRkUG9pbnRzKHBvaW50cykge1xuICAgIHBvaW50cy5mb3JFYWNoKHBvaW50ID0+IHRoaXMuYWRkUG9pbnQocG9pbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgcG9pbnQgdG8gdGhlIGFyZWEuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAtIE5ldyBwb2ludCB0byBhZGQgdG8gdGhlIHZpZXcuXG4gICAqL1xuICBhZGRQb2ludChwb2ludCkge1xuICAgIGNvbnN0ICRzaGFwZSA9IHRoaXMucmVuZGVyUG9pbnQocG9pbnQpO1xuICAgIHRoaXMuJHN2Zy5hcHBlbmRDaGlsZCgkc2hhcGUpO1xuICAgIHRoaXMuX3JlbmRlcmVkUG9pbnRzLnNldChwb2ludC5pZCwgJHNoYXBlKTtcbiAgICAvLyBtYXAgZm9yIGVhc2llciByZXRyaWV2aW5nIG9mIHRoZSBwb2ludFxuICAgIHRoaXMuc2hhcGVQb2ludE1hcC5zZXQoJHNoYXBlLCBwb2ludCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGEgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAtIFBvaW50IHRvIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZVBvaW50KHBvaW50KSB7XG4gICAgY29uc3QgJHNoYXBlID0gdGhpcy5fcmVuZGVyZWRQb2ludHMuZ2V0KHBvaW50LmlkKTtcbiAgICB0aGlzLnJlbmRlclBvaW50KHBvaW50LCAkc2hhcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkIC0gSWQgb2YgdGhlIHBvaW50IHRvIGRlbGV0ZS5cbiAgICovXG4gIGRlbGV0ZVBvaW50KGlkKSB7XG4gICAgY29uc3QgJHNoYXBlID0gdGhpcy5fcmVuZGVyZWRQb2ludHMuZ2V0KGlkKTtcbiAgICB0aGlzLiRzdmcucmVtb3ZlQ2hpbGQoJHNoYXBlKTtcbiAgICB0aGlzLl9yZW5kZXJlZFBvaW50cy5kZWxldGUoaWQpO1xuICAgIC8vIG1hcCBmb3IgZWFzaWVyIHJldHJpZXZpbmcgb2YgdGhlIHBvaW50XG4gICAgdGhpcy5zaGFwZVBvaW50TWFwLmRlbGV0ZSgkc2hhcGUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwYWNlVmlldztcbiIsImltcG9ydCBWaWV3IGZyb20gJy4uL3ZpZXdzL1ZpZXcnO1xuXG5jb25zdCBkZWZhdWx0VGVtcGxhdGUgPSBgXG4gIDxkaXYgY2xhc3M9XCJzZWN0aW9uLXNxdWFyZSBmbGV4LW1pZGRsZVwiPjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1mbG9hdCBmbGV4LW1pZGRsZVwiPjwvZGl2PlxuYDtcblxuLyoqXG4gKiBBIHZpZXcgdGhhdCBkZWZpbmUgYSBzcXVhcmVkIHpvbmUgb2YgbWF4aW11bSBzaXplIG9uIHRoZSB0b3Agb2YgdGhlIHNjcmVlblxuICogaW4gYHBvcnRyYWl0YCBvcmllbnRhdGlvbiBvciBvbiB0aGUgbGVmdCBvZiB0aGUgc2NyZWVuIGluICdsYW5kc2NhcGUnXG4gKiBvcmllbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGUgLSBUZW1wbGF0ZSBvZiB0aGUgdmlldy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZW50IC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZhcmlhYmxlcyB1c2VkIHRvIHBvcHVsYXRlXG4gKiAgdGhlIHRlbXBsYXRlLiB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXcjY29udGVudH0uXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRzIC0gTGlzdGVuZXJzIHRvIGluc3RhbGwgaW4gdGhlIHZpZXdcbiAqICB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXcjZXZlbnRzfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBvZiB0aGUgdmlldy5cbiAqICB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXcjb3B0aW9uc30uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICovXG5jbGFzcyBTcXVhcmVkVmlldyBleHRlbmRzIFZpZXcge1xuICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgY29udGVudCA9IHt9LCBldmVudHMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGVtcGxhdGUgPSAhdGVtcGxhdGUgPyBkZWZhdWx0VGVtcGxhdGUgOiB0ZW1wbGF0ZTtcblxuICAgIHN1cGVyKHRlbXBsYXRlLCBjb250ZW50LCBldmVudHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIG9uUmVuZGVyKCkge1xuICAgIHRoaXMuJHNxdWFyZSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5zZWN0aW9uLXNxdWFyZScpO1xuICAgIHRoaXMuJGZsb2F0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnNlY3Rpb24tZmxvYXQnKTtcblxuICAgIHRoaXMuJHNxdWFyZS5zdHlsZS5mbG9hdCA9ICdsZWZ0JztcbiAgICB0aGlzLiRmbG9hdC5zdHlsZS5mbG9hdCA9ICdsZWZ0JztcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBvblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pIHtcbiAgICBzdXBlci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuXG4gICAgbGV0IHNpemUsIGZsb2F0SGVpZ2h0LCBmbG9hdFdpZHRoO1xuXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAncG9ydHJhaXQnKSB7XG4gICAgICBzaXplID0gdmlld3BvcnRXaWR0aDtcbiAgICAgIGZsb2F0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgLSBzaXplO1xuICAgICAgZmxvYXRXaWR0aCA9IHZpZXdwb3J0V2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSB2aWV3cG9ydEhlaWdodDtcbiAgICAgIGZsb2F0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQ7XG4gICAgICBmbG9hdFdpZHRoID0gdmlld3BvcnRXaWR0aCAtIHNpemU7XG4gICAgfVxuXG4gICAgdGhpcy4kc3F1YXJlLnN0eWxlLndpZHRoID0gYCR7c2l6ZX1weGA7XG4gICAgdGhpcy4kc3F1YXJlLnN0eWxlLmhlaWdodCA9IGAke3NpemV9cHhgO1xuXG4gICAgdGhpcy4kZmxvYXQuc3R5bGUud2lkdGggPSBgJHtmbG9hdFdpZHRofXB4YDtcbiAgICB0aGlzLiRmbG9hdC5zdHlsZS5oZWlnaHQgPSBgJHtmbG9hdEhlaWdodH1weGA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3F1YXJlZFZpZXc7XG4iLCJpbXBvcnQgeyBhdWRpb0NvbnRleHQgfSBmcm9tICd3YXZlcy1hdWRpbyc7XG5pbXBvcnQgeyBTdXBlckxvYWRlciB9IGZyb20gJ3dhdmVzLWxvYWRlcnMnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5cbi8qKlxuICogQVBJIG9mIGEgY29tcGxpYW50IHZpZXcgZm9yIHRoZSBgYXVkaW8tYnVmZmVyLW1hbmFnZXJgIHNlcnZpY2UuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICogQGludGVyZmFjZSBBYnN0cmFjdEF1ZGlvQnVmZmVyTWFuYWdlclZpZXdcbiAqIEBleHRlbmRzIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFZpZXdcbiAqIEBhYnN0cmFjdFxuICovXG4vKipcbiAqIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIG9mIHRoZSB2aWV3IHdpdGggdGhlIGdpdmVuIHJhdGlvLlxuICpcbiAqIEBuYW1lIHNldFByb2dyZXNzUmF0aW9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQWJzdHJhY3RBdWRpb0J1ZmZlck1hbmFnZXJWaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvIC0gUHJvZ3Jlc3MgcmF0aW8gb2YgdGhlIGxvYWRlZCBhc3NldHMgKGJldHdlZW4gMCBhbmQgMSkuXG4gKi9cblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOmF1ZGlvLWJ1ZmZlci1tYW5hZ2VyJztcbmNvbnN0IGxvZyA9IGRlYnVnKCdzb3VuZHdvcmtzOnNlcnZpY2VzOmF1ZGlvLWJ1ZmZlci1tYW5hZ2VyJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5MaXN0cyhhKSB7XG4gIGNvbnN0IHJldCA9IFtdO1xuICBjb25zdCBmdW4gPSAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwuZm9yRWFjaChmdW4pIDogcmV0LnB1c2godmFsKTtcbiAgZnVuKGEpO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjbG9uZVBhdGhPYmoodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGxldCBjbG9uZSA9IG51bGw7XG5cbiAgICBpZiAoY2xhc3NOYW1lID09PSAnT2JqZWN0JylcbiAgICAgIGNsb25lID0ge307XG4gICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSAnQXJyYXknKVxuICAgICAgY2xvbmUgPSBbXTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWUpXG4gICAgICBjbG9uZVtrZXldID0gY2xvbmVQYXRoT2JqKHZhbHVlW2tleV0pO1xuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBjb25zdCByZWdleHAgPSAvXFwuW2EtekEtWjAtOV17Myw0fSQvO1xuXG4vLyBzdXBwb3J0ZWQgbWVkaWEgZm9ybWF0cyArIGpzb25cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvU3VwcG9ydGVkX21lZGlhX2Zvcm1hdHNcbmNvbnN0IHJlZ2V4cCA9IC9cXC4od2F2fG1wM3xtcDR8YWFjfGFpZnxhaWZmfG9nZ3x3ZWJtfGpzb24pJC9pO1xuXG5mdW5jdGlvbiBpc0ZpbGVQYXRoKHN0cikge1xuICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIHJlZ2V4cC50ZXN0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBpc0RpclNwZWMob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5wYXRoID09PSAnc3RyaW5nJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29tcG9zZVBhdGhPYmoob2JqLCBwYXRoTGlzdCwgcmVmTGlzdCwgZGlycyA9IGZhbHNlKSB7XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgaWYgKCghZGlycyAmJiBpc0ZpbGVQYXRoKHZhbHVlKSkgfHwgKGRpcnMgJiYgaXNEaXJTcGVjKHZhbHVlKSkpIHtcbiAgICAgIGNvbnN0IHJlZiA9IHsgb2JqLCBrZXkgfTtcbiAgICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgICBpZiAoIWRpcnMpXG4gICAgICAgIGluZGV4ID0gcGF0aExpc3QuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGF0aExpc3QucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgICByZWZMaXN0W2luZGV4XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICByZWZMaXN0W2luZGV4XS5wdXNoKHJlZik7XG5cbiAgICAgIG9ialtrZXldID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRlY29tcG9zZVBhdGhPYmoodmFsdWUsIHBhdGhMaXN0LCByZWZMaXN0LCBkaXJzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVSZWZMaXN0KHJlZkxpc3QsIGxvYWRlZE9iakxpc3QpIHtcbiAgY29uc3QgbGVuZ3RoID0gcmVmTGlzdC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCAhPT0gbG9hZGVkT2JqTGlzdC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFske1NFUlZJQ0VfSUR9XSBMb2FkZWQgQnVmZmVycyBkbyBub3QgbWF0Y2ggZmlsZSBkZWZpbmlvbmApO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlZnMgPSByZWZMaXN0W2ldO1xuXG4gICAgZm9yIChsZXQgaiA9IDAsIGwgPSByZWZzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgY29uc3QgcmVmID0gcmVmc1tqXTtcbiAgICAgIGNvbnN0IG9iaiA9IHJlZi5vYmo7XG4gICAgICBjb25zdCBrZXkgPSByZWYua2V5O1xuXG4gICAgICBvYmpba2V5XSA9IGxvYWRlZE9iakxpc3RbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iakZyb21QYXRoTGlzdChwYXRoTGlzdCwgY29tbW9uUGF0aCkge1xuICBsZXQgb2JqID0gW107XG5cbiAgZm9yIChsZXQgcGF0aCBvZiBwYXRoTGlzdCkge1xuICAgIGxldCBzdWJQYXRoSW5kZXggPSBwYXRoLmluZGV4T2YoY29tbW9uUGF0aCk7XG5cbiAgICBpZiAoc3ViUGF0aEluZGV4ID49IDApIHtcbiAgICAgIHN1YlBhdGhJbmRleCArPSBjb21tb25QYXRoLmxlbmd0aDtcblxuICAgICAgaWYgKHBhdGhbc3ViUGF0aEluZGV4XSA9PT0gJy8nKVxuICAgICAgICBzdWJQYXRoSW5kZXgrKztcblxuICAgICAgY29uc3Qgc3ViUGF0aCA9IHBhdGguc3Vic3RyaW5nKHN1YlBhdGhJbmRleCk7XG4gICAgICBjb25zdCBub2RlcyA9IHN1YlBhdGguc3BsaXQoJy8nKTtcbiAgICAgIGNvbnN0IGRlcHRoID0gbm9kZXMubGVuZ3RoO1xuICAgICAgbGV0IHJlZiA9IG9iajtcbiAgICAgIGxldCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwdGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYgKHJlZltrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmVmW2tleV0gPSBbXTtcblxuICAgICAgICByZWYgPSByZWZba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmVmLnB1c2gocGF0aCk7XG4gICAgfVxuXG4gICAgLy8gdHJhbnNmb3JtIGVtcHR5IGFycmF5IHRvIG9iamVjdFxuICAgIGlmIChvYmoubGVuZ3RoID09PSAwKVxuICAgICAgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHByZWZpeFBhdGhzKHBhdGhMaXN0LCBwcmVmaXgpIHtcbiAgLy8gdGVzdCBhYnNvbHV0ZSB1cmxzIChvciBwcm90b2NvbCByZWxhdGl2ZSlcbiAgY29uc3QgaXNBYnNvbHV0ZSA9IC9eaHR0cHM/OlxcL1xcL3xeXFwvXFwvL2k7XG5cbiAgcGF0aExpc3QgPSBwYXRoTGlzdC5tYXAoKHBhdGgpID0+IHtcbiAgICBpZiAoaXNBYnNvbHV0ZS50ZXN0KHBhdGgpIHx8IHByZWZpeCA9PT0gJy8nKVxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHByZWZpeCArIHBhdGg7XG4gIH0pO1xuXG4gIHJldHVybiBwYXRoTGlzdDtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYCdhdWRpby1idWZmZXItbWFuYWdlcidgIHNlcnZpY2UuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGFsbG93cyB0byBwcmVsb2FkIGZpbGVzIGFuZCBzdG9yZSB0aGVtIGludG8gYnVmZmVyc1xuICogYmVmb3JlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGV4cGVyaWVuY2UuIEF1ZGlvIGZpbGVzIHdpbGwgYmUgY29udmVydGVkIGFuZFxuICogc3RvcmVkIGludG8gQXVkaW9CdWZmZXIgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBvcHRpb25zLmFzc2V0c0RvbWFpbiAtIFByZWZpeCBjb25jYXRlbmF0ZWQgdG8gYWxsXG4gKiAgZ2l2ZW4gcGF0aHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5maWxlcyAtIERlZmluaXRpb24gb2YgZmlsZXMgdG8gbG9hZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRpcmVjdG9yaWVzIC0gRGVmaW5pdGlvbiBvZiBkaXJlY3RvcmllcyB0byBsb2FkLlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBvcHRpb25zLmRpcmVjdG9yaWVzIC0gTGlzdCBvZiBkaXJlY3RvcmllcyB0byBsb2FkLlxuICogQHBhcmFtIHtTdHJpbmd8bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkZpbGVTeXN0ZW1+TGlzdENvbmZpZ30gW29wdGlvbnMuZGlyZWN0b3JpZXM9bnVsbF0gLVxuICogIExvYWQgYWxsIHRoZSBmaWxlcyBpbiBwYXJ0aWN1bGFyIGRpcmVjdG9yaWVzLiBJZiBzZXR0ZWQgdGhpcyBvcHRpb24gcmVsaWVzXG4gKiAgb24gdGhlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuRmlsZVN5c3RlbX0gd2hpY2ggaXRzZWxmIHJlbGllcyBvblxuICogIGl0cyBzZXJ2ZXIgY291bnRlcnBhcnQsIHRoZSBhdWRpby1idWZmZXItbWFuYWdlciBjYW4gdGhlbiBubyBsb25nZXIgYmVcbiAqICBjb25zaWRlcmVkIGFzIGEgY2xpZW50LW9ubHkgc2VydmljZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXhhbXBsZVxuICogLy8gcmVxdWlyZSBhbmQgY29uZmlndXJlIHRoZSBgYXVkaW8tYnVmZmVyLW1hbmFnZXJgIGluc2lkZSB0aGUgZXhwZXJpZW5jZVxuICogLy8gY29uc3RydWN0b3JcbiAqIC8vIERlZmluaW5nIGEgc2luZ2xlIGFycmF5IG9mIGF1ZGlvIGZpbGVzIHJlc3VsdHMgaW4gYSBzaW5nbGVcbiAqIC8vIGFycmF5IG9mIGF1ZGlvIGJ1ZmZlcnMgYXNzb2NpYXRlZCB0byB0aGUgaWRlbnRpZmllciBgZGVmYXVsdGAuXG4gKlxuICogLy8gVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgd2F5cyB0byBzcGVjaWZ5IHRoZSBmaWxlcyB0byBiZSBsb2FkZWQgYW5kIHRoZVxuICogLy8gZGF0YSBzdHJ1Y3R1cmUgaW4gd2hpY2ggdGhlIGxvYWRlZCBkYXRhIG9iamVjdHMgYXJlIGFycmFuZ2VkOlxuICogLy9cbiAqIC8vICgxLikgV2l0aCB0aGUgJ2ZpbGVzJyBvcHRpb24sIHRoZSBmaWxlcyBhbmQgc3RydWN0dXJlIGFyZSBkZWZpbmVkIGJ5IGFuXG4gKiAvLyBvYmplY3Qgb2YgYW55IGRlcHRoIHRoYXQgY29udGFpbnMgZmlsZSBwYXRocy4gQWxsIHNwZWNpZmllZCBmaWxlcyBhcmVcbiAqIC8vIGxvYWRlZCBhbmQgdGhlIGxvYWRlZCBkYXRhIG9iamVjdHMgYXJlIHN0b3JlZCBpbnRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZVxuICogLy8gc3RydWN0dXJlIGFzIHRoZSBkZWZpbml0aW9uIG9iamVjdC5cbiAqXG4gKiB0aGlzLmF1ZGlvQnVmZmVyTWFuYWdlciA9IHRoaXMucmVxdWlyZSgnYXVkaW8tYnVmZmVyLW1hbmFnZXInLCB7IGZpbGVzOiBbXG4gKiAgICdzb3VuZHMvZHJ1bXMva2ljay5tcDMnLFxuICogICAnc291bmRzL2RydW1zL3NuYXJlLm1wMydcbiAqIF19KTtcbiAqXG4gKiB0aGlzLmF1ZGlvQnVmZmVyTWFuYWdlciA9IHRoaXMucmVxdWlyZSgnYXVkaW8tYnVmZmVyLW1hbmFnZXInLCB7IGZpbGVzOiB7XG4gKiAgIGtpY2s6ICdzb3VuZHMva2lja180NGtIei5tcDMnLFxuICogICBzbmFyZTogJ3NvdW5kcy84MDhzbmFyZS5tcDMnXG4gKiB9fSk7XG4gKlxuICogdGhpcy5hdWRpb0J1ZmZlck1hbmFnZXIgPSB0aGlzLnJlcXVpcmUoJ2F1ZGlvLWJ1ZmZlci1tYW5hZ2VyJywgeyBmaWxlczoge1xuICogICBsYXRpbjoge1xuICogICAgIGF1ZGlvOiAnbG9vcHMvc2hlaWxhLWUtcmFzcGJlcnJ5Lm1wMycsXG4gKiAgICAgbWFya2VyczogJ2xvb3BzL3NoZWlsYS1lLXJhc3BiZXJyeS1tYXJrZXJzLmpzb24nLFxuICogICB9LFxuICogICBqYXp6OiB7XG4gKiAgICAgYXVkaW86ICdsb29wcy9udXNzYmF1bS1zaHVmZmxlLm1wMycsXG4gKiAgICAgbWFya2VyczogJ2xvb3BzL251c3NiYXVtLXNodWZmbGUtbWFya2Vycy5qc29uJyxcbiAqICAgfSxcbiAqIH19KTtcbiAqXG4gKiB0aGlzLmF1ZGlvQnVmZmVyTWFuYWdlciA9IHRoaXMucmVxdWlyZSgnYXVkaW8tYnVmZmVyLW1hbmFnZXInLCB7IGZpbGVzOiB7XG4gKiAgIGluc3RydW1lbnRzOiBbXG4gKiAgICAgJ3NvdW5kcy9pbnN0cnVtZW50cy9raWNrXzQ0a0h6Lm1wMycsXG4gKiAgICAgJ3NvdW5kcy9pbnN0cnVtZW50cy84MDhzbmFyZS5tcDMnXSxcbiAqICAgbG9vcHM6IFtcbiAqICAgICAnc291bmRzL2xvb3BzL3NoZWlsYS1lLXJhc3BiZXJyeS5tcDMnLFxuICogICAgICdzb3VuZHMvbG9vcHMvbnVzc2JhdW0tc2h1ZmZsZS5tcDMnXSxcbiAqIH19KTtcbiAqXG4gKiAvLygyLikgVGhlICdkaXJlY3Rvcmllcycgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGxvYWQgdGhlIGZpbGVzIG9mIGFcbiAqIC8vIGdpdmVuIGRpcmVjdG9yeS4gRWFjaCBkaXJlY3RvcnkgaXMgc3BlY2lmaWVkIGJ5IGFuIG9iamVjdCB0aGF0IGhhcyBhXG4gKiAvLyBwcm9wZXJ0eSAncGF0aCcgd2l0aCB0aGUgZGlyZWN0b3J5IHBhdGggYW5kIG9wdGlvbmFsbHkgdGhlIGtleXNcbiAqIC8vICdyZWN1cnNpdmUnIChzcGVjaWZ5aW5nIHdoZXRoZXIgdGhlIGRpcmVjdG9yeSdzIHN1Yi1kaXJlY3RvcmllcyBhcmVcbiAqIC8vIGNvbnNpZGVyZWQpIGFuZCBhIGtleSAnbWF0Y2gnIChzcGVjaWZ5aW5nIGEgcmVnZXhwIHRvIHNlbGVjdCB0aGUgZmlsZXNcbiAqIC8vIGluIHRoZSBnaXZlbiBkaXJlY3RvcnkpLlxuICpcbiAqIC8vIFdpdGggdGhlIG9wdGlvbiAncmVjdXJzaXZlJyBzZXQgdG8gZmFsc2UsIGFsbCAobWF0Y2hpbmcpIGZpbGVzXG4gKiAvLyBpbiBhIGdpdmVuIGRpcmVjdG9yaXkgYXJlIGxvYWRlZCBpbnRvIGFuIGFycmF5cyBvZiBvYmplY3RzIHdpdGhvdXRcbiAqIC8vIGNvbnNpZGVyaW5nIHN1Yi1kaXJlY3Rvcmllcy4gVGhlIGFycmF5cyBvZiBsb2FkZWQgZGF0YSBvYmplY3RzIGFyZVxuICogLy8gYXJyYW5nZWQgaW4gdGhlIHNhbWUgZGF0YSBzdHJ1Y3R1cmUgYXMgdGhlIGRlZmluaXRpb24gb2JqZWN0LlxuICpcbiAqIHRoaXMuYXVkaW9CdWZmZXJNYW5hZ2VyID0gdGhpcy5yZXF1aXJlKCdhdWRpby1idWZmZXItbWFuYWdlcicsIHtcbiAqICAgZGlyZWN0b3JpZXM6IHtcbiAqICAgICBpbnN0cnVtZW50czogeyBwYXRoOiAnc291bmRzL2luc3RydW1lbnRzJywgcmVjdXJzaXZlOiBmYWxzZSB9LFxuICogICAgIGxvb3BzOiB7IHBhdGg6ICdzb3VuZHMvaW5zdHJ1bWVudHMnLCByZWN1cnNpdmU6IGZhbHNlIH0sXG4gKiAgIH0sXG4gKiB9KTtcbiAqXG4gKiAvLyBXaGVuICdyZWN1cnNpdmUnIGlzIHNldCB0byB0cnVlLCBhbGwgKG1hdGNoaW5nKSBmaWxlcyBpbiB0aGUgZ2l2ZW5cbiAqIC8vIGRpcmVjdG9yaWVzIGFuZCB0aGVpciBzdWItZGlyZWN0b3JpZXMgYXJlIGxvYWRlZCBhcyBhcnJheXMgb2Ygb2JqZWN0cy5cbiAqIC8vIFdpdGggdGhlIG9wdGlvbiAnZmxhdHRlbicgc2V0IHRvIHRydWUsIGFsbCBmaWxlcyBpbiB0aGUgZGVmaW5lZCBkaXJlY3RvcnlcbiAqIC8vIGFuZCBpdHMgc3ViLWRpcmVjdG9yaWVzIGFyZSBsb2FkZWQgaW50byBhIHNpbmdsZSBhcnJheS4gV2hlbiB0aGUgb3B0aW9uXG4gKiAvLyAnZmxhdHRlbicgc2V0IHRvIGZhbHNlLCB0aGUgZmlsZXMgb2YgZWFjaCBzdWItZGlyZWN0b3J5IGFyZSBhc3NlbWJsZWRcbiAqIC8vIGludG8gYW4gYXJyYXkgYW5kIGFsbCBvZiB0aGVzZSBhcnJheXMgYXJlIGFycmFuZ2VkIHRvIGEgZGF0YSBzdHJ1Y3R1cmVcbiAqIC8vIHRoYXQgcmVwcm9kdWNlcyB0aGUgc3ViLWRpcmVjdG9yeSB0cmVlIG9mIHRoZSBkZWZpbmVkIGRpcmVjdG9yaWVzLlxuICogLy8gVGhlIHJlc3VsdGluZyBkYXRhIHN0cnVjdHVyZSBjb3JyZXNwb25kcyB0byB0aGUgc3RydWN0dXJlIG9mIHRoZVxuICogLy8gZGVmaW5pdGlvbiBvYmplY3QgZXh0ZW5kZWQgYnkgdGhlIGRlZmluZWQgc3ViLWRpcmVjdG9yeSB0cmVlcy5cbiAqXG4gKiAvLyBUaGUgZm9sbG93aW5nIG9wdGlvbiByZXN1bHRzIGluIGEgc2luZ2xlIGFycmF5IG9mIHByZS1sb2FkZWQgZmlsZXM6XG4gKiB0aGlzLmF1ZGlvQnVmZmVyTWFuYWdlciA9IHRoaXMucmVxdWlyZSgnYXVkaW8tYnVmZmVyLW1hbmFnZXInLCB7XG4gKiAgIGRpcmVjdG9yaWVzOiB7XG4gKiAgICAgcGF0aDogJ3NvdW5kcycsXG4gKiAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICogICAgIGZsYXR0ZW46IHRydWUsXG4gKiAgICAgbWF0Y2g6IC9cXC5tcDMvLFxuICogICB9LFxuICogfSk7XG4gKlxuICogLy8gVGhpcyB2YXJpYW50IHJlc3VsdHMgaW4gYSBkYXRhIHN0cnVjdHVyZSB0aGF0IHJlcHJvZHVjZXMgdGhlXG4gKiAvLyBzdWItZGlyZWN0b3J5IHRyZWUgb2YgdGhlICdzb3VuZHMnIGRpcmVjdG9yeTpcbiAqIHRoaXMuYXVkaW9CdWZmZXJNYW5hZ2VyID0gdGhpcy5yZXF1aXJlKCdhdWRpby1idWZmZXItbWFuYWdlcicsIHtcbiAqICAgZGlyZWN0b3JpZXM6IHtcbiAqICAgICBwYXRoOiAnc291bmRzJyxcbiAqICAgICByZWN1cnNpdmU6IHRydWUsXG4gKiAgICAgbWF0Y2g6IC9cXC5tcDMvLFxuICogICB9LFxuICogfSk7XG4gKlxuICogLy8gVGhlIGxvYWRlZCBvYmplY3RzIGNhbiBiZSByZXRyaWV2ZWQgYWNjb3JkaW5nIHRvIHRoZWlyIGRlZmluaXRpb24sIGFzIGZvciBleGFtcGxlIDpcbiAqIGNvbnN0IGtpY2tCdWZmZXIgPSB0aGlzLmF1ZGlvQnVmZmVyTWFuYWdlci5kYXRhLmtpY2s7XG4gKiBjb25zdCBhdWRpb0J1ZmZlciA9IHRoaXMuYXVkaW9CdWZmZXJNYW5hZ2VyLmRhdGEubGF0aW4uYXVkaW87XG4gKiBjb25zdCBtYXJrZXJBcnJheSA9IHRoaXMuYXVkaW9CdWZmZXJNYW5hZ2VyLmRhdGEuamF6ei5tYXJrZXJzO1xuICogY29uc3Qgc25hcmVCdWZmZXIgPSB0aGlzLmF1ZGlvQnVmZmVyTWFuYWdlci5kYXRhLmluc3RydW1lbnRzWzFdO1xuICogY29uc3QgbnVzc2JhdW1Mb29wID0gdGhpcy5hdWRpb0J1ZmZlck1hbmFnZXIuZGF0YS5sb29wc1sxXTtcbiAqL1xuY2xhc3MgQXVkaW9CdWZmZXJNYW5hZ2VyIGV4dGVuZHMgU2VydmljZSB7XG4gIC8qKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbmNpYXRlZCBtYW51YWxseV8gKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgZmFsc2UpO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBhc3NldHNEb21haW46ICcnLFxuICAgICAgZmlsZXM6IG51bGwsXG4gICAgICBkaXJlY3RvcmllczogbnVsbCxcbiAgICAgIGF1ZGlvV3JhcFRhaWw6IDAsXG4gICAgICB2aWV3UHJpb3JpdHk6IDQsXG4gICAgICBkZWJ1ZzogZmFsc2UsIC8vIGlmIHNldCB0byB0cnVlLCB0aGUgc2VydmljZSBuZXZlciBcInJlYWR5XCIgdG8gZGVidWcgdGhlIHZpZXdcbiAgICB9O1xuXG4gICAgdGhpcy52aWV3ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERhdGEgc3RydWN0dXJlIGNvcnJlcG9uZGluZyB0byB0aGUgc3RydWN0dXJlIG9mIHJlcXVlc3RlZCBmaWxlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuXG4gICAgY29uc3QgZGlyZWN0b3JpZXMgPSB0aGlzLm9wdGlvbnMuZGlyZWN0b3JpZXM7XG5cbiAgICBpZiAoZGlyZWN0b3JpZXMgIT09IG51bGwpXG4gICAgICB0aGlzLl9maWxlU3lzdGVtID0gdGhpcy5yZXF1aXJlKCdmaWxlLXN5c3RlbScpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0YXJ0KCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG5cbiAgICB0aGlzLnNob3coKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsZXMgfHwgdGhpcy5vcHRpb25zLmRpcmVjdG9yaWVzKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZpbGVzKVxuICAgICAgICB0aGlzLmxvYWRGaWxlcyh0aGlzLm9wdGlvbnMuZmlsZXMsIHRoaXMudmlldyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyZWN0b3JpZXMpXG4gICAgICAgIHRoaXMubG9hZERpcmVjdG9yaWVzKHRoaXMub3B0aW9ucy5kaXJlY3RvcmllcywgdGhpcy52aWV3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcgPT09IGZhbHNlKVxuICAgICAgc3VwZXIucmVhZHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGZpbGVzIGRlZmluZWQgYXMgYSBzZXQgb2YgZmlsZSBwYXRocy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZk9iaiAtIERlZmluaXRpb24gb2YgZmlsZXMgdG8gbG9hZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdGluZyBkYXRhIHN0cnVjdHVyZVxuICAgKi9cbiAgbG9hZEZpbGVzKGRlZk9iaiwgdmlldyA9IG51bGwpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHBhdGhMaXN0ID0gW107XG4gICAgICBsZXQgcmVmTGlzdCA9IFtdO1xuXG4gICAgICBpZiAodHlwZW9mIGRlZk9iaiA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRlZk9iaiA9IFtkZWZPYmpdO1xuXG4gICAgICAvLyBjcmVhdGUgZGF0YSBvYmplY3QgY29weWluZyB0aGUgc3RyY3V0dXJlIG9mIHRoZSBmaWxlIGRlZmluaW9uIG9iamVjdFxuICAgICAgY29uc3QgZGF0YU9iaiA9IGNsb25lUGF0aE9iaihkZWZPYmopO1xuICAgICAgZGVjb21wb3NlUGF0aE9iaihkYXRhT2JqLCBwYXRoTGlzdCwgcmVmTGlzdCwgZmFsc2UpO1xuXG4gICAgICAvLyBwcmVmaXggcmVsYXRpdmUgcGF0aHMgd2l0aCBhc3NldHNEb21haW5cbiAgICAgIHBhdGhMaXN0ID0gcHJlZml4UGF0aHMocGF0aExpc3QsIHRoaXMub3B0aW9ucy5hc3NldHNEb21haW4pO1xuXG4gICAgICBsb2cocGF0aExpc3QsIHJlZkxpc3QpO1xuXG4gICAgICAvLyBsb2FkIGZpbGVzXG4gICAgICBpZiAocGF0aExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgU3VwZXJMb2FkZXIoKTtcbiAgICAgICAgbG9hZGVyLnNldEF1ZGlvQ29udGV4dChhdWRpb0NvbnRleHQpO1xuXG4gICAgICAgIGlmICh2aWV3ICYmIHZpZXcuc2V0UHJvZ3Jlc3NSYXRpbykge1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzUGVyRmlsZSA9IHBhdGhMaXN0Lm1hcCgoKSA9PiAwKTsgLy8gdHJhY2sgZmlsZXMgbG9hZGluZyBwcm9ncmVzc1xuXG4gICAgICAgICAgbG9hZGVyLnByb2dyZXNzQ2FsbGJhY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgcHJvZ3Jlc3NQZXJGaWxlW2UuaW5kZXhdID0gZS52YWx1ZTtcblxuICAgICAgICAgICAgbGV0IHRvdGFsUHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyZXNzUGVyRmlsZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyArPSBwcm9ncmVzc1BlckZpbGVbaV07XG5cbiAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3MgLz0gcHJvZ3Jlc3NQZXJGaWxlLmxlbmd0aDtcblxuICAgICAgICAgICAgdmlldy5zZXRQcm9ncmVzc1JhdGlvKHRvdGFsUHJvZ3Jlc3MpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkZXJcbiAgICAgICAgICAubG9hZChwYXRoTGlzdCwge1xuICAgICAgICAgICAgd3JhcEFyb3VuZEV4dGVudGlvbjogdGhpcy5vcHRpb25zLmF1ZGlvV3JhcFRhaWwsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigobG9hZGVkT2JqTGlzdCkgPT4ge1xuICAgICAgICAgICAgLy8gcGxhY2UgbG9hZGVkIG9iamVjdHMgKGkuZS4gYXVkaW8gYnVmZmVycyBhbmQganNvbiBmaWxlcykgaW50byB0aGUgc3RydWN0dXJlIG9mIHRoZSBmaWxlIGRlZmluaXRpb24gb2JqZWN0XG4gICAgICAgICAgICBwb3B1bGF0ZVJlZkxpc3QocmVmTGlzdCwgbG9hZGVkT2JqTGlzdCk7XG5cbiAgICAgICAgICAgIC8vIG1peCBsb2FkZWQgb2JqZWN0cyBpbnRvIGRhdGFcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5kYXRhLCBkYXRhT2JqKTtcbiAgICAgICAgICAgIHRoaXMucmVhZHkoKTtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YU9iaik7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlYWR5KCk7XG4gICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBmaWxlcyBkZWZpbmVkIGFzIGEgc2V0IG9mIGRpcmVjdG9yeSBwYXRocy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZk9iaiAtIERlZmluaXRpb24gb2YgZmlsZXMgdG8gbG9hZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBQcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdGluZyBkYXRhIHN0cnVjdHVyZVxuICAgKi9cbiAgbG9hZERpcmVjdG9yaWVzKGRlZk9iaiwgdmlldyA9IG51bGwpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGRpckRlZkxpc3QgPSBbXTtcbiAgICAgIGxldCBkaXJSZWZMaXN0ID0gW107XG5cbiAgICAgIC8vIGZvciB0aGUgY2FzZSB0aGF0IGp1c3QgYSBkaXJlY3Rvcnkgb2JqZWN0IGlzIGdpdmVuIGFzIGRlZmluaXRpb24sXG4gICAgICAvLyB3ZSBoYXZlIHRvIHdyYXAgaXQgdGVtcG9yYXJpbHkgaW50byBhIGR1bW15IG9iamVjdFxuICAgICAgZGVmT2JqID0geyBkZWY6IGRlZk9iaiB9O1xuXG4gICAgICBsZXQgZmlsZURlZk9iaiA9IGNsb25lUGF0aE9iaihkZWZPYmopOyAvLyBjbG9uZSBkZWZpbml0aW9uIG9iamVjdFxuXG4gICAgICAvLyBkZWNvbXBvc2UgZGlyZWN0b3J5IGRlZmluaXRpb24gaW50byBsaXN0IG9mIGRpcmVjdG9yeSBwYXRocyAoc3RyaW5ncylcbiAgICAgIGRlY29tcG9zZVBhdGhPYmooZmlsZURlZk9iaiwgZGlyRGVmTGlzdCwgZGlyUmVmTGlzdCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX2ZpbGVTeXN0ZW0uZ2V0TGlzdChkaXJEZWZMaXN0KVxuICAgICAgICAudGhlbigoZmlsZVBhdGhMaXN0TGlzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1YkRpckxpc3QgPSBbXTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBmaWxlUGF0aExpc3RMaXN0Lmxlbmd0aDtcblxuICAgICAgICAgIC8vIGNyZWF0ZSBzdWIgZGlyZWN0b3J5IGZpbGUgZGVmaW5pdGlvbnMgKGxpc3Qgb2YgZmlsZSBwYXRocyBzdHJ1Y3R1cmVkIGludG8gc3ViIGRpcmVjdG9yeSB0cmVlcyBkZXJpdmVkIGZyb20gZmlsZSBwYXRocylcbiAgICAgICAgICBpZiAobGVuZ3RoID09PSBkaXJEZWZMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBkaXJQYXRoID0gZGlyRGVmTGlzdFtpXS5wYXRoO1xuICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuID0gISFkaXJEZWZMaXN0W2ldLmZsYXR0ZW47XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhMaXN0ID0gZmlsZVBhdGhMaXN0TGlzdFtpXTtcbiAgICAgICAgICAgICAgbGV0IHN1YkRpciA9IHBhdGhMaXN0O1xuXG4gICAgICAgICAgICAgIGlmKCFmbGF0dGVuKVxuICAgICAgICAgICAgICAgIHN1YkRpciA9IGNyZWF0ZU9iakZyb21QYXRoTGlzdChwYXRoTGlzdCwgZGlyUGF0aCk7XG5cbiAgICAgICAgICAgICAgc3ViRGlyTGlzdC5wdXNoKHN1YkRpcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgZGlyZWN0b3J5IHBhdGhzIGluIGluaXRpYWwgZGVmaW5pdGlvbiBieSBzdWIgZGlyZWN0b3J5IGZpbGUgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgIC8vIHRvIGNyZWF0ZSBhIGNvbXBsZXRlIGZpbGUgZGVmaW5pdGlvbiBvYmplY3RcbiAgICAgICAgICAgIHBvcHVsYXRlUmVmTGlzdChkaXJSZWZMaXN0LCBzdWJEaXJMaXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHtTRVJWSUNFX0lEfV0gQ2Fubm90IHJldHJpZXZlIGZpbGUgcGF0aHMgZnJvbSBkZWZpbmVkIGRpcmVjdG9yaWVzYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdW53cmFwIHN1YkRpciBmcm9tIGR1bW15IG9iamVjdFxuICAgICAgICAgIGZpbGVEZWZPYmogPSBmaWxlRGVmT2JqLmRlZjtcblxuICAgICAgICAgIC8vIGxvYWQgZmlsZXNcbiAgICAgICAgICB0aGlzLmxvYWRGaWxlcyhmaWxlRGVmT2JqLCB2aWV3KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiByZWplY3QoZXJyb3IpKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiByZWplY3QoZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHdyYXBBcm91bmQsIGNvcHkgdGhlIGJlZ2luaW5nIGlucHV0IGJ1ZmZlciB0byB0aGUgZW5kIG9mIGFuIG91dHB1dCBidWZmZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHthcnJheWJ1ZmZlcn0gaW5CdWZmZXIge2FycmF5YnVmZmVyfSAtIFRoZSBpbnB1dCBidWZmZXJcbiAgICogQHJldHVybnMge2FycmF5YnVmZmVyfSAtIFRoZSBwcm9jZXNzZWQgYnVmZmVyICh3aXRoIGZyYW1lIGNvcGllZCBmcm9tIHRoZSBiZWdpbmluZyB0byB0aGUgZW5kKVxuICAgKi9cbiAgX3dyYXBBcm91bmQoaW5CdWZmZXIpIHtcbiAgICBjb25zdCBpbkxlbmd0aCA9IGluQnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCBvdXRMZW5ndGggPSBpbkxlbmd0aCArIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uICogaW5CdWZmZXIuc2FtcGxlUmF0ZTtcbiAgICBjb25zdCBvdXRCdWZmZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKGluQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMsIG91dExlbmd0aCwgaW5CdWZmZXIuc2FtcGxlUmF0ZSk7XG4gICAgbGV0IGFycmF5Q2hEYXRhLCBhcnJheU91dENoRGF0YTtcblxuICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBpbkJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBjaCsrKSB7XG4gICAgICBhcnJheUNoRGF0YSA9IGluQnVmZmVyLmdldENoYW5uZWxEYXRhKGNoKTtcbiAgICAgIGFycmF5T3V0Q2hEYXRhID0gb3V0QnVmZmVyLmdldENoYW5uZWxEYXRhKGNoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbkxlbmd0aDsgaSsrKVxuICAgICAgICBhcnJheU91dENoRGF0YVtpXSA9IGFycmF5Q2hEYXRhW2ldO1xuXG4gICAgICBmb3IgKGxldCBpID0gaW5MZW5ndGg7IGkgPCBvdXRMZW5ndGg7IGkrKylcbiAgICAgICAgYXJyYXlPdXRDaERhdGFbaV0gPSBhcnJheUNoRGF0YVtpIC0gaW5MZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRCdWZmZXI7XG4gIH1cblxuICAvKiogZGVwcmVjYXRlZCAqL1xuICBsb2FkKGZpbGVzLCB2aWV3ID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRGaWxlcyhmaWxlcywgdmlldyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBsb2FkZWQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBPYmplY3Qgb3IgZ3JvdXAgaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIE1lbWJlciBrZXkgaW4gZ3JvdXAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFJldHVybnMgdGhlIGxvYWRlZCBvYmplY3QuXG4gICAqL1xuICBnZXQoaWQsIGtleSA9IG51bGwpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLmRhdGFbaWRdO1xuXG4gICAgaWYgKG9iaiAmJiAoa2V5ICE9PSBudWxsKSlcbiAgICAgIHJldHVybiBvYmpba2V5XTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgQXVkaW9CdWZmZXJNYW5hZ2VyKTtcblxuZXhwb3J0IGRlZmF1bHQgQXVkaW9CdWZmZXJNYW5hZ2VyO1xuIiwiaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi4vY29yZS9TZXJ2aWNlJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuLi9jb3JlL3NlcnZpY2VNYW5hZ2VyJztcbmltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOmF1ZGlvLXNjaGVkdWxlcic7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgY2xpZW50IGAnYXVkaW8tc2NoZWR1bGVyJ2Agc2VydmljZS5cbiAqXG4gKiBUaGUgYGF1ZGlvLXNjaGVkdWxlcmAgcHJvdmlkZXMgYW4gYWNjZXNzIHRvIHRoZSBiYXNpYyBhdWRpbyBzY2hlZHVsZXIgdXNpbmcgdGhlXG4gKiBzY2hlZHVsZXIgcHJvdmlkZWQgYnkgdGhlIFtgd2F2ZXNqc2Bde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS93YXZlc2pzL2F1ZGlvfVxuICogbGlicmFyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZF0gLSBQZXJpb2Qgb2YgdGhlIHNjaGVkdWxlciAoZGVmYXV0cyB0b1xuICogIGN1cnJlbnQgdmFsdWUpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvb2thaGVhZF0gLSBMb29rYWhlYWQgb2YgdGhlIHNjaGVkdWxlciAoZGVmYXV0c1xuICogIHRvIGN1cnJlbnQgdmFsdWUpLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBzZWUgW2B3YXZlc0F1ZGlvLlNjaGVkdWxlcmBde0BsaW5rIGh0dHA6Ly93YXZlc2pzLmdpdGh1Yi5pby9hdWRpby8jYXVkaW8tc2NoZWR1bGVyfVxuICogQHNlZSBbYHBsYXRmb3JtYCBzZXJ2aWNlXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhdGZvcm19XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGluc2lkZSB0aGUgZXhwZXJpZW5jZSBjb25zdHJ1Y3RvclxuICogdGhpcy5hdWRpb1NjaGVkdWxlciA9IHRoaXMucmVxdWlyZSgnYXVkaW8tc2NoZWR1bGVyJyk7XG4gKlxuICogLy8gd2hlbiB0aGUgZXhwZXJpZW5jZSBoYXMgc3RhcnRlZFxuICogY29uc3QgbmV4dFRpbWUgPSB0aGlzLmF1ZGlvU2NoZWR1bGVyLmN1cnJlbnRUaW1lICsgMjtcbiAqIHRoaXMuYXVkaW9TY2hlZHVsZXIuYWRkKHRpbWVFbmdpbmUsIG5leHRUaW1lKTtcbiAqL1xuY2xhc3MgQXVkaW9TY2hlZHVsZXIgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgLyoqIF88c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5fX1dBUk5JTkdfXzwvc3Bhbj4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFuY2lhdGVkIG1hbnVhbGx5XyAqL1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgZmFsc2UpO1xuXG4gICAgdGhpcy5fcGxhdGZvcm0gPSB0aGlzLnJlcXVpcmUoJ3BsYXRmb3JtJywgeyBmZWF0dXJlczogJ3dlYi1hdWRpbycgfSk7XG5cbiAgICAvLyBpbml0aWFsaXplIHN5bmMgb3B0aW9uXG4gICAgdGhpcy5fc3luYyA9IG51bGw7XG4gICAgdGhpcy5fc3luY2VkUXVldWUgPSBudWxsO1xuXG4gICAgLy8gZ2V0IGF1ZGlvIHRpbWUgYmFzZWQgc2NoZWR1bGVyXG4gICAgdGhpcy5fc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGxvb2thaGVhZDogdGhpcy5fc2NoZWR1bGVyLmxvb2thaGVhZCxcbiAgICAgIHBlcmlvZDogdGhpcy5fc2NoZWR1bGVyLnBlcmlvZCxcbiAgICB9O1xuXG4gICAgLy8gY2FsbCBzdXBlci5jb25maWd1cmUgKGFjdGl2YXRlIHN5bmMgb3B0aW9uIG9ubHkgaWYgcmVxdWlyZWQpXG4gICAgc3VwZXIuY29uZmlndXJlKGRlZmF1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGBjb25maWd1cmVgIHRvIGNvbmZpZ3VyZSB0aGUgc2NoZWR1bGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGFwcGx5IHRvIHRoZSBzZXJ2aWNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICAvLyBjaGVjayBhbmQgc2V0IHNjaGVkdWxlciBwZXJpb2Qgb3B0aW9uXG4gICAgaWYgKG9wdGlvbnMucGVyaW9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLnBlcmlvZCA+IDAuMDEwKVxuICAgICAgICB0aGlzLl9zY2hlZHVsZXIucGVyaW9kID0gb3B0aW9ucy5wZXJpb2Q7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlZHVsZXIgcGVyaW9kOiAke29wdGlvbnMucGVyaW9kfWApO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGFuZCBzZXQgc2NoZWR1bGVyIGxvb2thaGVhZCBvcHRpb25cbiAgICBpZiAob3B0aW9ucy5sb29rYWhlYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMubG9va2FoZWFkID4gMC4wMTApXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlci5sb29rYWhlYWQgPSBvcHRpb25zLmxvb2thaGVhZDtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVkdWxlciBsb29rYWhlYWQ6ICR7b3B0aW9ucy5sb29rYWhlYWR9YCk7XG4gICAgfVxuXG4gICAgc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0YXJ0KCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG4gICAgdGhpcy5yZWFkeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgYXVkaW8gdGltZSBvZiB0aGUgc2NoZWR1bGVyLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIGdldCBhdWRpb1RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IGF1ZGlvIHRpbWUgb2YgdGhlIHNjaGVkdWxlciAoYWxpYXMgYHRoaXMuYXVkaW9UaW1lYCkuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuY3VycmVudFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzY2hlZHVsZXIncyBsb2dpY2FsIGF1ZGlvIHRpbWUgYW5kIHRoZSBgY3VycmVudFRpbWVgXG4gICAqIG9mIHRoZSBhdWRpbyBjb250ZXh0LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIGdldCBkZWx0YVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5jdXJyZW50VGltZSAtIGF1ZGlvLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW4gLSBGdW5jdGlvbiB0byBiZSBkZWZlcnJlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBUaGUgdGltZSBhdCB3aGljaCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29rYWhlYWQ9ZmFsc2VdIC0gRGVmaW5lcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgICogIGFudGljaXBhdGVkIChlLmcuIGZvciBhdWRpbyBldmVudHMpIG9yIHByZWNpc2VseSBhdCB0aGUgZ2l2ZW4gdGltZSAoZGVmYXVsdCkuXG4gICAqL1xuICBkZWZlcihmdW4sIHRpbWUsIGxvb2thaGVhZCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2NoZWR1bGVyID0gdGhpcy5fc2NoZWR1bGVyO1xuICAgIGNvbnN0IHNjaGVkdWxlclNlcnZpY2UgPSB0aGlzO1xuICAgIGxldCBlbmdpbmU7XG5cbiAgICBpZihsb29rYWhlYWQpIHtcbiAgICAgIHNjaGVkdWxlci5kZWZlcihmdW4sIHRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmdpbmUgPSB7XG4gICAgICAgIGFkdmFuY2VUaW1lOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgY29uc3QgZGVsdGEgPSBzY2hlZHVsZXJTZXJ2aWNlLmRlbHRhVGltZTtcblxuICAgICAgICAgIGlmKGRlbHRhID4gMClcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuLCAxMDAwICogZGVsdGEsIHRpbWUpOyAvLyBicmlkZ2Ugc2NoZWR1bGVyIGxvb2thaGVhZCB3aXRoIHRpbWVvdXRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmdW4odGltZSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBzY2hlZHVsZXIuYWRkKGVuZ2luZSwgdGltZSk7IC8vIGFkZCB3aXRob3V0IGNoZWNrc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0aW1lIGVuZ2luZSB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZ2luZSAtIEVuZ2luZSB0byBzY2hlZHVsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBUaGUgdGltZSBhdCB3aGljaCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICAgKi9cbiAgYWRkKGVuZ2luZSwgdGltZSkge1xuICAgIHRoaXMuX3NjaGVkdWxlci5hZGQoZW5naW5lLCB0aW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGVuZ2luZSBmcm9tIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZW5naW5lIC0gRW5naW5lIHRvIHJlbW92ZSBmcm9tIHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICByZW1vdmUoZW5naW5lKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVyLnJlbW92ZShlbmdpbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgc2NoZWR1bGVkIGZ1bmN0aW9ucyBhbmQgdGltZSBlbmdpbmVzIChzeW5jaHJvbml6ZWQgb3Igbm90KSBmcm9tXG4gICAqIHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLl9zY2hlZHVsZXIuY2xlYXIoKTtcbiAgfVxufVxuXG5zZXJ2aWNlTWFuYWdlci5yZWdpc3RlcihTRVJWSUNFX0lELCBBdWRpb1NjaGVkdWxlcik7XG5cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvU2NoZWR1bGVyO1xuIiwiaW1wb3J0IHsgYXVkaW9Db250ZXh0IH0gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi4vY29yZS9TZXJ2aWNlJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuLi9jb3JlL3NlcnZpY2VNYW5hZ2VyJztcblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOmF1ZGlvLXN0cmVhbS1tYW5hZ2VyJztcbmNvbnN0IGxvZyA9IGRlYnVnKCdzb3VuZHdvcmtzOnNlcnZpY2VzOmF1ZGlvLXN0cmVhbS1tYW5hZ2VyJyk7XG5cbi8vIFRPRE86XG4vLyAtIHN1cHBvcnQgc3RyZWFtaW5nIG9mIGZpbGVzIG9mIHRvdGFsIGR1cmF0aW9uIHNob3J0ZXIgdGhhbiBwYWNrZXQgZHVyYXRpb25cblxuZnVuY3Rpb24gbG9hZEF1ZGlvQnVmZmVyKHVybCkge1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlc3BvbnNlLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH1cblxuICAgIHJlcXVlc3Quc2VuZCgpO1xuICB9KTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYCdhdWRpby1zdHJlYW0tbWFuYWdlcidgIHNlcnZpY2UuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGFsbG93cyB0byBzdHJlYW0gYXVkaW8gYnVmZmVycyB0byB0aGUgY2xpZW50IGR1cmluZyB0aGUgZXhwZXJpZW5jZVxuICogKG5vdCBwcmVsb2FkZWQpLiBJbnB1dCBhdWRpbyBmaWxlcyBhcmUgc2VnbWVudGVkIGJ5IHRoZSBzZXJ2ZXIgdXBvbiBzdGFydHVwXG4gKiBhbmQgc2VudCB0byB0aGUgY2xpZW50cyB1cG9uIHJlcXVlc3QuIFNlcnZpY2Ugb25seSBhY2NlcHRzIC53YXYgZmlsZXMgYXQgdGhlXG4gKiBtb21lbnQuIFRoZSBzZXJ2aWNlIG1haW4gb2JqZWN0aXZlIGlzIHRvIDEpIGVuYWJsZSBzeW5jZWQgc3RyZWFtaW5nIGJldHdlZW5cbiAqIGNsaWVudHMgKG5vdCBwcmVjaXNlIGlmIGJhc2VkIG9uIG1lZGlhRWxlbWVudFNvdXJjZXMpLCBhbmQgMikgcHJvdmlkZSBhblxuICogZXF1aXZhbGVudCB0byB0aGUgbWVkaWFFbGVtZW50U291cmNlIG9iamVjdCAoc3RyZWFtaW5nIGFzIGEgV2ViIEF1ZGlvIEFQSVxuICogbm9kZSkgdGhhdCBjb3VsZCBiZSBwbHVnZ2VkIHRvIGFueSBvdGhlciBub2RlIGluIFNhZmFyaSAoYnlwYXNzaW5nIGUuZy4gZ2FpblxuICogb3IgYW5hbHl6ZXIgbm9kZXMgd2hlbiBwbHVnZ2VkIHRvIG1lZGlhRWxlbWVudFNvdXJjZSkuXG4gKlxuICogX18qVGhlIHNlcnZpY2UgbXVzdCBiZSB1c2VkIHdpdGggaXRzIFtzZXJ2ZXItc2lkZSBjb3VudGVycGFydF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3Mvc2VydmVyLkF1ZGlvU3RyZWFtTWFuYWdlcn0qX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubW9uaXRvckludGVydmFsIC0gSW50ZXJ2YWwgdGltZSAoaW4gc2VjKSBhdCB3aGljaCB0aGVcbiAqICBjbGllbnQgd2lsbCBjaGVjayBpZiBpdCBoYXMgZW5vdWdoIHByZWxvYWRlZCBhdWRpbyBkYXRhIHRvIGVuc3VyZSBzdHJlYW1pbmdcbiAqICBvciBpZiBpdCBuZWVkcyB0byByZXF1aXJlIHNvbWUgbW9yZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnJlcXVpcmVkQWR2YW5jZVRocmVzaG9sZCAtIFRocmVzaG9sZCB0aW1lIChpbiBzZWMpIG9mXG4gKiAgcHJlbG9hZGVkIGF1ZGlvIGRhdGEgYmVsb3cgd2hpY2ggdGhlIGNsaWVudCB3aWxsIHJlcXVpcmUgYSBuZXcgYXVkaW8gY2h1bmsuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICogQGV4YW1wbGVcbiAqIC8vIHJlcXVpcmUgdGhlIGBhdWRpby1zdHJlYW0tbWFuYWdlcmAgKGluIGV4cGVyaWVuY2UgY29uc3RydWN0b3IpXG4gKiB0aGlzLmF1ZGlvU3RyZWFtTWFuYWdlciA9IHRoaXMucmVxdWlyZSgnYXVkaW8tc3RyZWFtLW1hbmFnZXInLCB7XG4gKiAgIG1vbml0b3JJbnRlcnZhbDogMSxcbiAqICAgcmVxdWlyZWRBZHZhbmNlVGhyZXNob2xkOiAxMFxuICogfSk7XG4gKlxuICogLy8gcmVxdWVzdCBuZXcgYXVkaW8gc3RyZWFtIGZyb20gdGhlIHN0cmVhbSBtYW5hZ2VyIChpbiBleHBlcmllbmNlIHN0YXJ0IG1ldGhvZClcbiAqIGNvbnN0IGF1ZGlvU3RyZWFtID0gdGhpcy5hdWRpb1N0cmVhbU1hbmFnZXIuZ2V0QXVkaW9TdHJlYW0oKTtcbiAqIC8vIHNldHVwIGFuZCBzdGFydCBhdWRpbyBzdHJlYW1cbiAqIGF1ZGlvU3RyZWFtLnVybCA9ICdteS1hdWRpby1maWxlLW5hbWUnOyAvLyB3aXRob3V0IGV4dGVuc2lvblxuICogLy8gY29ubmVjdCBhcyB5b3Ugd291bGQgYW55IGF1ZGlvIG5vZGUgZnJvbSB0aGUgd2ViIGF1ZGlvIGFwaVxuICogYXVkaW9TdHJlYW0uY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICogYXVkaW9TdHJlYW0ubG9vcCA9IGZhbHNlOyAvLyBkaXNhYmxlIGxvb3BcbiAqIGF1ZGlvU3RyZWFtLnN5bmMgPSBmYWxzZTsgLy8gZGlzYWJsZSBzeW5jaHJvbml6YXRpb25cbiAqIC8vIG1pbWljcyBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgb25lbmRlZCBtZXRob2RcbiAqIGF1ZGlvU3RyZWFtLm9uZW5kZWQgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZygnc3RyZWFtIGVuZGVkJyk7IH07XG4gKiBhdWRpb1N0cmVhbS5zdGFydCgpOyAvLyBzdGFydCBhdWRpbyBzdHJlYW1cbiAqL1xuXG5jbGFzcyBBdWRpb1N0cmVhbU1hbmFnZXIgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgLyoqIF88c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5fX1dBUk5JTkdfXzwvc3Bhbj4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFudGlhdGVkIG1hbnVhbGx5XyAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihTRVJWSUNFX0lELCBmYWxzZSk7XG5cbiAgICB0aGlzLmJ1ZmZlckluZm9zID0gbmV3IE1hcCgpO1xuICAgIC8vIGRlZmluZSBnZW5lcmFsIG9mZnNldCBpbiBzeW5jIGxvb3AgKGluIHNlYykgKG5vdCBwcm9wYWdhdGVkIHRvXG4gICAgLy8gYWxyZWFkeSBjcmVhdGVkIGF1ZGlvIHN0cmVhbXMgd2hlbiBtb2RpZmllZClcbiAgICB0aGlzLnN5bmNTdGFydFRpbWUgPSAwO1xuXG4gICAgLy8gY29uZmlndXJlIG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIG1vbml0b3JJbnRlcnZhbDogMSwgLy8gaW4gc2Vjb25kc1xuICAgICAgcmVxdWlyZWRBZHZhbmNlVGhyZXNob2xkOiAxMCwgLy8gaW4gc2Vjb25kc1xuICAgICAgYXNzZXRzRG9tYWluOiAnJyxcbiAgICB9O1xuXG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgdGhpcy5zeW5jU2VydmljZSA9IHRoaXMucmVxdWlyZSgnc3luYycpO1xuXG4gICAgdGhpcy5fb25BY2tub3dsZWRnZVJlc3BvbnNlID0gdGhpcy5fb25BY2tub3dsZWRnZVJlc3BvbnNlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RhcnQoKSB7XG4gICAgc3VwZXIuc3RhcnQoKTtcbiAgICAvLyBzZW5kIHJlcXVlc3QgZm9yIGluZm9zIG9uIFwic3RyZWFtYWJsZVwiIGF1ZGlvIGZpbGVzXG4gICAgdGhpcy5yZWNlaXZlKCdhY2tub3dsZWdkZScsIHRoaXMuX29uQWNrbm93bGVkZ2VSZXNwb25zZSk7XG4gICAgdGhpcy5yZWNlaXZlKCdzeW5jU3RhcnRUaW1lJywgdmFsdWUgPT4gdGhpcy5zeW5jU3RhcnRUaW1lID0gdmFsdWUpO1xuICAgIHRoaXMuc2VuZCgncmVxdWVzdCcpO1xuXG4gICAgLy8gQHRvZG8gLSBzaG91bGQgcmVjZWl2ZSBhIHN5bmMgc3RhcnQgdGltZSBmcm9tIHNlcnZlclxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBidWZmZXJJbmZvcyAtIGluZm8gb24gYXVkaW8gZmlsZXMgdGhhdCBjYW4gYmUgc3RyZWFtZWRcbiAgICovXG4gIF9vbkFja25vd2xlZGdlUmVzcG9uc2UoYnVmZmVySW5mb3MpIHtcbiAgICBidWZmZXJJbmZvcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAvLyBAdG9kbyAtIHRoaXMgaGFzIHRvIGJlIHJldmlld2VkLCBub3Qgcm9idXN0XG4gICAgICBjb25zdCBjaHVua1BhdGggPSBpdGVtWzBdLm5hbWU7XG4gICAgICBjb25zdCBkaXJuYW1lID0gcGF0aC5kaXJuYW1lKGNodW5rUGF0aCk7XG4gICAgICBjb25zdCBwYXJ0cyA9IGRpcm5hbWUuc3BsaXQoJy8nKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcklkID0gcGFydHMucG9wKCk7XG5cbiAgICAgIGl0ZW0uZm9yRWFjaChjaHVuayA9PiB7XG4gICAgICAgIGNodW5rLnVybCA9IGNodW5rLm5hbWUucmVwbGFjZSgncHVibGljLycsIHRoaXMub3B0aW9ucy5hc3NldHNEb21haW4pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYnVmZmVySW5mb3Muc2V0KGJ1ZmZlcklkLCBpdGVtKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVhZHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgYXVkaW8gc3RyZWFtIG5vZGUuXG4gICAqL1xuICBnZXRBdWRpb1N0cmVhbSgpIHtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnN5bmNTdGFydFRpbWUsIHRoaXMuc3luY1NlcnZpY2UuZ2V0U3luY1RpbWUoKSk7XG4gICAgcmV0dXJuIG5ldyBBdWRpb1N0cmVhbShcbiAgICAgIHRoaXMuYnVmZmVySW5mb3MsXG4gICAgICB0aGlzLnN5bmNTZXJ2aWNlLFxuICAgICAgdGhpcy5vcHRpb25zLm1vbml0b3JJbnRlcnZhbCxcbiAgICAgIHRoaXMub3B0aW9ucy5yZXF1aXJlZEFkdmFuY2VUaHJlc2hvbGQsXG4gICAgICB0aGlzLnN5bmNTdGFydFRpbWVcbiAgICApO1xuICB9XG5cbn1cblxuLyoqXG4gKiBBbiBhdWRpbyBzdHJlYW0gbm9kZSwgYmVoYXZpbmcgYXMgd291bGQgYSBtZWRpYUVsZW1lbnRTb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYnVmZmVySW5mb3MgLSBNYXAgb2Ygc3RyZWFtYWJsZSBidWZmZXIgY2h1bmtzIGluZm9zLlxuICogQHBhcmFtIHtPYmplY3R9IHN5bmNTZXJ2aWNlIC0gU291bmR3b3JrcyBzeW5jIHNlcnZpY2UsIHVzZWQgZm9yIHN5bmMgbW9kZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtb25pdG9ySW50ZXJ2YWwgLSBTZWUgQXVkaW9TdHJlYW1NYW5hZ2VyJ3MuXG4gKiBAcGFyYW0ge051bWJlcn0gcmVxdWlyZWRBZHZhbmNlVGhyZXNob2xkIC0gU2VlIEF1ZGlvU3RyZWFtTWFuYWdlcidzLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQXVkaW9TdHJlYW1NYW5hZ2VyXG4gKi9cbmNsYXNzIEF1ZGlvU3RyZWFtIHtcbiAgLyoqIF88c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5fX1dBUk5JTkdfXzwvc3Bhbj4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFudGlhdGVkIG1hbnVhbGx5XyAqL1xuICBjb25zdHJ1Y3RvcihidWZmZXJJbmZvcywgc3luY1NlcnZpY2UsIG1vbml0b3JJbnRlcnZhbCwgcmVxdWlyZWRBZHZhbmNlVGhyZXNob2xkLCBzeW5jU3RhcnRUaW1lKSB7XG4gICAgLy8gYXJndW1lbnRzXG4gICAgdGhpcy5idWZmZXJJbmZvcyA9IGJ1ZmZlckluZm9zO1xuICAgIHRoaXMuc3luY1NlcnZpY2UgPSBzeW5jU2VydmljZTtcbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IG1vbml0b3JJbnRlcnZhbCAqIDEwMDA7IC8vIGluIG1zXG4gICAgdGhpcy5yZXF1aXJlZEFkdmFuY2VUaHJlc2hvbGQgPSByZXF1aXJlZEFkdmFuY2VUaHJlc2hvbGQ7XG4gICAgdGhpcy5zeW5jU3RhcnRUaW1lID0gc3luY1N0YXJ0VGltZTtcblxuICAgIC8vIGxvY2FsIGF0dHIuXG4gICAgdGhpcy5fc3luYyA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9wZXJpb2RpYyA9IGZhbHNlO1xuICAgIHRoaXMuX21ldGFEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG5cbiAgICB0aGlzLm91dHB1dCA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgICAvLyBzdHJlYW0gbW9uaXRvcmluZ1xuICAgIHRoaXMuX2ludGVydmFsSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcXVldWVFbmRUaW1lID0gMDtcbiAgICB0aGlzLl9zcmNNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fc3RvcFJlcXVpcmVkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZXNldCgpO1xuXG4gICAgdGhpcy5fcmVxdWVzdENodW5rcyA9IHRoaXMuX3JlcXVlc3RDaHVua3MuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbmVuZGVkID0gdGhpcy5fb25lbmRlZC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXQgLyByZXNldCBsb2NhbCBhdHRyaWJ1dGVzIChhdCBzdHJlYW0gY3JlYXRpb24gYW5kIHN0b3AoKSApLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0KCkge1xuICAgIHRoaXMuX2ZpcnN0Q2h1bmtOZXR3b3JrTGF0ZW5jeU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jdXJyZW50Q2h1bmtJbmRleCA9IC0xO1xuICAgIHRoaXMuX2ZpcnN0UGFja2V0U3RhdGUgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSB1cmwgb2YgYXVkaW8gZmlsZSB0byBzdHJlYW0sIHNlbmQgbWV0YSBkYXRhIHJlcXVlc3QgdG8gc2VydmVyIGNvbmNlcm5pbmcgdGhpcyBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gUmVxdWVzdGVkIGZpbGUgbmFtZSwgd2l0aG91dCBleHRlbnNpb25cbiAgICovXG4gIHNldCB1cmwoZmlsZW5hbWUpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkddIC0gQ2Fubm90IHNldCB1cmwgd2hpbGUgcGxheWluZycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHVybCBjb3JyZXNwb25kcyB0byBhIHN0cmVhbWFibGUgZmlsZVxuICAgIGlmICh0aGlzLmJ1ZmZlckluZm9zLmdldChmaWxlbmFtZSkpXG4gICAgICB0aGlzLl91cmwgPSBmaWxlbmFtZTtcbiAgICBlbHNlXG4gICAgICBjb25zb2xlLmVycm9yKGBbRVJST1JdIC0gJHtmaWxlbmFtZX0gdXJsIG5vdCBpbiAke3RoaXMuYnVmZmVySW5mb3N9IFxcbiAjIyMgdXJsIGRpc2NhcmRlZGApO1xuICB9XG5cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldC9HZXQgc3luY2hyb25pemVkIG1vZGUgc3RhdHVzLiBpbiBub24gc3luYy4gbW9kZSwgdGhlIHN0cmVhbSBhdWRpb1xuICAgKiB3aWxsIHN0YXJ0IHdoZW5ldmVyIHRoZSBmaXJzdCBhdWRpbyBidWZmZXIgaXMgZG93bmxvYWRlZC4gaW4gc3luYy4gbW9kZSxcbiAgICogdGhlIHN0cmVhbSBhdWRpbyB3aWxsIHN0YXJ0IChhZ2FpbiB3aGFuIHRoZSBhdWRpbyBidWZmZXIgaXMgZG93bmxvYWRlZClcbiAgICogd2l0aCBhbiBvZmZzZXQgaW4gdGhlIGJ1ZmZlciwgYXMgaWYgaXQgc3RhcnRlZCBwbGF5aW5nIGV4YWN0bHkgd2hlbiB0aGVcbiAgICogc3RhcnQoKSBjb21tYW5kIHdhcyBpc3N1ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbH0gdmFsIC0gRW5hYmxlIC8gZGlzYWJsZSBzeW5jXG4gICAqL1xuICBzZXQgc3luYyh2YWwpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkddIC0gQ2Fubm90IHNldCBzeW5jIHdoaWxlIHBsYXlpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zeW5jID0gdmFsO1xuICB9XG5cbiAgZ2V0IHN5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmM7XG4gIH1cblxuICAvKipcbiAgICogU2V0L0dldCBsb29wIG1vZGUuIG9uZW5kZWQoKSBtZXRob2Qgbm90IGNhbGxlZCBpZiBsb29wIGVuYWJsZWQuXG4gICAqIEBwYXJhbSB7Qm9vbH0gdmFsIC0gZW5hYmxlIC8gZGlzYWJsZSBzeW5jXG4gICAqL1xuICBzZXQgbG9vcCh2YWwpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkddIC0gQ2Fubm90IHNldCBsb29wIHdoaWxlIHBsYXlpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sb29wID0gdmFsO1xuICB9XG5cbiAgZ2V0IGxvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvb3A7XG4gIH1cblxuICAvKipcbiAgICogU2V0L0dldCBwZXJpb2RpYyBtb2RlLiB3ZSBkb24ndCB3YW50IHRoZSBzdHJlYW0gdG8gYmUgc3luY2hyb25pemVkIHRvXG4gICAqIGEgY29tbW9uIG9yaWdpbiwgYnV0IGhhdmUgdGhlbSBhbGlnbmVkIG9uIGEgZ3JpZC4gYWthLCB3ZSBkb24ndCB3YW4ndCB0b1xuICAgKiBjb21wZW5zYXRlIGZvciB0aGUgbG9hZGluZyB0aW1lLCB3aGVuIHN0YXJ0aW5nIHdpdGggYW4gb2Zmc2V0LlxuICAgKiBAcGFyYW0ge0Jvb2x9IHZhbCAtIGVuYWJsZSAvIGRpc2FibGUgcGVyaW9kaWNcbiAgICovXG4gIHNldCBwZXJpb2RpYyh2YWwpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkddIC0gQ2Fubm90IHNldCBsb29wIHdoaWxlIHBsYXlpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wZXJpb2RpYyA9IHZhbDtcbiAgfVxuXG4gIGdldCBwZXJpb2RpYygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVyaW9kaWM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0b3RhbCBkdXJhdGlvbiAoaW4gc2Vjcykgb2YgdGhlIGF1ZGlvIGZpbGUgY3VycmVudGx5IHN0cmVhbWVkLlxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmJ1ZmZlckluZm9zLmdldCh0aGlzLl91cmwpO1xuICAgIGNvbnN0IGxhc3RDaHVuayA9IGJ1ZmZlckluZm9bYnVmZmVySW5mby5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGxhc3RDaHVuay5zdGFydCArIGxhc3RDaHVuay5kdXJhdGlvbjtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdCB0aGUgc3RyZWFtIHRvIGFuIGF1ZGlvIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9Ob2RlfSBub2RlIC0gQXVkaW8gbm9kZSB0byBjb25uZWN0IHRvLlxuICAgKi9cbiAgY29ubmVjdChub2RlKSB7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdChub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgY2FsbGVkIHdoZW4gc3RyZWFtIGZpbmlzaGVkIHBsYXlpbmcgb24gaXRzIG93biAod29uJ3QgZmlyZSBpZiBsb29wXG4gICAqIGVuYWJsZWQpLlxuICAgKi9cbiAgb25lbmRlZCgpIHt9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBjYWxsZWQgd2hlbiBzdHJlYW0gZHJvcHMgYSBwYWNrZXQgKGFycml2ZWQgdG9vIGxhdGUpLlxuICAgKi9cbiAgb25kcm9wKCkge1xuICAgIGNvbnNvbGUud2FybignYXVkaW9zdHJlYW06IHRvbyBsb25nIGxvYWRpbmcsIGRpc2NhcmRpbmcgYnVmZmVyJyk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGNhbGxlZCB3aGVuIHN0cmVhbSByZWNlaXZlZCBhIHBhY2tldCBsYXRlLCBidXQgbm90IHRvbyBtdWNoIHRvIGRyb3BcbiAgICogaXQgKGdhcCBpbiBhdWRpbykuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gZGVsYXkgdGltZS5cbiAgICovXG4gIG9ubGF0ZSh0aW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTdGFydCBzdHJlYW1pbmcgYXVkaW8gc291cmNlLlxuICAgKiBAd2FybmluZyAtIG9mZnNldCBkb2Vzbid0IHNlZW0gdG8gbWFrZSBzZW5zIHdoZW4gbm90IGxvb3AgYW5kIG5vdCBwZXJpb2RpY1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gdGltZSBpbiBidWZmZXIgZnJvbSB3aGljaCB0byBzdGFydCAoaW4gc2VjKVxuICAgKi9cbiAgc3RhcnQob2Zmc2V0ID0gMCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgY29uc29sZS53YXJuKCdbV0FSTklOR10gLSBzdGFydCgpIGRpc2NhcmRlZCwgbXVzdCBzdG9wIGZpcnN0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgd2UgZGlzcG9zZSBvZiB2YWxpZCB1cmwgdG8gZXhlY3V0ZSBzdGFydFxuICAgIGlmICh0aGlzLl91cmwgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkddIC0gc3RhcnQoKSBkaXNjYXJkZWQsIG11c3QgZGVmaW5lIHZhbGlkIHVybCBmaXJzdCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdlIGNvbnNpZGVyIHRoZSBzdHJlYW0gc3RhcnRlZCBub3dcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5idWZmZXJJbmZvcy5nZXQodGhpcy5fdXJsKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG5cbiAgICBpZiAodGhpcy5zeW5jKSB7XG4gICAgICBjb25zdCBzeW5jVGltZSA9IHRoaXMuc3luY1NlcnZpY2UuZ2V0U3luY1RpbWUoKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMuc3luY1N0YXJ0VGltZTtcbiAgICAgIG9mZnNldCA9IHN5bmNUaW1lIC0gc3RhcnRUaW1lICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvb3ApXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgJSBkdXJhdGlvbjtcblxuICAgIC8vIHRoaXMgbG9va3MgY29oZXJlbnQgZm9yIGFsbCBjb21iaW5hdGlvbnMgb2YgYGxvb3BgIGFuZCBgc3luY2BcbiAgICAvLyBjb25zb2xlLmxvZygnb2Zmc2V0Jywgb2Zmc2V0KTtcbiAgICAvLyBjb25zb2xlLmxvZygnZHVyYXRpb24nLCBkdXJhdGlvbik7XG5cbiAgICBpZiAob2Zmc2V0ID49IGR1cmF0aW9uKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtXQVJOSU5HXSAtIHN0YXJ0KCkgZGlzY2FyZGVkLCByZXF1ZXN0ZWQgb2Zmc2V0XG4gICAgICAgICgke29mZnNldH0gc2VjKSBsYXJnZXIgdGhhbiBmaWxlIGR1cmF0aW9uICgke2R1cmF0aW9ufSBzZWMpYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZmluZCBpbmRleCBvZiB0aGUgY2h1bmsgY29ycmVzcG9uZGluZyB0byBnaXZlbiBvZmZzZXRcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBvZmZzZXRJbkZpcnN0Q2h1bmsgPSAwO1xuICAgIC8vIGNvbnNvbGUubG9nKGJ1ZmZlckluZm8sIGluZGV4LCBidWZmZXJJbmZvW2luZGV4XSk7XG5cbiAgICB3aGlsZSAodGhpcy5fY3VycmVudENodW5rSW5kZXggPT09IC0xICYmIGluZGV4IDwgYnVmZmVySW5mby5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rSW5mb3MgPSBidWZmZXJJbmZvW2luZGV4XTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gY2h1bmtJbmZvcy5zdGFydDtcbiAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY2h1bmtJbmZvcy5kdXJhdGlvbjtcblxuICAgICAgaWYgKG9mZnNldCA+PSBzdGFydCAmJiBvZmZzZXQgPCBlbmQpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudENodW5rSW5kZXggPSBpbmRleDtcbiAgICAgICAgb2Zmc2V0SW5GaXJzdENodW5rID0gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIG5lZ2F0aXZlIG9mZnNldCwgcGljayBmaXJzdCBjaHVuay4gVGhpcyBjYW4gYmUgdXNlZnVsbCB0byBzdGFydFxuICAgIC8vIHN5bmNlZCBzdHJlYW0gd2hpbGUgZ2l2ZSB0aGVtIHNvbWUgZGVsYXkgdG8gcHJlbG9hZCB0aGUgZmlyc3QgY2h1bmtcbiAgICBpZiAodGhpcy5fY3VycmVudENodW5rSW5kZXggPT09IC0xICYmIG9mZnNldCA8IDApXG4gICAgICB0aGlzLl9jdXJyZW50Q2h1bmtJbmRleCA9IDA7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnQXVkaW9TdHJlYW0uc3RhcnQoKScsIHRoaXMuX3VybCwgdGhpcy5fY3VycmVudENodW5rSW5kZXgpO1xuICAgIHRoaXMuX3N0b3BSZXF1aXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlRW5kVGltZSA9IHRoaXMuc3luY1NlcnZpY2UuZ2V0U3luY1RpbWUoKSAtIG9mZnNldEluRmlyc3RDaHVuaztcblxuICAgIC8vIEBpbXBvcnRhbnQgLSBuZXZlciBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZXNlIDIgY2FsbHNcbiAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodGhpcy5fcmVxdWVzdENodW5rcywgdGhpcy5tb25pdG9ySW50ZXJ2YWwpO1xuICAgIHRoaXMuX3JlcXVlc3RDaHVua3MoKTtcbiAgfVxuXG4gIF9vbmVuZGVkKCkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5vbmVuZGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgYXVkaW8gc3RyZWFtLiBNaW1pY3MgQXVkaW9CdWZmZXJTb3VyY2VOb2RlIHN0b3AoKSBtZXRob2QuIEEgc3RvcHBlZFxuICAgKiBhdWRpbyBzdHJlYW0gY2FuIGJlIHN0YXJ0ZWQgKG5vIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG9uZSBhcyByZXF1aXJlZCB3aGVuXG4gICAqIHVzaW5nIGFuIEF1ZGlvQnVmZmVyU291cmNlTm9kZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBvZmZzZXQgdGltZSAoaW4gc2VjKSBmcm9tIG5vdyBhdCB3aGljaFxuICAgKiAgdGhlIGF1ZGlvIHN0cmVhbSBzaG91bGQgc3RvcCBwbGF5aW5nLlxuICAgKi9cbiAgc3RvcChvZmZzZXQgPSAwKSB7XG4gICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xuICAgICAgY29uc29sZS53YXJuKCdbV0FSTklOR10gLSBzdG9wIGRpc2NhcmRlZCwgbm90IHN0YXJ0ZWQgb3IgYWxyZWFkeSBlbmRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnRlcnZhbElkICE9PSB1bmRlZmluZWQpXG4gICAgICB0aGlzLl9jbGVhclJlcXVlc3RDaHVua3MoKTtcblxuXG4gICAgdGhpcy5fc3RvcFJlcXVpcmVkID0gdHJ1ZTsgLy8gYXZvaWQgcGxheWluZyBidWZmZXIgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRpbmdcbiAgICB0aGlzLl9yZXNldCgpO1xuXG4gICAgY29uc3Qgbm93ID0gdGhpcy5zeW5jU2VydmljZS5nZXRTeW5jVGltZSgpO1xuICAgIGNvbnN0IGF1ZGlvVGltZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fc3JjTWFwLnNpemU7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgdGhpcy5fc3JjTWFwLmZvckVhY2goKHNyYywgc3RhcnRUaW1lKSA9PiB7XG4gICAgICBjb3VudGVyICs9IDE7XG4gICAgICBzcmMub25lbmRlZCA9IG51bGw7XG5cbiAgICAgIC8vIHBpY2sgYSBzb3VyY2UgYXJiaXRyYXJpbHkgdG8gdHJpZ2dlciB0aGUgYG9uZW5kZWRgIGV2ZW50IHByb3Blcmx5XG4gICAgICBpZiAoY291bnRlciA9PT0gc2l6ZSlcbiAgICAgICAgc3JjLm9uZW5kZWQgPSB0aGlzLl9vbmVuZGVkO1xuXG4gICAgICBpZiAoc3RhcnRUaW1lIDwgKG5vdyArIG9mZnNldCkgfHzCoHNyYy5vbmVuZGVkICE9PSBudWxsKVxuICAgICAgICBzcmMuc3RvcChhdWRpb1RpbWUgKyBvZmZzZXQpO1xuICAgICAgZWxzZVxuICAgICAgICBzcmMuc3RvcChhdWRpb1RpbWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc3JjTWFwLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggXCJsb2NhbCBidWZmZXIgdGltZVwiIGZvciB0aGUgYXVkaW8gc3RyZWFtLFxuICAgKiByZXF1ZXN0IG5ldyBidWZmZXIgY2h1bmtzIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXF1ZXN0Q2h1bmtzKCkge1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmJ1ZmZlckluZm9zLmdldCh0aGlzLl91cmwpO1xuICAgIGNvbnN0IG5vdyA9IHRoaXMuc3luY1NlcnZpY2UuZ2V0U3luY1RpbWUoKTtcblxuICAgIC8vIGhhdmUgdG8gZGVhbCBwcm9wZXJseSB3aXRoXG4gICAgd2hpbGUgKHRoaXMuX3F1ZXVlRW5kVGltZSAtIG5vdyA8PSB0aGlzLnJlcXVpcmVkQWR2YW5jZVRocmVzaG9sZCkge1xuICAgICAgLy8gaW4gbm9uIHN5bmMgbW9kZSwgd2Ugd2FudCB0aGUgc3RhcnQgdGltZSB0byBiZSBkZWxheWVkIHdoZW4gdGhlIGZpcnN0XG4gICAgICAvLyBidWZmZXIgaXMgYWN0dWFsbHkgcmVjZWl2ZWQsIHNvIHdlIGxvYWQgaXQgYmVmb3JlIHJlcXVlc3RpbmcgbmV4dCBvbmVzXG4gICAgICBpZiAodGhpcy5fZmlyc3RQYWNrZXRTdGF0ZSA9PT0gMSAmJiAhdGhpcy5fc3luYylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjb25zdCBjaHVua0luZm9zID0gYnVmZmVySW5mb1t0aGlzLl9jdXJyZW50Q2h1bmtJbmRleF07XG4gICAgICBjb25zdCBjaHVua1N0YXJ0VGltZSA9IHRoaXMuX3F1ZXVlRW5kVGltZSAtIGNodW5rSW5mb3Mub3ZlcmxhcFN0YXJ0O1xuICAgICAgY29uc3QgdXJsID0gY2h1bmtJbmZvcy51cmw7XG5cbiAgICAgIC8vIGZsYWcgdGhhdCBmaXJzdCBwYWNrZXQgaGFzIGJlZW4gcmVxdWlyZWQgYW5kIHRoYXQgd2UgbXVzdCBhd2FpdCBmb3IgaXRzXG4gICAgICAvLyBhcnJpdmFsIGluIHVuc3luYyBtb2RlIGJlZm9yZSBhc2tpbmcgZm9yIG1vcmUsIGFzIHRoZSBuZXR3b3JrIGRlbGF5XG4gICAgICAvLyB3aWxsIGRlZmluZSB0aGUgYHRydWVgIHN0YXJ0IHRpbWVcbiAgICAgIGlmICh0aGlzLl9maXJzdFBhY2tldFN0YXRlID09PSAwICYmICF0aGlzLl9zeW5jKVxuICAgICAgICB0aGlzLl9maXJzdFBhY2tldFN0YXRlID0gMTtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ2N1cnJlbnRDaHVua0luZGV4JywgdGhpcy5fY3VycmVudENodW5rSW5kZXgpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3RpbWVBdFF1ZXVlRW5kJywgdGhpcy5fcXVldWVFbmRUaW1lKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdjaHVua1N0YXJ0VGltZScsIGNodW5rU3RhcnRUaW1lKTtcblxuICAgICAgY29uc3QgY3VycmVudENodW5rSW5kZXggPSB0aGlzLl9jdXJyZW50Q2h1bmtJbmRleDtcblxuICAgICAgdGhpcy5fY3VycmVudENodW5rSW5kZXggKz0gMTtcbiAgICAgIHRoaXMuX3F1ZXVlRW5kVGltZSArPSBjaHVua0luZm9zLmR1cmF0aW9uO1xuXG4gICAgICBsZXQgaXNMYXN0Q2h1bmsgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDaHVua0luZGV4ID09PSBidWZmZXJJbmZvLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRDaHVua0luZGV4ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBoYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uY2Ugb3V0c2lkZSB0aGUgbG9vcCwgaXQgbWlnaHQgYXBwZW5kXG4gICAgICAgICAgLy8gdGhhdCB3ZSBmaW5pc2ggdGhlIHdob2xlIGxvYWRpbmcgd2l0aG91dCBhY3R1YWxseSBoYXZpbmcgYW5cbiAgICAgICAgICAvLyBpbnRlcnZhbElkLCBtYXliZSBoYW5kbGUgdGhpcyBtb3JlIHByb3Blcmx5IHdpdGggcmVjY3Vyc2l2ZVxuICAgICAgICAgIC8vIGBzZXRUaW1lb3V0YHNcbiAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZClcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUmVxdWVzdENodW5rcygpO1xuICAgICAgICAgIC8vIGJ1dCByZXNldCBsYXRlciBhcyB0aGUgbGFzdCBjaHVuayBzdGlsbCBuZWVkcyB0aGUgY3VycmVudCBvZmZzZXRzXG4gICAgICAgICAgaXNMYXN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxvYWQgYW5kIGFkZCBidWZmZXIgdG8gcXVldWVcbiAgICAgIGxvYWRBdWRpb0J1ZmZlcih1cmwpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc3RvcFJlcXVpcmVkKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBtYXJrIHRoYXQgZmlyc3QgcGFja2V0IGFycml2ZWQgYW5kIHRoYXQgd2UgY2FuIGFzayBmb3IgbW9yZVxuICAgICAgICBpZiAodGhpcy5fZmlyc3RQYWNrZXRTdGF0ZSA9PT0gMSAmJiAhdGhpcy5fc3luYylcbiAgICAgICAgICB0aGlzLl9maXJzdFBhY2tldFN0YXRlID0gMjtcblxuICAgICAgICBjb25zdCB7IG92ZXJsYXBTdGFydCwgb3ZlcmxhcEVuZCB9ID0gY2h1bmtJbmZvcztcbiAgICAgICAgdGhpcy5fYWRkQnVmZmVyVG9RdWV1ZShidWZmZXIsIGNodW5rU3RhcnRUaW1lLCBvdmVybGFwU3RhcnQsIG92ZXJsYXBFbmQsIGlzTGFzdENodW5rKTtcblxuICAgICAgICBpZiAoaXNMYXN0Q2h1bmspXG4gICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNMYXN0Q2h1bmspXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxvb2tpbmcgZm9yIG5ldyBjaHVua3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhclJlcXVlc3RDaHVua3MoKSB7XG4gICAgLy8gY29uc29sZS5sb2coYEF1ZGlvU3RyZWFtLl9jbGVhclJlcXVlc3RDaHVua3MoKSAke3RoaXMuX3VybH0gLSBjbGVhckludGVydmFsYCwgdGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbElkKTtcbiAgICB0aGlzLl9pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhdWRpbyBidWZmZXIgdG8gc3RyZWFtIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBidWZmZXIgLSBBdWRpbyBidWZmZXIgdG8gYWRkIHRvIHBsYXlpbmcgcXVldWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgLSBUaW1lIGF0IHdoaWNoIGF1ZGlvIGJ1ZmZlciBwbGF5aW5nIGlzIGR1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG92ZXJsYXBTdGFydCAtIER1cmF0aW9uIChpbiBzZWMpIG9mIHRoZSBhZGRpdGlvbmFsIGF1ZGlvXG4gICAqICBjb250ZW50IGFkZGVkIGJ5IHRoZSBub2RlLWF1ZGlvLXNsaWNlciAob24gc2VydmVyIHNpZGUpIGF0IGF1ZGlvIGJ1ZmZlcidzXG4gICAqICBoZWFkICh1c2VkIGluIGZhZGUtaW4gbWVjaGFuaXNtIHRvIGF2b2lkIHBlcmNlaXZpbmcgcG90ZW50aWFsIC5tcDNcbiAgICogIGVuY29kaW5nIGFydGlmYWN0cyBpbnRyb2R1Y2VkIHdoZW4gYnVmZmVyIHN0YXJ0cyB3aXRoIG5vbi16ZXJvIHZhbHVlKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3ZlcmxhcEVuZCAtIER1cmF0aW9uIChpbiBzZWMpIG9mIHRoZSBhZGRpdGlvbmFsIGF1ZGlvXG4gICAqICBjb250ZW50IGFkZGVkIGF0IGF1ZGlvIGJ1ZmZlcidzIHRhaWwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkQnVmZmVyVG9RdWV1ZShidWZmZXIsIHN0YXJ0VGltZSwgb3ZlcmxhcFN0YXJ0LCBvdmVybGFwRW5kLCBpc0xhc3RDaHVuaykge1xuICAgIC8vIGhhcmQtY29kZSBvdmVybGFwIGZhZGUtaW4gYW5kIG91dCBpbiBidWZmZXJcbiAgICBjb25zdCBudW1TYW1wbGVzRmFkZUluID0gTWF0aC5mbG9vcihvdmVybGFwU3RhcnQgKiBidWZmZXIuc2FtcGxlUmF0ZSk7XG4gICAgY29uc3QgbnVtU2FtcGxlc0ZhZGVPdXQgPSBNYXRoLmZsb29yKG92ZXJsYXBFbmQgKiBidWZmZXIuc2FtcGxlUmF0ZSk7XG4gICAgLy8gbG9vcCBvdmVyIGF1ZGlvIGNoYW5uZWxzXG4gICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBidWZmZXIubnVtYmVyT2ZDaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsRGF0YSA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcblxuICAgICAgLy8gZmFkZSBpblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TYW1wbGVzRmFkZUluOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ2FpbiA9IGkgLyAobnVtU2FtcGxlc0ZhZGVJbiAtIDEpO1xuICAgICAgICBjaGFubmVsRGF0YVtpXSA9IGNoYW5uZWxEYXRhW2ldICogZ2FpbjtcbiAgICAgIH1cblxuICAgICAgLy8gZmFkZSBvdXRcbiAgICAgIGZvciAobGV0IGkgPSBjaGFubmVsRGF0YS5sZW5ndGggLSBudW1TYW1wbGVzRmFkZU91dDsgaSA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGdhaW4gPSAoY2hhbm5lbERhdGEubGVuZ3RoIC0gaSAtIDEpIC8gKG51bVNhbXBsZXNGYWRlT3V0IC0gMSk7XG4gICAgICAgIGNoYW5uZWxEYXRhW2ldID0gY2hhbm5lbERhdGFbaV0gKiBnYWluO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgY29uc3Qgc3luY1RpbWUgPSB0aGlzLnN5bmNTZXJ2aWNlLmdldFN5bmNUaW1lKCk7XG4gICAgY29uc3Qgbm93ID0gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIGxldCBvZmZzZXQgPSBzdGFydFRpbWUgLSBzeW5jVGltZTtcblxuICAgIC8vIC0gaW4gYG5vbiBzeW5jYCBzY2VuYXJpbywgd2Ugd2FudCB0byB0YWtlIGluIGFjY291bnQgdGhlIGxhdGVuY3kgaW5kdWNlZFxuICAgIC8vIGJ5IHRoZSBsb2FkaW5nIG9mIHRoZSBmaXJzdCBjaHVuay4gVGhpcyBsYXRlbmN5IG11c3QgdGhlbiBiZSBhcHBsaWVkXG4gICAgLy8gdG8gYWxsIHN1YnNlcXVlbnQgY2h1bmtzLlxuICAgIC8vIC0gaW4gYHN5bmNgIHNjZW5hcmlvcywgd2UganVzdCBsZXQgdGhlIGxvZ2ljYWwgc3RhcnQgdGltZSBhbmQgY29tcHV0ZWRcbiAgICAvLyBvZmZzZXQgZG8gdGhlaXIgam9iLi4uXG4gICAgLy8gLSBpbiBgcGVyaW9kaWNgIHNjZW5hcmlvcyB3ZSBkb24ndCB3YW50IHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBsb2FkaW5nIHRpbWVcbiAgICBpZiAoIXRoaXMuX3N5bmMgJiYgIXRoaXMuX3BlcmlvZGljKSB7XG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMuX2ZpcnN0Q2h1bmtOZXR3b3JrTGF0ZW5jeU9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0Q2h1bmtOZXR3b3JrTGF0ZW5jeU9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0IC09IHRoaXMuX2ZpcnN0Q2h1bmtOZXR3b3JrTGF0ZW5jeU9mZnNldDtcbiAgICB9XG5cbiAgICAvLyBpZiBjb21wdXRlZCBvZmZzZXQgaXMgc21hbGxlciB0aGFuIGR1cmF0aW9uXG4gICAgaWYgKC1vZmZzZXQgPD0gYnVmZmVyLmR1cmF0aW9uKSB7XG4gICAgICAvLyBjcmVhdGUgYXVkaW8gc291cmNlXG4gICAgICBjb25zdCBzcmMgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBzcmMuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgICBzcmMuYnVmZmVyID0gYnVmZmVyO1xuXG4gICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICBzcmMuc3RhcnQobm93LCAtb2Zmc2V0KTtcbiAgICAgICAgLy8gdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc3RhcnRcbiAgICAgICAgdGhpcy5vbmxhdGUoLW9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmMuc3RhcnQobm93ICsgb2Zmc2V0LCAwKTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBrZWVwIGFuZCBjbGVhbiByZWZlcmVuY2UgdG8gc291cmNlXG4gICAgICB0aGlzLl9zcmNNYXAuc2V0KHN0YXJ0VGltZSwgc3JjKTtcblxuICAgICAgc3JjLm9uZW5kZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NyY01hcC5kZWxldGUoc3RhcnRUaW1lKTtcblxuICAgICAgICBpZiAoaXNMYXN0Q2h1bmspXG4gICAgICAgICAgdGhpcy5fb25lbmRlZCgpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmRyb3AoKTtcbiAgICB9XG4gIH1cblxufVxuXG5zZXJ2aWNlTWFuYWdlci5yZWdpc3RlcihTRVJWSUNFX0lELCBBdWRpb1N0cmVhbU1hbmFnZXIpO1xuZXhwb3J0IGRlZmF1bHQgQXVkaW9TdHJlYW1NYW5hZ2VyO1xuIiwiaW1wb3J0IGNsaWVudCBmcm9tICcuLi9jb3JlL2NsaWVudCc7XG5pbXBvcnQgU2VydmljZSBmcm9tICcuLi9jb3JlL1NlcnZpY2UnO1xuaW1wb3J0IFNlZ21lbnRlZFZpZXcgZnJvbSAnLi4vdmlld3MvU2VnbWVudGVkVmlldyc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5cbi8qKlxuICogQVBJIG9mIGEgY29tcGxpYW50IHZpZXcgZm9yIHRoZSBgYXV0aGAgc2VydmljZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAaW50ZXJmYWNlIEFic3RyYWN0QXV0aFZpZXdcbiAqIEBleHRlbmRzIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFZpZXdcbiAqIEBhYnN0cmFjdFxuICovXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCB3aGVuIHRoZSBwYXNzd29yZCBpcyBzdWJtaXR0ZWRcbiAqIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBuYW1lIHNldFNlbmRQYXNzd29yZENhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0QXV0aFZpZXdcbiAqIEBmdW5jdGlvblxuICogQGFic3RyYWN0XG4gKiBAaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3NlbmRQYXNzd29yZENhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgdXNlclxuICogIHN1Ym1pdCB0aGUgcGFzc3dvcmRcbiAqL1xuLyoqXG4gKiBSZWdpc3RlciB0aGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgcGFzc3dvcmQgaXMgcmVzZXRcbiAqIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBuYW1lIHNldFJlc2V0UGFzc3dvcmRDYWxsYmFja1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdEF1dGhWaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzZXRSZXNldENhbGxiYWNrfSBjYWxsYmFjayAtXG4gKiAgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSB1c2VyIHJlc2V0IHRoZSBwYXNzd29yZFxuICovXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmlldyBhY2NvcmRpbmcgdG8gdGhlIHJlc3BvbnNlIHRvIHRoZSBzdWJtaXR0ZWQgcGFzc3dvcmQuXG4gKlxuICogQG5hbWUgdXBkYXRlUmVqZWN0ZWRTdGF0dXNcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQWJzdHJhY3RBdXRoVmlld1xuICogQGZ1bmN0aW9uXG4gKiBAYWJzdHJhY3RcbiAqIEBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBgdHJ1ZWAgaWYgdGhlIHN1Ym1pdHRlZCBwYXNzd29yZCBpcyByZWplY3RlZCxcbiAqICBgZmFsc2VgIHdoZW4gdGhlIHBhc3N3b3JkIGlzIHJlc2V0LlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSB1c2VyIHN1Ym1pdCB0aGUgcGFzc3dvcmQuXG4gKlxuICogQGNhbGxiYWNrXG4gKiBAbmFtZSBzZW5kUGFzc3dvcmRDYWxsYmFja1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdEF1dGhWaWV3XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIC0gUGFzc3dvcmQgZ2l2ZW4gYnkgdGhlIHVzZXIuXG4gKi9cbi8qKlxuICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSB1c2VyIHJlc2V0IHRoZSBwYXNzd29yZC5cbiAqXG4gKiBAY2FsbGJhY2tcbiAqIEBuYW1lIHJlc2V0Q2FsbGJhY2tcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQWJzdHJhY3RBdXRoVmlld1xuICovXG5cblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOmF1dGgnO1xuY29uc3QgTE9DQUxfU1RPUkFHRV9LRVkgPSBgc291bmR3b3Jrczoke1NFUlZJQ0VfSUR9YDtcblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYGF1dGhgIHNlcnZpY2UuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGFsbG93cyB0byBsb2NrIHRoZSBhcHBsaWNhdGlvbiB0byBzcGVjaWZpYyB1c2VycyBieSBhZGRpbmcgYVxuICogc2ltcGxlIGxvZ2dpbmcgcGFnZSB0byB0aGUgY2xpZW50LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPjogVGhpcyBzZXJ2aWNlIHNob3VsZG4ndCBiZSBjb25zaWRlcmVkXG4gKiBzZWN1cmUgZnJvbSBhIHByb2R1Y3Rpb24gcHJlc3BlY3RpdmUuXG4gKlxuICogX18qVGhlIHNlcnZpY2UgbXVzdCBiZSB1c2VkIHdpdGggaXRzIFtzZXJ2ZXItc2lkZSBjb3VudGVycGFydF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3Mvc2VydmVyLkF1dGh9Kl9fXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICogQGV4YW1wbGVcbiAqIHRoaXMuYXV0aCA9IHRoaXMucmVxdWlyZSgnYXV0aCcpO1xuICovXG5jbGFzcyBBdXRoIGV4dGVuZHMgU2VydmljZSB7XG4gIC8qKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbmNpYXRlZCBtYW51YWxseV8gKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHZpZXdQcmlvcml0eTogMTAwLFxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZ3VyZShkZWZhdWx0cyk7XG5cbiAgICB0aGlzLl9wYXNzd29yZCA9IG51bGw7XG5cbiAgICB0aGlzLl9vbkFjY2VzR3JhbnRlZFJlc3BvbnNlID0gdGhpcy5fb25BY2Nlc0dyYW50ZWRSZXNwb25zZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQWNjZXNSZWZ1c2VkUmVzcG9uc2UgPSB0aGlzLl9vbkFjY2VzUmVmdXNlZFJlc3BvbnNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2VuZFBhc3N3b3JkID0gdGhpcy5fc2VuZFBhc3N3b3JkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVzZXRQYXNzd29yZCA9IHRoaXMuX3Jlc2V0UGFzc3dvcmQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgdGhpcy52aWV3LnNldFNlbmRQYXNzd29yZENhbGxiYWNrKHRoaXMuX3NlbmRQYXNzd29yZCk7XG4gICAgdGhpcy52aWV3LnNldFJlc2V0Q2FsbGJhY2sodGhpcy5fcmVzZXRQYXNzd29yZCk7XG5cbiAgICB0aGlzLnJlY2VpdmUoJ2dyYW50ZWQnLCB0aGlzLl9vbkFjY2VzR3JhbnRlZFJlc3BvbnNlKTtcbiAgICB0aGlzLnJlY2VpdmUoJ3JlZnVzZWQnLCB0aGlzLl9vbkFjY2VzUmVmdXNlZFJlc3BvbnNlKTtcblxuICAgIGNvbnN0IHN0b3JlZFBhc3N3b3JkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xuXG4gICAgaWYgKHN0b3JlZFBhc3N3b3JkICE9PSBudWxsKVxuICAgICAgdGhpcy5fc2VuZFBhc3N3b3JkKHN0b3JlZFBhc3N3b3JkKTtcblxuICAgIHRoaXMuc2hvdygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuc3RvcCgpO1xuXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZ3JhbnRlZCcsIHRoaXMuX29uQWNjZXNHcmFudGVkUmVzcG9uc2UpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlZnVzZWQnLCB0aGlzLl9vbkFjY2VzUmVmdXNlZFJlc3BvbnNlKTtcblxuICAgIHRoaXMuaGlkZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgc3RvcmVkIHBhc3N3b3JkIGZyb20gbG9jYWwgc3RvcmFnZS4gVGhpcyBtZXRob2QgaXMgYWltZWQgYXRcbiAgICogYmVpbmcgY2FsbGVkIGZyb20gaW5zaWRlIGFuIGV4cGVyaWVuY2UgLyBjb250cm9sbGVyLiBBbnkgVUkgdXBkYXRlXG4gICAqIHJlc3VsdGluZyBmcm9tIHRoZSBjYWxsIG9mIHRoaXMgbWV0aG9kIHNob3VsZCB0aGVuIGJlIGhhbmRsZWQgZnJvbSB0aGVcbiAgICogZXhwZXJpZW5jZS5cbiAgICovXG4gIGxvZ291dCgpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0NBTF9TVE9SQUdFX0tFWSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3NlbmRQYXNzd29yZChwYXNzd29yZCkge1xuICAgIHRoaXMuX3Bhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgdGhpcy5zZW5kKCdwYXNzd29yZCcsIHBhc3N3b3JkKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfcmVzZXRQYXNzd29yZCgpIHtcbiAgICB0aGlzLl9wYXNzd29yZCA9IG51bGw7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVJlamVjdGVkU3RhdHVzKGZhbHNlKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25BY2Nlc0dyYW50ZWRSZXNwb25zZSgpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgdGhpcy5fcGFzc3dvcmQpO1xuICAgIHRoaXMucmVhZHkoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25BY2Nlc1JlZnVzZWRSZXNwb25zZSgpIHtcbiAgICB0aGlzLnZpZXcudXBkYXRlUmVqZWN0ZWRTdGF0dXModHJ1ZSk7XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgQXV0aCk7XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGg7XG4iLCJpbXBvcnQgY2xpZW50IGZyb20gJy4uL2NvcmUvY2xpZW50JztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5cbi8qKlxuICogQVBJIG9mIGEgY29tcGxpYW50IHZpZXcgZm9yIHRoZSBgY2hlY2tpbmAgc2VydmljZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAaW50ZXJmYWNlIEFic3RyYWN0Q2hlY2tpblZpZXdcbiAqIEBleHRlbmRzIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFZpZXdcbiAqIEBhYnN0cmFjdFxuICovXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCB3aGVuIHRoZSB1c2VyIGlzIHJlYWR5IHRvXG4gKiBjb250aW51ZS5cbiAqXG4gKiBAbmFtZSBzZXRSZWFkeUNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0Q2hlY2tpblZpZXdcbiAqIEBmdW5jdGlvblxuICogQGFic3RyYWN0XG4gKiBAaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3JlYWR5Q2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSB1c2VyXG4gKiAgaXMgcmVhZHkgdG8gY29udGludWUuXG4gKi9cbi8qKlxuICogVXBkYXRlIHRoZSBsYWJlbCByZXRyaWV2ZWQgYnkgdGhlIHNlcnZlci5cbiAqXG4gKiBAbmFtZSB1cGRhdGVMYWJlbFxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdENoZWNraW5WaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIC0gTGFiZWwgdG8gYmUgZGlzcGxheWVkIGluIHRoZSB2aWV3LlxuICovXG4vKipcbiAqIE1ldGhvZCBleGVjdXRlZCB3aGVuIGFuIGVycm9yIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciAod2hlbiBubyBwbGFjZSBpc1xuICogaXMgYXZhaWxhYmxlIGluIHRoZSBleHBlcmllbmNlKS5cbiAqXG4gKiBAbmFtZSB1cGRhdGVFcnJvclN0YXR1c1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdENoZWNraW5WaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSB1c2VyIGlzIHJlYWR5IHRvIGNvbnRpbnVlLlxuICpcbiAqIEBjYWxsYmFja1xuICogQG5hbWUgcmVhZHlDYWxsYmFja1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdENoZWNraW5WaWV3XG4gKi9cblxuXG5jb25zdCBTRVJWSUNFX0lEID0gJ3NlcnZpY2U6Y2hlY2tpbic7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgY2xpZW50IGAnY2hlY2tpbidgIHNlcnZpY2UuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGlzIG9uZSBvZiB0aGUgcHJvdmlkZWQgc2VydmljZXMgYWltZWQgYXQgaWRlbnRpZnlpbmcgY2xpZW50cyBpbnNpZGVcbiAqIHRoZSBleHBlcmllbmNlIGFsb25nIHdpdGggdGhlIFtgJ2xvY2F0b3InYF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkxvY2F0b3J9XG4gKiBhbmQgW2AncGxhY2VyJ2Bde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5QbGFjZXJ9IHNlcnZpY2VzLlxuICpcbiAqIFRoZSBgJ2NoZWNraW4nYCBzZXJ2aWNlIGlzIHRoZSBtb3N0IHNpbXBsZSBhbW9uZyB0aGVzZSBzZXJ2aWNlcyBhcyB0aGUgc2VydmVyXG4gKiBzaW1wbHkgYXNzaWducyBhIHRpY2tldCB0byB0aGUgY2xpZW50IGFtb25nIHRoZSBhdmFpbGFibGUgb25lcy4gVGhlIHRpY2tldCBjYW5cbiAqIG9wdGlvbmFsbHkgYmUgYXNzb2NpYXRlZCB3aXRoIGNvb3JkaW5hdGVzIG9yIGxhYmVscyBhY2NvcmRpbmcgdG8gdGhlIHNlcnZlclxuICogYHNldHVwYCBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoZSBzZXJ2aWNlIHJlcXVpcmVzIHRoZSBbJ3BsYXRmb3JtJ117QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlBsYXRmb3JtfVxuICogc2VydmljZSwgYXMgaXQgaXMgY29uc2lkZXJlZCB0aGF0IGFuIGluZGV4IHNob3VsZCBiZSBnaXZlbiBvbmx5IHRvIGNsaWVudHMgd2hvXG4gKiBhY3RpdmVseSBlbnRlcmVkIHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBfXypUaGUgc2VydmljZSBtdXN0IGJlIHVzZWQgd2l0aCBpdHMgW3NlcnZlci1zaWRlIGNvdW50ZXJwYXJ0XXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9zZXJ2ZXIuQ2hlY2tpbn0qX19cbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuTG9jYXRvcn1cbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5QbGFjZXJ9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2hvd0RpYWxvZz1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHNlcnZpY2Ugc2hvdWxkXG4gKiAgZGlzcGxheSBhIHZpZXcgaW5mb3JtaW5nIHRoZSBjbGllbnQgb2YgaXRzIHBvc2l0aW9uLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBleGFtcGxlXG4gKiAvLyBpbnNpZGUgdGhlIGV4cGVyaWVuY2UgY29uc3RydWN0b3JcbiAqIHRoaXMuY2hlY2tpbiA9IHRoaXMucmVxdWlyZSgnY2hlY2tpbicsIHsgc2hvd0RpYWxvZzogdHJ1ZSB9KTtcbiAqL1xuY2xhc3MgQ2hlY2tpbiBleHRlbmRzIFNlcnZpY2Uge1xuICAvKiogXzxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZSBpbnN0YW5jaWF0ZWQgbWFudWFsbHlfICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQsIHRydWUpO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBzaG93RGlhbG9nOiBmYWxzZSxcbiAgICAgIG9yZGVyOiAnYXNjZW5kaW5nJyxcbiAgICAgIHZpZXdQcmlvcml0eTogNixcbiAgICB9O1xuXG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgdGhpcy5yZXF1aXJlKCdwbGF0Zm9ybScpO1xuXG4gICAgLyoqXG4gICAgICogSW5kZXggZ2l2ZW4gYnkgdGhlIHNlcnZlci5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSAtMTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbm5hbCBsYWJlbCBnaXZlbiBieSB0aGUgc2VydmVyLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25uYWwgY29vcmRpbmF0ZXMgZ2l2ZW4gYnkgdGhlIHNlcnZlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBudWxsO1xuXG4gICAgLy8gYmluZCBjYWxsYmFja3MgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICB0aGlzLl9vblBvc2l0aW9uUmVzcG9uc2UgPSB0aGlzLl9vblBvc2l0aW9uUmVzcG9uc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblVuYXZhaWxhYmxlUmVzcG9uc2UgPSB0aGlzLl9vblVuYXZhaWxhYmxlUmVzcG9uc2UuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgdGhpcy5zZXR1cCA9IHRoaXMuX3NoYXJlZENvbmZpZ1NlcnZpY2U7XG5cbiAgICAvLyBzZW5kIHJlcXVlc3QgdG8gdGhlIHNlcnZlclxuICAgIHRoaXMuc2VuZCgncmVxdWVzdCcsIHRoaXMub3B0aW9ucy5vcmRlcik7XG5cbiAgICAvLyBzZXR1cCBsaXN0ZW5lcnMgZm9yIHRoZSBzZXJ2ZXIncyByZXNwb25zZVxuICAgIHRoaXMucmVjZWl2ZSgncG9zaXRpb24nLCB0aGlzLl9vblBvc2l0aW9uUmVzcG9uc2UpO1xuICAgIHRoaXMucmVjZWl2ZSgndW5hdmFpbGFibGUnLCB0aGlzLl9vblVuYXZhaWxhYmxlUmVzcG9uc2UpO1xuXG4gICAgdGhpcy5zaG93KCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RvcCgpIHtcbiAgICBzdXBlci5zdG9wKCk7XG4gICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBmb3IgdGhlIHNlcnZlcidzIHJlc3BvbnNlXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncG9zaXRpb24nLCB0aGlzLl9vblBvc2l0aW9uUmVzcG9uc2UpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3VuYXZhaWxhYmxlJywgdGhpcy5fb25VbmF2YWlsYWJsZVJlc3BvbnNlKTtcblxuICAgIHRoaXMuaGlkZSgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vblBvc2l0aW9uUmVzcG9uc2UoaW5kZXgsIGxhYmVsLCBjb29yZGluYXRlcykge1xuICAgIGNsaWVudC5pbmRleCA9IHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICBjbGllbnQubGFiZWwgPSB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgaWYgKGNvb3JkaW5hdGVzICE9PSBudWxsICYmICFjbGllbnQuY29vcmRpbmF0ZXMpXG4gICAgICBjbGllbnQuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0RpYWxvZykge1xuICAgICAgY29uc3QgZGlzcGxheUxhYmVsID0gbGFiZWwgfHwgKGluZGV4ICsgMSkudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMudmlldy51cGRhdGVMYWJlbChkaXNwbGF5TGFiZWwpO1xuICAgICAgdGhpcy52aWV3LnNldFJlYWR5Q2FsbGJhY2sodGhpcy5yZWFkeS5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25VbmF2YWlsYWJsZVJlc3BvbnNlKCkge1xuICAgIHRoaXMudmlldy51cGRhdGVFcnJvclN0YXR1cyh0cnVlKTtcbiAgfVxufVxuXG5zZXJ2aWNlTWFuYWdlci5yZWdpc3RlcihTRVJWSUNFX0lELCBDaGVja2luKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tpbjtcbiIsImltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5cblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOmVycm9yLXJlcG9ydGVyJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYCdlcnJvci1yZXBvcnRlcidgIHNlcnZpY2UuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGFsbG93cyB0byBsb2cgamF2YXNjcmlwdCBlcnJvcnMgdGhhdCBjb3VsZCBvY2N1ciBkdXJpbmcgdGhlXG4gKiBhcHBsaWNhdGlvbiBsaWZlIGN5Y2xlLiBFcnJvcnMgYXJlIGNhdWdodCBhbmQgc2VudCB0byB0aGUgc2VydmVyIGluIG9yZGVyXG4gKiB0byBiZSBwZXJzaXN0ZWQgaW4gYSBmaWxlLlxuICogQnkgZGVmYXVsdCwgdGhlIGxvZyBmaWxlcyBhcmUgbG9jYXRlZCBpbiB0aGUgYGxvZ3MvY2xpZW50c2AgZGlyZWN0b3J5IGluc2lkZVxuICogdGhlIGFwcGxpY2F0aW9uIGRpcmVjdG9yeS5cbiAqXG4gKiAqVGhlIHNlcnZpY2UgaXMgYXV0b21hdGljYWxseSBsYXVuY2hlZCB3aGVuZXZlciB0aGUgYXBwbGljYXRpb24gZGV0ZWN0cyB0aGVcbiAqIHVzZSBvZiBhIG5ldHdvcmtlZCBhY3Rpdml0eS4gSXQgc2hvdWxkIG5ldmVyIGJlIHJlcXVpcmVkIG1hbnVhbGx5IGluc2lkZVxuICogYW4gYXBwbGljYXRpb24uKlxuICpcbiAqIF9fKlRoZSBzZXJ2aWNlIG11c3QgYmUgdXNlZCB3aXRoIGl0cyBbc2VydmVyLXNpZGUgY291bnRlcnBhcnRde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL3NlcnZlci5FcnJvclJlcG9ydGVyfSpfX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqL1xuY2xhc3MgRXJyb3JSZXBvcnRlciBleHRlbmRzIFNlcnZpY2Uge1xuICAvKiogXzxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZSBpbnN0YW5jaWF0ZWQgbWFudWFsbHlfICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQsIHRydWUpO1xuXG4gICAgdGhpcy5fb25FcnJvciA9IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25FcnJvcik7XG4gICAgdGhpcy5yZWFkeSgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vbkVycm9yKGUpIHtcbiAgICBsZXQgc3RhY2s7XG4gICAgbGV0IGZpbGUgPSBlLmZpbGVuYW1lO1xuICAgIGZpbGUgPSBmaWxlLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLm9yaWdpbiwgJycpO1xuICAgIGNvbnN0IGxpbmUgPSBlLmxpbmVubztcbiAgICBjb25zdCBjb2wgPSBlLmNvbG5vO1xuICAgIGNvbnN0IG1zZyA9IGUubWVzc2FnZTtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gICAgdGhpcy5zZW5kKCdlcnJvcicsIGZpbGUsIGxpbmUsIGNvbCwgbXNnLCB1c2VyQWdlbnQpO1xuICB9XG59XG5cbnNlcnZpY2VNYW5hZ2VyLnJlZ2lzdGVyKFNFUlZJQ0VfSUQsIEVycm9yUmVwb3J0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBFcnJvclJlcG9ydGVyO1xuIiwiaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi4vY29yZS9TZXJ2aWNlJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuLi9jb3JlL3NlcnZpY2VNYW5hZ2VyJztcblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOmZpbGUtc3lzdGVtJztcbmNvbnN0IGlzU3RyaW5nID0gKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyk7XG5cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYCdmaWxlLXN5c3RlbSdgIHNlcnZpY2UuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGFsbG93IHRvIHJldHJpZXZlIGEgbGlzdCBvZiBmaWxlcyBvciBkaXJlY3RvcmllcyBmcm9tIGEgZ2l2ZW4gcGF0aC5cbiAqIElmIGEgYGxpc3RgIG9wdGlvbiBpcyBnaXZlbiB3aGVuIHJlcXVpcmluZyB0aGUgc2VydmljZSwgdGhlIHNlcnZpY2UgbWFya3NcbiAqIGl0c2VsZiBhcyBgcmVhZHlgIHdoZW4gdGhlIGZpbGUgbGlzdCBpcyByZXR1cm5lZCBieSB0aGUgc2VydmVyLlxuICogVGhlIHNlcnZpY2UgY2FuIGJlIHVzZWQgbGF0ZXIgdG8gcmV0cmlldmUgbmV3IGZpbGUgbGlzdHMsIGVhY2ggcmVxdWlyZWQgbGlzdCBpc1xuICogY2FjaGVkIGNsaWVudC1zaWRlIHRvIHByZXZlbnQgdXNlbGVzcyBuZXR3b3JrIHRyYWZmaWMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5GaWxlU3lzdGVtfkxpc3RDb25maWd8QXJyYXk8U3RyaW5nPnxBcnJheTxtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuRmlsZVN5c3RlbX5MaXN0Q29uZmlnPn0gb3B0aW9uLmxpc3QgLVxuICogIExpc3QgdG9cbiAqXG4gKiBfXypUaGUgc2VydmljZSBtdXN0IGJlIHVzZWQgd2l0aCBpdHMgW2NsaWVudC1zaWRlIGNvdW50ZXJwYXJ0XXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuRmlsZVN5c3RlbX0qX19cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXhhbXBsZVxuICogLy8gcmVxdWlyZSBhbmQgY29uZmlndXJlIHRoZSBgZmlsZS1zeXN0ZW1gIHNlcnZpY2UgaW5zaWRlIHRoZSBleHBlcmllbmNlXG4gKiAvLyBjb25zdHJ1Y3RvciwgdGhlIGZpbGUgbGlzdCB0byBiZSByZXRyaXZlIGNhbiBiZSBjb25maWd1cmVkIGFzIGEgc2ltcGxlIHN0cmluZ1xuICogdGhpcy5maWxlU3lzdGVtID0gdGhpcy5yZXF1aXJlKCdmaWxlLXN5c3RlbScsIHsgbGlzdDogJ2F1ZGlvJyB9KTtcbiAqIC8vIC4uLiBvciBhcyBhIGZ1bGwge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5GaWxlU3lzdGVtfkxpc3RDb25maWd9XG4gKiAvLyBvYmplY3QgZm9yIGJldHRlciBjb250cm9sIG92ZXIgdGhlIHJldHVybmVkIGZpbGUgbGlzdFxuICogdGhpcy5maWxlU3lzdGVtID0gdGhpcy5yZXF1aXJlKCdmaWxlLXN5c3RlbScsIHsgbGlzdDoge1xuICogICAgIHBhdGg6ICdhdWRpbycsXG4gKiAgICAgbWF0Y2g6IC9cXC53YXYkLyxcbiAqICAgICByZWN1cnNpdmU6IHRydWUsXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIGdpdmVuIHRoZSBmb2xsb3dpbmcgZmlsZSBzeXN0ZW1cbiAqIC8vIGF1ZGlvL1xuICogLy8gICB2b2ljZS5tcDNcbiAqIC8vICAgdm9pY2Uud2F2XG4gKiAvLyAgIGRydW0vXG4gKiAvLyAgICAga2ljay5tcDNcbiAqIC8vICAgICBraWNrLndhdlxuICogLy8gdGhlIGZpcnN0IHF1ZXJ5IHdpbGwgcmV0dXJuIHRoZSBmb2xsb3dpbmcgcmVzdWx0OlxuICogPiBbJy9hdWRpby92b2ljZS5tcDMnLCAnYXVkaW8vdm9pY2Uud2F2J11cbiAqIC8vIHdoaWxlIHRoZSBzZWNvbmQgb25lIHdpbGwgcmV0dXJuOlxuICogPiBbJy9hdWRpby92b2ljZS53YXYnLCAnYXVkaW8vZHJ1bS9raWNrLndhdiddXG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkZpbGVTeXN0ZW1+TGlzdENvbmZpZ31cbiAqL1xuY2xhc3MgRmlsZVN5c3RlbSBleHRlbmRzIFNlcnZpY2Uge1xuICAvKiogXzxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZSBpbnN0YW5jaWF0ZWQgbWFudWFsbHlfICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQsIHRydWUpO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7IGxpc3Q6IG51bGwgfTtcbiAgICB0aGlzLmNvbmZpZ3VyZShkZWZhdWx0cyk7XG5cbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIC8vIGFzIGZpbGUgc3lzdGVtIGlzIGFzeW5jIChzZXJ2ZXIgc2lkZSksIG5vdGhpbmcgZ3VhcmFudGVlcyByZXNwb25zZSBvcmRlclxuICAgIHRoaXMuX3JlcXVlc3RJZCA9IDA7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5saXN0ICE9PSBudWxsKVxuICAgICAgdGhpcy5nZXRMaXN0KHRoaXMub3B0aW9ucy5saXN0KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWR5KCk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuRmlsZVN5c3RlbX5MaXN0Q29uZmlnXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwYXRoIC0gTmFtZSBvZiB0aGUgZm9sZGVyIHRvIHNlYXJjaCBpbnRvLlxuICAgKiBAcHJvcGVydHkge1JlZ0V4cH0gW21hdGNoPScqJ10gLSBSZWdFeHAgdXNlZCB0byBmaWx0ZXIgdGhlIHJlc3VsdHMuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gLSBGbGFnIHdoZXRoZXIgdGhlIHNlYXJjaCBzaG91bGQgYmVcbiAgICogIHJlY3Vyc2l2ZS5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZGlyZWN0b3JpZXM9ZmFsc2VdIC0gSWYgdHJ1ZSBvbmx5IHJldHVybiBkaXJlY3RvcmllcyxcbiAgICogIGZpbGVzIG90aGVyd2lzZS5cbiAgICovXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBsaXN0IG9mIGZpbGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuRmlsZVN5c3RlbX5MaXN0Q29uZmlnfEFycmF5PFN0cmluZz58QXJyYXk8bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkZpbGVTeXN0ZW1+TGlzdENvbmZpZz59IGNvbmZpZyAtXG4gICAqICBEZXRhaWxzIG9mIHRoZSByZXF1ZXN0ZWQgbGlzdChzKS4gVGhlIHJlcXVlc3RlZCBmaWxlcyBvciBkaXJlY3RvcmllcyBtdXN0XG4gICAqICBiZSBwdWJsaWNseSBhY2Nlc3NpYmxlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PnxQcm9taXNlPEFycmF5PEFycmF5Pj59IC0gUHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhblxuICAgKiAgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYWJzb2x1dGUgdXJscyBvZiB0aGUgZmlsZXMgb3IgZGlyZWN0b3JpZXMuXG4gICAqICBJZiBgY29uZmlnYCBpcyBhbiBhcnJheSwgdGhlIHJlc3VsdHMgd2lsbCBiZSBhbiBhcnJheSBvZiBhcnJheXNcbiAgICogIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBlYWNoIGRpZmZlcmVudCByZXF1ZXN0LlxuICAgKlxuICAgKiBAZXhhbXBsZTpcbiAgICogLy8gMS4gU2luZ2xlIGxpc3RcbiAgICogLy8gcmV0cmlldmUgYWxsIHRoZSBmaWxlIGluIGEgZm9sZGVyXG4gICAqIGZpbGVTeXN0ZW0uZ2V0TGlzdCgnbXktZGlyZWN0b3J5JykudGhlbigobGlzdCkgPT4gLi4uICk7XG4gICAqIC8vIG9yLCByZXRyaWV2ZSBhbGwgdGhlIGAud2F2YCBmaWxlcyBpbnNpZGUgYSBnaXZlbiBmb2xkZXIsXG4gICAqIC8vc2VhcmNoIHJlY3Vyc2l2ZWx5XG4gICAqIGZpbGVTeXN0ZW0uZ2V0TGlzdCh7XG4gICAqICAgcGF0aDogJ215LWRpcmVjdG9yeScsXG4gICAqICAgbWF0Y2g6IC9cXC53YXYvLFxuICAgKiAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICogfSkudGhlbigobGlzdCkgPT4gLi4uICk7XG4gICAqXG4gICAqIC8vIDIuIE11bHRpcGxlIFJlcXVlc3RzXG4gICAqIC8vIHJldHJpZXZlIGFsbCB0aGUgZmlsZSBpbiAyIGRpZmZlcmVudCBmb2xkZXJzLCB0aGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZVxuICAgKiAvLyBhbiBhcnJheSBjb250YWluaW5nIHRoZSAyIGxpc3RzXG4gICAqIGZpbGVTeXN0ZW0uZ2V0TGlzdChbJ215LWRpcmVjdG9yeTEnLCAnbXktZGlyZWN0b3J5MiddKVxuICAgKiAgIC50aGVuKChsaXN0cykgPT4gLi4uICk7XG4gICAqIC8vIG9yXG4gICAqIGZpbGVTeXN0ZW0uZ2V0TGlzdChbeyAuLi4gfSwgeyAuLi4gfV0pXG4gICAqICAgLnRoZW4oKGxpc3RzKSA9PiAuLi4gKTtcbiAgICovXG4gIGdldExpc3QoY29uZmlnKSB7XG4gICAgLy8gc2VyaWFsaXplIHRoZSBqc29uIGNvbmZpZyB0byBwcm9wZXJseSBoYW5kbGUgUmVnRXhwLCBhZGFwdGVkIGZyb206XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjA3NTkyNy9zZXJpYWxpemF0aW9uLW9mLXJlZ2V4cCNhbnN3ZXItMzM0MTY2ODRcbiAgICBjb25zdCBfY29uZmlnID0gSlNPTi5zdHJpbmdpZnkoY29uZmlnLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIHJldHVybiBgX19SRUdFWFAgJHt2YWx1ZS50b1N0cmluZygpfWA7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGtleSA9IGlzU3RyaW5nKGNvbmZpZykgPyBjb25maWcgOiBfY29uZmlnO1xuXG4gICAgaWYgKHRoaXMuX2NhY2hlW2tleV0pXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVba2V5XTtcblxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3JlcXVlc3RJZDtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBgbGlzdDoke2lkfWA7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgKz0gMTtcblxuICAgICAgdGhpcy5yZWNlaXZlKGNoYW5uZWwsIChyZXN1bHRzKSA9PiB7XG4gICAgICAgIC8vIEBub3RlIC0gc29ja2V0LmlvIHJlbW92ZSB0aGUgZmlyc3QgbGlzdGVuZXIgaWYgbm8gZnVuYyBhcmd1bWVudCBnaXZlblxuICAgICAgICAvLyAgICAgICAgIHNob3VsZCBiZSBkb25lIHByb3Blcmx5IC0+IHVwZGF0ZSBzb2NrZXQgYW5kIEFjdGl2aXR5XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoY2hhbm5lbCk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXN0ICE9PSBudWxsICYmIGNoYW5uZWwgPT09ICdsaXN0OjAnKVxuICAgICAgICAgIHRoaXMuZmlsZUxpc3QgPSByZXN1bHRzO1xuICAgICAgICAgIHRoaXMucmVhZHkoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNlbmQoJ3JlcXVlc3QnLCBpZCwgX2NvbmZpZyk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RJZCArPSAxO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY2FjaGVba2V5XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgRmlsZVN5c3RlbSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZpbGVTeXN0ZW07XG4iLCJpbXBvcnQgU2VydmljZSBmcm9tICcuLi9jb3JlL1NlcnZpY2UnO1xuaW1wb3J0IHNlcnZpY2VNYW5hZ2VyIGZyb20gJy4uL2NvcmUvc2VydmljZU1hbmFnZXInO1xuaW1wb3J0IGNsaWVudCBmcm9tICcuLi9jb3JlL2NsaWVudCc7XG5cblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOmdlb2xvY2F0aW9uJztcbmNvbnN0IGdlb2xvY2F0aW9uID0gbmF2aWdhdG9yLmdlb2xvY2F0aW9uO1xuXG5mdW5jdGlvbiBnZW9wb3NpdGlvblRvSnNvbihnZW9wb3NpdGlvbikge1xuICByZXR1cm4ge1xuICAgIHRpbWVzdGFtcDogZ2VvcG9zaXRpb24udGltZXN0YW1wLFxuICAgIGNvb3Jkczoge1xuICAgICAgYWNjdXJhY3k6IGdlb3Bvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeSxcbiAgICAgIGFsdGl0dWRlOiBnZW9wb3NpdGlvbi5jb29yZHMuYWx0aXR1ZGUsXG4gICAgICBhbHRpdHVkZUFjY3VyYWN5OiBnZW9wb3NpdGlvbi5jb29yZHMuYWx0aXR1ZGVBY2N1cmFjeSxcbiAgICAgIGhlYWRpbmc6IGdlb3Bvc2l0aW9uLmNvb3Jkcy5oZWFkaW5nLFxuICAgICAgbGF0aXR1ZGU6IGdlb3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogZ2VvcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgIHNwZWVkOiBnZW9wb3NpdGlvbi5jb29yZHMuc3BlZWRcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tR2VvcG9zaXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICBjb29yZHM6IHtcbiAgICAgIGFjY3VyYWN5OiAxMCxcbiAgICAgIGFsdGl0dWRlOiAxMCxcbiAgICAgIGFsdGl0dWRlQWNjdXJhY3k6IDEwLFxuICAgICAgaGVhZGluZzogMCxcbiAgICAgIGxhdGl0dWRlOiBNYXRoLnJhbmRvbSgpICogMTgwIC0gOTAsXG4gICAgICBsb25naXR1ZGU6IE1hdGgucmFuZG9tKCkgKiAzNjAgLSAxODAsXG4gICAgICBzcGVlZDogMSxcbiAgICB9XG4gIH07XG59XG5cbi8vIHRoaXMgaXMgcXVpdGUgYSBsYXJnZSB1cGRhdGUuLi5cbmZ1bmN0aW9uIHVwZGF0ZVJhbmRvbUdlb3Bvc2l0aW9uKGdlb3Bvc2l0aW9uKSB7XG4gIGdlb3Bvc2l0aW9uLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBnZW9wb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUgKz0gKE1hdGgucmFuZG9tKCkgKiAxZS00KSAtICgxZS00IC8gMik7XG4gIGdlb3Bvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUgKz0gKE1hdGgucmFuZG9tKCkgKiAxZS00KSAtICgxZS00IC8gMik7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgY2xpZW50IGAnZ2VvbG9jYXRpb24nYCBzZXJ2aWNlLlxuICpcbiAqIFRoZSBgJ2dlb2xvY2F0aW9uJ2Agc2VydmljZSBhbGxvd3MgdG8gcmV0cmlldmUgdGhlIGxhdGl0dWRlIGFuZCBsb25naXR1ZGVcbiAqIG9mIHRoZSBjbGllbnQgdXNpbmcgYGdwc2AuIFRoZSBjdXJyZW50IHZhbHVlcyBhcmUgc3RvcmUgaW50byB0aGVcbiAqIGBjbGllbnQuY29vcmRpbmF0ZXNgIG1lbWJlci5cbiAqXG4gKiBfXypUaGUgc2VydmljZSBtdXN0IGJlIHVzZWQgd2l0aCBpdHMgW3NlcnZlci1zaWRlIGNvdW50ZXJwYXJ0XXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9zZXJ2ZXIuR2VvbG9jYXRpb259Kl9fXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IG9wdGlvbnMuXG4gKiBAcGFyYW0geydzdGFydCd8J3N0b3AnfSBbb3B0aW9ucy5zdGF0ZT0nc3RhcnQnXSAtIERlZmF1bHQgc3RhdGUgd2hlbiB0aGVcbiAqICBzZXJ2aWNlIGlzIGxhdW5jaGVkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVIaWdoQWNjdXJhY3k9dHJ1ZV0gLSBEZWZpbmUgaWYgdGhlIGFwcGxpY2F0aW9uXG4gKiAgd291bGQgbGlrZSB0byByZWNlaXZlIHRoZSBiZXN0IHBvc3NpYmxlIHJlc3VsdHMgKGNmLiBbaHR0cHM6Ly9kZXYudzMub3JnL2dlby9hcGkvc3BlYy1zb3VyY2UuaHRtbCNoaWdoLWFjY3VyYWN5XShodHRwczovL2Rldi53My5vcmcvZ2VvL2FwaS9zcGVjLXNvdXJjZS5odG1sI2hpZ2gtYWNjdXJhY3kpKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKi9cbmNsYXNzIEdlb2xvY2F0aW9uIGV4dGVuZHMgU2VydmljZSB7XG4gIC8qKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbmNpYXRlZCBtYW51YWxseV8gKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHN0YXRlOiAnc3RhcnQnLFxuICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxuICAgICAgLy8gYnlwYXNzOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgdGhpcy5wbGF0Zm9ybSA9IHRoaXMucmVxdWlyZSgncGxhdGZvcm0nKTtcblxuICAgIHRoaXMuX29uU3VjY2VzcyA9IHRoaXMuX29uU3VjY2Vzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fd2F0Y2hJZCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIH1cblxuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5mZWF0dXJlKSB7XG4gICAgICBsZXQgZmVhdHVyZSA9ICdnZW9sb2NhdGlvbic7XG5cbiAgICAgIGlmIChvcHRpb25zLmJ5cGFzcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYnlwYXNzID09PSB0cnVlKVxuICAgICAgICBmZWF0dXJlID0gJ2dlb2xvY2F0aW9uLW1vY2snO1xuXG4gICAgICB0aGlzLm9wdGlvbnMuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlcXVpcmVGZWF0dXJlKGZlYXR1cmUpO1xuICAgIH1cblxuICAgIHN1cGVyLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5mZWF0dXJlID09PSAnZ2VvbG9jYXRpb24tbW9jaycpIHtcbiAgICAgIGNvbnN0IGdlb3Bvc2l0aW9uID0gZ2V0UmFuZG9tR2VvcG9zaXRpb24oKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNsaWVudChnZW9wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLy8gb25seSBzeW5jIHZhbHVlcyByZXRyaWV2ZWQgZnJvbSBgcGxhdGZvcm1gIHdpdGggc2VydmVyIGJlZm9yZSBnZXR0aW5nIHJlYWR5XG4gICAgdGhpcy5lbWl0KCdnZW9wb3NpdGlvbicsIGNsaWVudC5nZW9wb3NpdGlvbik7XG4gICAgdGhpcy5zZW5kKCdnZW9wb3NpdGlvbicsIGdlb3Bvc2l0aW9uVG9Kc29uKGNsaWVudC5nZW9wb3NpdGlvbikpO1xuICAgIHRoaXMucmVhZHkoKTtcblxuICAgIHRoaXMuc2V0U3RhdGUodGhpcy5vcHRpb25zLnN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBzZXJ2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0geydzdGFydCd8J3N0b3AnfSBTdHJpbmcgLSBOZXcgc3RhdGUgb2YgdGhlIHNlcnZpY2UuXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3N0YXJ0JylcbiAgICAgICAgdGhpcy5fc3RhcnRXYXRjaCgpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLl9zdG9wV2F0Y2goKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHRoZSByZWZyZXNoIG9mIHRoZSBwb3NpdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydFdhdGNoKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl93YXRjaElkID0gZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbih0aGlzLl9vblN1Y2Nlc3MsIHRoaXMuX29uRXJyb3IsIHRoaXMub3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dhdGNoSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVJhbmRvbUdlb3Bvc2l0aW9uKGNsaWVudC5nZW9wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX29uU3VjY2VzcyhjbGllbnQuZ2VvcG9zaXRpb24pO1xuICAgICAgfSwgMzAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSByZWZyZXNoIG9mIHRoZSBwb3NpdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wV2F0Y2goKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZyA9PT0gZmFsc2UpXG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl93YXRjaElkKTtcbiAgICBlbHNlXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3dhdGNoSWQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vblN1Y2Nlc3MoZ2VvcG9zaXRpb24pIHtcbiAgICB0aGlzLl91cGRhdGVDbGllbnQoZ2VvcG9zaXRpb24pO1xuICAgIHRoaXMuZW1pdCgnZ2VvcG9zaXRpb24nLCBnZW9wb3NpdGlvbik7XG4gICAgdGhpcy5zZW5kKCdnZW9wb3NpdGlvbicsIGdlb3Bvc2l0aW9uVG9Kc29uKGdlb3Bvc2l0aW9uKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3VwZGF0ZUNsaWVudChnZW9wb3NpdGlvbikge1xuICAgIGNvbnN0IGNvb3JkcyA9IGdlb3Bvc2l0aW9uLmNvb3JkcztcbiAgICBjbGllbnQuY29vcmRpbmF0ZXMgPSBbY29vcmRzLmxhdGl0dWRlLCBjb29yZHMubG9uZ2l0dWRlXTtcbiAgICBjbGllbnQuZ2VvcG9zaXRpb24gPSBnZW9wb3NpdGlvbjtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25FcnJvcihlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgR2VvbG9jYXRpb24pO1xuXG5leHBvcnQgZGVmYXVsdCBHZW9sb2NhdGlvbjtcbiIsImltcG9ydCBjbGllbnQgZnJvbSAnLi4vY29yZS9jbGllbnQnO1xuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi4vY29yZS9TZXJ2aWNlJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuLi9jb3JlL3NlcnZpY2VNYW5hZ2VyJztcbmltcG9ydCBTZWdtZW50ZWRWaWV3IGZyb20gJy4uL3ZpZXdzL1NlZ21lbnRlZFZpZXcnO1xuXG5jb25zdCBTRVJWSUNFX0lEID0gJ3NlcnZpY2U6bGFuZ3VhZ2UnO1xuXG5jb25zdCBkZWZhdWx0Vmlld1RlbXBsYXRlID0gYFxuIDxkaXYgY2xhc3M9XCJzZWN0aW9uLXRvcFwiPjwvZGl2PlxuIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWNlbnRlclwiPlxuICAgPCUgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXksaW5kZXgpIHsgJT5cbiAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0blwiIGRhdGEtaWQ9XCI8JT0ga2V5ICU+XCI+PCU9IG9wdGlvbnNba2V5XSAlPjwvYnV0dG9uPlxuICAgPCUgfSk7ICU+XG4gPC9kaXY+XG4gPGRpdiBjbGFzcz1cInNlY3Rpb24tYm90dG9tXCI+PC9kaXY+XG5gO1xuXG4vKipcbiAqIEFQSSBvZiBhIGNvbXBsaWFudCB2aWV3IGZvciB0aGUgYGxhbmd1YWdlYCBzZXJ2aWNlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBpbnRlcmZhY2UgQWJzdHJhY3RMYW5ndWFnZVZpZXdcbiAqIEBleHRlbmRzIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFZpZXdcbiAqIEBhYnN0cmFjdFxuICovXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCB3aGVuIHRoZSBwYXNzd29yZCBpcyBzdWJtaXR0ZWRcbiAqIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBuYW1lIHNldFNlbGVjdGlvbkNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0TGFuZ3VhZ2VWaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzZWxlY3Rpb25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXJcbiAqICBjaG9vc2UgaXRzIGxhbmd1YWdlXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXIgY2hvb3NlIGl0cyBsYW5ndWFnZS5cbiAqXG4gKiBAY2FsbGJhY2tcbiAqIEBuYW1lIHNlbGVjdGlvbkNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0TGFuZ3VhZ2VWaWV3XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gaWQgb2YgdGhlIGxhbmd1YWdlLlxuICovXG5cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYGxhbmd1YWdlYCBzZXJ2aWNlLlxuICpcbiAqIFRoaXMgc2VydmljZSBwcmVzZW50IGEgdmlldyB0aGF0IGFsbG93cyB0byBkZWZpbmUgYSBsYW5nYWdlIGZvciB0aGUgY2xpZW50LlxuICogVXNpbmcgdGhpcyBzZXJ2aWNlIGltcGxpZXMgdGhhdCB0aGUgYXBwbGljYXRpb24gc2hvdWxkIGhhbmRsZSBpdHNlbGYgdGhpc1xuICogaW5mb3JtYXRpb24gaW4gdGhlIHZpZXdzIG9mIHRoZSB0aGUgc2VydmljZXMgYXMgd2VsbCBhcyBpbiB0aGUgZXhwZXJpZW5jZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXhhbXBsZVxuICogdGhpcy5sYW5ndWFnZSA9IHRoaXMucmVxdWlyZSgnbGFuZ3VhZ2UnLCB7IG9wdGlvbnM6IHsgZW46ICdFbmdsaXNoJywgZnI6J0ZyYW7Dp2FpcycgfX0pO1xuICovXG5jbGFzcyBMYW5ndWFnZSBleHRlbmRzIFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihTRVJWSUNFX0lELCBmYWxzZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHZpZXdQcmlvcml0eTogOSxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgIH1cblxuICAgIHRoaXMuY29uZmlndXJlKGRlZmF1bHRzKTtcblxuICAgIHRoaXMuX29uU2VsZWN0aW9uID0gdGhpcy5fb25TZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgdGhpcy52aWV3Lm1vZGVsLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMub3B0aW9ucztcbiAgICB0aGlzLnZpZXcuc2V0U2VsZWN0aW9uQ2FsbGJhY2sodGhpcy5fb25TZWxlY3Rpb24pO1xuXG4gICAgdGhpcy5zaG93KCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RvcCgpIHtcbiAgICBzdXBlci5zdG9wKCk7XG4gICAgdGhpcy5oaWRlKCk7XG4gIH1cblxuICBfb25TZWxlY3Rpb24oaWQpIHtcbiAgICBjbGllbnQubGFuZ3VhZ2UgPSBpZDtcbiAgICB0aGlzLnJlYWR5KCk7XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgTGFuZ3VhZ2UpO1xuXG5leHBvcnQgZGVmYXVsdCBMYW5ndWFnZTtcbiIsImltcG9ydCBjbGllbnQgZnJvbSAnLi4vY29yZS9jbGllbnQnO1xuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi4vY29yZS9TZXJ2aWNlJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuLi9jb3JlL3NlcnZpY2VNYW5hZ2VyJztcblxuLyoqXG4gKiBBUEkgb2YgYSBjb21wbGlhbnQgdmlldyBmb3IgdGhlIGBsb2NhdG9yYCBzZXJ2aWNlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBpbnRlcmZhY2UgQWJzdHJhY3RMb2NhdG9yVmlld1xuICogQGV4dGVuZHMgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0Vmlld1xuICogQGFic3RyYWN0XG4gKi9cbi8qKlxuICogU2V0IGFuZCBkaXNwbGF5IHRoZSBgYXJlYWAgZGVmaW5pdGlvbiAoYXMgZGVmaW5lZCBpbiBzZXJ2ZXIgY29uZmlndXJhdGlvbikuXG4gKlxuICogQG5hbWUgc2V0QXJlYVxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdExvY2F0b3JWaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZWEgLSBBcmVhIGRlZmludGlvbiBhcyBkZWNsYXJlZCBpbiBzZXJ2ZXIgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLndpZHRoIC0gV2l0aCBvZiB0aGUgYXJlYS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLmhlaWdodCAtIEhlaWdodCBvZiB0aGUgYXJlYS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXJlYS5sYWJlbHM9W11dIC0gTGFiZWxzIG9mIHRoZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXJlYS5jb29yZGluYXRlcz1bXV0gLSBDb29yZGluYXRlcyBvZiB0aGUgYXJlYS5cbiAqL1xuLyoqXG4gKiBSZWdpc3RlciB0aGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgdXNlciBzZWxlY3QgYSBwb3NpdGlvbi5cbiAqXG4gKiBAbmFtZSBzZXRTZWxlY3RDYWxsYmFja1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdExvY2F0b3JWaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzZWxlY3RDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICogIHdoZW4gYSBwb3NpdGlvbiBpcyBzZWxlY3RlZC4gVGhpcyBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBpbmRleGAsXG4gKiBgbGFiZWxgIGFuZCBgY29vcmRpbmF0ZXNgIG9mIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb24uXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXIgc2VsZWN0IGEgcG9zaXRpb24uXG4gKlxuICogQGNhbGxiYWNrXG4gKiBAbmFtZSBzZWxlY3RDYWxsYmFja1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdExvY2F0b3JWaWV3XG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgc2VsZWN0ZWQgbG9jYXRpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgLSBMYWJlbCBvZiB0aGUgc2VsZWN0ZWQgbG9jYXRpb24gaWYgYW55LlxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBjb29yZGluYXRlcyAtIENvb3JkaW5hdGVzIChgW3gsIHldYCkgb2YgdGhlIHNlbGVjdGVkXG4gKiAgbG9jYXRpb24gaWYgYW55LlxuICovXG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTpsb2NhdG9yJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYCdsb2NhdG9yJ2Agc2VydmljZS5cbiAqXG4gKiBUaGlzIHNlcnZpY2UgaXMgb25lIG9mIHRoZSBwcm92aWRlZCBzZXJ2aWNlcyBhaW1lZCBhdCBpZGVudGlmeWluZyBjbGllbnRzIGluc2lkZVxuICogdGhlIGV4cGVyaWVuY2UgYWxvbmcgd2l0aCB0aGUgW2AncGxhY2VyJ2Bde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5QbGFjZXJ9XG4gKiBhbmQgW2AnY2hlY2tpbidgXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2hlY2tpbn0gc2VydmljZXMuXG4gKlxuICogVGhlIGAnbG9jYXRvcidgIHNlcnZpY2UgYWxsb3dzIGEgY2xpZW50IHRvIGdpdmUgaXRzIGFwcHJveGltYXRlIGxvY2F0aW9uIGluc2lkZVxuICogYSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBhcmVhYCBhcyBkZWZpbmVkIGluIHRoZSBzZXJ2ZXIncyBgc2V0dXBgXG4gKiBjb25maWd1cmF0aW9uIG1lbWJlci5cbiAqXG4gKiBfXypUaGUgc2VydmljZSBtdXN0IGJlIHVzZWQgd2l0aCBpdHMgW3NlcnZlci1zaWRlIGNvdW50ZXJwYXJ0XXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9zZXJ2ZXIuTG9jYXRvcn0qX19cbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhY2VyfVxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkNoZWNraW59XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmFuZG9tPWZhbHNlXSAtIERlZmluZXMgd2hldGhlciB0aGUgbG9jYXRpb24gaXNcbiAqICBzZXQgcmFuZG9tbHkgKG1haW5seSBmb3IgZGV2ZWxvcG1lbnQgcHVycG9zZXMpLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBleGFtcGxlXG4gKiAvLyBpbnNpZGUgdGhlIGV4cGVyaWVuY2UgY29uc3RydWN0b3JcbiAqIHRoaXMubG9jYXRvciA9IHRoaXMucmVxdWlyZSgnbG9jYXRvcicpO1xuICovXG5jbGFzcyBMb2NhdG9yIGV4dGVuZHMgU2VydmljZSB7XG4gIC8qKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbmNpYXRlZCBtYW51YWxseV8gKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHJhbmRvbTogZmFsc2UsXG4gICAgICB2aWV3UHJpb3JpdHk6IDYsXG4gICAgfTtcblxuICAgIHRoaXMuY29uZmlndXJlKGRlZmF1bHRzKTtcblxuICAgIHRoaXMuX3NoYXJlZENvbmZpZyA9IHRoaXMucmVxdWlyZSgnc2hhcmVkLWNvbmZpZycpO1xuXG4gICAgdGhpcy5fb25Ba25vd2xlZGdlUmVzcG9uc2UgPSB0aGlzLl9vbkFrbm93bGVkZ2VSZXNwb25zZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NlbmRDb29yZGluYXRlcyA9IHRoaXMuX3NlbmRDb29yZGluYXRlcy5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0YXJ0KCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG4gICAgdGhpcy5zaG93KCk7XG5cbiAgICB0aGlzLnNlbmQoJ3JlcXVlc3QnKTtcbiAgICB0aGlzLnJlY2VpdmUoJ2Fja25vd2xlZGdlJywgdGhpcy5fb25Ba25vd2xlZGdlUmVzcG9uc2UpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuc3RvcCgpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Fja25vd2xlZGdlJywgdGhpcy5fb25Ba25vd2xlZGdlUmVzcG9uc2UpO1xuICAgIHRoaXMuaGlkZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmVhQ29uZmlnUGF0aCAtIFBhdGggdG8gdGhlIGFyZWEgaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBfb25Ba25vd2xlZGdlUmVzcG9uc2UoYXJlYUNvbmZpZ1BhdGgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmRvbSkge1xuICAgICAgY29uc3QgeCA9IE1hdGgucmFuZG9tKCkgKiBhcmVhLndpZHRoO1xuICAgICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCkgKiBhcmVhLmhlaWdodDtcbiAgICAgIHRoaXMuX3NlbmRDb29yZGluYXRlcyh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX3NoYXJlZENvbmZpZy5nZXQoYXJlYUNvbmZpZ1BhdGgpO1xuICAgICAgdGhpcy52aWV3LnNldEFyZWEoYXJlYSk7XG4gICAgICB0aGlzLnZpZXcuc2V0U2VsZWN0Q2FsbGJhY2sodGhpcy5fc2VuZENvb3JkaW5hdGVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBjb29yZGluYXRlcyB0byB0aGUgc2VydmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgY2xpZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgY2xpZW50LlxuICAgKi9cbiAgX3NlbmRDb29yZGluYXRlcyh4LCB5KSB7XG4gICAgY2xpZW50LmNvb3JkaW5hdGVzID0gW3gsIHldO1xuXG4gICAgdGhpcy5zZW5kKCdjb29yZGluYXRlcycsIGNsaWVudC5jb29yZGluYXRlcyk7XG4gICAgdGhpcy5yZWFkeSgpO1xuICB9XG59XG5cbnNlcnZpY2VNYW5hZ2VyLnJlZ2lzdGVyKFNFUlZJQ0VfSUQsIExvY2F0b3IpO1xuXG5leHBvcnQgZGVmYXVsdCBMb2NhdG9yO1xuIiwiaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi4vY29yZS9TZXJ2aWNlJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuLi9jb3JlL3NlcnZpY2VNYW5hZ2VyJztcbmltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbmNvbnN0IGF1ZGlvU2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTptZXRyaWMtc2NoZWR1bGVyJztcblxuY29uc3QgRVBTSUxPTiA9IDFlLTEyO1xuXG5jbGFzcyBTeW5jU2NoZWR1bGVySG9vayBleHRlbmRzIGF1ZGlvLlRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihzeW5jU2NoZWR1bGVyLCBtZXRyaWNTY2hlZHVsZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5uZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcbiAgICB0aGlzLm5leHRUaW1lID0gSW5maW5pdHk7XG5cbiAgICB0aGlzLnN5bmNTY2hlZHVsZXIgPSBzeW5jU2NoZWR1bGVyO1xuICAgIHRoaXMubWV0cmljU2NoZWR1bGVyID0gbWV0cmljU2NoZWR1bGVyO1xuXG4gICAgc3luY1NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpOyAvLyBhZGQgaG9vayB0byBzeW5jIChtYXN0ZXIpIHNjaGVkdWxlclxuICB9XG5cbiAgYWR2YW5jZVRpbWUoc3luY1RpbWUpIHtcbiAgICBjb25zdCBtZXRyaWNTY2hlZHVsZXIgPSB0aGlzLm1ldHJpY1NjaGVkdWxlcjtcbiAgICBjb25zdCBuZXh0UG9zaXRpb24gPSBtZXRyaWNTY2hlZHVsZXIuX2FkdmFuY2VQb3NpdGlvbihzeW5jVGltZSwgdGhpcy5uZXh0UG9zaXRpb24sIG1ldHJpY1NjaGVkdWxlci5fbWV0cmljU3BlZWQpO1xuICAgIGNvbnN0IG5leHRUaW1lID0gbWV0cmljU2NoZWR1bGVyLmdldFN5bmNUaW1lQXRNZXRyaWNQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuXG4gICAgdGhpcy5uZXh0UG9zaXRpb24gPSBuZXh0UG9zaXRpb247XG4gICAgdGhpcy5uZXh0VGltZSA9IG5leHRUaW1lO1xuXG4gICAgcmV0dXJuIG5leHRUaW1lO1xuICB9XG5cbiAgcmVzY2hlZHVsZSgpIHtcbiAgICBjb25zdCBtZXRyaWNTY2hlZHVsZXIgPSB0aGlzLm1ldHJpY1NjaGVkdWxlcjtcbiAgICBjb25zdCBuZXh0UG9zaXRpb24gPSBtZXRyaWNTY2hlZHVsZXIuX2VuZ2luZVF1ZXVlLnRpbWU7XG4gICAgY29uc3Qgc3luY1RpbWUgPSBtZXRyaWNTY2hlZHVsZXIuZ2V0U3luY1RpbWVBdE1ldHJpY1Bvc2l0aW9uKG5leHRQb3NpdGlvbik7XG5cbiAgICBpZiAoc3luY1RpbWUgIT09IHRoaXMubmV4dFRpbWUpIHtcbiAgICAgIHRoaXMubmV4dFBvc2l0aW9uID0gbmV4dFBvc2l0aW9uO1xuICAgICAgdGhpcy5uZXh0VGltZSA9IHN5bmNUaW1lO1xuXG4gICAgICB0aGlzLnJlc2V0VGltZShzeW5jVGltZSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFN5bmNFdmVudEVuZ2luZSBleHRlbmRzIGF1ZGlvLlRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihzeW5jU2NoZWR1bGVyLCBtZXRyaWNTY2hlZHVsZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5zeW5jU2NoZWR1bGVyID0gc3luY1NjaGVkdWxlcjtcbiAgICB0aGlzLm1ldHJpY1NjaGVkdWxlciA9IG1ldHJpY1NjaGVkdWxlcjtcblxuICAgIHRoaXMuc3luY1RpbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tZXRyaWNQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRlbXBvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGVtcG9Vbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZXZlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICBzeW5jU2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XG4gIH1cblxuICBhZHZhbmNlVGltZShzeW5jVGltZSkge1xuICAgIHRoaXMubWV0cmljU2NoZWR1bGVyLl9zeW5jKHRoaXMuc3luY1RpbWUsIHRoaXMubWV0cmljUG9zaXRpb24sIHRoaXMudGVtcG8sIHRoaXMudGVtcG9Vbml0LCB0aGlzLmV2ZW50KTtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cblxuICBzZXQoc3luY1RpbWUsIG1ldHJpY1Bvc2l0aW9uLCB0ZW1wbywgdGVtcG9Vbml0LCBldmVudCkge1xuICAgIHRoaXMuc3luY1RpbWUgPSBzeW5jVGltZTtcbiAgICB0aGlzLm1ldHJpY1Bvc2l0aW9uID0gbWV0cmljUG9zaXRpb247XG4gICAgdGhpcy50ZW1wbyA9IHRlbXBvO1xuICAgIHRoaXMudGVtcG9Vbml0ID0gdGVtcG9Vbml0O1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcblxuICAgIHRoaXMucmVzZXRUaW1lKHN5bmNUaW1lKTtcbiAgfVxuXG4gIHJlc2V0KHN5bmNUaW1lLCBtZXRyaWNQb3NpdGlvbiwgdGVtcG8sIHRlbXBvVW5pdCwgZXZlbnQpIHtcbiAgICB0aGlzLnN5bmNUaW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWV0cmljUG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50ZW1wbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRlbXBvVW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmV2ZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5yZXNldFRpbWUoSW5maW5pdHkpO1xuICB9XG59XG5cbmNsYXNzIEJlYXRFbmdpbmUgZXh0ZW5kcyBhdWRpby5UaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3IobWV0cm8pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5tZXRybyA9IG1ldHJvO1xuICAgIGF1ZGlvU2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBuZXh0IGJlYXRcbiAgYWR2YW5jZVRpbWUoYXVkaW9UaW1lKSB7XG4gICAgY29uc3QgbWV0cm8gPSB0aGlzLm1ldHJvO1xuXG4gICAgY29uc3QgY29udCA9IG1ldHJvLmNhbGxiYWNrKG1ldHJvLm1lYXN1cmVDb3VudCwgbWV0cm8uYmVhdENvdW50KTtcbiAgICBtZXRyby5iZWF0Q291bnQrKztcblxuICAgIGlmIChjb250ID09PSB1bmRlZmluZWQgfHwgY29udCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKG1ldHJvLmJlYXRDb3VudCA+PSBtZXRyby5udW1CZWF0cylcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuXG4gICAgICByZXR1cm4gYXVkaW9UaW1lICsgbWV0cm8uYmVhdFBlcmlvZDtcbiAgICB9XG5cbiAgICBtZXRyby5yZXNldFBvc2l0aW9uKEluZmluaXR5KTtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWV0cm8gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubWFzdGVyKVxuICAgICAgdGhpcy5tYXN0ZXIucmVtb3ZlKHRoaXMpO1xuICB9XG59XG5cbmNsYXNzIE1ldHJvbm9tZUVuZ2luZSBleHRlbmRzIGF1ZGlvLlRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihzdGFydFBvc2l0aW9uLCBudW1CZWF0cywgYmVhdExlbmd0aCwgc3RhcnRPbkJlYXQsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgdGhpcy5udW1CZWF0cyA9IG51bUJlYXRzO1xuICAgIHRoaXMuYmVhdExlbmd0aCA9IGJlYXRMZW5ndGg7XG4gICAgdGhpcy5zdGFydE9uQmVhdCA9IHN0YXJ0T25CZWF0O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIHRoaXMubWVhc3VyZUxlbmd0aCA9IG51bUJlYXRzICogYmVhdExlbmd0aDtcbiAgICB0aGlzLmJlYXRQZXJpb2QgPSAwO1xuICAgIHRoaXMubWVhc3VyZUNvdW50ID0gMDtcbiAgICB0aGlzLmJlYXRDb3VudCA9IDA7XG5cbiAgICBpZiAobnVtQmVhdHMgPiAxKVxuICAgICAgdGhpcy5iZWF0RW5naW5lID0gbmV3IEJlYXRFbmdpbmUodGhpcyk7XG4gIH1cblxuICAvLyByZXR1cm4gcG9zaXRpb24gb2YgbmV4dCBtZWFzdXJlXG4gIHN5bmNTcGVlZChzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIG1ldHJpY1NwZWVkKSB7XG4gICAgaWYgKG1ldHJpY1NwZWVkIDw9IDAgJiYgdGhpcy5iZWF0RW5naW5lKVxuICAgICAgdGhpcy5iZWF0RW5naW5lLnJlc2V0VGltZShJbmZpbml0eSk7XG4gIH1cblxuICAvLyByZXR1cm4gcG9zaXRpb24gb2YgbmV4dCBtZWFzdXJlXG4gIHN5bmNQb3NpdGlvbihzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIG1ldHJpY1NwZWVkKSB7XG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcblxuICAgIGlmICh0aGlzLmJlYXRFbmdpbmUpXG4gICAgICB0aGlzLmJlYXRFbmdpbmUucmVzZXRUaW1lKEluZmluaXR5KTtcblxuICAgIC8vIHNpbmNlIHdlIGFyZSBhbnl3YXkgYSBsaXR0bGUgaW4gYWR2YW5jZSwgbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3Qgc2tpcFxuICAgIC8vIHRoZSBzdGFydCBwb2ludCBkdWUgdG8gcm91bmRpbmcgZXJyb3JzXG4gICAgbWV0cmljUG9zaXRpb24gLT0gRVBTSUxPTjtcblxuICAgIHRoaXMuYmVhdFBlcmlvZCA9IHRoaXMuYmVhdExlbmd0aCAvIG1ldHJpY1NwZWVkO1xuICAgIHRoaXMuYmVhdENvdW50ID0gMDtcblxuICAgIGlmIChtZXRyaWNQb3NpdGlvbiA+PSBzdGFydFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gbWV0cmljUG9zaXRpb24gLSBzdGFydFBvc2l0aW9uO1xuICAgICAgY29uc3QgZmxvYXRNZWFzdXJlcyA9IHJlbGF0aXZlUG9zaXRpb24gLyB0aGlzLm1lYXN1cmVMZW5ndGg7XG4gICAgICBsZXQgbWVhc3VyZUNvdW50ID0gTWF0aC5mbG9vcihmbG9hdE1lYXN1cmVzKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVQaGFzZSA9IGZsb2F0TWVhc3VyZXMgLSBtZWFzdXJlQ291bnQ7XG5cbiAgICAgIGlmICh0aGlzLmJlYXRFbmdpbmUgJiYgdGhpcy5zdGFydE9uQmVhdCkge1xuICAgICAgICBjb25zdCBmbG9hdEJlYXRzID0gdGhpcy5udW1CZWF0cyAqIG1lYXN1cmVQaGFzZTtcbiAgICAgICAgY29uc3QgbmV4dEJlYXRDb3VudCA9IE1hdGguY2VpbChmbG9hdEJlYXRzKSAlIHRoaXMubnVtQmVhdHM7XG5cbiAgICAgICAgdGhpcy5iZWF0Q291bnQgPSBuZXh0QmVhdENvdW50OyAvLyBuZXh0IGJlYXRcblxuICAgICAgICBpZihuZXh0QmVhdENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgYXVkaW9UaW1lID0gYXVkaW9TY2hlZHVsZXIuY3VycmVudFRpbWU7XG4gICAgICAgICAgY29uc3QgbmV4dEJlYXREZWxheSA9IChuZXh0QmVhdENvdW50IC0gZmxvYXRCZWF0cykgKiB0aGlzLmJlYXRQZXJpb2Q7XG4gICAgICAgICAgdGhpcy5iZWF0RW5naW5lLnJlc2V0VGltZShhdWRpb1RpbWUgKyBuZXh0QmVhdERlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihtZWFzdXJlUGhhc2UgPiAwKVxuICAgICAgICBtZWFzdXJlQ291bnQrKztcblxuICAgICAgdGhpcy5tZWFzdXJlQ291bnQgPSBtZWFzdXJlQ291bnQgLSAxO1xuXG4gICAgICByZXR1cm4gc3RhcnRQb3NpdGlvbiArIG1lYXN1cmVDb3VudCAqIHRoaXMubWVhc3VyZUxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLm1lYXN1cmVDb3VudCA9IDA7XG4gICAgcmV0dXJuIHN0YXJ0UG9zaXRpb247XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBuZXh0IG1lYXN1cmVcbiAgYWR2YW5jZVBvc2l0aW9uKHN5bmNUaW1lLCBtZXRyaWNQb3NpdGlvbiwgbWV0cmljU3BlZWQpIHtcbiAgICBjb25zdCBhdWRpb1RpbWUgPSBhdWRpb1NjaGVkdWxlci5jdXJyZW50VGltZTtcblxuICAgIHRoaXMubWVhc3VyZUNvdW50Kys7XG5cbiAgICAvLyB3aGV0aGVyIG1ldHJvbm9tZSBjb250aW51ZXMgKGRlZmF1bHQgaXMgdHJ1ZSlcbiAgICBjb25zdCBjb250ID0gdGhpcy5jYWxsYmFjayh0aGlzLm1lYXN1cmVDb3VudCwgMCk7XG5cbiAgICB0aGlzLmJlYXRDb3VudCA9IDE7XG5cbiAgICBpZiAoY29udCA9PT0gdW5kZWZpbmVkIHx8IGNvbnQgPT09IHRydWUpIHtcbiAgICAgIGlmICh0aGlzLmJlYXRFbmdpbmUpXG4gICAgICAgIHRoaXMuYmVhdEVuZ2luZS5yZXNldFRpbWUoYXVkaW9UaW1lICsgdGhpcy5iZWF0UGVyaW9kKTtcblxuICAgICAgcmV0dXJuIG1ldHJpY1Bvc2l0aW9uICsgdGhpcy5tZWFzdXJlTGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJlYXRFbmdpbmUpXG4gICAgICB0aGlzLmJlYXRFbmdpbmUucmVzZXRUaW1lKEluZmluaXR5KTtcblxuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuYmVhdEVuZ2luZSlcbiAgICAgIHRoaXMuYmVhdEVuZ2luZS5kZXN0cm95KCk7XG5cbiAgICBpZiAodGhpcy5tYXN0ZXIpXG4gICAgICB0aGlzLm1hc3Rlci5yZW1vdmUodGhpcyk7XG4gIH1cbn1cblxuY2xhc3MgTWV0cmljU2NoZWR1bGVyIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQsIHRydWUpO1xuXG4gICAgdGhpcy5fc3luY1NjaGVkdWxlciA9IHRoaXMucmVxdWlyZSgnc3luYy1zY2hlZHVsZXInKTtcblxuICAgIHRoaXMuX2VuZ2luZVF1ZXVlID0gbmV3IGF1ZGlvLlByaW9yaXR5UXVldWUoKTtcbiAgICB0aGlzLl9lbmdpbmVTZXQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fbWV0cm9ub21lRW5naW5lTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgdGhpcy5fdGVtcG8gPSA2MDsgLy8gdGVtcG8gaW4gYmVhdHMgcGVyIG1pbnV0ZSAoQlBNKVxuICAgIHRoaXMuX3RlbXBvVW5pdCA9IDAuMjU7IC8vIHRlbXBvIHVuaXQgZXhwcmVzc2VkIGluIGZyYWN0aW9ucyBvZiBhIHdob2xlIG5vdGVcbiAgICB0aGlzLl9tZXRyaWNTcGVlZCA9IDAuMjU7IC8vIHdob2xlIG5vdGVzIHBlciBzZWNvbmRcblxuICAgIHRoaXMuX3N5bmNUaW1lID0gMDtcbiAgICB0aGlzLl9tZXRyaWNQb3NpdGlvbiA9IDA7XG5cbiAgICB0aGlzLl9zeW5jU2NoZWR1bGVySG9vayA9IG51bGw7XG4gICAgdGhpcy5fc3luY0V2ZW50RW5naW5lID0gbnVsbDtcblxuICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jYWxsaW5nRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZTtcblxuICAgIC8vIGNvbnN0IGRlZmF1bHRzID0ge307XG4gICAgLy8gdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgdGhpcy5fb25Jbml0ID0gdGhpcy5fb25Jbml0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TeW5jID0gdGhpcy5fb25TeW5jLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DbGVhciA9IHRoaXMuX29uQ2xlYXIuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG5cbiAgICB0aGlzLl9zeW5jU2NoZWR1bGVySG9vayA9IG5ldyBTeW5jU2NoZWR1bGVySG9vayh0aGlzLl9zeW5jU2NoZWR1bGVyLCB0aGlzKTtcbiAgICB0aGlzLl9zeW5jRXZlbnRFbmdpbmUgPSBuZXcgU3luY0V2ZW50RW5naW5lKHRoaXMuX3N5bmNTY2hlZHVsZXIsIHRoaXMpO1xuXG4gICAgdGhpcy5zZW5kKCdyZXF1ZXN0Jyk7XG4gICAgdGhpcy5yZWNlaXZlKCdpbml0JywgdGhpcy5fb25Jbml0KTtcbiAgICB0aGlzLnJlY2VpdmUoJ2NsZWFyJywgdGhpcy5fb25DbGVhcik7XG4gICAgdGhpcy5yZWNlaXZlKCdzeW5jJywgdGhpcy5fb25TeW5jKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuc3RvcCgpO1xuICB9XG5cbiAgX2NhbGxFdmVudExpc3RlbmVycyhldmVudCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5nZXQoZXZlbnQpO1xuXG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdGhpcy5fY2FsbGluZ0V2ZW50TGlzdGVuZXJzID0gdHJ1ZTtcblxuICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgc3luY1RpbWU6IHRoaXMuX3N5bmNUaW1lLFxuICAgICAgICBtZXRyaWNQb3NpdGlvbjogdGhpcy5fbWV0cmljUG9zaXRpb24sXG4gICAgICAgIHRlbXBvOiB0aGlzLl90ZW1wbyxcbiAgICAgICAgdGVtcG9Vbml0OiB0aGlzLl90ZW1wb1VuaXQsXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBsaXN0ZW5lcnMpXG4gICAgICAgIGNhbGxiYWNrKGV2ZW50LCBkYXRhKTtcblxuICAgICAgdGhpcy5fY2FsbGluZ0V2ZW50TGlzdGVuZXJzID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgX3Jlc2NoZWR1bGVNZXRyaWNFbmdpbmVzKCkge1xuICAgIGNvbnN0IHN5bmNUaW1lID0gdGhpcy5zeW5jVGltZTtcbiAgICBjb25zdCBtZXRyaWNQb3NpdGlvbiA9IHRoaXMuZ2V0TWV0cmljUG9zaXRpb25BdFN5bmNUaW1lKHN5bmNUaW1lKTtcblxuICAgIHRoaXMuX2VuZ2luZVF1ZXVlLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy5fbWV0cmljU3BlZWQgPiAwKSB7XG4gICAgICAvLyBwb3NpdGlvbiBlbmdpbmVzXG4gICAgICBjb25zdCBtZXRyaWNTcGVlZCA9IHRoaXMuX21ldHJpY1NwZWVkO1xuICAgICAgY29uc3QgcXVldWUgPSB0aGlzLl9lbmdpbmVRdWV1ZTtcblxuICAgICAgZm9yIChsZXQgZW5naW5lIG9mIHRoaXMuX2VuZ2luZVNldCkge1xuICAgICAgICBjb25zdCBuZXh0RW5naW5lUG9zaXRpb24gPSBlbmdpbmUuc3luY1Bvc2l0aW9uKHN5bmNUaW1lLCBtZXRyaWNQb3NpdGlvbiwgbWV0cmljU3BlZWQpO1xuICAgICAgICBxdWV1ZS5pbnNlcnQoZW5naW5lLCBuZXh0RW5naW5lUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH3CoFxuICAgIGVsc2Uge1xuICAgICAgLy8gc3RvcCBlbmdpbmVzXG4gICAgICBmb3IgKGxldCBlbmdpbmUgb2YgdGhpcy5fZW5naW5lU2V0KSB7XG4gICAgICAgIGlmIChlbmdpbmUuc3luY1NwZWVkKVxuICAgICAgICAgIGVuZ2luZS5zeW5jU3BlZWQoc3luY1RpbWUsIG1ldHJpY1Bvc2l0aW9uLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zeW5jU2NoZWR1bGVySG9vay5yZXNjaGVkdWxlKCk7XG4gIH1cblxuICBfY2xlYXJFbmdpbmVzKCkge1xuICAgIHRoaXMuX2VuZ2luZVF1ZXVlLmNsZWFyKCk7XG4gICAgdGhpcy5fZW5naW5lU2V0LmNsZWFyKCk7XG5cbiAgICBmb3IgKGxldCBba2V5LCBlbmdpbmVdIG9mIHRoaXMuX21ldHJvbm9tZUVuZ2luZU1hcClcbiAgICAgIGVuZ2luZS5kZXN0cm95KCk7XG5cbiAgICB0aGlzLl9tZXRyb25vbWVFbmdpbmVNYXAuY2xlYXIoKTtcblxuICAgIHRoaXMuX3N5bmNTY2hlZHVsZXJIb29rLnJlc2NoZWR1bGUoKTtcbiAgfVxuXG4gIF9hZHZhbmNlUG9zaXRpb24oc3luY1RpbWUsIG1ldHJpY1Bvc2l0aW9uLCBtZXRyaWNTcGVlZCkge1xuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX2VuZ2luZVF1ZXVlLmhlYWQ7XG4gICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gZW5naW5lLmFkdmFuY2VQb3NpdGlvbihzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIG1ldHJpY1NwZWVkKTtcblxuICAgIGlmIChuZXh0RW5naW5lUG9zaXRpb24gPT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMuX2VuZ2luZVNldC5kZWxldGUoZW5naW5lKTtcblxuICAgIHJldHVybiB0aGlzLl9lbmdpbmVRdWV1ZS5tb3ZlKGVuZ2luZSwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcbiAgfVxuXG4gIF9zeW5jKHN5bmNUaW1lLCBtZXRyaWNQb3NpdGlvbiwgdGVtcG8sIHRlbXBvVW5pdCwgZXZlbnQpIHtcbiAgICB0aGlzLl9zeW5jVGltZSA9IHN5bmNUaW1lO1xuICAgIHRoaXMuX21ldHJpY1Bvc2l0aW9uID0gbWV0cmljUG9zaXRpb247XG5cbiAgICB0aGlzLl90ZW1wbyA9IHRlbXBvO1xuICAgIHRoaXMuX3RlbXBvVW5pdCA9IHRlbXBvVW5pdDtcbiAgICB0aGlzLl9tZXRyaWNTcGVlZCA9IHRlbXBvICogdGVtcG9Vbml0IC8gNjA7XG5cbiAgICBpZiAoZXZlbnQpXG4gICAgICB0aGlzLl9jYWxsRXZlbnRMaXN0ZW5lcnMoZXZlbnQpO1xuXG4gICAgdGhpcy5fcmVzY2hlZHVsZU1ldHJpY0VuZ2luZXMoKTtcbiAgfVxuXG4gIF9jbGVhclN5bmNFdmVudCgpIHtcbiAgICB0aGlzLl9zeW5jRXZlbnRFbmdpbmUucmVzZXQoKTtcbiAgfVxuXG4gIF9zZXRTeW5jRXZlbnQoc3luY1RpbWUsIG1ldHJpY1Bvc2l0aW9uLCB0ZW1wbywgdGVtcG9Vbml0LCBldmVudCkge1xuICAgIHRoaXMuX2NsZWFyU3luY0V2ZW50KCk7XG5cbiAgICBpZiAoc3luY1RpbWUgPiB0aGlzLnN5bmNUaW1lKVxuICAgICAgdGhpcy5fc3luY0V2ZW50RW5naW5lLnNldChzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIHRlbXBvLCB0ZW1wb1VuaXQsIGV2ZW50KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9zeW5jKHN5bmNUaW1lLCBtZXRyaWNQb3NpdGlvbiwgdGVtcG8sIHRlbXBvVW5pdCwgZXZlbnQpO1xuICB9XG5cbiAgX29uSW5pdChzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIHRlbXBvLCB0ZW1wb1VuaXQpIHtcbiAgICB0aGlzLl9zeW5jKHN5bmNUaW1lLCBtZXRyaWNQb3NpdGlvbiwgdGVtcG8sIHRlbXBvVW5pdCk7XG4gICAgdGhpcy5yZWFkeSgpO1xuICB9XG5cbiAgX29uQ2xlYXIoKSB7XG4gICAgdGhpcy5fY2xlYXJTeW5jRXZlbnQoKTtcbiAgICB0aGlzLl9jbGVhckVuZ2luZXMoKTtcbiAgfVxuXG4gIF9vblN5bmMoc3luY1RpbWUsIG1ldHJpY1Bvc2l0aW9uLCB0ZW1wbywgdGVtcG9Vbml0LCBldmVudCkge1xuICAgIHRoaXMuX3NldFN5bmNFdmVudChzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIHRlbXBvLCB0ZW1wb1VuaXQsIGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IGF1ZGlvIHRpbWUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYXVkaW9UaW1lKCkge1xuICAgIHJldHVybiBhdWRpb1NjaGVkdWxlci5jdXJyZW50VGltZTtcbiAgfVxuXG4gIGdldCBzeW5jVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY1NjaGVkdWxlci5zeW5jVGltZTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY1NjaGVkdWxlci5zeW5jVGltZTtcbiAgfVxuXG4gIGdldCBtZXRyaWNQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5fdGVtcG8gPiAwKVxuICAgICAgcmV0dXJuIHRoaXMuX21ldHJpY1Bvc2l0aW9uICsgKHRoaXMuX3N5bmNTY2hlZHVsZXIuc3luY1RpbWUgLSB0aGlzLl9zeW5jVGltZSkgKiB0aGlzLl9tZXRyaWNTcGVlZDtcblxuICAgIHJldHVybiB0aGlzLl9tZXRyaWNQb3NpdGlvbjtcbiAgfVxuXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0cmljUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBhdWRpbyBzY2hlZHVsZXIncyBsb2dpY2FsIGF1ZGlvIHRpbWUgYW5kIHRoZSBgY3VycmVudFRpbWVgXG4gICAqIG9mIHRoZSBhdWRpbyBjb250ZXh0LlxuICAgKi9cbiAgZ2V0IGRlbHRhVGltZSgpIHtcbiAgICByZXR1cm4gYXVkaW9TY2hlZHVsZXIuY3VycmVudFRpbWUgLSBhdWRpby5hdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCB0ZW1wby5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIFRlbXBvIGluIEJQTS5cbiAgICovXG4gIGdldCB0ZW1wbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcG87XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCB0ZW1wbyB1bml0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGVtcG8gdW5pdCBpbiByZXNwZWN0IHRvIHdob2xlIG5vdGUuXG4gICAqL1xuICBnZXQgdGVtcG9Vbml0KCkge1xuICAgIHJldHVybiB0aGlzLl90ZW1wb1VuaXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG1ldHJpYyBwb3NpdGlvbiBjb3Jyc3BvbmRpbmcgdG8gYSBnaXZlbiBhdWRpbyB0aW1lIChyZWdhcmRpbmcgdGhlIGN1cnJlbnQgdGVtcG8pLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgLSB0aW1lXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBtZXRyaWMgcG9zaXRpb25cbiAgICovXG4gIGdldE1ldHJpY1Bvc2l0aW9uQXRBdWRpb1RpbWUoYXVkaW9UaW1lKSB7XG4gICAgaWYgKHRoaXMuX3RlbXBvID4gMCkge1xuICAgICAgY29uc3Qgc3luY1RpbWUgPSB0aGlzLl9zeW5jU2NoZWR1bGVyLmdldFN5bmNUaW1lQXRBdWRpb1RpbWUoYXVkaW9UaW1lKTtcbiAgICAgIHJldHVybiB0aGlzLl9tZXRyaWNQb3NpdGlvbiArIChzeW5jVGltZSAtIHRoaXMuX3N5bmNUaW1lKSAqIHRoaXMuX21ldHJpY1NwZWVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9tZXRyaWNQb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbWV0cmljIHBvc2l0aW9uIGNvcnJzcG9uZGluZyB0byBhIGdpdmVuIHN5bmMgdGltZSAocmVnYXJkaW5nIHRoZSBjdXJyZW50IHRlbXBvKS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIC0gdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gbWV0cmljIHBvc2l0aW9uXG4gICAqL1xuICBnZXRNZXRyaWNQb3NpdGlvbkF0U3luY1RpbWUoc3luY1RpbWUpIHtcbiAgICBpZiAodGhpcy5fdGVtcG8gPiAwKVxuICAgICAgcmV0dXJuIHRoaXMuX21ldHJpY1Bvc2l0aW9uICsgKHN5bmNUaW1lIC0gdGhpcy5fc3luY1RpbWUpICogdGhpcy5fbWV0cmljU3BlZWQ7XG5cbiAgICByZXR1cm4gdGhpcy5fbWV0cmljUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN5bmMgdGltZSBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbWV0cmljIHBvc2l0aW9uIChyZWdhcmRpbmcgdGhlIGN1cnJlbnQgdGVtcG8pLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc2l0aW9uIC0gbWV0cmljIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBzeW5jIHRpbWVcbiAgICovXG4gIGdldFN5bmNUaW1lQXRNZXRyaWNQb3NpdGlvbihtZXRyaWNQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldHJpY1NwZWVkID0gdGhpcy5fbWV0cmljU3BlZWQ7XG5cbiAgICBpZiAobWV0cmljUG9zaXRpb24gPCBJbmZpbml0eSAmJiBtZXRyaWNTcGVlZCA+IDApXG4gICAgICByZXR1cm4gdGhpcy5fc3luY1RpbWUgKyAobWV0cmljUG9zaXRpb24gLSB0aGlzLl9tZXRyaWNQb3NpdGlvbikgLyBtZXRyaWNTcGVlZDtcblxuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXVkaW8gdGltZSBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbWV0cmljIHBvc2l0aW9uIChyZWdhcmRpbmcgdGhlIGN1cnJlbnQgdGVtcG8pLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc2l0aW9uIC0gbWV0cmljIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBhdWRpbyB0aW1lXG4gICAqL1xuICBnZXRBdWRpb1RpbWVBdE1ldHJpY1Bvc2l0aW9uKG1ldHJpY1Bvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0cmljU3BlZWQgPSB0aGlzLl9tZXRyaWNTcGVlZDtcblxuICAgIGlmIChtZXRyaWNQb3NpdGlvbiA8IEluZmluaXR5ICYmIG1ldHJpY1NwZWVkID4gMCkge1xuICAgICAgY29uc3Qgc3luY1RpbWUgPSB0aGlzLl9zeW5jVGltZSArIChtZXRyaWNQb3NpdGlvbiAtIHRoaXMuX21ldHJpY1Bvc2l0aW9uKSAvIG1ldHJpY1NwZWVkO1xuICAgICAgcmV0dXJuIHRoaXMuX3N5bmNTY2hlZHVsZXIuZ2V0QXVkaW9UaW1lQXRTeW5jVGltZShzeW5jVGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmdldChldmVudCk7XG5cbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNldChldmVudCwgbGlzdGVuZXJzKTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmdldChldmVudCk7XG5cbiAgICBpZiAobGlzdGVuZXJzKVxuICAgICAgbGlzdGVuZXJzLnJlbW92ZShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gbWV0cmljIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW4gLSBGdW5jdGlvbiB0byBiZSBkZWZlcnJlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1ldHJpY1Bvc2l0aW9uIC0gVGhlIG1ldHJpYyBwb3NpdGlvbiBhdCB3aGljaCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29rYWhlYWQ9ZmFsc2VdIC0gRGVmaW5lcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgICogIGFudGljaXBhdGVkIChlLmcuIGZvciBhdWRpbyBldmVudHMpIG9yIHByZWNpc2VseSBhdCB0aGUgZ2l2ZW4gdGltZSAoZGVmYXVsdCkuXG4gICAqL1xuICBhZGRFdmVudChmdW4sIG1ldHJpY1Bvc2l0aW9uLCBsb29rYWhlYWQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNjaGVkdWxlclNlcnZpY2UgPSB0aGlzO1xuICAgIGNvbnN0IGVuZ2luZSA9IHtcbiAgICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgICAgIGlmIChzcGVlZCA9PT0gMClcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIH0sXG4gICAgICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuXG4gICAgICAgIGlmIChtZXRyaWNQb3NpdGlvbiA+PSBwb3NpdGlvbilcbiAgICAgICAgICByZXR1cm4gbWV0cmljUG9zaXRpb247XG5cbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfSxcbiAgICAgIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBzY2hlZHVsZXJTZXJ2aWNlLmRlbHRhVGltZTtcblxuICAgICAgICBpZiAoZGVsdGEgPiAwKVxuICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuLCAxMDAwICogZGVsdGEsIHBvc2l0aW9uKTsgLy8gYnJpZGdlIHNjaGVkdWxlciBsb29rYWhlYWQgd2l0aCB0aW1lb3V0XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmdW4ocG9zaXRpb24pO1xuXG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHRoaXMuYWRkKGVuZ2luZSwgbWV0cmljUG9zaXRpb24pOyAvLyBhZGQgd2l0aG91dCBjaGVja3NcbiAgfVxuXG4gIGFkZChlbmdpbmUsIHN0YXJ0UG9zaXRpb24gPSB0aGlzLm1ldHJpY1Bvc2l0aW9uKSB7XG4gICAgdGhpcy5fZW5naW5lU2V0LmFkZChlbmdpbmUpO1xuXG4gICAgY29uc3QgbWV0cmljUG9zaXRpb24gPSBNYXRoLm1heChzdGFydFBvc2l0aW9uLCB0aGlzLm1ldHJpY1Bvc2l0aW9uKTtcblxuICAgIC8vIHNjaGVkdWxlIGVuZ2luZVxuICAgIGlmICghdGhpcy5fY2FsbGluZ0V2ZW50TGlzdGVuZXJzICYmIHRoaXMuX21ldHJpY1NwZWVkID4gMCkge1xuICAgICAgY29uc3Qgc3luY1RpbWUgPSB0aGlzLnN5bmNUaW1lO1xuICAgICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gZW5naW5lLnN5bmNQb3NpdGlvbihzeW5jVGltZSwgbWV0cmljUG9zaXRpb24sIHRoaXMuX21ldHJpY1NwZWVkKTtcblxuICAgICAgdGhpcy5fZW5naW5lUXVldWUuaW5zZXJ0KGVuZ2luZSwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcbiAgICAgIHRoaXMuX3N5bmNTY2hlZHVsZXJIb29rLnJlc2NoZWR1bGUoKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmUoZW5naW5lKSB7XG4gICAgY29uc3Qgc3luY1RpbWUgPSB0aGlzLnN5bmNUaW1lO1xuICAgIGNvbnN0IG1ldHJpY1Bvc2l0aW9uID0gdGhpcy5nZXRNZXRyaWNQb3NpdGlvbkF0U3luY1RpbWUoc3luY1RpbWUpO1xuXG4gICAgLy8gc3RvcCBlbmdpbmVcbiAgICBpZiAoZW5naW5lLnN5bmNTcGVlZClcbiAgICAgIGVuZ2luZS5zeW5jU3BlZWQoc3luY1RpbWUsIG1ldHJpY1Bvc2l0aW9uLCAwKTtcblxuICAgIGlmICh0aGlzLl9lbmdpbmVTZXQuZGVsZXRlKGVuZ2luZSkgJiYgIXRoaXMuX2NhbGxpbmdFdmVudExpc3RlbmVycyAmJiB0aGlzLl9tZXRyaWNTcGVlZCA+IDApIHtcbiAgICAgIHRoaXMuX2VuZ2luZVF1ZXVlLnJlbW92ZShlbmdpbmUpO1xuICAgICAgdGhpcy5fc3luY1NjaGVkdWxlckhvb2sucmVzY2hlZHVsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2RpYyBjYWxsYmFjayBzdGFydGluZyBhdCBhIGdpdmVuIG1ldHJpYyBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsYmFjayBmdW5jdGlvbiAoY3ljbGUsIGJlYXQpXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gbnVtQmVhdHMgLSBudW1iZXIgb2YgYmVhdHMgKHRpbWUgc2lnbmF0dXJlIG51bWVyYXRvcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1ldHJpY0RpdiAtIG1ldHJpYyBkaXZpc2lvbiBvZiB3aG9sZSBub3RlICh0aW1lIHNpZ25hdHVyZSBkZW5vbWluYXRvcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRlbXBvU2NhbGUgLSBsaW5lYXIgdGVtcG8gc2NhbGUgZmFjdG9yIChpbiByZXNwZWN0IHRvIG1hc3RlciB0ZW1wbylcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydFBvc2l0aW9uIC0gbWV0cmljIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBiZWF0XG4gICAqL1xuICBhZGRNZXRyb25vbWUoY2FsbGJhY2ssIG51bUJlYXRzID0gNCwgbWV0cmljRGl2ID0gNCwgdGVtcG9TY2FsZSA9IDEsIHN0YXJ0UG9zaXRpb24gPSAwLCBzdGFydE9uQmVhdCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYmVhdExlbmd0aCA9IDEgLyAobWV0cmljRGl2ICogdGVtcG9TY2FsZSk7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IE1ldHJvbm9tZUVuZ2luZShzdGFydFBvc2l0aW9uLCBudW1CZWF0cywgYmVhdExlbmd0aCwgc3RhcnRPbkJlYXQsIGNhbGxiYWNrKTtcblxuICAgIHRoaXMuX21ldHJvbm9tZUVuZ2luZU1hcC5zZXQoY2FsbGJhY2ssIGVuZ2luZSk7XG4gICAgdGhpcy5hZGQoZW5naW5lLCBzdGFydFBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgcGVyaW9kaWMgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICByZW1vdmVNZXRyb25vbWUoY2FsbGJhY2sgLyosIGVuZFBvc2l0aW9uICovICkge1xuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX21ldHJvbm9tZUVuZ2luZU1hcC5nZXQoY2FsbGJhY2spO1xuXG4gICAgaWYgKGVuZ2luZSkge1xuICAgICAgdGhpcy5fbWV0cm9ub21lRW5naW5lTWFwLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICB0aGlzLnJlbW92ZShlbmdpbmUpO1xuICAgIH1cbiAgfVxufVxuXG5zZXJ2aWNlTWFuYWdlci5yZWdpc3RlcihTRVJWSUNFX0lELCBNZXRyaWNTY2hlZHVsZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBNZXRyaWNTY2hlZHVsZXI7XG4iLCJpbXBvcnQgbW90aW9uSW5wdXQgZnJvbSAnbW90aW9uLWlucHV0JztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTptb3Rpb24taW5wdXQnO1xuXG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgY2xpZW50IGAnbW90aW9uLWlucHV0J2Agc2VydmljZS5cbiAqXG4gKiBUaGlzIHNlcnZpY2UgcHJvdmlkZXMgYSB3cmFwcGVyIGZvciB0aGVcbiAqIFtgbW90aW9uSW5wdXRgXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY29sbGVjdGl2ZS1zb3VuZHdvcmtzL21vdGlvbi1pbnB1dH1cbiAqIGV4dGVybmFsIG1vZHVsZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXhhbXBsZVxuICogLy8gaW4gdGhlIGV4cGVyaW5jZSBjb25zdHJ1Y3RvclxuICogdGhpcy5tb3Rpb25JbnB1dCA9IHRoaXMucmVxdWlyZSgnbW90aW9uLWlucHV0JywgeyBkZXNjcmlwdG9yczogWydlbmVyZ3knXSB9KTtcbiAqIC8vIHdoZW4gdGhlIGV4cGVyaWVuY2UgaGFzIHN0YXJ0ZWRcbiAqIGlmICh0aGlzLm1vdGlvbklucHV0LmlzQXZhaWxhYmxlKCdlbmVyZ3knKSkge1xuICogICB0aGlzLm1vdGlvbklucHV0LmFkZExpc3RlbmVyKCdlbmVyZ3knLCAoZGF0YSkgPT4ge1xuICogICAgIC8vIGRpZ2VzdCBtb3Rpb24gZGF0YVxuICogICB9KTtcbiAqIH0gZWxzZSB7XG4gKiAgIC8vIGhhbmRsZSBlcnJvclxuICogfVxuICovXG5jbGFzcyBNb3Rpb25JbnB1dCBleHRlbmRzIFNlcnZpY2Uge1xuICAvKiogXzxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZSBpbnN0YW5jaWF0ZWQgbWFudWFsbHlfICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQsIGZhbHNlKTtcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgZGVzY3JpcHRvcnM6IFtdLFxuICAgICAgLy8gQHRvZG8gLSBob3cgdG8gaGFuZGxlIGlmIG9ubHkgc29tZSBkZXNjcmlwdG9ycyBhcmUgaW52YWxpZCA/XG4gICAgICAvLyBzaG93RXJyb3I6IGZhbHNlLFxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZ3VyZShkZWZhdWx0cyk7XG4gICAgLy8gQHRvZG8gLSBzaG91bGQgYmUgaGFuZGxlZCBkaXJlY3RseSBpbnNpZGUgdGhlIG1vdGlvbklucHV0XG4gICAgdGhpcy5fZGVzY3JpcHRvcnNWYWxpZGl0eSA9IHt9O1xuICAgIHRoaXMuX2Rlc2NyaXB0b3JzUGVyaW9kID0ge307XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgZGVmYXVsdCBjb25maWd1cmUgdG8gYWRkIGRlc2NyaXB0b3JzIGZyb20gbXVsdGlwbGUgY2FsbHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHNlcnZpY2UuXG4gICAqL1xuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVzY3JpcHRvcnMpXG4gICAgICBvcHRpb25zLmRlc2NyaXB0b3JzID0gdGhpcy5vcHRpb25zLmRlc2NyaXB0b3JzLmNvbmNhdChvcHRpb25zLmRlc2NyaXB0b3JzKTtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgbW90aW9uSW5wdXRcbiAgICAgIC5pbml0KC4uLnRoaXMub3B0aW9ucy5kZXNjcmlwdG9ycylcbiAgICAgIC50aGVuKChtb2R1bGVzKSA9PiB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5kZXNjcmlwdG9ycy5mb3JFYWNoKChuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0b3JzVmFsaWRpdHlbbmFtZV0gPSBtb2R1bGVzW2luZGV4XS5pc1ZhbGlkO1xuICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0b3JzUGVyaW9kW25hbWVdID0gbW9kdWxlc1tpbmRleF0ucGVyaW9kO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlYWR5KCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RvcCgpIHtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGlmIGEgZ2l2ZW4gZGVzY3JpcHRvciBpcyBhdmFpbGFibGUgb3Igbm90XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gRGVzY3JpcHRvciBuYW1lLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiBhdmFpbGFibGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNBdmFpbGFibGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdG9yc1ZhbGlkaXR5W25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV2ZW50IHBlcmlvZCBvZiBhIGRlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBEZXNjcmlwdG9yIG5hbWUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gRXZlbnQgcGVyaW9kIChpbiBzZWNvbmRzKS5cbiAgICovXG4gIGdldFBlcmlvZChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0b3JzUGVyaW9kW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIGEgZ2l2ZW4gZGVzY3JpcHRvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBEZXNjcmlwdG9yIG5hbWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBhZGRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9kZXNjcmlwdG9yc1ZhbGlkaXR5W25hbWVdKVxuICAgICAgbW90aW9uSW5wdXQuYWRkTGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3RlbmVyIG9mIGV2ZW50cyB0cmlnZ2VyZWQgYnkgYSBnaXZlbiBkZXNjcmlwdG9yLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIERlc2NyaXB0b3IgbmFtZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9kZXNjcmlwdG9yc1ZhbGlkaXR5W25hbWVdKVxuICAgICAgbW90aW9uSW5wdXQucmVtb3ZlTGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICB9XG59XG5cbnNlcnZpY2VNYW5hZ2VyLnJlZ2lzdGVyKFNFUlZJQ0VfSUQsIE1vdGlvbklucHV0KTtcblxuZXhwb3J0IGRlZmF1bHQgTW90aW9uSW5wdXQ7XG4iLCJpbXBvcnQgU2VydmljZSBmcm9tICcuLi9jb3JlL1NlcnZpY2UnO1xuaW1wb3J0IHNlcnZpY2VNYW5hZ2VyIGZyb20gJy4uL2NvcmUvc2VydmljZU1hbmFnZXInO1xuXG5jb25zdCBTRVJWSUNFX0lEID0gJ3NlcnZpY2U6bmV0d29yayc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgY2xpZW50IGAnbmV0d29yaydgIHNlcnZpY2UuXG4gKlxuICogVGhpcyBzZXJ2aWNlIHByb3ZpZGVzIGEgZ2VuZXJpYyB3YXkgdG8gY3JlYXRlIGNsaWVudCB0byBjbGllbnQgY29tbXVuaWNhdGlvbnNcbiAqIHRocm91Z2ggd2Vic29ja2V0cyB3aXRob3V0IHNlcnZlciBzaWRlIGN1c3RvbSBjb2RlLlxuICpcbiAqIF9fKlRoZSBzZXJ2aWNlIG11c3QgYmUgdXNlZCB3aXRoIGl0cyBbc2VydmVyLXNpZGUgY291bnRlcnBhcnRde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL3NlcnZlci5OZXR3b3JrfSpfX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBleGFtcGxlXG4gKiAvLyBpbnNpZGUgdGhlIGV4cGVyaWVuY2UgY29uc3RydWN0b3JcbiAqIHRoaXMubmV0d29yayA9IHRoaXMucmVxdWlyZSgnbmV0d29yaycpO1xuICogLy8gYWZ0ZXIgdGhlIGV4cGVyaWVuY2UgaGFzIHN0YXJ0ZWQsIGxpc3RlbnMgdG8gZXZlbnRzXG4gKiB0aGlzLm5ldHdvcmsucmVjZWl2ZSgnbXk6Y2hhbm5lbCcsICguLi5hcmdzKSA9PiB7XG4gKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIGBhcmdzYFxuICogfSk7XG4gKiAvLyBzb21ld2hlcmUgaW4gdGhlIGV4cGVyaWVuY2VcbiAqIHRoaXMubmV0d29yay5zZW5kKCdwbGF5ZXInLCAnbXk6Y2hhbm5lbCcsIDQyLCBmYWxzZSk7XG4gKi9cbmNsYXNzIE5ldHdvcmsgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgLyoqIF88c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5fX1dBUk5JTkdfXzwvc3Bhbj4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFuY2lhdGVkIG1hbnVhbGx5XyAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihTRVJWSUNFX0lELCB0cnVlKTtcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge307XG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RhcnQoKSB7XG4gICAgc3VwZXIuc3RhcnQoKTtcblxuICAgIC8vIGNvbW1vbiBsb2dpYyBmb3IgcmVjZWl2ZXJzXG4gICAgc3VwZXIucmVjZWl2ZSgncmVjZWl2ZScsICguLi52YWx1ZXMpID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tjaGFubmVsXTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSlcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi52YWx1ZXMpKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVhZHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0byBnaXZlbiBjbGllbnQgdHlwZShzKS5cbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8U3RyaW5nPn0gY2xpZW50VHlwZXMgLSBDbGllbnQgdHlwZShzKSB0byBzZW5kIHRoZVxuICAgKiAgbWVzc2FnZSB0by5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWwgLSBDaGFubmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0gey4uLk1peGVkfSB2YWx1ZXMgLSBWYWx1ZXMgdG8gc2VuZCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHNlbmQoY2xpZW50VHlwZXMsIGNoYW5uZWwsIC4uLnZhbHVlcykge1xuICAgIHZhbHVlcy51bnNoaWZ0KGNsaWVudFR5cGVzLCBjaGFubmVsKTtcbiAgICBzdXBlci5zZW5kKCdzZW5kJywgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0byBhbGwgdGhlIGNvbm5lY3RlZCBjbGllbnRzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIENoYW5uZWwgb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7Li4uTWl4ZWR9IHZhbHVlcyAtIFZhbHVlcyB0byBzZW5kIGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgYnJvYWRjYXN0KGNoYW5uZWwsIC4uLnZhbHVlcykge1xuICAgIHZhbHVlcy51bnNoaWZ0KGNoYW5uZWwpO1xuICAgIHN1cGVyLnNlbmQoJ2Jyb2FkY2FzdCcsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBvbiBhIGdpdmVuXG4gICAqIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFubmVsIC0gQ2hhbm5lbCB0byBsaXN0ZW4gdG8uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICovXG4gIHJlY2VpdmUoY2hhbm5lbCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tjaGFubmVsXSlcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tjaGFubmVsXSA9IFtdO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzW2NoYW5uZWxdLnB1c2goY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gbGlzdGVuaW5nIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWwgLSBDaGFubmVsIHRvIHN0b3AgbGlzdGVuaW5nIHRvLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICByZW1vdmVMaXN0ZW5lcihjaGFubmVsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tjaGFubmVsXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3RlbmVycykpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgTmV0d29yayk7XG5cbmV4cG9ydCBkZWZhdWx0IE5ldHdvcms7XG4iLCJpbXBvcnQgY2xpZW50IGZyb20gJy4uL2NvcmUvY2xpZW50JztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5pbXBvcnQgU2VsZWN0VmlldyBmcm9tICcuLi9wcmVmYWJzL1NlbGVjdFZpZXcnO1xuaW1wb3J0IFNwYWNlVmlldyBmcm9tICcuLi9wcmVmYWJzL1NwYWNlVmlldyc7XG5pbXBvcnQgU3F1YXJlZFZpZXcgZnJvbSAnLi4vcHJlZmFicy9TcXVhcmVkVmlldyc7XG5cbi8qKlxuICogQVBJIG9mIGEgY29tcGxpYW50IHZpZXcgZm9yIHRoZSBgcGxhY2VyYCBzZXJ2aWNlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBpbnRlcmZhY2UgQWJzdHJhY3RQbGFjZXJWaWV3XG4gKiBAZXh0ZW5kcyBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQWJzdHJhY3RWaWV3XG4gKiBAYWJzdHJhY3RcbiAqL1xuLyoqXG4gKiBTZXQgYW5kIGRpc3BsYXkgdGhlIGBhcmVhYCBkZWZpbml0aW9uIChhcyBkZWZpbmVkIGluIHNlcnZlciBjb25maWd1cmF0aW9uKS5cbiAqXG4gKiBAbmFtZSBzZXRSZWFkeUNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhY2VyVmlld1xuICogQGZ1bmN0aW9uXG4gKiBAYWJzdHJhY3RcbiAqIEBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmVhIC0gRGVmaW5pdGlvbiBvZiB0aGUgYXJlYS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLndpZHRoIC0gV2l0aCBvZiB0aGUgYXJlYS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLmhlaWdodCAtIEhlaWdodCBvZiB0aGUgYXJlYS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXJlYS5sYWJlbHM9W11dIC0gTGFiZWxzIG9mIHRoZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXJlYS5jb29yZGluYXRlcz1bXV0gLSBDb29yZGluYXRlcyBvZiB0aGUgYXJlYS5cbiAqL1xuLyoqXG4gKiBSZWdpc3RlciB0aGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgdXNlciBzZWxlY3QgYSBwb3NpdGlvbi5cbiAqXG4gKiBAbmFtZSBzZXRTZWxlY3RDYWxsYmFja1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFBsYWNlclZpZXdcbiAqIEBmdW5jdGlvblxuICogQGFic3RyYWN0XG4gKiBAaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXIgc2VsZWN0IGEgcG9zaXRpb24uXG4gKiAgVGhpcyBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBpbmRleGAsIGBsYWJlbGAgYW5kIGBjb29yZGluYXRlc2Agb2ZcbiAqICB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uLlxuICovXG4vKipcbiAqIERpc3BsYXkgdGhlIGF2YWlsYWJsZSBwb3NpdGlvbnMuXG4gKlxuICogQG5hbWUgZGlzcGxheVBvc2l0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhY2VyVmlld1xuICogQGZ1bmN0aW9uXG4gKiBAYWJzdHJhY3RcbiAqIEBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjYXBhY2l0eSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjbGllbnRzIGFsbG93ZWQuXG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IFtsYWJlbHM9bnVsbF0gLSBBbiBhcnJheSBvZiB0aGUgbGFiZWxzIGZvciB0aGUgcG9zaXRpb25zXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PE51bWJlcj4+fSBbY29vcmRpbmF0ZXM9bnVsbF0gLSBBbiBhcnJheSBvZiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvc2l0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhDbGllbnRzUGVyUG9zaXRpb249MV0gLSBOdW1iZXIgb2YgY2xpZW50cyBhbGxvd2VkIGZvciBlYWNoIHBvc2l0aW9uLlxuICovXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmlldyBhY2Nyb2RpbmcgdG8gdGhlIGRpc2FibGVkIHBvc2l0aW9ucy5cbiAqXG4gKiBAbmFtZSB1cGRhdGVEaXNhYmxlZFBvc2l0aW9uc1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFBsYWNlclZpZXdcbiAqIEBmdW5jdGlvblxuICogQGFic3RyYWN0XG4gKiBAaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGRpc2FibGVkUG9zaXRpb25zIC0gQXJyYXkgY29udGFpbmluZyB0aGUgaW5kZXhlcyBvZlxuICogIHRoZSBkaXNhYmxlZCBwb3NpdGlvbnMuXG4gKi9cbi8qKlxuICogVXBkYXRlIHRoZSB2aWV3IHdoZW4gdGhlIHBvc2l0aW9uIHNlbGVjdGVkIGJ5IHRoZSB1c2VyIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuXG4gKlxuICogQG5hbWUgcmVqZWN0XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhY2VyVmlld1xuICogQGZ1bmN0aW9uXG4gKiBAYWJzdHJhY3RcbiAqIEBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gZGlzYWJsZWRQb3NpdGlvbnMgLSBBcnJheSBjb250YWluaW5nIHRoZSBpbmRleGVzIG9mXG4gKiAgdGhlIGRpc2FibGVkIHBvc2l0aW9ucy5cbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgdXNlciBzZWxlY3QgYSBwb3NpdGlvbi5cbiAqXG4gKiBAY2FsbGJhY2tcbiAqIEBuYW1lIHNlbGVjdENhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhY2VyVmlld1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggb2YgdGhlIHNlbGVjdGVkIGxvY2F0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIC0gTGFiZWwgb2YgdGhlIHNlbGVjdGVkIGxvY2F0aW9uIGlmIGFueS5cbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gY29vcmRpbmF0ZXMgLSBDb29yZGluYXRlcyAoYFt4LCB5XWApIG9mIHRoZSBzZWxlY3RlZFxuICogIGxvY2F0aW9uIGlmIGFueS5cbiAqL1xuXG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTpwbGFjZXInO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIGAncGxhY2VyJ2Agc2VydmljZS5cbiAqXG4gKiBUaGlzIHNlcnZpY2UgaXMgb25lIG9mIHRoZSBwcm92aWRlZCBzZXJ2aWNlcyBhaW1lZCBhdCBpZGVudGlmeWluZyBjbGllbnRzIGluc2lkZVxuICogdGhlIGV4cGVyaWVuY2UgYWxvbmcgd2l0aCB0aGUgW2AnbG9jYXRvcidgXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuTG9jYXRvcn1cbiAqIGFuZCBbYCdjaGVja2luJ2Bde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5DaGVja2lufSBzZXJ2aWNlcy5cbiAqXG4gKiBUaGUgYCdwbGFjZXInYCBzZXJ2aWNlIGFsbG93cyBhIGNsaWVudCB0byBjaG9vc2UgaXRzIGxvY2F0aW9uIGFtb25nIGEgc2V0IG9mXG4gKiBwb3NpdGlvbnMgZGVmaW5lZCBpbiB0aGUgc2VydmVyJ3MgYHNldHVwYCBjb25maWd1cmF0aW9uIGVudHJ5LlxuICpcbiAqIF9fKlRoZSBzZXJ2aWNlIG11c3QgYmUgdXNlZCB3aXRoIGl0cyBbc2VydmVyLXNpZGUgY291bnRlcnBhcnRde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL3NlcnZlci5QbGFjZXJ9Kl9fXG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkxvY2F0b3J9XG4gKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2hlY2tpbn1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGU9J2xpc3QnXSAtIFNldHMgdGhlIGludGVyYWN0aW9uIG1vZGUgZm9yIHRoZVxuICogIGNsaWVudCB0byBjaG9vc2UgaXRzIHBvc2l0aW9uLCB0aGUgYCdsaXN0J2AgbW9kZSBwcm9wb3NlcyBhIGRyb3AtZG93biBtZW51XG4gKiAgd2hpbGUgdGhlIGAnZ3JhcGhpYydgIG1vZGUgKHdoaWNoIHJlcXVpcmVzIGxvY2F0ZWQgcG9zaXRpb25zKSBwcm9wb3NlcyBhblxuICogIGludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIGFyZWEgYW5kIGRvdHMgZm9yIGVhY2ggYXZhaWxhYmxlIGxvY2F0aW9uLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBleGFtcGxlXG4gKiAvLyBpbnNpZGUgdGhlIGV4cGVyaWVuY2UgY29uc3RydWN0b3JcbiAqIHRoaXMucGxhY2VyID0gdGhpcy5yZXF1aXJlKCdwbGFjZXInLCB7IG1vZGU6ICdncmFwaGljJyB9KTtcbiAqL1xuY2xhc3MgUGxhY2VyIGV4dGVuZHMgU2VydmljZSB7XG4gIC8qKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbmNpYXRlZCBtYW51YWxseV8gKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIG1vZGU6ICdsaXN0JyxcbiAgICAgIHZpZXdQcmlvcml0eTogNixcbiAgICB9O1xuXG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgLyoqXG4gICAgICogSW5kZXggb2YgdGhlIHBvc2l0aW9uIHNlbGVjdGVkIGJ5IHRoZSB1c2VyLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBvZiB0aGUgcG9zaXRpb24gc2VsZWN0ZWQgYnkgdGhlIHVzZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gbnVsbDtcblxuICAgIHRoaXMuX29uQWtub3dsZWRnZVJlc3BvbnNlID0gdGhpcy5fb25Ba25vd2xlZGdlUmVzcG9uc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNsaWVudEpvaW5lZCA9IHRoaXMuX29uQ2xpZW50Sm9pbmVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DbGllbnRMZWF2ZWQgPSB0aGlzLl9vbkNsaWVudExlYXZlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2VsZWN0ID0gdGhpcy5fb25TZWxlY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNvbmZpcm1SZXNwb25zZSA9IHRoaXMuX29uQ29uZmlybVJlc3BvbnNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25SZWplY3RSZXNwb25zZSA9IHRoaXMuX29uUmVqZWN0UmVzcG9uc2UuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NoYXJlZENvbmZpZ1NlcnZpY2UgPSB0aGlzLnJlcXVpcmUoJ3NoYXJlZC1jb25maWcnKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuICAgIHRoaXMuc2hvdygpO1xuXG4gICAgdGhpcy5zZW5kKCdyZXF1ZXN0Jyk7XG5cbiAgICB0aGlzLnJlY2VpdmUoJ2Frbm93bGVnZGUnLCB0aGlzLl9vbkFrbm93bGVkZ2VSZXNwb25zZSk7XG4gICAgdGhpcy5yZWNlaXZlKCdjb25maXJtJywgdGhpcy5fb25Db25maXJtUmVzcG9uc2UpO1xuICAgIHRoaXMucmVjZWl2ZSgncmVqZWN0JywgdGhpcy5fb25SZWplY3RSZXNwb25zZSk7XG4gICAgdGhpcy5yZWNlaXZlKCdjbGllbnQtam9pbmVkJywgdGhpcy5fb25DbGllbnRKb2luZWQpO1xuICAgIHRoaXMucmVjZWl2ZSgnY2xpZW50LWxlYXZlZCcsIHRoaXMuX29uQ2xpZW50TGVhdmVkKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Frbm93bGVnZGUnLCB0aGlzLl9vbkFrbm93bGVkZ2VSZXNwb25zZSk7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY29uZmlybScsIHRoaXMuX29uQ29uZmlybVJlc3BvbnNlKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWplY3QnLCB0aGlzLl9vblJlamVjdFJlc3BvbnNlKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbGllbnQtam9pbmVkJywgdGhpcy5fb25DbGllbnRKb2luZWQpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NsaWVudC1sZWF2ZWQnLCB0aGlzLl9vbkNsaWVudExlYXZlZCk7XG5cbiAgICB0aGlzLmhpZGUoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25Ba25vd2xlZGdlUmVzcG9uc2Uoc2V0dXBDb25maWdJdGVtLCBkaXNhYmxlZFBvc2l0aW9ucykge1xuICAgIGNvbnN0IHNldHVwID0gdGhpcy5fc2hhcmVkQ29uZmlnU2VydmljZS5nZXQoc2V0dXBDb25maWdJdGVtKTtcbiAgICBjb25zdCBhcmVhID0gc2V0dXAuYXJlYTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IHNldHVwLmNhcGFjaXR5O1xuICAgIGNvbnN0IGxhYmVscyA9IHNldHVwLmxhYmVscztcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHNldHVwLmNvb3JkaW5hdGVzO1xuICAgIGNvbnN0IG1heENsaWVudHNQZXJQb3NpdGlvbiA9IHNldHVwLm1heENsaWVudHNQZXJQb3NpdGlvbjtcblxuICAgIHRoaXMubmJyUG9zaXRpb25zID0gY2FwYWNpdHkgLyBtYXhDbGllbnRzUGVyUG9zaXRpb247XG5cbiAgICBpZiAoYXJlYSlcbiAgICAgIHRoaXMudmlldy5zZXRBcmVhKGFyZWEpO1xuXG4gICAgdGhpcy52aWV3LmRpc3BsYXlQb3NpdGlvbnMoY2FwYWNpdHksIGxhYmVscywgY29vcmRpbmF0ZXMsIG1heENsaWVudHNQZXJQb3NpdGlvbik7XG4gICAgdGhpcy52aWV3LnVwZGF0ZURpc2FibGVkUG9zaXRpb25zKGRpc2FibGVkUG9zaXRpb25zKTtcbiAgICB0aGlzLnZpZXcuc2V0U2VsZWN0Q2FsbGFjayh0aGlzLl9vblNlbGVjdCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX29uU2VsZWN0KGluZGV4LCBsYWJlbCwgY29vcmRpbmF0ZXMpIHtcbiAgICB0aGlzLnNlbmQoJ3Bvc2l0aW9uJywgaW5kZXgsIGxhYmVsLCBjb29yZGluYXRlcyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX29uQ29uZmlybVJlc3BvbnNlKGluZGV4LCBsYWJlbCwgY29vcmRpbmF0ZXMpIHtcbiAgICBjbGllbnQuaW5kZXggPSB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgY2xpZW50LmxhYmVsID0gdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIGNsaWVudC5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgdGhpcy5yZWFkeSgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vbkNsaWVudEpvaW5lZChkaXNhYmxlZFBvc2l0aW9ucykge1xuICAgIGlmIChkaXNhYmxlZFBvc2l0aW9ucy5sZW5ndGggPj0gdGhpcy5uYnJQb3NpdGlvbnMpXG4gICAgICB0aGlzLnZpZXcucmVqZWN0KGRpc2FibGVkUG9zaXRpb25zKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnZpZXcudXBkYXRlRGlzYWJsZWRQb3NpdGlvbnMoZGlzYWJsZWRQb3NpdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vbkNsaWVudExlYXZlZChkaXNhYmxlZFBvc2l0aW9ucykge1xuICAgIHRoaXMudmlldy51cGRhdGVEaXNhYmxlZFBvc2l0aW9ucyhkaXNhYmxlZFBvc2l0aW9ucyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX29uUmVqZWN0UmVzcG9uc2UoZGlzYWJsZWRQb3NpdGlvbnMpIHtcbiAgICBpZiAoZGlzYWJsZWRQb3NpdGlvbnMubGVuZ3RoID49IHRoaXMubmJyUG9zaXRpb25zKVxuICAgICAgdGhpcy52aWV3LnJlamVjdChkaXNhYmxlZFBvc2l0aW9ucyk7XG4gICAgZWxzZVxuICAgICAgdGhpcy52aWV3LnVwZGF0ZURpc2FibGVkUG9zaXRpb25zKGRpc2FibGVkUG9zaXRpb25zKTtcbiAgfVxufVxuXG5zZXJ2aWNlTWFuYWdlci5yZWdpc3RlcihTRVJWSUNFX0lELCBQbGFjZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBQbGFjZXI7XG4iLCJpbXBvcnQgeyBhdWRpb0NvbnRleHQgfSBmcm9tICd3YXZlcy1hdWRpbyc7XG5pbXBvcnQgY2xpZW50IGZyb20gJy4uL2NvcmUvY2xpZW50JztcbmltcG9ydCBNb2JpbGVEZXRlY3QgZnJvbSAnbW9iaWxlLWRldGVjdCc7XG5pbXBvcnQgTm9TbGVlcCBmcm9tICdub3NsZWVwLmpzL2Rpc3QvTm9TbGVlcC5taW4nO1xuaW1wb3J0IHNjcmVlbmZ1bGwgZnJvbSAnc2NyZWVuZnVsbCc7XG5pbXBvcnQgU2VydmljZSBmcm9tICcuLi9jb3JlL1NlcnZpY2UnO1xuaW1wb3J0IHNlcnZpY2VNYW5hZ2VyIGZyb20gJy4uL2NvcmUvc2VydmljZU1hbmFnZXInO1xuXG4vKipcbiAqIEFQSSBvZiBhIGNvbXBsaWFudCB2aWV3IGZvciB0aGUgYHBsYXRmb3JtYCBzZXJ2aWNlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBpbnRlcmZhY2UgQWJzdHJhY3RQbGF0Zm9ybVZpZXdcbiAqIEBleHRlbmRzIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFZpZXdcbiAqIEBhYnN0cmFjdFxuICovXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXIgdG91Y2hlcyB0aGUgc2NyZWVuIGZvciB0aGUgZmlyc3QgdGltZS5cbiAqXG4gKiBAbmFtZSBzZXRUb3VjaFN0YXJ0Q2FsbGJhY2tcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQWJzdHJhY3RQbGF0Zm9ybVZpZXdcbiAqIEBmdW5jdGlvblxuICogQGFic3RyYWN0XG4gKiBAaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3RvdWNoU3RhcnRDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXJcbiAqICB0b3VjaGVzIHRoZSBzY3JlZW4gZm9yIHRoZSBmaXJzdCB0aW1lLlxuICovXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBzY3JlZW4gZm9yIHRoZSBmaXJzdCB0aW1lLlxuICpcbiAqIEBuYW1lIHNldE1vdXNlZG93bkNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhdGZvcm1WaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHttb3VzZURvd25DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHVzZXJcbiAqICBjbGlja3MgdGhlIHNjcmVlbiBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gKi9cbi8qKlxuICogVXBkYXRlIHRoZSB2aWV3IHRvIG5vdGlmeSB0aGF0IHRoZSBjb21wYXRpYmlsaXR5IGNoZWNrcyBhcmUgdGVybWluYXRlZC5cbiAqXG4gKiBAbmFtZSB1cGRhdGVDaGVja2luZ1N0YXR1c1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFBsYXRmb3JtVmlld1xuICogQGZ1bmN0aW9uXG4gKiBAYWJzdHJhY3RcbiAqIEBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAqL1xuLyoqXG4gKiBVcGRhdGUgdGhlIHZpZXcgdG8gbm90aWZ5IGlmIHRoZSBkZXZpY2UgaXMgY29tcGF0aWJsZSBvciBub3QuXG4gKlxuICogQG5hbWUgdXBkYXRlSXNDb21wYXRpYmxlU3RhdHVzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhdGZvcm1WaWV3XG4gKiBAZnVuY3Rpb25cbiAqIEBhYnN0cmFjdFxuICogQGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICovXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmlldyB0byBub3RpZnkgaWYgdGhlIGFwcGxpY2F0aW9uIG9idGFpbmVkIGFsbCB0aGUgYXV0aG9yaXphdGlvbnNcbiAqIG9yIG5vdC5cbiAqXG4gKiBAbmFtZSB1cGRhdGVIYXNBdXRob3JpemF0aW9uc1N0YXR1c1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFBsYXRmb3JtVmlld1xuICogQGZ1bmN0aW9uXG4gKiBAYWJzdHJhY3RcbiAqIEBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgdXNlciB0b3VjaGVzIHRoZSBzY3JlZW4gZm9yIHRoZSBmaXJzdCB0aW1lLlxuICpcbiAqIEBjYWxsYmFja1xuICogQG5hbWUgdG91Y2hTdGFydENhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhdGZvcm1WaWV3XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIC0gUGFzc3dvcmQgZ2l2ZW4gYnkgdGhlIHVzZXIuXG4gKi9cbi8qKlxuICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgc2NyZWVuIGZvciB0aGUgZmlyc3QgdGltZS5cbiAqXG4gKiBAY2FsbGJhY2tcbiAqIEBuYW1lIG1vdXNlRG93bkNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0UGxhdGZvcm1WaWV3XG4gKi9cblxuXG5cbi8qKlxuICogU3RydWN0dXJlIG9mIHRoZSBkZWZpbml0aW9uIGZvciB0aGUgdGVzdCBvZiBhIGZlYXR1cmUuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlBsYXRmb3JtfmRlZmluaXRpb25cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaWQgLSBJZCBvZiB0aGUgZGVmaW5pdGlvbi5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNoZWNrIC0gQSBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYHRydWVgIGlmIHRoZVxuICogIGZlYXR1cmUgaXMgYXZhaWxhYmxlIG9uIHRoZSBwbGF0Zm9ybSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbc3RhcnRIb29rXSAtIEEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgYFByb21pc2VgIHRvIGJlXG4gKiAgZXhlY3V0ZWQgb24gc3RhcnQgKGZvciBleGFtcGxlIHRvIGFzayBhY2Nlc3MgdG8gbWljcm9waG9uZSBvciBnZW9sb2NhdGlvbikuXG4gKiAgVGhlIHJldHVybmVkIHByb21pc2Ugc2hvdWxkIGJlIHJlc29sdmVkIG9uIGB0cnVlYCBpcyB0aGUgcHJvY2VzcyBzdWNjZWRlZCBvclxuICogIGBmYWxzZWAgaXMgdGhlIHByZWNlc3MgZmFpbGVkIChlLmcuIHBlcm1pc3Npb24gbm90IGdyYW50ZWQpLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2ludGVyYWN0aW9uSG9va10gLSBBIGZ1bmN0aW9uIHJldHVybmluZyBhIFByb21pc2V0byBiZVxuICogIGV4ZWN1dGVkIG9uIHRoZSBmaXJzdCBpbnRlcmFjdGlvbiAoaS5lLiBgY2xpY2tgIG9yIGB0b3VjaHN0YXJ0YCkgb2YgdGhlIHVzZXJcbiAqICB3aXRoIGFwcGxpY2F0aW9uIChmb3IgZXhhbXBsZSwgdG8gaW5pdGlhbGl6ZSBBdWRpb0NvbnRleHQgb24gaU9TIGRldmljZXMpLlxuICogIFRoZSByZXR1cm5lZCBwcm9taXNlIHNob3VsZCBiZSByZXNvbHZlZCBvbiBgdHJ1ZWAgaXMgdGhlIHByb2Nlc3Mgc3VjY2VkZWQgb3JcbiAqICBgZmFsc2VgIGlzIHRoZSBwcmVjZXNzIGZhaWxlZCAoZS5nLiBwZXJtaXNzaW9uIG5vdCBncmFudGVkKS5cbiAqL1xuY29uc3QgZGVmYXVsdERlZmluaXRpb25zID0gW1xuICB7XG4gICAgaWQ6ICd3ZWItYXVkaW8nLFxuICAgIGNoZWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIWF1ZGlvQ29udGV4dDtcbiAgICB9LFxuICAgIGludGVyYWN0aW9uSG9vazogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXVkaW9Db250ZXh0LnJlc3VtZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWNsaWVudC5wbGF0Zm9ybS5pc01vYmlsZSlcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGcgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICBnLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgZy5nYWluLnZhbHVlID0gMC4wMDAwMDAwMDE7IC8vIC0xODBkQiA/XG5cbiAgICAgICAgY29uc3QgbyA9IGF1ZGlvQ29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgICAgIG8uY29ubmVjdChnKTtcbiAgICAgICAgby5mcmVxdWVuY3kudmFsdWUgPSAyMDtcbiAgICAgICAgby5zdGFydCgwKTtcblxuICAgICAgICAvLyBwcmV2ZW50IGFuZHJvaWQgdG8gc3RvcCBhdWRpbyBieSBrZWVwaW5nIHRoZSBvc2NpbGxhdG9yIGFjdGl2ZVxuICAgICAgICBpZiAoY2xpZW50LnBsYXRmb3JtLm9zICE9PSAnYW5kcm9pZCcpXG4gICAgICAgICAgby5zdG9wKGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIDAuMDEpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogJ2ZpeC1pb3Mtc2FtcGxlcmF0ZScsXG4gICAgY2hlY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbkhvb2s6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNsaWVudC5wbGF0Zm9ybS5vcyA9PT0gJ2lvcycpIHtcbiAgICAgICAgLy8gaW4gaXBvZCwgd2hlbiB0aGUgcHJvYmxlbSBvY2N1cnMsIHNhbXBsZVJhdGUgaGFzIGJlZW4gb2JzZXJ2ZWRcbiAgICAgICAgLy8gdG8gYmUgc2V0IGF0IDE2MDAwSHosIGFzIG5vIGV4aGF1c3RpdmUgdGVzdGluZyBoYXMgYmVlbiBkb25lXG4gICAgICAgIC8vIGFzc3VtZSA8IDQwMDAwIGlzIGEgYmFkIHZhbHVlLlxuICAgICAgICBjb25zdCBsb2NhbFN0b3JhZ2VLZXkgPSAnc291bmR3b3JrczpmaXgtaW9zLXNhbXBsZXJhdGUnO1xuXG4gICAgICAgIGlmIChhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSA8IDQwMDAwKSB7XG4gICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZUtleSwgdHJ1ZSk7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYXNSZWxvYWRlZCA9ICEhd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU3RvcmFnZUtleSk7XG5cbiAgICAgICAgaWYgKGhhc1JlbG9hZGVkKSB7XG4gICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGxvY2FsU3RvcmFnZUtleSk7XG4gICAgICAgICAgY2xpZW50LnBsYXRmb3JtLmhhc1JlbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH0sXG4gIH0sXG4gIHtcbiAgICAvLyBAbm90ZTogYHRvdWNoYCBmZWF0dXJlIHdvcmthcm91bmRcbiAgICAvLyBjZi4gaHR0cDovL3d3dy5zdHVjb3guY29tL2Jsb2cveW91LWNhbnQtZGV0ZWN0LWEtdG91Y2hzY3JlZW4vXG4gICAgaWQ6ICdtb2JpbGUtZGV2aWNlJyxcbiAgICBjaGVjazogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2xpZW50LnBsYXRmb3JtLmlzTW9iaWxlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGlkOiAnYXVkaW8taW5wdXQnLFxuICAgIGNoZWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSAoXG4gICAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fFxuICAgICAgICBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG4gICAgICAgIG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuICEhbmF2aWdhdG9yLmdldFVzZXJNZWRpYTtcbiAgICB9LFxuICAgIHN0YXJ0SG9vazogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBAdG9kbyAtIHVzZSBuZXcgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBpZiBhdmFpbGFibGVcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0sIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLnN0b3AoKTtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGlkOiAnZnVsbC1zY3JlZW4nLFxuICAgIGNoZWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGZ1bmN0aW9ubmFsaXR5IHRoYXQgY2Fubm90IGJyYWtlIHRoZSBhcHBsaWNhdGlvblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbkhvb2soKSB7XG4gICAgICBpZiAoc2NyZWVuZnVsbC5lbmFibGVkKVxuICAgICAgICBzY3JlZW5mdWxsLnJlcXVlc3QoKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogJ2dlb2xvY2F0aW9uJyxcbiAgICBjaGVjazogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uO1xuICAgIH0sXG4gICAgc3RhcnRIb29rOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbigocG9zaXRpb24pID0+IHtcbiAgICAgICAgICAvLyBwb3B1bGF0ZSBjbGllbnQgd2l0aCBmaXJzdCB2YWx1ZVxuICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IHBvc2l0aW9uLmNvb3JkcztcbiAgICAgICAgICBjbGllbnQuY29vcmRpbmF0ZXMgPSBbY29vcmRzLmxhdGl0dWRlLCBjb29yZHMubG9uZ2l0dWRlXTtcbiAgICAgICAgICBjbGllbnQuZ2VvcG9zaXRpb24gPSBwb3NpdGlvbjtcblxuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGlkOiAnZ2VvbG9jYXRpb24tbW9jaycsXG4gICAgY2hlY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBzdGFydEhvb2s6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbGF0ID0gTWF0aC5yYW5kb20oKSAqIDM2MCAtIDE4MDtcbiAgICAgIGNvbnN0IGxuZyA9IE1hdGgucmFuZG9tKCkgKiAxODAgLSA5MDtcbiAgICAgIGNsaWVudC5jb29yZGluYXRlcyA9IFtsYXQsIGxuZ107XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcmljaHRyL05vU2xlZXAuanMvYmxvYi9tYXN0ZXIvTm9TbGVlcC5qc1xuICAgIC8vIHdhcm5pbmc6IGNhdXNlIDE1MCUgY3B1IHVzZSBpbiBjaHJvbWUgZGVza3RvcC4uLlxuICAgIGlkOiAnd2FrZS1sb2NrJyxcbiAgICBjaGVjazogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBmdW5jdGlvbm5hbGl0eSB0aGF0IGNhbm5vdCBicmFrZSB0aGUgYXBwbGljYXRpb25cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaW50ZXJhY3Rpb25Ib29rOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG5vU2xlZXAgPSBuZXcgTm9TbGVlcCgpO1xuICAgICAgbm9TbGVlcC5lbmFibGUoKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG4gIH1cbl07XG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTpwbGF0Zm9ybSc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgY2xpZW50IGAncGxhdGZvcm0nYCBzZXJ2aWNlLlxuICpcbiAqIFRoZSBgcGxhdGZvcm1gIHNlcnZpY2VzIGlzIHJlc3BvbnNpYmxlIGZvciBnaXZpbmcgZ2VuZXJhbCBpbmZvcm1hdGlvbnNcbiAqIGFib3V0IHRoZSB1c2VyJ3MgZGV2aWNlIGFzIHdlbGwgYXMgY2hlY2tpbmcgYXZhaWxhYmlsaXR5IGFuZCBwcm92aWRpbmcgaG9va3NcbiAqIGluIG9yZGVyIHRvIGluaXRpYWxpemUgdGhlIGZlYXR1cmVzIHJlcXVpcmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiAoYXVkaW8sXG4gKiBtaWNyb3Bob25lLCBldGMuKS5cbiAqIElmIG9uZSBvZiB0aGUgcmVxdWlyZWQgZGVmaW5pdGlvbnMgaXMgbm90IGF2YWlsYWJsZSwgYSB2aWV3IGlzIGNyZWF0ZWQgd2l0aFxuICogYW4gZXJyb3IgbWVzc2FnZSBhbmQgYGNsaWVudC5jb21wYXRpYmxlYCBpcyBzZXQgdG8gYGZhbHNlYC5cbiAqXG4gKiBBdmFpbGFibGUgYnVpbHQtaW4gZGVmaW5pdGlvbnMgYXJlOlxuICogLSAnd2ViLWF1ZGlvJ1xuICogLSAnbW9iaWxlLWRldmljZSc6IG9ubHktYWNjZXB0IG1vYmlsZSBkZXZpY2VzIGluIHRoZSBhcHBsaWNhdGlvbiAoYmFzZWQgb25cbiAqICAgVXNlci1BZ2VudCBzbmlmZmluZylcbiAqIC0gJ2F1ZGlvLWlucHV0JzogQW5kcm9pZCBPbmx5XG4gKiAtICdmdWxsLXNjcmVlbic6IEFuZHJvaWQgT25seSwgdGhpcyBmZWF0dXJlIHdvbid0IGJsb2NrIHRoZSBhcHBsaWNhdGlvbiBpZlxuICogICBub3QgYXZhaWxhYmxlLlxuICogLSAnZ2VvbG9jYXRpb24nOiBjaGVjayBpZiB0aGUgbmF2aWdhdG9yIHN1cHBvcnRzIGdlb2xvY2F0aW9uLiBUaGUgYGNvb3JkaW5hdGVzYFxuICogICBhbmQgYGdlb3Bvc2l0aW9uYCBvZiB0aGUgYGNsaWVudGAgYXJlIHBvcHVsYXRlZCB3aGVuIHRoZSBwbGFmb3JtIHNlcnZpY2VcbiAqICAgcmVzb2x2ZXMuIChpZiBubyB1cGRhdGUgb2YgdGhlIGNvb3JkaW5hdGVzIGFyZSBuZWVkZWQgaW4gdGhlIGFwcGxpY2F0aW9uLFxuICogICByZXF1aXJpbmcgZ2VvbG9jYXRpb24gZmVhdHVyZSB3aXRob3V0IHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBzZXJ2aWNlIHNob3VsZFxuICogICBzdWZmaWNlKS5cbiAqIC0gJ3dha2UtbG9jayc6IHVzZSB3aXRoIGNhdXRpb24sIGhhcyBiZWVuIG9ic2VydmVkIGNvbnN1bW1pbmdcbiAqICAgMTUwJSBjcHUgaW4gY2hyb21lIGRlc2t0b3AuXG4gKlxuICpcbiAqIF88c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5fX1dBUk5JTkdfXzwvc3Bhbj4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmVcbiAqIGluc3RhbmNpYXRlZCBtYW51YWxseV9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fFN0cmluZ30gb3B0aW9ucy5mZWF0dXJlcyAtIElkKHMpIG9mIHRoZSBmZWF0dXJlKHMpXG4gKiAgcmVxdWlyZWQgYnkgdGhlIGFwcGxpY2F0aW9uLiBBdmFpbGFibGUgYnVpbGQtaW4gZmVhdHVyZXMgYXJlOlxuICogIC0gJ3dlYi1hdWRpbydcbiAqICAtICdtb2JpbGUtZGV2aWNlJzogb25seSBhY2NlcHQgbW9iaWxlIGRldmljZXMgKHJlY29nbml0aW9uIGJhc2VkIFVzZXItQWdlbnQpXG4gKiAgLSAnYXVkaW8taW5wdXQnOiBBbmRyb2lkIG9ubHlcbiAqICAtICdmdWxsLXNjcmVlbic6IEFuZHJvaWQgb25seVxuICogIC0gJ2dlb2xvY2F0aW9uJzogYWNjZXB0IGdlb2xvY2FsaXplZCBkZXZpY2VzLiBQb3B1bGF0ZSB0aGUgY2xpZW50IHdpdGhcbiAqICAgICBjdXJyZW50IHBvc2l0aW9uXG4gKiAgLSAnd2FrZS1sb2NrJzogdGhpcyBmZWF0dXJlIHNob3VsZCBiZSB1c2VkIHdpdGggY2F1dGlvbiBhc1xuICogICAgIGl0IGhhcyBiZWVuIG9ic2VydmVkIHRvIHVzZSAxNTAlIG9mIGNwdSBpbiBjaHJvbWUgZGVza3RvcC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2hvd0RpYWxvZz10cnVlXSAtIElmIHNldCB0byBgZmFsc2VgLCB0aGUgc2VydmljZVxuICogIGV4ZWN1dGUgYWxsIGhvb2tzIHdpdGhvdXQgd2FpdGluZyBmb3IgYSB1c2VyIGludGVyYWN0aW9uIGFuZCBkb2Vzbid0IHNob3dcbiAqICB0aGUgc2VydmljZSdzIHZpZXcuIFRoaXMgb3B0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gY29udHJvbGxlZFxuICogIGVudmlyb25uZW1lbnRzIHdoZXJlIHRoZSB0YXJnZXQgcGxhdGZvcm0gaXMga25vd24gZm9yIHdvcmtpbmcgd2l0aG91dFxuICogIHRoaXMgbmVlZCAoZS5nLiBpcyBub3QgaU9TKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXhhbXBsZVxuICogLy8gaW5zaWRlIHRoZSBleHBlcmllbmNlIGNvbnN0cnVjdG9yXG4gKiB0aGlzLnBsYXRmb3JtID0gdGhpcy5yZXF1aXJlKCdwbGF0Zm9ybScsIHsgZmVhdHVyZXM6ICd3ZWItYXVkaW8nIH0pO1xuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5jbGllbnQjcGxhdGZvcm19XG4gKi9cbmNsYXNzIFBsYXRmb3JtIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQsIGZhbHNlKTtcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgc2hvd0RpYWxvZzogdHJ1ZSxcbiAgICAgIHZpZXc6IG51bGwsXG4gICAgICB2aWV3UHJpb3JpdHk6IDEwLFxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZ3VyZShkZWZhdWx0cyk7XG5cbiAgICB0aGlzLnZpZXcgPSBudWxsO1xuXG4gICAgLy8gdGhpcy5fZGVmYXVsdFZpZXdUZW1wbGF0ZSA9IGRlZmF1bHRWaWV3VGVtcGxhdGU7XG4gICAgLy8gdGhpcy5fZGVmYXVsdFZpZXdDb250ZW50ID0gZGVmYXVsdFZpZXdDb250ZW50O1xuXG4gICAgdGhpcy5fcmVxdWlyZWRGZWF0dXJlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9mZWF0dXJlRGVmaW5pdGlvbnMgPSB7fTtcblxuICAgIGRlZmF1bHREZWZpbml0aW9ucy5mb3JFYWNoKChkZWYpID0+IHRoaXMuYWRkRmVhdHVyZURlZmluaXRpb24oZGVmKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5mZWF0dXJlcykge1xuICAgICAgbGV0IGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcztcblxuICAgICAgaWYgKHR5cGVvZiBmZWF0dXJlcyA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZlYXR1cmVzID0gW2ZlYXR1cmVzXTtcblxuICAgICAgaWYgKGZlYXR1cmVzLmluZGV4T2YoJ3dlYi1hdWRpbycpICE9PSAtMSlcbiAgICAgICAgZmVhdHVyZXMucHVzaCgnZml4LWlvcy1zYW1wbGVyYXRlJyk7XG5cbiAgICAgIHRoaXMucmVxdWlyZUZlYXR1cmUoLi4uZmVhdHVyZXMpO1xuXG4gICAgICBkZWxldGUgb3B0aW9ucy5mZWF0dXJlcztcbiAgICB9XG5cbiAgICBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogIFN0YXJ0IHRoZSBjbGllbnQuXG4gICAqICBBbGdvcml0aG06XG4gICAqICAtIGNoZWNrIHJlcXVpcmVkIGZlYXR1cmVzXG4gICAqICAtIGlmIChmYWxzZSlcbiAgICogICAgIHNob3cgJ3NvcnJ5JyBzY3JlZW5cbiAgICogIC0gZWxzZVxuICAgKiAgICAgc2hvdyAnd2VsY29tZScgc2NyZWVuXG4gICAqICAgICBleGVjdXRlIHN0YXJ0IGhvb2sgKHByb21pc2UpXG4gICAqICAgICAtIGlmIChwcm9taXNlID09PSB0cnVlKVxuICAgKiAgICAgICAgc2hvdyB0b3VjaCB0byBzdGFydFxuICAgKiAgICAgICAgYmluZCBldmVudHNcbiAgICogICAgIC0gZWxzZVxuICAgKiAgICAgICAgc2hvdyAnc29ycnknIHNjcmVlblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgc3VwZXIuc3RhcnQoKTtcblxuICAgIHRoaXMuX2RlZmluZUF1ZGlvRmlsZUV4dGVudGlvbigpO1xuICAgIHRoaXMuX2RlZmluZVBsYXRmb3JtKCk7XG5cbiAgICAvLyByZXNvbHZlIHJlcXVpcmVkIGZlYXR1cmVzIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gICAgY2xpZW50LmNvbXBhdGlibGUgPSB0aGlzLl9jaGVja1JlcXVpcmVkRmVhdHVyZXMoKTtcblxuICAgIC8vIGhhbmRsZSBgc2hvd0RpYWxvZyA9PT0gZmFsc2VgXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93RGlhbG9nID09PSBmYWxzZSkge1xuICAgICAgaWYgKGNsaWVudC5jb21wYXRpYmxlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZXMgPSB0aGlzLl9nZXRIb29rcygnc3RhcnRIb29rJyk7XG4gICAgICAgIGNvbnN0IGludGVyYWN0aW9uUHJvbWlzZXMgPSB0aGlzLl9nZXRIb29rcygnaW50ZXJhY3Rpb25Ib29rJyk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW10uY29uY2F0KHN0YXJ0UHJvbWlzZXMsIGludGVyYWN0aW9uUHJvbWlzZXMpO1xuXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKGJvb2wgPT4gcmVzb2x2ZWQgPSByZXNvbHZlZCAmJiBib29sKTtcblxuICAgICAgICAgIGlmIChyZXNvbHZlZClcbiAgICAgICAgICAgIHRoaXMucmVhZHkoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNlcnZpY2U6cGxhdGZvcm0gLSBkaWRuJ3Qgb2J0YWluIHRoZSBuZWNlc3NhcnkgYXV0aG9yaXphdGlvbnNgKTtcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VydmljZTpwbGF0Zm9ybSAtIGNsaWVudCBub3QgY29tcGF0aWJsZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWZhdWx0IHZpZXcgdmFsdWVzXG4gICAgICB0aGlzLnZpZXcudXBkYXRlQ2hlY2tpbmdTdGF0dXMoZmFsc2UpO1xuICAgICAgdGhpcy52aWV3LnVwZGF0ZUlzQ29tcGF0aWJsZVN0YXR1cyhudWxsKTtcbiAgICAgIHRoaXMudmlldy51cGRhdGVIYXNBdXRob3JpemF0aW9uc1N0YXR1cyhudWxsKTtcblxuICAgICAgaWYgKCFjbGllbnQuY29tcGF0aWJsZSkge1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlSXNDb21wYXRpYmxlU3RhdHVzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlSXNDb21wYXRpYmxlU3RhdHVzKHRydWUpO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlQ2hlY2tpbmdTdGF0dXModHJ1ZSk7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuXG4gICAgICAgIC8vIGV4ZWN1dGUgc3RhcnQgaG9va1xuICAgICAgICBjb25zdCBzdGFydFByb21pc2VzID0gdGhpcy5fZ2V0SG9va3MoJ3N0YXJ0SG9vaycpO1xuXG4gICAgICAgIFByb21pc2UuYWxsKHN0YXJ0UHJvbWlzZXMpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBzdGFydCBob29rIGZhaWxlZFxuICAgICAgICAgIGxldCBoYXNBdXRob3JpemF0aW9ucyA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHN1Y2Nlc3MgPT4gaGFzQXV0aG9yaXphdGlvbnMgPSBoYXNBdXRob3JpemF0aW9ucyAmJiBzdWNjZXNzKTtcblxuICAgICAgICAgIHRoaXMudmlldy51cGRhdGVIYXNBdXRob3JpemF0aW9uc1N0YXR1cyhoYXNBdXRob3JpemF0aW9ucyk7XG4gICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZUNoZWNraW5nU3RhdHVzKGZhbHNlKTtcblxuICAgICAgICAgIGlmIChoYXNBdXRob3JpemF0aW9ucykge1xuICAgICAgICAgICAgLy8gbW92ZSB0byAndG91Y2hlbmQnIGFuZCAnbW91c2V1cCcgYmVjYXVzZSAndG91Y2hzdGFydCcgaXMgbm9cbiAgICAgICAgICAgIC8vIGxvbmdlciByZWNvZ25pemVkIGFzIGEgdXNlciBnZXN0dXJlIGluIGFuZHJvaWRcbiAgICAgICAgICAgIC8vIEB0b2RvIC0gZGVmaW5lIHdoYXQgdG8gZG8gd2l0aCB0aGUgdGVtcGxhdGUuLi5cbiAgICAgICAgICAgIC8vIGNmLiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFvRjFUM083X0U0dDFQWUhWNmd5Q3dIeE9pM3lzdG0wZVNMNXhadTdudk9nL2VkaXQjaGVhZGluZz1oLnFxNTlldjN1OGZiYVxuICAgICAgICAgICAgdGhpcy52aWV3LiRlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uSW50ZXJhY3Rpb24oJ3RvdWNoJykpO1xuICAgICAgICAgICAgdGhpcy52aWV3LiRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25JbnRlcmFjdGlvbignbW91c2UnKSk7XG4gICAgICAgICAgICAvLyB0aGlzLnZpZXcuc2V0VG91Y2hTdGFydENhbGxiYWNrKHRoaXMuX29uSW50ZXJhY3Rpb24oJ3RvdWNoJykpO1xuICAgICAgICAgICAgLy8gdGhpcy52aWV3LnNldE1vdXNlRG93bkNhbGxiYWNrKHRoaXMuX29uSW50ZXJhY3Rpb24oJ21vdXNlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIuc3RhY2spKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RydWN0dXJlIG9mIHRoZSBkZWZpbml0aW9uIGZvciB0aGUgdGVzdCBvZiBhIGZlYXR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlBsYXRmb3JtfmRlZmluaXRpb259IG9iaiAtIERlZmluaXRpb24gb2ZcbiAgICogIHRoZSBmZWF0dXJlLlxuICAgKi9cbiAgYWRkRmVhdHVyZURlZmluaXRpb24ob2JqKSB7XG4gICAgdGhpcy5fZmVhdHVyZURlZmluaXRpb25zW29iai5pZF0gPSBvYmo7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWlyZSBmZWF0dXJlcyBmb3IgdGhlIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gZmVhdHVyZXMgLSBJZChzKSBvZiB0aGUgZmVhdHVyZShzKSB0byBiZSByZXF1aXJlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcXVpcmVGZWF0dXJlKC4uLmZlYXR1cmVzKSB7XG4gICAgZmVhdHVyZXMuZm9yRWFjaCgoaWQpID0+IHRoaXMuX3JlcXVpcmVkRmVhdHVyZXMuYWRkKGlkKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGBpbnRlcmFjdGlvbnNgIGhvb2tzIGZyb20gdGhlIGBwbGF0Zm9ybWAgc2VydmljZS5cbiAgICogQWxzbyBhY3RpdmF0ZSB0aGUgbWVkaWEgYWNjb3JkaW5nIHRvIHRoZSBgb3B0aW9uc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JbnRlcmFjdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBjb25zdCBub1NsZWVwID0gbmV3IE5vU2xlZXAoKTtcbiAgICAgIG5vU2xlZXAuZW5hYmxlKCk7XG5cbiAgICAgIGNsaWVudC5wbGF0Zm9ybS5pbnRlcmFjdGlvbiA9IHR5cGU7XG4gICAgICAvLyBleGVjdXRlIGludGVyYWN0aW9uIGhvb2tzIGZyb20gdGhlIHBsYXRmb3JtXG4gICAgICBjb25zdCBpbnRlcmFjdGlvblByb21pc2VzID0gdGhpcy5fZ2V0SG9va3MoJ2ludGVyYWN0aW9uSG9vaycpO1xuXG4gICAgICBQcm9taXNlLmFsbChpbnRlcmFjdGlvblByb21pc2VzKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaChib29sID0+IHJlc29sdmVkID0gcmVzb2x2ZWQgJiYgYm9vbCk7XG5cbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlldy51cGRhdGVIYXNBdXRob3JpemF0aW9uc1N0YXR1cyhyZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVyci5zdGFjaykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGFsbCBgY2hlY2tgIGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoZSByZXF1aXJlZCBmZWF0dXJlcy5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBgdHJ1ZWAgaWYgYWxsIGNoZWNrcyBwYXNzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja1JlcXVpcmVkRmVhdHVyZXMoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXF1aXJlZEZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICBjb25zdCBjaGVja0Z1bmN0aW9uID0gdGhpcy5fZmVhdHVyZURlZmluaXRpb25zW2ZlYXR1cmVdLmNoZWNrO1xuXG4gICAgICBpZiAoISh0eXBlb2YgY2hlY2tGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY2hlY2sgZnVuY3Rpb24gZGVmaW5lZCBmb3IgJHtmZWF0dXJlfSBmZWF0dXJlYCk7XG5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBjaGVja0Z1bmN0aW9uKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9nZXRIb29rcyh0eXBlKSB7XG4gICAgY29uc3QgaG9va3MgPSBbXTtcblxuICAgIHRoaXMuX3JlcXVpcmVkRmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGhvb2sgPSB0aGlzLl9mZWF0dXJlRGVmaW5pdGlvbnNbZmVhdHVyZV1bdHlwZV07XG5cbiAgICAgIGlmIChob29rKVxuICAgICAgICBob29rcy5wdXNoKGhvb2spO1xuICAgIH0pO1xuXG4gICAgLy8gcmV0dXJuIGFuIGFycmF5IG9mIFByb21pc2VzIGluc3RlYWQgb2YgZnVuY3Rpb25cbiAgICByZXR1cm4gaG9va3MubWFwKGhvb2sgPT4gaG9vaygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZSBgY2xpZW50LnBsYXRmb3JtYCB3aXRoIHRoZSBwcmVmZXJlZCBhdWRpbyBmaWxlIGV4dGVudGlvblxuICAgKiBmb3IgdGhlIHBsYXRmb3JtLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlZmluZUF1ZGlvRmlsZUV4dGVudGlvbigpIHtcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAvLyBodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2V2ZXJ5dGhpbmcuaHRtbFxuICAgIGlmICghIShhLmNhblBsYXlUeXBlICYmIGEuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7JykpKVxuICAgICAgY2xpZW50LnBsYXRmb3JtLmF1ZGlvRmlsZUV4dCA9ICcubXAzJztcbiAgICBlbHNlIGlmICghIShhLmNhblBsYXlUeXBlICYmIGEuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwidm9yYmlzXCInKSkpXG4gICAgICBjbGllbnQucGxhdGZvcm0uYXVkaW9GaWxlRXh0ID0gJy5vZ2cnO1xuICAgIGVsc2VcbiAgICAgIGNsaWVudC5wbGF0Zm9ybS5hdWRpb0ZpbGVFeHQgPSAnLndhdic7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGUgYGNsaWVudC5wbGF0Zm9ybWAgd2l0aCB0aGUgb3MgbmFtZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWZpbmVQbGF0Zm9ybSgpIHtcbiAgICBjb25zdCB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50XG4gICAgY29uc3QgbWQgPSBuZXcgTW9iaWxlRGV0ZWN0KHVhKTtcblxuICAgIGNsaWVudC5wbGF0Zm9ybS5pc01vYmlsZSA9IChtZC5tb2JpbGUoKSAhPT0gbnVsbCk7IC8vIHRydWUgaWYgcGhvbmUgb3IgdGFibGV0XG4gICAgY2xpZW50LnBsYXRmb3JtLm9zID0gKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgb3MgPSBtZC5vcygpO1xuXG4gICAgICBpZiAob3MgPT09ICdBbmRyb2lkT1MnKVxuICAgICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgICAgZWxzZSBpZiAob3MgPT09ICdpT1MnKVxuICAgICAgICByZXR1cm4gJ2lvcyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH0pKCk7XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgUGxhdGZvcm0pO1xuXG5leHBvcnQgZGVmYXVsdCBQbGF0Zm9ybTtcbiIsImltcG9ydCBTZWdtZW50ZWRWaWV3IGZyb20gJy4uL3ZpZXdzL1NlZ21lbnRlZFZpZXcnO1xuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi4vY29yZS9TZXJ2aWNlJztcbmltcG9ydCBzZXJ2aWNlTWFuYWdlciBmcm9tICcuLi9jb3JlL3NlcnZpY2VNYW5hZ2VyJztcblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOnJhdy1zb2NrZXQnO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIGByYXctc29ja2V0YCBzZXJ2aWNlLlxuICpcbiAqIFRoaXMgc2VydmljZSBjcmVhdGVzIGFuIGFkZGl0aW9ubmFsIG5hdGl2ZSBzb2NrZXQgd2l0aCBpdHMgYmluYXJ5IHR5cGUgc2V0XG4gKiB0byBgYXJyYXlidWZmZXJgIGFuZCBmb2N1c2VkIG9uIHBlcmZvcm1hbmNlcy5cbiAqIEl0IGFsbG93cyB0aGUgdHJhbnNmZXJ0IG9mIGBUeXBlZEFycmF5YCBkYXRhIHdyYXBwZWQgd2l0aCBhIG1pbmltYWwgY2hhbm5lbFxuICogbWVjaGFuaXNtICh1cCB0byAyNTYgY2hhbm5lbHMpLlxuICpcbiAqIF9fKlRoZSBzZXJ2aWNlIG11c3QgYmUgdXNlZCB3aXRoIGl0cyBbc2VydmVyLXNpZGUgY291bnRlcnBhcnRde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL3NlcnZlci5SYXdTb2NrZXR9Kl9fXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICovXG5jbGFzcyBSYXdTb2NrZXQgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHZpZXdDdG9yOiBTZWdtZW50ZWRWaWV3LFxuICAgICAgdmlld1ByaW9yaXR5OiA1LFxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZ3VyZShkZWZhdWx0cyk7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW5lcnMgZm9yIHRoZSBpbmNvbW1pbmcgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0PFN0cmluZywgU2V0PEZ1bmN0aW9uPj59XG4gICAgICogQG5hbWUgX2xpc3RlbmVyc1xuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9zZXJ2ZXIuUmF3U29ja2V0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIHRoaXMuX3Byb3RvY29sID0gbnVsbDtcbiAgICB0aGlzLl9vblJlY2VpdmVDb25uZWN0aW9uSW5mb3MgPSB0aGlzLl9vblJlY2VpdmVDb25uZWN0aW9uSW5mb3MuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlY2VpdmVBY2tub2xlZGdlbWVudCA9IHRoaXMuX29uUmVjZWl2ZUFja25vbGVkZ2VtZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25NZXNzYWdlID0gdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RhcnQoKSB7XG4gICAgc3VwZXIuc3RhcnQoKTtcbiAgICB0aGlzLnNob3coKTtcblxuICAgIHN1cGVyLnNlbmQoJ3JlcXVlc3QnKTtcbiAgICBzdXBlci5yZWNlaXZlKCdpbmZvcycsIHRoaXMuX29uUmVjZWl2ZUNvbm5lY3Rpb25JbmZvcyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGV4ZWN1dGVkIHdoZW4gdGhlIHNlcnZpY2UgcmVjZWl2ZSBjb25uZWN0aW9uIGluZm9ybWF0aW9ucyBmcm9tIHRoZVxuICAgKiBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0IC0gUG9ydCBvbiB3aGljaCBvcGVuIHRoZSBuZXcgc29ja2V0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG9jb2wgLSBVc2VyLWRlZmluZWQgcHJvdG9jb2wgdG8gYmUgdXNlZCBpbiByYXcgc29ja2V0XG4gICAqICBleGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b2tlbiAtIFVuaXF1ZSB0b2tlbiB0byByZXRyaWV2ZSBpbiB0aGUgZmlyc3QgbWVzc2FnZSB0b1xuICAgKiAgaWRlbnR5IHRoZSBjbGllbnQgc2VydmVyLXNpZGUsIGFsbG93IHRvIG1hdGNoIHRoZSBzb2NrZXQgd2l0aCBpdHNcbiAgICogIGNvcnJlc3BvbmRpbmcgY2xpZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUmVjZWl2ZUNvbm5lY3Rpb25JbmZvcyhwb3J0LCBwcm90b2NvbCwgdG9rZW4pIHtcbiAgICB0aGlzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIHRoaXMuX2NoYW5uZWxzID0gcHJvdG9jb2wubWFwKChlbnRyeSkgPT4gZW50cnkuY2hhbm5lbCk7XG5cbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0aW9uLWluZm9zJywgdGhpcy5fb25SZWNlaXZlQ29ubmVjdGlvbkluZm9zKTtcblxuICAgIGNvbnN0IHNvY2tldFByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnJlcGxhY2UoL15odHRwPy8sICd3cycpO1xuICAgIGNvbnN0IHNvY2tldEhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIGNvbnN0IHVybCA9IGAke3NvY2tldFByb3RvY29sfS8vJHtzb2NrZXRIb3N0bmFtZX06JHtwb3J0fWA7XG5cbiAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICB0aGlzLnNvY2tldC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAvLyBzZW5kIHRva2VuIGJhY2sgdG8gdGhlIHNlcnZlciBhbmQgd2FpdCBmb3IgYWNrbm9sZWRnZW1lbnRcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgIGRhdGFbMF0gPSB0b2tlbjtcblxuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKSA9PiB7XG4gICAgICB0aGlzLnNlbmQoJ3NlcnZpY2U6aGFuZHNoYWtlJywgZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25SZWNlaXZlQWNrbm9sZWRnZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gdGhlIHNlcnZlciBhY2tub2xlZGdlcyB0aGUgbWF0Y2hpbmcgYmV0d2VlbiBhXG4gICAqIGNsaWVudCBhbmQgYSBzb2NrZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZWNlaXZlQWNrbm9sZWRnZW1lbnQoZSkge1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhKVswXTtcbiAgICBjb25zdCB7IGNoYW5uZWwsIHR5cGUgfSA9IHRoaXMuX3Byb3RvY29sW2luZGV4XTtcblxuICAgIC8vIGlnbm9yZSBpbmNvbW1pbmcgbWVzc2FnZXMgdGhhdCBjb3VsZCBvY2N1ciBpZlxuICAgIC8vIGFja25vbGVkZ2VtZW50IHdhcyBub3QgeWV0IHJlY2VpdmVkXG4gICAgaWYgKGNoYW5uZWwgPT09ICdzZXJ2aWNlOmhhbmRzaGFrZS1hY2snKcKge1xuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uUmVjZWl2ZUFja25vbGVkZ2VtZW50KTtcbiAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UpO1xuICAgICAgdGhpcy5yZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBvZiB0aGUgc29ja2V0IGBtZXNzYWdlYCBldmVudC4gVW53cmFwIHRoZSBjaGFubmVsIGFuZFxuICAgKiB0aGUgZGF0YSBjb250YWluZWQgaW4gdGhlIHBheWxvYWQgYW5kIGV4ZWN1dGUgdGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25NZXNzYWdlKGUpIHtcbiAgICBjb25zdCBpbmRleCA9IG5ldyBVaW50OEFycmF5KGUuZGF0YSlbMF07XG5cbiAgICBpZiAoIXRoaXMuX3Byb3RvY29sW2luZGV4XSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm90b2NvbCBpbmRleDogJHtpbmRleH1gKTtcblxuICAgIGNvbnN0IHsgY2hhbm5lbCwgdHlwZSB9ID0gdGhpcy5fcHJvdG9jb2xbaW5kZXhdO1xuICAgIGNvbnN0IHZpZXdDdG9yID0gd2luZG93W2Ake3R5cGV9QXJyYXlgXTtcbiAgICBjb25zdCBkYXRhID0gbmV3IHZpZXdDdG9yKGUuZGF0YSwgdmlld0N0b3IuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2xpc3RlbmVyc1tjaGFubmVsXTtcblxuICAgIGlmIChjYWxsYmFja3MpXG4gICAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGRhdGEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIHdoZW4gcmVjZWl2aW5nIGEgbWVzc2FnZSBvbiBhIHNwZWNpZmljXG4gICAqIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFubmVsIC0gQ2hhbm5lbCBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIHJlY2VpdmUoY2hhbm5lbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICBpZiAoIWxpc3RlbmVyc1tjaGFubmVsXSlcbiAgICAgIGxpc3RlbmVyc1tjaGFubmVsXSA9IG5ldyBTZXQoKTtcblxuICAgIGxpc3RlbmVyc1tjaGFubmVsXS5hZGQoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBvbiBhIHNwZWNpZmljIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFubmVsIC0gQ2hhbm5lbCBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIC0gRGF0YS5cbiAgICovXG4gIHNlbmQoY2hhbm5lbCwgZGF0YSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY2hhbm5lbHMuaW5kZXhPZihjaGFubmVsKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBjaGFubmVsIFwiJHtjaGFubmVsfVwiYCk7XG5cbiAgICBjb25zdCB7IHR5cGUgfSA9IHRoaXMuX3Byb3RvY29sW2luZGV4XTtcbiAgICBjb25zdCB2aWV3Q3RvciA9IHdpbmRvd1tgJHt0eXBlfUFycmF5YF07XG4gICAgY29uc3Qgc2l6ZSA9IGRhdGEgPyAxICsgZGF0YS5sZW5ndGggOiAxO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgdmlld0N0b3Ioc2l6ZSk7XG5cbiAgICBjb25zdCBjaGFubmVsVmlldyA9IG5ldyBVaW50OEFycmF5KHZpZXdDdG9yLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICBjaGFubmVsVmlld1swXSA9IGluZGV4O1xuICAgIC8vIHBvcHVsYXRlIGJ1ZmZlclxuICAgIHZpZXcuc2V0KG5ldyB2aWV3Q3RvcihjaGFubmVsVmlldy5idWZmZXIpLCAwKTtcblxuICAgIGlmIChkYXRhKVxuICAgICAgdmlldy5zZXQoZGF0YSwgMSk7XG5cbiAgICB0aGlzLnNvY2tldC5zZW5kKHZpZXcuYnVmZmVyKTtcbiAgfVxufVxuXG5zZXJ2aWNlTWFuYWdlci5yZWdpc3RlcihTRVJWSUNFX0lELCBSYXdTb2NrZXQpO1xuXG5leHBvcnQgZGVmYXVsdCBSYXdTb2NrZXQ7XG4iLCJpbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5pbXBvcnQgU2VydmljZSBmcm9tICcuLi9jb3JlL1NlcnZpY2UnO1xuaW1wb3J0IGNsaWVudCBmcm9tICcuLi9jb3JlL2NsaWVudCc7XG5cblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOnNoYXJlZC1jb25maWcnO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIGNsaWVudCBgJ3NoYXJlZC1jb25maWcnYCBzZXJ2aWNlLlxuICpcbiAqIFRoZSBgc2hhcmVkLWNvbmZpZ2Agc2VydmljZSBhbGxvd3MgY2xpZW50cyB0byBhY2Nlc3MgaXRlbXMgb2YgdGhlIHNlcnZlclxuICogY29uZmlndXJhdGlvbi5cbiAqIEFsbCBjb25maWd1cmF0aW9uIGl0ZW1zIHJldHJpZXZlZCBieSB0aGUgc2VydmVyIGFyZSBhbHNvIHN0b3JlZCBpbiB0aGVcbiAqIGBjbGllbnQuY29uZmlnYCBhdHRyaWJ1dGUuXG4gKlxuICogX18qVGhlIHNlcnZpY2UgbXVzdCBiZSB1c2VkIHdpdGggaXRzXG4gKiBbc2VydmVyLXNpZGUgY291bnRlcnBhcnRde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL3NlcnZlci5TaGFyZWRDb25maWd9Kl9fXG4gKlxuICogXzxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZVxuICogaW5zdGFuY2lhdGVkIG1hbnVhbGx5X1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IG9wdGlvbnMuaXRlbXMgLSBMaXN0IG9mIHRoZSBjb25maWd1cmF0aW9uIGl0ZW1zXG4gKiAgcmVxdWlyZWQgYnkgdGhlIHNlcnZlci4gVGhlIGdpdmVuIHN0cmluZ3MgZm9sbG93IGEgY29udmVudGlvbiBkZWZpbmluZyBhIHBhdGhcbiAqICB0byB0aGUgcmVxdWlyZWQgY29uZmlndXJhdGlvbiBpdGVtLlxuICogIF9leGFtcGxlOl8gYCdzZXR1cC5hcmVhJ2Agd2lsbCByZXRyaWV2ZSB0aGUgdmFsdWUgKGhlcmUgYW4gb2JqZWN0KVxuICogIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBhcmVhYCBrZXkgaW5zaWRlIHRoZSBgc2V0dXBgIGVudHJ5IG9mIHRoZSBzZXJ2ZXJcbiAqICBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBleGFtcGxlXG4gKiAvLyBpbnNpZGUgdGhlIGV4cGVyaWVuY2UgY29uc3RydWN0b3JcbiAqIHRoaXMuc2hhcmVkQ29uZmlnID0gdGhpcy5yZXF1aXJlKCdzaGFyZWQtY29uZmlnJywgeyBpdGVtczogWydzZXR1cC5hcmVhJ10gfSk7XG4gKiAvLyB3aGVuIHRoZSBleHBlcmllbmNlIGhhcyBzdGFydGVkXG4gKiBjb25zdCBhcmVhV2lkdGggPSB0aGlzLnNoYXJlZENvbmZpZy5nZXQoJ3NldHVwLmFyZWEud2lkdGgnKTtcbiAqL1xuY2xhc3MgU2hhcmVkQ29uZmlnIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBpdGVtcyByZXF1aXJlZCBieSB0aGUgY2xpZW50LlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGNvbmZpZ3VyYXRpb24gaXRlbXMgc2hhcmVkIGJ5IHRoZSBzZXJ2ZXIuIFRoZVxuICAgICAqIG9iamVjdCBpcyBmbGF0dGVuZWQgaW4gb3JkZXIgdG8gbWluaW1pemUgdGhlIG5lZWRlZCBjb21tdW5pY2F0aW9ucyBiZXR3ZWVuXG4gICAgICogdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlci5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG5cbiAgICB0aGlzLl9vbkNvbmZpZ1Jlc3BvbnNlID0gdGhpcy5fb25Db25maWdSZXNwb25zZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX2l0ZW1zID0gdGhpcy5faXRlbXMuY29uY2F0KG9wdGlvbnMuaXRlbXMpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuaXRlbXM7XG4gICAgfVxuXG4gICAgc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0YXJ0KCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG5cbiAgICB0aGlzLnNlbmQoJ3JlcXVlc3QnLCB0aGlzLl9pdGVtcyk7XG4gICAgdGhpcy5yZWNlaXZlKCdjb25maWcnLCB0aGlzLl9vbkNvbmZpZ1Jlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25Db25maWdSZXNwb25zZShkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gY2xpZW50LmNvbmZpZyA9IGRhdGE7XG4gICAgdGhpcy5yZWFkeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgY29uZmlndXJhdGlvbiB2YWx1ZSBmcm9tIGl0cyBrZXksIGFzIGRlZmluZWQgaW4gc2VydmVyIHNpZGVcbiAgICogc2VydmljZSdzIGBhZGRJdGVtYCBtZXRob2Qgb3IgaW4gY2xpZW50LXNpZGUgYGl0ZW1zYCBvcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtIC0gS2V5IHRvIHRoZSBjb25maWd1cmF0aW9uIGl0ZW0gKF9leDpfIGAnc2V0dXAuYXJlYSdgKVxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICovXG4gIGdldChpdGVtKSB7XG4gICAgY29uc3QgcGFydHMgPSBpdGVtLnNwbGl0KCcuJyk7XG4gICAgbGV0IHRtcCA9IHRoaXMuZGF0YTtcblxuICAgIHBhcnRzLmZvckVhY2goKGF0dHIpID0+IHRtcCA9IHRtcFthdHRyXSk7XG5cbiAgICByZXR1cm4gdG1wO1xuICB9XG59XG5cbnNlcnZpY2VNYW5hZ2VyLnJlZ2lzdGVyKFNFUlZJQ0VfSUQsIFNoYXJlZENvbmZpZyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNoYXJlZENvbmZpZztcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vLi4vdXRpbHMvRXZlbnRFbWl0dGVyJztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vKiBDT05UUk9MIFVOSVRTXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqIEBwcml2YXRlICovXG5jbGFzcyBfUGFyYW0gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHR5cGUsIG5hbWUsIGxhYmVsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBzZXQodmFsKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgX3Byb3BhZ2F0ZShzZW5kVG9TZXJ2ZXIgPSB0cnVlKSB7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLnZhbHVlKTsgLy8gY2FsbCBldmVudCBsaXN0ZW5lcnNcblxuICAgIGlmIChzZW5kVG9TZXJ2ZXIpXG4gICAgICB0aGlzLnBhcmVudC5zZW5kKCd1cGRhdGUnLCB0aGlzLm5hbWUsIHRoaXMudmFsdWUpOyAvLyBzZW5kIHRvIHNlcnZlclxuXG4gICAgdGhpcy5wYXJlbnQuZW1pdCgndXBkYXRlJywgdGhpcy5uYW1lLCB0aGlzLnZhbHVlKTsgLy8gY2FsbCBwYXJlbnQgbGlzdGVuZXJzXG4gIH1cblxuICB1cGRhdGUodmFsLCBzZW5kVG9TZXJ2ZXIgPSB0cnVlKSB7XG4gICAgdGhpcy5zZXQodmFsKTtcbiAgICB0aGlzLl9wcm9wYWdhdGUoc2VuZFRvU2VydmVyKTtcbiAgfVxufVxuXG5cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgX0Jvb2xlYW5QYXJhbSBleHRlbmRzIF9QYXJhbSB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgbmFtZSwgbGFiZWwsIGluaXQpIHtcbiAgICBzdXBlcihwYXJlbnQsICdib29sZWFuJywgbmFtZSwgbGFiZWwpO1xuICAgIHRoaXMuc2V0KGluaXQpO1xuICB9XG5cbiAgc2V0KHZhbCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gIH1cbn1cblxuLyoqIEBwcml2YXRlICovXG5jbGFzcyBfRW51bVBhcmFtIGV4dGVuZHMgX1BhcmFtIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBuYW1lLCBsYWJlbCwgb3B0aW9ucywgaW5pdCkge1xuICAgIHN1cGVyKHBhcmVudCwgJ2VudW0nLCBuYW1lLCBsYWJlbCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNldChpbml0KTtcbiAgfVxuXG4gIHNldCh2YWwpIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzLm9wdGlvbnMuaW5kZXhPZih2YWwpO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgfVxuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgX051bWJlclBhcmFtIGV4dGVuZHMgX1BhcmFtIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBuYW1lLCBsYWJlbCwgbWluLCBtYXgsIHN0ZXAsIGluaXQpIHtcbiAgICBzdXBlcihwYXJlbnQsICdudW1iZXInLCBuYW1lLCBsYWJlbCk7XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICB0aGlzLnNldChpbml0KTtcbiAgfVxuXG4gIHNldCh2YWwpIHtcbiAgICB0aGlzLnZhbHVlID0gTWF0aC5taW4odGhpcy5tYXgsIE1hdGgubWF4KHRoaXMubWluLCB2YWwpKTtcbiAgfVxufVxuXG4vKiogQHByaXZhdGUgKi9cbmNsYXNzIF9UZXh0UGFyYW0gZXh0ZW5kcyBfUGFyYW0ge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5hbWUsIGxhYmVsLCBpbml0KSB7XG4gICAgc3VwZXIocGFyZW50LCAndGV4dCcsIG5hbWUsIGxhYmVsKTtcbiAgICB0aGlzLnNldChpbml0KTtcbiAgfVxuXG4gIHNldCh2YWwpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgX1RyaWdnZXJQYXJhbSBleHRlbmRzIF9QYXJhbSB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgbmFtZSwgbGFiZWwpIHtcbiAgICBzdXBlcihwYXJlbnQsICd0cmlnZ2VyJywgbmFtZSwgbGFiZWwpO1xuICB9XG5cbiAgc2V0KHZhbCkgeyAvKiBub3RoaW5nIHRvIHNldCBoZXJlICovIH1cbn1cblxuY29uc3QgU0VSVklDRV9JRCA9ICdzZXJ2aWNlOnNoYXJlZC1wYXJhbXMnO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIGNsaWVudCBgJ3NoYXJlZC1wYXJhbXMnYCBzZXJ2aWNlLlxuICpcbiAqIFRoZSBgc2hhcmVkLXBhcmFtc2Agc2VydmljZSBpcyB1c2VkIHRvIG1haW50YWluIGFuZCB1cGRhdGUgZ2xvYmFsIHBhcmFtZXRlcnNcbiAqIHVzZWQgYW1vbmcgYWxsIGNvbm5lY3RlZCBjbGllbnRzLiBFYWNoIGRlZmluZWQgcGFyYW1ldGVyIGNhbiBiZSBvZiB0aGVcbiAqIGZvbGxvd2luZyBkYXRhIHR5cGVzOlxuICogLSBib29sZWFuXG4gKiAtIGVudW1cbiAqIC0gbnVtYmVyXG4gKiAtIHRleHRcbiAqIC0gdHJpZ2dlclxuICpcbiAqIFRoZSBwYXJhbWV0ZXJzIGFyZSBjb25maWd1cmVkIGluIHRoZSBzZXJ2ZXIgc2lkZSBjb3VudGVycGFydCBvZiB0aGUgc2VydmljZS5cbiAqXG4gKiBUbyBjcmVhdGUgYSBjb250cm9sIHN1cmZhY2UgZnJvbSB0aGUgcGFyYW1ldGVycyBkZWZpbml0aW9ucywgYSBkZWRpY2F0ZWQgc2NlbmVcbiAqIFtgQmFzaWNTaGFyZWRDb250cm9sbGVyYF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkJhc2ljU2hhcmVkQ29udHJvbGxlcn1cbiAqIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBfXypUaGUgc2VydmljZSBtdXN0IGJlIHVzZWQgYWxvbmcgd2l0aCBpdHNcbiAqIFtzZXJ2ZXItc2lkZSBjb3VudGVycGFydF17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3Mvc2VydmVyLlNoYXJlZFBhcmFtc30qX19cbiAqXG4gKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlXG4gKiBpbnN0YW5jaWF0ZWQgbWFudWFsbHlfXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBpbnNpZGUgdGhlIGV4cGVyaWVuY2UgY29uc3RydWN0b3JcbiAqIHRoaXMuc2hhcmVkUGFyYW1zID0gdGhpcy5yZXF1aXJlKCdzaGFyZWQtcGFyYW1zJyk7XG4gKiAvLyB3aGVuIHRoZSBleHBlcmllbmNlIHN0YXJ0cywgbGlzdGVuIGZvciBwYXJhbWV0ZXIgdXBkYXRlc1xuICogdGhpcy5zaGFyZWRQYXJhbXMuYWRkUGFyYW1MaXN0ZW5lcignc3ludGg6Z2FpbicsICh2YWx1ZSkgPT4ge1xuICogICB0aGlzLnN5bnRoLnNldEdhaW4odmFsdWUpO1xuICogfSk7XG4gKlxuICogQHNlZSBbYEJhc2ljU2hhcmVkQ29udHJvbGxlcmAgc2NlbmVde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5CYXNpY1NoYXJlZENvbnRyb2xsZXJ9XG4gKi9cbmNsYXNzIFNoYXJlZFBhcmFtcyBleHRlbmRzIFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihTRVJWSUNFX0lELCB0cnVlKTtcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge307XG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgLyoqXG4gICAgICogRGljdGlvbmFyeSBvZiBhbGwgdGhlIHBhcmFtZXRlcnMgYW5kIGNvbW1hbmRzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG5hbWUgcGFyYW1zXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5TaGFyZWRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wYXJhbXMgPSB7fTtcblxuICAgIHRoaXMuX29uSW5pdFJlc3BvbnNlID0gdGhpcy5fb25Jbml0UmVzcG9uc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblVwZGF0ZVJlc3BvbnNlID0gdGhpcy5fb25VcGRhdGVSZXNwb25zZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0YXJ0KCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG5cbiAgICB0aGlzLnNlbmQoJ3JlcXVlc3QnKTtcblxuICAgIHRoaXMucmVjZWl2ZSgnaW5pdCcsIHRoaXMuX29uSW5pdFJlc3BvbnNlKTtcbiAgICB0aGlzLnJlY2VpdmUoJ3VwZGF0ZScsIHRoaXMuX29uVXBkYXRlUmVzcG9uc2UpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuc3RvcCgpO1xuICAgIC8vIGRvbid0IHJlbW92ZSAndXBkYXRlJyBsaXN0ZW5lciwgYXMgdGhlIGNvbnRyb2wgaXMgcnVubmlnIGFzIGEgYmFja2dyb3VuZCBwcm9jZXNzXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaW5pdCcsIHRoaXMuX29uSW5pdFJlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25Jbml0UmVzcG9uc2UoY29uZmlnKSB7XG4gICAgY29uZmlnLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuX2NyZWF0ZVBhcmFtKGVudHJ5KTtcbiAgICAgIHRoaXMucGFyYW1zW3BhcmFtLm5hbWVdID0gcGFyYW07XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlYWR5KCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX29uVXBkYXRlUmVzcG9uc2UobmFtZSwgdmFsKSB7XG4gICAgLy8gdXBkYXRlLCBidXQgZG9uJ3Qgc2VuZCBiYWNrIHRvIHNlcnZlclxuICAgIHRoaXMudXBkYXRlKG5hbWUsIHZhbCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9jcmVhdGVQYXJhbShpbml0KSB7XG4gICAgbGV0IHBhcmFtID0gbnVsbDtcblxuICAgIHN3aXRjaCAoaW5pdC50eXBlKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcGFyYW0gPSBuZXcgX0Jvb2xlYW5QYXJhbSh0aGlzLCBpbml0Lm5hbWUsIGluaXQubGFiZWwsIGluaXQudmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIHBhcmFtID0gbmV3IF9FbnVtUGFyYW0odGhpcywgaW5pdC5uYW1lLCBpbml0LmxhYmVsLCBpbml0Lm9wdGlvbnMsIGluaXQudmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcGFyYW0gPSBuZXcgX051bWJlclBhcmFtKHRoaXMsIGluaXQubmFtZSwgaW5pdC5sYWJlbCwgaW5pdC5taW4sIGluaXQubWF4LCBpbml0LnN0ZXAsIGluaXQudmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIHBhcmFtID0gbmV3IF9UZXh0UGFyYW0odGhpcywgaW5pdC5uYW1lLCBpbml0LmxhYmVsLCBpbml0LnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RyaWdnZXInOlxuICAgICAgICBwYXJhbSA9IG5ldyBfVHJpZ2dlclBhcmFtKHRoaXMsIGluaXQubmFtZSwgaW5pdC5sYWJlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlNoYXJlZFBhcmFtc35wYXJhbUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVXBkYXRlZCB2YWx1ZSBvZiB0aGUgc2hhcmVkIHBhcmFtZXRlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIGxpc3RlbiBhIHNwZWNpZmljIHBhcmFtZXRlciBjaGFuZ2VzLiBUaGUgbGlzdGVuZXIgaXNcbiAgICogZXhlY3V0ZWQgaW1tZWRpYXRlbHkgd2hlbiBhZGRlZCB3aXRoIHRoZSBwYXJhbWV0ZXIgY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlNoYXJlZFBhcmFtc35wYXJhbUNhbGxiYWNrfSBsaXN0ZW5lciAtXG4gICAqICBMaXN0ZW5lciB0byBhZGQuXG4gICAqL1xuICBhZGRQYXJhbUxpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLnBhcmFtc1tuYW1lXTtcblxuICAgIGlmIChwYXJhbSkge1xuICAgICAgcGFyYW0uYWRkTGlzdGVuZXIoJ3VwZGF0ZScsIGxpc3RlbmVyKTtcblxuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09ICd0cmlnZ2VyJylcbiAgICAgICAgbGlzdGVuZXIocGFyYW0udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygndW5rbm93biBwYXJhbSBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gbGlzdGVuaW5nIGEgc3BlY2lmaWMgcGFyYW1ldGVyIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge21vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5TaGFyZWRQYXJhbXN+cGFyYW1DYWxsYmFja30gbGlzdGVuZXIgLVxuICAgKiAgTGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlUGFyYW1MaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5wYXJhbXNbbmFtZV07XG5cbiAgICBpZiAocGFyYW0pXG4gICAgICBwYXJhbS5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgbGlzdGVuZXIpO1xuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUubG9nKCd1bmtub3duIHBhcmFtIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHJldHVybnMge01peGVkfSAtIEN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICovXG4gIGdldFZhbHVlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXNbbmFtZV0udmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2YWx1ZSBvZiBhIHBhcmFtZXRlciAodXNlZCB3aGVuIGBvcHRpb25zLmhhc0dVST10cnVlYClcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbCAtIE5ldyB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzZW5kVG9TZXJ2ZXI9dHJ1ZV0gLSBGbGFnIHdoZXRoZXIgdGhlIHZhbHVlIHNob3VsZCBiZVxuICAgKiAgcHJvcGFnYXRlZCB0byB0aGUgc2VydmVyLlxuICAgKi9cbiAgdXBkYXRlKG5hbWUsIHZhbCwgc2VuZFRvU2VydmVyID0gdHJ1ZSkge1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5wYXJhbXNbbmFtZV07XG5cbiAgICBpZiAocGFyYW0pXG4gICAgICBwYXJhbS51cGRhdGUodmFsLCBzZW5kVG9TZXJ2ZXIpO1xuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUubG9nKCd1bmtub3duIHNoYXJlZCBwYXJhbWV0ZXIgXCInICsgbmFtZSArICdcIicpO1xuICB9XG59XG5cbnNlcnZpY2VNYW5hZ2VyLnJlZ2lzdGVyKFNFUlZJQ0VfSUQsIFNoYXJlZFBhcmFtcyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNoYXJlZFBhcmFtcztcbiIsImltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5pbXBvcnQgeyBhdWRpb0NvbnRleHQgfSBmcm9tICd3YXZlcy1hdWRpbyc7XG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTpzaGFyZWQtcmVjb3JkZXInO1xuXG4vLyBjb25zdCBmaWx0ZXIgPSBmaWxlbmFtZSA9PiB0cnVlO1xuXG5jbGFzcyBTaGFyZWRSZWNvcmRlciBleHRlbmRzIFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihTRVJWSUNFX0lEKTtcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgcmVjb3JkZXI6IGZhbHNlLFxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZ3VyZShkZWZhdWx0cyk7XG5cbiAgICB0aGlzLl9yYXdTb2NrZXQgPSB0aGlzLnJlcXVpcmUoJ3Jhdy1zb2NrZXQnKTtcbiAgICB0aGlzLl9hdWRpb0J1ZmZlck1hbmFnZXIgPSB0aGlzLnJlcXVpcmUoJ2F1ZGlvLWJ1ZmZlci1tYW5hZ2VyJyk7XG4gICAgdGhpcy5fcGxhdGZmb3JtID0gbnVsbDtcblxuICAgIHRoaXMuX2dhaW4gPSAxO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3N0cmVhbXMgPSB7fTtcbiAgICB0aGlzLl9idWZmZXJzID0ge307XG4gICAgdGhpcy5fYnVmZmVyTmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX29uQXZhaWxhYmxlRmlsZSA9IHRoaXMuX29uQXZhaWxhYmxlRmlsZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWNvcmRlciA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fcGxhdGZmb3JtID0gdGhpcy5yZXF1aXJlKCdwbGF0Zm9ybScsIHtcbiAgICAgICAgZmVhdHVyZXM6IFsnYXVkaW8taW5wdXQnLCAnd2ViLWF1ZGlvJ10sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgdGhpcy5yZWNlaXZlKCdhdmFpbGFibGUtZmlsZScsIHRoaXMuX29uQXZhaWxhYmxlRmlsZSk7XG5cbiAgICAvLyBAdG9kbyAtIGltcGxlbWVudCBhIGhhbmRzaGFrZSB0byBub3RpZnkgdGhlIHNlcnZlciBhYm91dCB3aG9cbiAgICAvLyBpcyBhIGNvbnN1bWVyIGFuZCB3aG8gaXMgYSByZWNvcmRlci5cbiAgICB0aGlzLnJlYWR5KCk7XG4gIH1cblxuICBzZXRHYWluKHZhbHVlKSB7XG4gICAgdGhpcy5fZ2FpbiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIENvbnN1bWVyIGludGVyZmFjZSAqL1xuXG4gIC8qKlxuICAgKiBHZXQgbm90aWZpY2F0aW9ucyBmb3IgbmV3IGF2YWlsYWJsZSBmaWxlc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIElkIG9mIHRoZSBidWZmZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwaGFzZSAtIElmIHJpbmcgYnVmZmVyLCBwaGFzZSBvZiB0aGUgYnVmZmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgLSBQYXRoIG9mIHRoZSBmaWxlIG9uIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBfb25BdmFpbGFibGVGaWxlKG5hbWUsIHBoYXNlLCBmaWxlbmFtZSkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzLmdldChuYW1lKTtcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgY29uc3QgeyBmaWx0ZXIsIGNhbGxiYWNrIH0gPSBsaXN0ZW5lcjtcblxuICAgICAgaWYgKGZpbHRlci5sZW5ndGggPT09IDAgfHzCoGZpbHRlci5pbmRleE9mKHBoYXNlKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFtuYW1lXTogeyBbcGhhc2VdOiBmaWxlbmFtZSB9IH07XG5cbiAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJNYW5hZ2VyXG4gICAgICAgICAgLmxvYWRGaWxlcyhkZXNjcmlwdGlvbilcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb0J1ZmZlciA9IHRoaXMuX2F1ZGlvQnVmZmVyTWFuYWdlci5nZXQobmFtZSwgcGhhc2UpO1xuICAgICAgICAgICAgY2FsbGJhY2soYXVkaW9CdWZmZXIsIHBoYXNlKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKGVyci5zdGFjaykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKlxuICAgKi9cbiAgYWRkTGlzdGVuZXIobmFtZSwgZmlsdGVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2xpc3RlbmVycy5zZXQobmFtZSwgeyBmaWx0ZXIsIGNhbGxiYWNrIH0pO1xuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIobmFtZSkge1xuICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUobmFtZSk7XG4gIH1cblxuXG4gIC8qKiBSZWNvcmRlciBpbnRlcmZhY2UgKi9cblxuICBfZ2V0SW5kZXgobmFtZSkge1xuICAgIGxldCBpbmRleCA9IHRoaXMuX2J1ZmZlck5hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX2J1ZmZlck5hbWVzLmxlbmd0aDtcbiAgICAgIHRoaXMuX2J1ZmZlck5hbWVzW2luZGV4XSA9IG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcmVjb3JkIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNodW5rRHVyYXRpb24gLSBEdXJhdGlvbiBvZiBlYWNoIGNodW5rIGluIHNlY29uZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNodW5rUGVyaW9kIC0gUGVyaW9kIGJldHdlZW4gZWFjaCBjaHVuay5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bUNodW5rcyAtIE51bWJlciBvZiBjaHVuayBpbiB0aGUgcmVjb3JkaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGN5Y2xpYyAtIERlZmluZSBpZiByaW5nIGJ1ZmZlciBvciBub3QuXG4gICAqL1xuICBjcmVhdGVCdWZmZXIobmFtZSwgY2h1bmtEdXJhdGlvbiwgY2h1bmtQZXJpb2QsIG51bUNodW5rcywgY3ljbGljID0gdHJ1ZSkge1xuICAgIC8vIGNsaWVudCBzcGVjaWZpYyBpbmRleCBvZiB0aGUgZ2l2ZW4gbmFtZVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgobmFtZSk7XG4gICAgY29uc3QgaW5mb3MgPSB7IGluZGV4LCBuYW1lLCBjaHVua0R1cmF0aW9uLCBjaHVua1BlcmlvZCwgbnVtQ2h1bmtzLCBjeWNsaWMgfTtcbiAgICBjb25zdCBzYW1wbGVSYXRlID0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG4gICAgbGV0IGxlbmd0aDtcblxuICAgIGlmICghY3ljbGljKVxuICAgICAgbGVuZ3RoID0gY2h1bmtQZXJpb2QgKiAobnVtQ2h1bmtzIC0gMSkgKyBjaHVua0R1cmF0aW9uO1xuICAgIGVsc2VcbiAgICAgIGxlbmd0aCA9IGNodW5rUGVyaW9kICogbnVtQ2h1bmtzO1xuXG4gICAgaW5mb3MubGVuZ3RoID0gbGVuZ3RoICogc2FtcGxlUmF0ZTtcbiAgICBpbmZvcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcblxuICAgIC8vIGtlZXAgYSBsb2NhbCBjb3B5IG9mIHRoZSBpbmZvcm1hdGlvbnNcbiAgICB0aGlzLl9idWZmZXJzW25hbWVdID0gaW5mb3M7XG4gICAgdGhpcy5zZW5kKCdjcmVhdGUtYnVmZmVyJywgaW5mb3MpO1xuICB9XG5cbiAgc3RhcnRSZWNvcmQobmFtZSkge1xuICAgIGNvbnN0IGluZm9zID0gdGhpcy5fYnVmZmVyc1tuYW1lXTtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9zdHJlYW1zW25hbWVdO1xuXG4gICAgaWYgKCFpbmZvcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN0YXJ0IG5vbiBleGlzdGluZyBidWZmZXI6IFwiJHtuYW1lfVwiYCk7XG4gICAgZWxzZSBpZiAoc3RyZWFtKVxuICAgICAgdGhpcy5fZGlzY29ubmVjdEdyYXBoKG5hbWUpO1xuXG4gICAgY29uc3QgaW5kZXggPSBpbmZvcy5pbmRleDtcblxuICAgIC8vIGlmIG5vdCBjeWNsaWMgdG8gYmUgYWJsZSB0byBzdG9wIHRoZSByZWNvcmRcbiAgICBpZiAoaW5mb3MuY3ljbGljID09PSBmYWxzZSlcbiAgICAgIGluZm9zLnBvaW50ZXIgPSAwO1xuXG4gICAgLy8gc2VuZCBzdGFydCBtZXNzYWdlIChyZWluaXQgYnVmZmVyIHBvaW50ZXIpXG4gICAgY29uc3QgbXNnID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgbXNnWzBdID0gaW5kZXg7XG4gICAgdGhpcy5fcmF3U29ja2V0LnNlbmQoJ3NoYXJlZC1yZWNvcmRlcjpzdGFydC1yZWNvcmQnLCBtc2cpO1xuXG4gICAgLy8gc3RhcnQgcmVjb3JkaW5nXG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IDQwOTY7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplICsgMSk7XG4gICAgYnVmZmVyWzBdID0gaW5kZXg7XG5cbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSwgKHN0cmVhbSkgPT4ge1xuICAgICAgY29uc3Qgc2NyaXB0UHJvY2Vzc29yID0gYXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihidWZmZXJTaXplLCAxLCAxKTtcbiAgICAgIHNjcmlwdFByb2Nlc3Nvci5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICBzY3JpcHRQcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblxuICAgICAgICBpZiAodGhpcy5fZ2FpbiAhPT0gMSkge1xuICAgICAgICAgIGNvbnN0IGdhaW4gPSB0aGlzLl9nYWluO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGRhdGFbaV0gKj0gZ2FpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlci5zZXQoZGF0YSwgMSk7XG4gICAgICAgIHRoaXMuX3Jhd1NvY2tldC5zZW5kKCdzaGFyZWQtcmVjb3JkZXI6bmV3LWJsb2NrJywgYnVmZmVyKTtcblxuICAgICAgICAvLyBtYWludGFpbiBhIGxvY2FsIHBvaW50ZXIgdG8gdHJpZ2dlciBgc3RvcFJlY29yZGAgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gICAgICAgIGlmIChpbmZvcy5jeWNsaWMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaW5mb3MucG9pbnRlciArPSBidWZmZXJTaXplO1xuXG4gICAgICAgICAgaWYgKGluZm9zLnBvaW50ZXIgPj0gaW5mb3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5fZGlzY29ubmVjdEdyYXBoKGluZm9zLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1ZGlvSW4gPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAgICAgIGF1ZGlvSW4uY29ubmVjdChzY3JpcHRQcm9jZXNzb3IpO1xuXG4gICAgICB0aGlzLl9zdHJlYW1zW25hbWVdID0geyBzdHJlYW0sIGF1ZGlvSW4sIHNjcmlwdFByb2Nlc3NvciB9O1xuICAgIH0sIGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYnVmZmVyLlxuICAgKi9cbiAgc3RvcFJlY29yZChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9zdHJlYW1zW25hbWVdKSByZXR1cm47XG5cbiAgICAvLyBzZW5kIHN0b3AgbWVzc2FnZVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgobmFtZSk7XG4gICAgY29uc3QgbXNnID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgbXNnWzBdID0gaW5kZXg7XG4gICAgdGhpcy5fcmF3U29ja2V0LnNlbmQoJ3NoYXJlZC1yZWNvcmRlcjpzdG9wLXJlY29yZCcsIG1zZyk7XG5cbiAgICB0aGlzLl9kaXNjb25uZWN0R3JhcGgobmFtZSk7XG4gIH1cblxuICBfZGlzY29ubmVjdEdyYXBoKG5hbWUpIHtcbiAgICBjb25zdCB7IHN0cmVhbSwgYXVkaW9Jbiwgc2NyaXB0UHJvY2Vzc29yIH0gPSB0aGlzLl9zdHJlYW1zW25hbWVdO1xuICAgIHNjcmlwdFByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XG4gICAgYXVkaW9Jbi5kaXNjb25uZWN0KCk7XG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKClbMF0uc3RvcCgpO1xuICAgIGRlbGV0ZSB0aGlzLl9zdHJlYW1zW25hbWVdO1xuICB9XG59XG5cbnNlcnZpY2VNYW5hZ2VyLnJlZ2lzdGVyKFNFUlZJQ0VfSUQsIFNoYXJlZFJlY29yZGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgU2hhcmVkUmVjb3JkZXI7XG4iLCJpbXBvcnQgeyBhdWRpb0NvbnRleHQgfSBmcm9tICd3YXZlcy1hdWRpbyc7XG5pbXBvcnQgU2VnbWVudGVkVmlldyBmcm9tICcuLi92aWV3cy9TZWdtZW50ZWRWaWV3JztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4uL2NvcmUvU2VydmljZSc7XG5pbXBvcnQgc2VydmljZU1hbmFnZXIgZnJvbSAnLi4vY29yZS9zZXJ2aWNlTWFuYWdlcic7XG5pbXBvcnQgU3luY01vZHVsZSBmcm9tICdzeW5jL2NsaWVudCc7XG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTpzeW5jJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBjbGllbnQgYCdzeW5jJ2Agc2VydmljZS5cbiAqXG4gKiBUaGUgYHN5bmNgIHNlcnZpY2Ugc3luY2hyb25pemVzIHRoZSBsb2NhbCBhdWRpbyBjbG9jayBvZiB0aGUgY2xpZW50IHdpdGggdGhlXG4gKiBjbG9jayBvZiB0aGUgc2VydmVyIChtYXN0ZXIgY2xvY2spLiBJdCBpbnRlcm5hbGx5IHJlbGllcyBvbiB0aGUgYFdlYkF1ZGlvYFxuICogY2xvY2sgYW5kIHRoZW4gcmVxdWlyZXMgdGhlIGBwbGF0Zm9ybWAgc2VydmljZSB0byBhY2Nlc3MgdGhpcyBmZWF0dXJlLlxuICpcbiAqIF9fKlRoZSBzZXJ2aWNlIG11c3QgYmUgdXNlZCB3aXRoIGl0c1xuICogW3NlcnZlci1zaWRlIGNvdW50ZXJwYXJ0XXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9zZXJ2ZXIuU3luY30qX19cbiAqXG4gKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlXG4gKiBpbnN0YW5jaWF0ZWQgbWFudWFsbHlfXG4gKlxuICogX05vdGU6XyB0aGUgc2VydmljZSBpcyBiYXNlZCBvblxuICogW2BnaXRodWIuY29tL2NvbGxlY3RpdmUtc291bmR3b3Jrcy9zeW5jYF0oaHR0cHM6Ly9naXRodWIuY29tL2NvbGxlY3RpdmUtc291bmR3b3Jrcy9zeW5jKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGluc2lkZSB0aGUgZXhwZXJpZW5jZSBjb25zdHJ1Y3RvclxuICogdGhpcy5zeW5jID0gdGhpcy5yZXF1aXJlKCdzeW5jJyk7XG4gKiAvLyB3aGVuIHRoZSBleHBlcmllbmNlIGhhcyBzdGFydGVkLCB0cmFuc2xhdGUgdGhlIHN5bmMgdGltZSBpbiBsb2NhbCB0aW1lXG4gKiBjb25zdCBzeW5jVGltZSA9IHRoaXMuc3luYy5nZXRTeW5jVGltZSgpO1xuICogY29uc3QgbG9jYWxUaW1lID0gdGhpcy5zeW5jLmdldEF1ZGlvVGltZShzeW5jVGltZSk7XG4gKi9cbmNsYXNzIFN5bmMgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHZpZXdQcmlvcml0eTogMyxcbiAgICAgIHVzZUF1ZGlvVGltZTogdHJ1ZSxcbiAgICAgIC8vIEB0b2RvIC0gYWRkIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBzeW5jIHNlcnZpY2VcbiAgICB9O1xuXG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgY29uc3QgZ2V0VGltZSA9IHRoaXMub3B0aW9ucy51c2VBdWRpb1RpbWUgP1xuICAgICAgKCkgPT4gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lIDpcbiAgICAgICgpID0+IChuZXcgRGF0ZSgpLmdldFRpbWUoKSAqIDAuMDAxKTtcblxuICAgIHRoaXMuX3N5bmMgPSBuZXcgU3luY01vZHVsZShnZXRUaW1lKTtcbiAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuXG4gICAgdGhpcy5yZXF1aXJlKCdwbGF0Zm9ybScsIHsgZmVhdHVyZXM6ICd3ZWItYXVkaW8nIH0pO1xuXG4gICAgdGhpcy5fc3luY1N0YXR1c1JlcG9ydCA9IHRoaXMuX3N5bmNTdGF0dXNSZXBvcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZXBvcnRMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuICAgIHRoaXMuc2hvdygpO1xuXG4gICAgY29uc3Qgc2VuZEZ1bmN0aW9uID0gKC4uLmFyZ3MpID0+IHRoaXMuc2VuZCgncGluZycsIC4uLmFyZ3MpO1xuICAgIGNvbnN0IHJlY2VpdmVGdW5jdGlvbiA9IGNhbGxiYWNrID0+IHRoaXMucmVjZWl2ZSgncG9uZycsIGNhbGxiYWNrKTtcblxuICAgIHRoaXMuX3N5bmMuc3RhcnQoc2VuZEZ1bmN0aW9uLCByZWNlaXZlRnVuY3Rpb24sIHRoaXMuX3N5bmNTdGF0dXNSZXBvcnQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gICAgc3VwZXIuc3RvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGltZSBpbiB0aGUgbG9jYWwgY2xvY2suIElmIG5vIGFyZ3VtZW50cyBwcm92aWRlZCxcbiAgICogcmV0dXJucyB0aGUgY3VycmVudCBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3luY1RpbWUgLSBUaW1lIGZyb20gdGhlIHN5bmMgY2xvY2sgKGluIF9zZWNvbmRzXykuXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBMb2NhbCB0aW1lIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gICAqICBgc3luY1RpbWVgIChpbiBfc2Vjb25kc18pLlxuICAgKi9cbiAgZ2V0QXVkaW9UaW1lKHN5bmNUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmMuZ2V0TG9jYWxUaW1lKHN5bmNUaW1lKTtcbiAgfVxuXG4gIGdldExvY2FsVGltZShzeW5jVGltZSkge1xuICAgIHJldHVybiB0aGlzLl9zeW5jLmdldExvY2FsVGltZShzeW5jVGltZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aW1lIGluIHRoZSBzeW5jIGNsb2NrLiBJZiBubyBhcmd1bWVudHMgcHJvdmlkZWQsXG4gICAqIHJldHVybnMgdGhlIGN1cnJlbnQgc3luYyB0aW1lLlxuICAgKiBAcGFyYW0ge051bWJlcn0gYXVkaW9UaW1lIC0gVGltZSBmcm9tIHRoZSBsb2NhbCBjbG9jayAoaW4gX3NlY29uZHNfKS5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIFN5bmMgdGltZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICAgKiAgYGF1ZGlvVGltZWAgKGluIF9zZWNvbmRzXykuXG4gICAqL1xuICBnZXRTeW5jVGltZShhdWRpb1RpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luYy5nZXRTeW5jVGltZShhdWRpb1RpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRoZSBzeW5jaHJvbml6YXRpb24gcmVwb3J0cyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBhZGRMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlcG9ydExpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9zeW5jU3RhdHVzUmVwb3J0KHJlcG9ydCkge1xuICAgIGlmIChyZXBvcnQuc3RhdHVzID09PSAndHJhaW5pbmcnIHx8IHJlcG9ydC5zdGF0dXMgPT09ICdzeW5jJykge1xuICAgICAgdGhpcy5fcmVwb3J0TGlzdGVuZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiAgY2FsbGJhY2socmVwb3J0KSk7XG5cbiAgICAgIGlmICghdGhpcy5fcmVhZHkpIHtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlYWR5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgU3luYyk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bmM7XG4iLCJpbXBvcnQgU2VydmljZSBmcm9tICcuLi9jb3JlL1NlcnZpY2UnO1xuaW1wb3J0IHNlcnZpY2VNYW5hZ2VyIGZyb20gJy4uL2NvcmUvc2VydmljZU1hbmFnZXInO1xuaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuY29uc3QgYXVkaW9TY2hlZHVsZXIgPSBhdWRpby5nZXRTY2hlZHVsZXIoKTtcblxuY2xhc3MgU3luY1RpbWVTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBhdWRpby5TY2hlZHVsaW5nUXVldWUge1xuICBjb25zdHJ1Y3RvcihzeW5jLCBzY2hlZHVsZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5zeW5jID0gc3luYztcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLnNjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xuICAgIHRoaXMubmV4dFN5bmNUaW1lID0gSW5maW5pdHk7XG5cbiAgICAvLyBjYWxsIHRoaXMucmVzeW5jIGluIHN5bmMgY2FsbGJhY2tcbiAgICB0aGlzLnJlc3luYyA9IHRoaXMucmVzeW5jLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zeW5jLmFkZExpc3RlbmVyKHRoaXMucmVzeW5jKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYy5nZXRTeW5jVGltZSh0aGlzLnNjaGVkdWxlci5jdXJyZW50VGltZSk7XG4gIH1cblxuICBhZHZhbmNlVGltZShhdWRpb1RpbWUpIHtcbiAgICBjb25zdCBuZXh0U3luY1RpbWUgPSBzdXBlci5hZHZhbmNlVGltZSh0aGlzLm5leHRTeW5jVGltZSk7XG4gICAgY29uc3QgbmV4dEF1ZGlvVGltZSA9IHRoaXMuc3luYy5nZXRBdWRpb1RpbWUobmV4dFN5bmNUaW1lKTtcblxuICAgIHRoaXMubmV4dFN5bmNUaW1lID0gbmV4dFN5bmNUaW1lO1xuXG4gICAgcmV0dXJuIG5leHRBdWRpb1RpbWU7XG4gIH1cblxuICByZXNldFRpbWUoc3luY1RpbWUpIHtcbiAgICBpZiAoc3luY1RpbWUgPT09IHVuZGVmaW5lZClcbiAgICAgIHN5bmNUaW1lID0gdGhpcy5zeW5jLmdldFN5bmNUaW1lKCk7XG5cbiAgICB0aGlzLm5leHRTeW5jVGltZSA9IHN5bmNUaW1lO1xuXG4gICAgY29uc3QgYXVkaW9UaW1lID0gdGhpcy5zeW5jLmdldEF1ZGlvVGltZShzeW5jVGltZSk7XG4gICAgdGhpcy5tYXN0ZXIucmVzZXRFbmdpbmVUaW1lKHRoaXMsIGF1ZGlvVGltZSk7XG4gIH1cblxuICByZXN5bmMoKSB7XG4gICAgaWYgKHRoaXMubmV4dFN5bmNUaW1lICE9PSBJbmZpbml0eSkge1xuICAgICAgY29uc3QgbmV4dEF1ZGlvVGltZSA9IHRoaXMuc3luYy5nZXRBdWRpb1RpbWUodGhpcy5uZXh0U3luY1RpbWUpO1xuICAgICAgdGhpcy5tYXN0ZXIucmVzZXRFbmdpbmVUaW1lKHRoaXMsIG5leHRBdWRpb1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVRpbWUodGhpcywgSW5maW5pdHkpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTRVJWSUNFX0lEID0gJ3NlcnZpY2U6c3luYy1zY2hlZHVsZXInO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIGNsaWVudCBgJ3N5bmMtc2NoZWR1bGVyJ2Agc2VydmljZS5cbiAqXG4gKiBUaGUgYHN5bmMtc2NoZWR1bGVyYCBwcm92aWRlcyBhIHNjaGVkdWxlciBzeW5jaHJvbmlzZWQgYW1vbmcgYWxsIGNsaWVudCB1c2luZyB0aGVcbiAqIFtgc3luY2Bde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5TeW5jfSBzZXJ2aWNlLlxuICpcbiAqIFdoaWxlIHRoaXMgc2VydmljZSBoYXMgbm8gZGlyZWN0IHNlcnZlciBjb3VudGVycGFydCwgaXRzIGRlcGVuZGVuY3kgb24gdGhlXG4gKiBbYHN5bmNgXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuU3luY30gc2VydmljZSB3aGljaCByZXF1aXJlcyB0aGVcbiAqIGV4aXN0ZW5jZSBvZiBhIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZF0gLSBQZXJpb2Qgb2YgdGhlIHNjaGVkdWxlciAoZGVmYXV0cyB0b1xuICogIGN1cnJlbnQgdmFsdWUpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvb2thaGVhZF0gLSBMb29rYWhlYWQgb2YgdGhlIHNjaGVkdWxlciAoZGVmYXV0c1xuICogIHRvIGN1cnJlbnQgdmFsdWUpLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqIEBzZWUgW2B3YXZlc0F1ZGlvLlNjaGVkdWxlcmBde0BsaW5rIGh0dHA6Ly93YXZlc2pzLmdpdGh1Yi5pby9hdWRpby8jYXVkaW8tc2NoZWR1bGVyfVxuICogQHNlZSBbYHBsYXRmb3JtYCBzZXJ2aWNlXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUGxhdGZvcm19XG4gKiBAc2VlIFtgc3luY2Agc2VydmljZV17QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlN5bmN9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGluc2lkZSB0aGUgZXhwZXJpZW5jZSBjb25zdHJ1Y3RvclxuICogdGhpcy5zeW5jU2NoZWR1bGVyID0gdGhpcy5yZXF1aXJlKCdzY2hlZHVsZXInKTtcbiAqXG4gKiAvLyB3aGVuIHRoZSBleHBlcmllbmNlIGhhcyBzdGFydGVkXG4gKiBjb25zdCBuZXh0U3luY1RpbWUgPSB0aGlzLnN5bmNTY2hlZHVsZXIuY3VycmVudCArIDI7XG4gKiB0aGlzLnN5bmNTY2hlZHVsZXIuYWRkKHRpbWVFbmdpbmUsIG5leHRTeW5jVGltZSk7XG4gKi9cbmNsYXNzIFN5bmNTY2hlZHVsZXIgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgLyoqIF88c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5fX1dBUk5JTkdfXzwvc3Bhbj4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmUgaW5zdGFuY2lhdGVkIG1hbnVhbGx5XyAqL1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoU0VSVklDRV9JRCwgZmFsc2UpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBzeW5jIG9wdGlvblxuICAgIHRoaXMuX3N5bmMgPSBudWxsO1xuICAgIHRoaXMuX3N5bmNlZFF1ZXVlID0gbnVsbDtcblxuICAgIC8vIGluaXQgYXVkaW8gdGltZSBiYXNlZCBzY2hlZHVsZXIsIHN5bmMgc2VydmljZSwgYW5kIHF1ZXVlXG4gICAgdGhpcy5fcGxhdGZvcm0gPSB0aGlzLnJlcXVpcmUoJ3BsYXRmb3JtJywgeyBmZWF0dXJlczogJ3dlYi1hdWRpbycgfSk7XG4gICAgdGhpcy5fc3luYyA9IHRoaXMucmVxdWlyZSgnc3luYycpO1xuICAgIHRoaXMuX3N5bmNlZFF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgdGhpcy5fc3luY2VkUXVldWUgPSBuZXcgU3luY1RpbWVTY2hlZHVsaW5nUXVldWUodGhpcy5fc3luYywgYXVkaW9TY2hlZHVsZXIpO1xuICAgIHRoaXMucmVhZHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IGF1ZGlvIHRpbWUgb2YgdGhlIHNjaGVkdWxlci5cbiAgICogQGluc3RhbmNlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYXVkaW9UaW1lKCkge1xuICAgIHJldHVybiBhdWRpb1NjaGVkdWxlci5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHN5bmMgdGltZSBvZiB0aGUgc2NoZWR1bGVyLlxuICAgKiBAaW5zdGFuY2VcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzeW5jVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY2VkUXVldWUuY3VycmVudFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCBzeW5jIHRpbWUgb2YgdGhlIHNjaGVkdWxlciAoYWxpYXMgYHRoaXMuc3luY1RpbWVgKS5cbiAgICogQGluc3RhbmNlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmNlZFF1ZXVlLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIERpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc2NoZWR1bGVyJ3MgbG9naWNhbCBhdWRpbyB0aW1lIGFuZCB0aGUgYGN1cnJlbnRUaW1lYFxuICAgKiBvZiB0aGUgYXVkaW8gY29udGV4dC5cbiAgICogQGluc3RhbmNlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGVsdGFUaW1lKCkge1xuICAgIHJldHVybiBhdWRpb1NjaGVkdWxlci5jdXJyZW50VGltZSAtIGF1ZGlvLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3luYyB0aW1lIGNvcnJlc3BvbmRpbmcgdG8gZ2l2ZW4gYXVkaW8gdGltZS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSBhdWRpb1RpbWUgLSBhdWRpbyB0aW1lLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gc3luYyB0aW1lIGNvcnJlc3BvbmRpbmcgdG8gZ2l2ZW4gYXVkaW8gdGltZS5cbiAgICovXG4gIGdldFN5bmNUaW1lQXRBdWRpb1RpbWUoYXVkaW9UaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmMuZ2V0U3luY1RpbWUoYXVkaW9UaW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXVkaW8gdGltZSBjb3JyZXNwb25kaW5nIHRvIGdpdmVuIHN5bmMgdGltZS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSBzeW5jVGltZSAtIHN5bmMgdGltZS5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIGF1ZGlvIHRpbWUgY29ycmVzcG9uZGluZyB0byBnaXZlbiBzeW5jIHRpbWUuXG4gICAqL1xuICBnZXRBdWRpb1RpbWVBdFN5bmNUaW1lKHN5bmNUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmMuZ2V0QXVkaW9UaW1lKHN5bmNUaW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW4gLSBGdW5jdGlvbiB0byBiZSBkZWZlcnJlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBUaGUgdGltZSBhdCB3aGljaCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29rYWhlYWQ9ZmFsc2VdIC0gRGVmaW5lcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgICogIGFudGljaXBhdGVkIChlLmcuIGZvciBhdWRpbyBldmVudHMpIG9yIHByZWNpc2VseSBhdCB0aGUgZ2l2ZW4gdGltZSAoZGVmYXVsdCkuXG4gICAqL1xuICBkZWZlcihmdW4sIHRpbWUsIGxvb2thaGVhZCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2NoZWR1bGVyID0gdGhpcy5fc3luY2VkUXVldWU7XG4gICAgY29uc3Qgc2NoZWR1bGVyU2VydmljZSA9IHRoaXM7XG4gICAgbGV0IGVuZ2luZTtcblxuICAgIGlmKGxvb2thaGVhZCkge1xuICAgICAgc2NoZWR1bGVyLmRlZmVyKGZ1biwgdGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZ2luZSA9IHtcbiAgICAgICAgYWR2YW5jZVRpbWU6IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICBjb25zdCBkZWx0YSA9IHNjaGVkdWxlclNlcnZpY2UuZGVsdGFUaW1lO1xuXG4gICAgICAgICAgaWYoZGVsdGEgPiAwKVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW4sIDEwMDAgKiBkZWx0YSwgdGltZSk7IC8vIGJyaWRnZSBzY2hlZHVsZXIgbG9va2FoZWFkIHdpdGggdGltZW91dFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZ1bih0aW1lKTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHNjaGVkdWxlci5hZGQoZW5naW5lLCB0aW1lKTsgLy8gYWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRpbWUgZW5naW5lIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZW5naW5lIC0gRW5naW5lIHRvIHNjaGVkdWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBmdW5jdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuXG4gICAqL1xuICBhZGQoZW5naW5lLCB0aW1lKSB7XG4gICAgdGhpcy5fc3luY2VkUXVldWUuYWRkKGVuZ2luZSwgdGltZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBlbmdpbmUgZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZ2luZSAtIEVuZ2luZSB0byByZW1vdmUgZnJvbSB0aGUgc2NoZWR1bGVyLlxuICAgKi9cbiAgcmVtb3ZlKGVuZ2luZSkge1xuICAgIHRoaXMuX3N5bmNlZFF1ZXVlLnJlbW92ZShlbmdpbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgc2NoZWR1bGVkIGZ1bmN0aW9ucyBhbmQgdGltZSBlbmdpbmVzIGZyb20gdGhlIHNjaGVkdWxlci5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3N5bmNlZFF1ZXVlLmNsZWFyKCk7XG4gIH1cbn1cblxuc2VydmljZU1hbmFnZXIucmVnaXN0ZXIoU0VSVklDRV9JRCwgU3luY1NjaGVkdWxlcik7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bmNTY2hlZHVsZXI7XG4iLCIvKipcbiAqIEJhc2UgY2xhc3MgdG8gZXh0ZW5kIGluIG9yZGVyIHRvIGJlIHVzZWQgaW4gY29uam9uY3Rpb24gd2l0aCBhXG4gKiBbYENhbnZhc1ZpZXdgXXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld30uIFRoZXNlIGNsYXNzZXNcbiAqIHByb3ZpZGUgYWx0b2dldGhlciBhIGNsZWFuIHdheSB0byBtYW5hZ2UgdGhlIGB1cGRhdGVgIGFuZCBgcmVuZGVyYCBjeWNsZXNcbiAqIG9mIGFuIGFuaW1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3VwZGF0ZVBlcmlvZD0wXSAtIExvZ2ljYWwgdGltZSAoaW4gX3NlY29uZF8pIGJldHdlZW5cbiAqICBlYWNoIHN1YnNlcXVlbnQgdXBkYXRlcy4gSWYgYDBgLCB0aGUgdXBkYXRlIHBlcmlvZCBpcyBzbGF2ZWQgb24gdGhlXG4gKiAgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgcGVyaW9kICh3aGljaCBpcyBhcHByaW9wcmlhdGUgZm9yIG1vc3Qgb2YgdGhlXG4gKiAgdXNlLWNhc2VzKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld31cbiAqL1xuY2xhc3MgQ2FudmFzMmRSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHVwZGF0ZVBlcmlvZCA9IDApIHtcbiAgICB0aGlzLnVwZGF0ZVBlcmlvZCA9IHVwZGF0ZVBlcmlvZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgKGxvZ2ljYWwpIHRpbWUgb2YgdGhlIENhbnZhczJkUmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGN1cnJlbnRUaW1lXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5DYW52YXMyZFJlbmRlcmVyXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHdpZHRoIG9mIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGNhbnZhc1dpZHRoXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5DYW52YXMyZFJlbmRlcmVyXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlaWdodCBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBjYW52YXNIZWlnaHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkNhbnZhczJkUmVuZGVyZXJcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc0hlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcmllbnRhdGlvbiBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAbmFtZSBvcmllbnRhdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzMmRSZW5kZXJlclxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBudWxsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIG9uUmVzaXplKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIG9yaWVudGF0aW9uKSB7XG4gICAgdGhpcy5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBpbnN0YW5jZSBpcyBhZGRlZCB0byBhIGBDYW52YXNWaWV3YC5cbiAgICogYHRoaXMuY2FudmFzV2lkdGhgIGFuZCBgdGhpcy5jYW52YXNIZWlnaHRgIHNob3VsZCBiZSBhdmFpbGFibGUgYXQgdGhpc1xuICAgKiBwb2ludC5cbiAgICovXG4gIGluaXQoKSB7fVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIHRoYXQgc2hvdWxkIGhvc3QgdGhlIGNvZGUgdGhhdCB1cGRhdGVzIHRoZSBwcm9wZXJ0aWVzXG4gICAqIG9mIHRoZSBDYW52YXMyZFJlbmRlcmVyIChwaHlzaWNzLCBldGMuKVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHQgLSBMb2dpY2FsIHRpbWUgc2luY2UgdGhlIGxhc3QgdXBkYXRlLiBJZlxuICAgKiAgYHRoaXMudXBkYXRlUGVyaW9kYCBpcyBlcXVhbCB0byB6ZXJvIDAsIGBkdGAgaXMgdGhlIGVsYXNwZWQgdGltZSBzaW5jZVxuICAgKiAgdGhlIGxhc3QgcmVuZGVyLlxuICAgKi9cbiAgdXBkYXRlKGR0KSB7fVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIHRoYXQgc2hvdWxkIGhvc3QgdGhlIGNvZGUgdGhhdCBkcmF3IGludG8gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIDJkIGNvbnRleHQgb2YgdGhlIGNhbnZhcy5cbiAgICovXG4gIHJlbmRlcihjdHgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhczJkUmVuZGVyZXI7XG4iLCIvKipcbiAqIFJlbmRlcmluZyBsb29wIGhhbmRsaW5nIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhbmQgdGhlIGB1cGRhdGVgIC9cbiAqIGByZW5kZXJgIGN5Y2xlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBsb29wID0ge1xuICByZW5kZXJpbmdHcm91cHM6IFtdLFxuXG4gIF9pc1J1bm5pbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gQ3VycmVudCB0aW1lIGluIHNlY29uZHMuXG4gICAqL1xuICBnZXRUaW1lKCkge1xuICAgIHJldHVybiAwLjAwMSAqICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA/XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSByZW5kZXJpbmcgbG9vcCBpZiBub3Qgc3RhcnRlZC5cbiAgICovXG4gIHJlcXVpcmVTdGFydCgpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7IHJldHVybjsgfVxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuXG4gICAgKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBzZWxmLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZHQgPSB0aW1lIC0gc2VsZi5sYXN0UmVuZGVyVGltZTtcbiAgICAgICAgY29uc3QgcmVuZGVyaW5nR3JvdXBzID0gc2VsZi5yZW5kZXJpbmdHcm91cHM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZW5kZXJpbmdHcm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXAgPSByZW5kZXJpbmdHcm91cHNbaV07XG4gICAgICAgICAgLy8gbGV0IHRoZSBncm91cCBoYW5kbGUgdGhlIHVwZGF0ZVBlcmlvZCBvZiBlYWNoIHJlbmRlcmVyXG4gICAgICAgICAgZ3JvdXAudXBkYXRlKHRpbWUsIGR0KTtcbiAgICAgICAgICBncm91cC5yZW5kZXIoZHQpOyAvLyBmb3J3YXJkIGBkdGAgZm9yIGBwcmVSZW5kZXJgIG1ldGhvZFxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5sYXN0UmVuZGVyVGltZSA9IHRpbWU7XG4gICAgICAgIHNlbGYuckFGaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuckFGaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfSh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGxvb3AgaWYgbm8gcmVuZGVyZXIgYXJlIHN0aWxsIHByZXNlbnQuIElmIG5vdCBhYm9ydC5cbiAgICovXG4gIHJlcXVpcmVTdG9wKCkge1xuICAgIC8vIEB0b2RvIC0gaGFuZGxlIHNldmVyYWwgcGFyYWxsZWwgZ3JvdXBzXG4gICAgbGV0IHNob3VsZFN0b3AgPSB0cnVlO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnJlbmRlcmluZ0dyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0dyb3Vwc1tpXS5yZW5kZXJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzaG91bGRTdG9wID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFN0b3ApIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuckFGaWQpO1xuICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSByZW5kZXJpbmcgZ3JvdXAgdG8gdGhlIGxvb3AuXG4gICAqL1xuICByZWdpc3RlclJlbmRlcmluZ0dyb3VwKGdyb3VwKSB7XG4gICAgdGhpcy5yZW5kZXJpbmdHcm91cHMucHVzaChncm91cCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGEgZ3JvdXAgb2YgcmVuZGVyZXJzIG9uIGEgc2luZ2xlIGZ1bGwgc2NyZWVuIGNhbnZhcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5UaGlzIGNsYXNzIGlzIGEgcHJvcGVydHkgb2ZcbiAqIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld30gc2hvdWxkIGJlIGNvbnNpZGVyZWQgcHJpdmF0ZS48L3NwYW4+XG4gKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyBjb250ZXh0IGluIHdoaWNoXG4gKiAgdGhlIHJlbmRlcmVyIHNob3VsZCBkcmF3LlxuICogQHBhcmFtIHtCb29sZWFufSBbcHJlc2VydmVQaXhlbFJhdGlvPWZhbHNlXSAtIERlZmluZSBpZiB0aGUgY2FudmFzIHNob3VsZFxuICogIHRha2UgYWNjb3VudCBvZiB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIGZvciB0aGUgZHJhd2luZy4gV2hlbiBzZXQgdG8gYHRydWVgLFxuICogIHF1YWxpdHkgaWYgZmF2b3JlZCBvdmVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqL1xuY2xhc3MgQ2FudmFzMmRSZW5kZXJpbmdHcm91cCB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgcHJlc2VydmVQaXhlbFJhdGlvID0gZmFsc2UsIHNraXBGcmFtZXMgPSAwKSB7XG4gICAgLyoqXG4gICAgICogMmQgY29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKiBAbmFtZSBjdHhcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkNhbnZhczJkUmVuZGVyaW5nR3JvdXBcbiAgICAgKi9cbiAgICB0aGlzLmN0eCA9IGN0eDtcblxuICAgIC8qKlxuICAgICAqIFN0YWNrIG9mIHRoZSByZWdpc3RlcmVkIHJlbmRlcmVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUmVuZGVyZXI+fVxuICAgICAqIEBuYW1lIHJlbmRlcmVyc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzMmRSZW5kZXJpbmdHcm91cFxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBIb29rcyBleGVjdXRlZCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgZWFjaCByQUYgY2FsbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucHJlUmVuZGVyID0gbnVsbDtcbiAgICB0aGlzLnBvc3RSZW5kZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGl4ZWwgcmF0aW8gb2YgdGhlIGRldmljZSwgc2V0IHRvIDEgaWYgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcGl4ZWxSYXRpb1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzMmRSZW5kZXJpbmdHcm91cFxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IChmdW5jdGlvbihjdHgpIHtcbiAgICAgIGNvbnN0IGRQUiA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICBjb25zdCBiUFIgPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICByZXR1cm4gcHJlc2VydmVQaXhlbFJhdGlvID8gKGRQUiAvIGJQUikgOiAxO1xuICAgIH0odGhpcy5jdHgpKTtcblxuICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgdGhpcy5mcmFtZU1vZHVsbyA9IHNraXBGcmFtZXMgKyAxO1xuICAgIHRoaXMuYWNjdW1EdCA9IDA7XG5cbiAgICAvLyByZWdpc3RlciB0aGUgZ3JvdXAgaW50byB0aGUgbG9vcFxuICAgIGxvb3AucmVnaXN0ZXJSZW5kZXJpbmdHcm91cCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoZSBjYW52YXMuIFByb3BhZ2F0ZSBuZXcgbG9naWNhbCBgd2lkdGhgIGFuZCBgaGVpZ2h0YFxuICAgKiBhY2NvcmRpbmcgdG8gYHRoaXMucGl4ZWxSYXRpb2AgdG8gYWxsIHJlZ2lzdGVyZWQgcmVuZGVyZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRXaWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0SGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9yaWVudGF0aW9uIC0gT3JpZW50YXRpb24gb2YgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgb25SZXNpemUodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIG9yaWVudGF0aW9uKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcblxuICAgIHRoaXMuY2FudmFzV2lkdGggPSB2aWV3cG9ydFdpZHRoICogcGl4ZWxSYXRpbztcbiAgICB0aGlzLmNhbnZhc0hlaWdodCA9IHZpZXdwb3J0SGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5cbiAgICBjdHguY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXNXaWR0aDtcbiAgICBjdHguY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgIGN0eC5jYW52YXMuc3R5bGUud2lkdGggPSBgJHt2aWV3cG9ydFdpZHRofXB4YDtcbiAgICBjdHguY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke3ZpZXdwb3J0SGVpZ2h0fXB4YDtcblxuICAgIC8vIHByb3BhZ2F0ZSBsb2dpY2FsIHNpemUgdG8gcmVuZGVyZXJzXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnJlbmRlcmVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLnJlbmRlcmVyc1tpXS5vblJlc2l6ZSh0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCwgb3JpZW50YXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZSBgdXBkYXRlYCB0byBhbGwgcmVnaXN0ZXJlZCByZW5kZXJlcnMuIFRoZSBgdXBkYXRlYCBtZXRob2RcbiAgICogZm9yIGVhY2ggcmVuZGVyZXIgaXMgY2FsbGVkIGFjY29yZGluZyB0byB0aGVpciB1cGRhdGUgcGVyaW9kLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIEN1cnJlbnQgdGltZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR0IC0gRGVsdGEgdGltZSBpbiBzZWNvbmRzIHNpbmNlIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlKHRpbWUsIGR0KSB7XG4gICAgY29uc3QgcmVuZGVyZXJzID0gdGhpcy5yZW5kZXJlcnM7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlbmRlcmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcmVuZGVyZXJzW2ldO1xuICAgICAgY29uc3QgdXBkYXRlUGVyaW9kID0gcmVuZGVyZXIudXBkYXRlUGVyaW9kO1xuXG4gICAgICBpZiAodXBkYXRlUGVyaW9kID09PSAwKSB7XG4gICAgICAgIHJlbmRlcmVyLnVwZGF0ZShkdCk7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChyZW5kZXJlci5jdXJyZW50VGltZSA8IHRpbWUpIHtcbiAgICAgICAgICByZW5kZXJlci51cGRhdGUodXBkYXRlUGVyaW9kKTtcbiAgICAgICAgICByZW5kZXJlci5jdXJyZW50VGltZSArPSB1cGRhdGVQZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvcGFnYXRlIGByZW5kZXJgIHRvIGFsbCB0aGUgcmVnaXN0ZXJlZCByZW5kZXJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdCAtIERlbHRhIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSB0aGUgbGFzdFxuICAgKiAgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbC5cbiAgICovXG4gIHJlbmRlcihkdCkge1xuICAgIGxldCBhY2N1bUR0ID0gdGhpcy5hY2N1bUR0ICsgZHQ7XG5cbiAgICBpZiAodGhpcy5mcmFtZUNvdW50ID09PSAwKSB7XG4gICAgICBjb25zdCB7IGN0eCwgcmVuZGVyZXJzIH0gPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5wcmVSZW5kZXIgIT09IG51bGwpXG4gICAgICAgIHRoaXMucHJlUmVuZGVyKGN0eCwgYWNjdW1EdCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlbmRlcmVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIHJlbmRlcmVyc1tpXS5yZW5kZXIoY3R4KTtcblxuICAgICAgaWYgKHRoaXMucG9zdFJlbmRlciAhPT0gbnVsbClcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyKGN0eCwgYWNjdW1EdCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xuXG4gICAgICBhY2N1bUR0ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lQ291bnQgPSAodGhpcy5mcmFtZUNvdW50ICsgMSkgJSB0aGlzLmZyYW1lTW9kdWxvO1xuICAgIHRoaXMuYWNjdW1EdCA9IGFjY3VtRHQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgYFJlbmRlcmVyYCBpbnN0YW5jZSB0byB0aGUgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlJlbmRlcmVyfSByZW5kZXJlciAtIFJlbmRlcmVyIHRvIGFkZCB0b1xuICAgKiAgdGhlIGdyb3VwLlxuICAgKi9cbiAgYWRkKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlcnMucHVzaChyZW5kZXJlcik7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IGxvb3AuZ2V0VGltZSgpO1xuICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSByZW5kZXJlclxuICAgIHJlbmRlcmVyLmN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICByZW5kZXJlci5waXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIHJlbmRlcmVyLm9uUmVzaXplKHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0LCB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICByZW5kZXJlci5pbml0KCk7XG4gICAgLy8gaWYgZmlyc3QgcmVuZGVyZXIgYWRkZWQsIHN0YXJ0IHRoZSBsb29wXG4gICAgaWYgKHRoaXMucmVuZGVyZXJzLmxlbmd0aCA9PT0gMSlcbiAgICAgIGxvb3AucmVxdWlyZVN0YXJ0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgYFJlbmRlcmVyYCBpbnN0YW5jZSBmcm9tIHRoZSBncm91cC5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gUmVuZGVyZXIgdG8gcmVtb3ZlXG4gICAqICBmcm9tIHRoZSBncm91cC5cbiAgICovXG4gIHJlbW92ZShyZW5kZXJlcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZW5kZXJlcnMuaW5kZXhPZihyZW5kZXJlcik7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnJlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgLy8gaWYgbGFzdCByZW5kZXJlciByZW1vdmVkLCBzdG9wIHRoZSBsb29wXG4gICAgICBpZiAodGhpcy5yZW5kZXJlcnMubGVuZ3RoID09PSAwKVxuICAgICAgICBsb29wLnJlcXVpcmVTdG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhczJkUmVuZGVyaW5nR3JvdXA7XG4iLCJpbXBvcnQgU2VnbWVudGVkVmlldyBmcm9tICcuL1NlZ21lbnRlZFZpZXcnO1xuaW1wb3J0IENhbnZhc1JlbmRlcmluZ0dyb3VwIGZyb20gJy4vQ2FudmFzUmVuZGVyaW5nR3JvdXAnO1xuXG5cbmNvbnN0IGRlZmF1bHRDYW52YXNUZW1wbGF0ZSA9IGBcbiAgPGNhbnZhcyBjbGFzcz1cImJhY2tncm91bmRcIj48L2NhbnZhcz5cbiAgPGRpdiBjbGFzcz1cImZvcmVncm91bmRcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi10b3AgZmxleC1taWRkbGVcIj48JT0gdG9wICU+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tY2VudGVyIGZsZXgtY2VudGVyXCI+PCU9IGNlbnRlciAlPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWJvdHRvbSBmbGV4LW1pZGRsZVwiPjwlPSBib3R0b20gJT48L2Rpdj5cbiAgPC9kaXY+XG5gO1xuXG4vKipcbiAqIFZpZXcgZGVzaWduZWQgZm9yIGV4cGVyaWVuY2VzIHdoZXJlIDJkIGdyYXBoaWNhbCByZW5kZXJpbmcgaXMgbmVlZGVkLlxuICogVGhlIHZpZXcgaXMgYmFzaWNhbGx5IGEgYFNlZ21lbnRlZFZpZXdgIHdpdGggYSBgY2FudmFzYCBlbGVtZW50IGluXG4gKiB0aGUgYmFja2dyb3VuZCBhbmQgYSBzZXQgb2YgaGVscGVycyB0byBoYW5kbGUgdGhlIF9fcmVuZGVyZXJzX18gKG9iamVjdHNcbiAqIHRoYXQgZHJhdyBzb21ldGhpbmcgaW50byB0aGUgY2FudmFzKS5cbiAqXG4gKiBfPHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+X19XQVJOSU5HX188L3NwYW4+IFZpZXdzIHNob3VsZCBwcmVmZXJhYmx5IGJ5XG4gKiBjcmVhdGVkIHVzaW5nIHRoZSBbYEV4cGVyaWVuY2UjY3JlYXRlVmlld2Bde0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5FeHBlcmllbmNlI2NyZWF0ZVZpZXd9XG4gKiBtZXRob2QuX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZSAtIFRlbXBsYXRlIG9mIHRoZSB2aWV3LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnQgLSBPYmplY3QgY29udGFpbmluZyB0aGUgdmFyaWFibGVzIHVzZWQgdG8gcG9wdWxhdGVcbiAqICB0aGUgdGVtcGxhdGUuIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNjb250ZW50fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudHMgLSBMaXN0ZW5lcnMgdG8gaW5zdGFsbCBpbiB0aGUgdmlld1xuICogIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNldmVudHN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIG9mIHRoZSB2aWV3LlxuICogIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNvcHRpb25zfS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlNlZ21lbnRlZFZpZXd9XG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXd9XG4gKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUmVuZGVyZXJ9XG4gKi9cbmNsYXNzIENhbnZhc1ZpZXcgZXh0ZW5kcyBTZWdtZW50ZWRWaWV3IHtcbiAgY29uc3RydWN0b3IodGVtcGxhdGUsIGNvbnRlbnQsIGV2ZW50cywgb3B0aW9ucykge1xuICAgIHRlbXBsYXRlID0gdGVtcGxhdGUgfHwgZGVmYXVsdENhbnZhc1RlbXBsYXRlO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHByZXNlcnZlUGl4ZWxSYXRpbzogZmFsc2UsXG4gICAgICBza2lwRnJhbWVzOiAwLFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgc3VwZXIodGVtcGxhdGUsIGNvbnRlbnQsIGV2ZW50cywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wb3Jhcnkgc3RhY2sgdGhlIHJlbmRlcmVycyB3aGVuIHRoZSB2aWV3IGlzIG5vdCB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHR5cGUge1NldH1cbiAgICAgKiBAbmFtZSBfcmVuZGVyZXJTdGFja1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyZXJTdGFjayA9IG5ldyBTZXQoKTtcblxuICAgIC8qKlxuICAgICAqIEZsYWcgdG8gdHJhY2sgdGhlIGZpcnN0IGBvblJlbmRlcmAgY2FsbC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBuYW1lIF9oYXNSZW5kZXJlZE9uY2VcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkNhbnZhc1ZpZXdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hhc1JlbmRlcmVkT25jZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZW5kZXJpbmcgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkNhbnZhc1JlbmRlcmluZ0dyb3VwfVxuICAgICAqIEBuYW1lIF9yZW5kZXJpbmdHcm91cFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyaW5nR3JvdXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIERPTSBlbGVtZW50IHRvIGRyYXcgaW50by5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBuYW1lICRjYW52YXNcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LiRjYW52YXNcbiAgICAgKi9cbiAgICB0aGlzLiRjYW52YXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogMmQgY29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKiBAbmFtZSAkY2FudmFzXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC4kY2FudmFzXG4gICAgICovXG4gICAgdGhpcy5jdHggPSBudWxsO1xuICB9XG5cbiAgZ2V0IHBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmluZ0dyb3VwLnBpeGVsUmF0aW87XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgb25SZW5kZXIoKSB7XG4gICAgc3VwZXIub25SZW5kZXIoKTtcblxuICAgIHRoaXMuJGNhbnZhcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy4kY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHJlbmRlcmluZyBncm91cCBpZiB0aGUgY2FudmFzIGluc3RhbmNlIGhhcyBjaGFuZ2VkIGFmdGVyIGEgcmVuZGVyXG4gICAgaWYgKHRoaXMuX3JlbmRlcmluZ0dyb3VwKVxuICAgICAgdGhpcy5fcmVuZGVyaW5nR3JvdXAuY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBpZiAoIXRoaXMuX2hhc1JlbmRlcmVkT25jZSkge1xuICAgICAgY29uc3QgcHJlc2VydmVQaXhlbFJhdGlvID0gdGhpcy5vcHRpb25zLnByZXNlcnZlUGl4ZWxSYXRpbztcbiAgICAgIGNvbnN0IHNraXBGcmFtZXMgPSB0aGlzLm9wdGlvbnMuc2tpcEZyYW1lcztcbiAgICAgIHRoaXMuX3JlbmRlcmluZ0dyb3VwID0gbmV3IENhbnZhc1JlbmRlcmluZ0dyb3VwKHRoaXMuY3R4LCBwcmVzZXJ2ZVBpeGVsUmF0aW8sIHNraXBGcmFtZXMpO1xuXG4gICAgICAvLyBwcmV2ZW50IGNyZWF0aW5nIGEgbmV3IHJlbmRlcmluZyBncm91cCBlYWNoIHRpbWUgdGhlIHZpZXcgaXMgcmUtcmVuZGVyZWRcbiAgICAgIHRoaXMuX2hhc1JlbmRlcmVkT25jZSA9IHRydWU7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW50cnkgcG9pbnQgY2FsbGVkIHdoZW4gdGhlIHJlbmRlcmluZ0dyb3VwIGZvciB0aGUgdmlldyBpcyByZWFkeS5cbiAgICogQmFzaWNhbGx5IGFsbG93cyB0byBpbnN0YW5jaWF0ZSBzb21lIHJlbmRlcmVycyBmcm9tIGluc2lkZSB0aGUgdmlldy5cbiAgICovXG4gIGluaXQoKSB7fVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBvblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pIHtcbiAgICBzdXBlci5vblJlc2l6ZSh2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgb3JpZW50YXRpb24pO1xuICAgIHRoaXMuX3JlbmRlcmluZ0dyb3VwLm9uUmVzaXplKHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0LCBvcmllbnRhdGlvbik7XG5cbiAgICAvLyBhZGQgc3RhY2tlZCByZW5kZXJlcnMgdG8gdGhlIHJlbmRlcmluZyBncm91cFxuICAgIHRoaXMuX3JlbmRlcmVyU3RhY2suZm9yRWFjaCgocmVuZGVyZXIpID0+IHRoaXMuX3JlbmRlcmluZ0dyb3VwLmFkZChyZW5kZXJlcikpO1xuICAgIHRoaXMuX3JlbmRlcmVyU3RhY2suY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBleGVjdXRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICogY3ljbGUsIGJlZm9yZSB0aGUgZXhlY3V0aW9uIG9mIHRoZSByZW5kZXJlcnMuXG4gICAqIEBjYWxsYmFjayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld35wcmVSZW5kZXJlclxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHQgLSBEZWx0YSB0aW1lIGluIHNlY29uZHMgc2luY2UgbGFzdCByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjYW52YXNXaWR0aCAtIEN1cnJlbnQgd2lkdGggb2YgdGhlIGNhbnZhcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNhbnZhc0hlaWdodCAtIEN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gICAqL1xuICAvKipcbiAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBleGVjdXRlIGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaFxuICAgKiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjeWNsZS5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld35wcmVSZW5kZXJlcn0gY2FsbGJhY2sgLVxuICAgKiAgRnVuY3Rpb24gdG8gZXhlY3V0ZSBiZWZvcmUgZWFjaCByZW5kZXJpbmcgY3ljbGUuXG4gICAqL1xuICBzZXRQcmVSZW5kZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9yZW5kZXJpbmdHcm91cC5wcmVSZW5kZXIgPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBleGVjdXRlZCBhdCB0aGUgZW5kIG9mIGVhY2ggYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICogY3ljbGUsIGFmdGVyIHRoZSBleGVjdXRpb24gb2YgdGhlIHJlbmRlcmVycy5cbiAgICogQGNhbGxiYWNrIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5DYW52YXNWaWV3fnBvc3RSZW5kZXJlclxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHQgLSBEZWx0YSB0aW1lIGluIHNlY29uZHMgc2luY2UgbGFzdCByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjYW52YXNXaWR0aCAtIEN1cnJlbnQgd2lkdGggb2YgdGhlIGNhbnZhcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNhbnZhc0hlaWdodCAtIEN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gICAqL1xuICAvKipcbiAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBleGVjdXRlIGF0IHRoZSBlbmQgb2YgZWFjaFxuICAgKiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjeWNsZS5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuQ2FudmFzVmlld35wb3N0UmVuZGVyZXJ9IGNhbGxiYWNrIC1cbiAgICogIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgYmVmb3JlIGVhY2ggcmVuZGVyaW5nIGN5Y2xlLlxuICAgKi9cbiAgc2V0UG9zdFJlbmRlcihjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlbmRlcmluZ0dyb3VwLnBvc3RSZW5kZXIgPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSByZW5kZXJlciB0byB0aGUgYFJlbmRlcmluZ0dyb3VwYC4gVGhlIHJlbmRlcmVyIGlzIGF1dG9tYXRpY2FsbHlcbiAgICogYWN0aXZhdGVkIHdoZW4gYWRkZWQgdG8gdGhlIGdyb3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5SZW5kZXJlcn0gcmVuZGVyZXIgLSBSZW5kZXJlciB0byBhZGQuXG4gICAqL1xuICBhZGRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLmlzVmlzaWJsZSlcbiAgICAgIHRoaXMuX3JlbmRlcmluZ0dyb3VwLmFkZChyZW5kZXJlcik7XG4gICAgZWxzZVxuICAgICAgdGhpcy5fcmVuZGVyZXJTdGFjay5hZGQocmVuZGVyZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlbmRlcmVyIGZyb20gdGhlIGBSZW5kZXJpbmdHcm91cGAuIFRoZSByZW5kZXJlciBpcyBhdXRvbWF0aWNhbGx5XG4gICAqIGRpc2FjdGl2YXRlZCB3aGVuIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlJlbmRlcmVyfSByZW5kZXJlciAtIFJlbmRlcmVyIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuaXNWaXNpYmxlKVxuICAgICAgdGhpcy5fcmVuZGVyaW5nR3JvdXAucmVtb3ZlKHJlbmRlcmVyKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9yZW5kZXJlclN0YWNrLmRlbGV0ZShyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVmlldztcbiIsImltcG9ydCBWaWV3IGZyb20gJy4vVmlldyc7XG5cbmNvbnN0IGRlZmF1bHRUZW1wbGF0ZSA9IGBcbiAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdG9wIGZsZXgtbWlkZGxlXCI+PHA+PCU9IHRvcCAlPjwvcD48L2Rpdj5cbiAgPGRpdiBjbGFzcz1cInNlY3Rpb24tY2VudGVyIGZsZXgtY2VudGVyXCI+PHA+PCU9IGNlbnRlciAlPjwvcD48L2Rpdj5cbiAgPGRpdiBjbGFzcz1cInNlY3Rpb24tYm90dG9tIGZsZXgtbWlkZGxlXCI+PHA+PCU9IGJvdHRvbSAlPjwvcD48L2Rpdj5cbmA7XG5cbi8qKlxuICogQ3JlYXRlIHZpZXdzIHdoaWNoIGtlZXAgZGVmaW5lZCB2ZXJ0aWNhbCByYXRpb3MgYW1vbmcgZWxlbWVudHMuIFRoZXNlIHJhdGlvc1xuICogYXJlIGtlcHQgYmV0d2VlbiB0aGUgZGlmZmVyZW50IHBhcnRzIGluIHBvcnRyYWl0IGFuZCBsYW5kc2NhcGUgb3JpZW50YXRpb24uXG4gKiBUaGUgZGVmYXVsdCBTZWdtZW50ZWQgdmlldyBkZWZpbmVzIGEgbGF5b3V0IHdpdGggMyB2ZXJ0aWNhbHMgcGFydHMuXG4gKlxuICogT3RoZXJzIHJhdGlvcyBjYW4gYmUgZGVmaW5lZCBieSBjcmVhdGluZyBhIG5ldyB0ZW1wbGF0ZSBhbmQgZGVmaW5pbmcgdGhlXG4gKiByYXRpb3Mgb2YgdGhlIGRpZmZlcmVudCBlbGVtZW50cyBieSBvdmVycmlkaW5nIHRoZSBgcmF0aW9gIG9wdGlvbi5cbiAqIFRoZSBzdW0gb2YgYWxsIHRoZSByYXRpb3Mgc2hvdWxkIGJlIGVxdWFsIHRvIDEuXG4gKlxuICogXzxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPiBWaWV3cyBzaG91bGQgYmUgY3JlYXRlZCB1c2luZ1xuICoge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BY3Rpdml0eSNjcmVhdGVWaWV3fSBtZXRob2QuX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZSAtIFRlbXBsYXRlIG9mIHRoZSB2aWV3LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnQgLSBPYmplY3QgY29udGFpbmluZyB0aGUgdmFyaWFibGVzIHVzZWQgdG8gcG9wdWxhdGVcbiAqICB0aGUgdGVtcGxhdGUuIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNjb250ZW50fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudHMgLSBFdmVudCBsaXN0ZW5lcnMgdG8gaW5zdGFsbCB0byB0aGUgdmlld1xuICogIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNldmVudHN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIG9mIHRoZSB2aWV3LlxuICogIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNvcHRpb25zfS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXd9XG4gKi9cbmNsYXNzIFNlZ21lbnRlZFZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgY29uc3RydWN0b3IodGVtcGxhdGUsIGNvbnRlbnQgPSB7fSwgZXZlbnRzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGZhbGxiYWNrIG9uIGRlZmF1bHQgdGVtcGxhdGUgaWYgYHRlbXBsYXRlID0gbnVsbGBcbiAgICB0ZW1wbGF0ZSA9ICF0ZW1wbGF0ZSA/IGRlZmF1bHRUZW1wbGF0ZSA6IHRlbXBsYXRlO1xuICAgIHN1cGVyKHRlbXBsYXRlLCBjb250ZW50LCBldmVudHMsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGFzc29jaWF0aW5nIHNlbGVjdG9ycyBhcyBkZWZpbmVkIGluIHRoZSBnaXZlbiB0ZW1wbGF0ZSBhc3NvY2lhdGVkXG4gICAgICogd2l0aCB0aGVpciB2ZXJ0aWNhbCByYXRpbywgdGhlIHJhdGlvIGlzIGFwcGx5ZWQgaW4gYm90aCAncG9ydHJhaXQnIGFuZFxuICAgICAqICdsYW5kc2NhcGUnIG9yaWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmc6TnVtYmVyPn1cbiAgICAgKiBAbmFtZSByYXRpb3NcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlNlZ21lbnRlZFZpZXdcbiAgICAgKi9cbiAgICB0aGlzLnJhdGlvcyA9IG9wdGlvbnMucmF0aW9zIHx8wqB7XG4gICAgICAnLnNlY3Rpb24tdG9wJzogMC4zLFxuICAgICAgJy5zZWN0aW9uLWNlbnRlcic6IDAuNSxcbiAgICAgICcuc2VjdGlvbi1ib3R0b20nOiAwLjIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHNlbGVjdG9ycyBkZWZpbmVkIGluIHRoZSB0ZW1wbGF0ZSBhc3NvY2lhdGVkXG4gICAgICogd2l0aCB0aGVpciB2ZXJ0aWNhbCByYXRpbywgdGhlIHJhdGlvIGlzIGFwcGx5ZWQgaW4gYm90aCAncG9ydHJhaXQnXG4gICAgICogYW5kICdsYW5kc2NhcGUnIG9yaWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmc6RWxlbWVudD59XG4gICAgICogQG5hbWUgcmF0aW9zXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5TZWdtZW50ZWRWaWV3XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl8kc2VjdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBvblJlbmRlcigpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnJhdGlvcykuZm9yRWFjaCgoc2VsKSA9PiB7XG4gICAgICBjb25zdCAkZWwgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKHNlbCk7XG5cbiAgICAgIGlmICgkZWwgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93IHNlbGVjdG9yIFwiJHtzZWx9XCJgKTtcblxuICAgICAgdGhpcy5fJHNlY3Rpb25zW3NlbF0gPSAkZWw7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgb25SZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZW50YXRpb24pIHtcbiAgICBzdXBlci5vblJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmllbnRhdGlvbik7XG5cbiAgICBmb3IgKGxldCBzZWwgaW4gdGhpcy5yYXRpb3MpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gdGhpcy5yYXRpb3Nbc2VsXTtcbiAgICAgIGNvbnN0ICRlbCA9IHRoaXMuXyRzZWN0aW9uc1tzZWxdO1xuXG4gICAgICAkZWwuc3R5bGUubWluSGVpZ2h0ID0gYCR7cmF0aW8gKiBoZWlnaHR9cHhgO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWdtZW50ZWRWaWV3O1xuIiwiLyoqXG4gKiBIZWxwZXIgdG8gaGFuZGxlIGB0b3VjaGAgZXZlbnRzIG9uIGEgZ2l2ZW4gZWxlbWVudC4gRGVjb21wb3NlIGEgbXVsdGl0b3VjaFxuICogZXZlbnQgaW4gc2V2ZXJhbCBwYXJhbGxlbCBldmVudHMsIHByb3BhZ2F0ZSBub3JtYWxpemVkIHZhbHVlcyBhY2NvcmRpbmcgdG9cbiAqIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSAkZWwgLSBFbGVtZW50IHRvIGxpc3RlbiBmb3IgYHRvdWNoYCBldmVudHMuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudFxuICovXG5jbGFzcyBUb3VjaFN1cmZhY2Uge1xuICBjb25zdHJ1Y3RvcigkZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgdG8gbGlzdGVuLlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG5hbWUgJGVsXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mICBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVG91Y2hTdXJmYWNlXG4gICAgICovXG4gICAgdGhpcy4kZWwgPSAkZWw7XG5cbiAgICAvKipcbiAgICAgKiBUb3VjaCBpZCwgbm9ybWFsaXplZCBwb3NpdGlvbiBwYWlycyBmb3IgZWFjaCBjdXJyZW50IHRvdWNoZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyOjxBcnJheTxOdW1iZXI+Pn1cbiAgICAgKiBAbmFtZSB0b3VjaGVzXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mICBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVG91Y2hTdXJmYWNlXG4gICAgICovXG4gICAgdGhpcy50b3VjaGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGluZyByZWN0IG9mIGB0aGlzLiRlbGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBuYW1lIF9lbEJvdW5kaW5nUmVjdFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiAgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlRvdWNoU3VyZmFjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZWxCb3VuZGluZ1JlY3QgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBuYW1lIF9saXN0ZW5lcnNcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5Ub3VjaFN1cmZhY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgdGhpcy5fbm9ybWFsaXplQ29vcmRpbmF0ZXMgPSAob3B0aW9ucy5ub3JtYWxpemVDb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMubm9ybWFsaXplQ29vcmRpbmF0ZXMgOiB0cnVlO1xuXG4gICAgLy8gY2FjaGUgYm91bmRpbmcgcmVjdCB2YWx1ZXMgYW5kIGxpc3RlbiBmb3Igd2luZG93IHJlc2l6ZVxuICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nUmVjdCA9IHRoaXMuX3VwZGF0ZUJvdW5kaW5nUmVjdC5iaW5kKHRoaXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl91cGRhdGVCb3VuZGluZ1JlY3QpO1xuICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nUmVjdCgpO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5faGFuZGxlVG91Y2hTdGFydCA9IHRoaXMuX2hhbmRsZVRvdWNoKChpZCwgeCwgeSwgdCwgZSkgPT4ge1xuICAgICAgdGhpcy50b3VjaGVzW2lkXSA9IFt4LCB5XTtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZSgndG91Y2hzdGFydCcsIGlkLCB4LCB5LCB0LCBlKTtcbiAgICB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSA9IHRoaXMuX2hhbmRsZVRvdWNoKChpZCwgeCwgeSwgdCwgZSkgPT4ge1xuICAgICAgdGhpcy50b3VjaGVzW2lkXSA9IFt4LCB5XTtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZSgndG91Y2htb3ZlJywgaWQsIHgsIHksIHQsIGUpO1xuICAgIH0pO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5faGFuZGxlVG91Y2hFbmQgPSB0aGlzLl9oYW5kbGVUb3VjaCgoaWQsIHgsIHksIHQsIGUpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRvdWNoZXNbaWRdO1xuICAgICAgdGhpcy5fcHJvcGFnYXRlKCd0b3VjaGVuZCcsIGlkLCB4LCB5LCB0LCBlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaE1vdmUpO1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xuXG4gICAgLy8gZmFsbGJhY2sgZm9yIG1vdXNlIGludGVyYWN0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGBUb3VjaFN1cmZhY2VgLCByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBmcm9tIGB0aGlzLiRlbGBcbiAgICogYW5kIGRlbGV0ZSBhbGwgcG9pbnRlcnMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl91cGRhdGVCb3VuZGluZ1JlY3QpO1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaE1vdmUpO1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xuICAgIC8vIGRlbGV0ZSBwb2ludGVyc1xuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGJvdW5kaW5nIHJlY3Qgb2YgYHRoaXMuJGVsYFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUJvdW5kaW5nUmVjdCgpIHtcbiAgICB0aGlzLl9lbEJvdW5kaW5nUmVjdCA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgLy8gdGhpcyBoYXMgYmVlbiBpbnRyb2R1Y2VkIGluIDZjODIzNGJiODNkMmRmM2U1NmYxYjIxYTBjYWVhNGU0ZWY2NTdlYjQgYW5kXG4gICAgLy8gYnJlYWtzIGEgbG90IG9mIHRoaW5ncy4uLiByZXNwZWNpZnkgdGhlIGJlaGF2aW9yIHdoZW5cbiAgICAvLyBub3JtYWxpemVDb29yZGluYXRlcyA9PT0gZmFsc2UsIGJlY2F1c2UgaXMgbm90IHJlbGF0ZWQgdG8gdGhlIGdpdmVuXG4gICAgLy8gZWxlbWVudCAodGhpcy4kZWwpIGFzIGltcGxlbWVudGVkLlxuICAgIC8vICh0aGUgb25seSBhcHAgdGhhdCBkZXBlbmRzIG9uIHRoaXMgb3B0aW9uIGlzIHByb2JhYmx5IGNvbG9vcCwgc28gY2hlY2sgaXQpXG4gICAgLy8gdGhpcy5fZWxCb3VuZGluZ1JlY3QgPSB7XG4gICAgLy8gICB0b3A6IDAsXG4gICAgLy8gICBib3R0b206IDAsXG4gICAgLy8gICBsZWZ0OiAwLFxuICAgIC8vICAgcmlnaHQ6IDAsXG4gICAgLy8gICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgLy8gICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAvLyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgbW9ldGhvZCB0byBoYW5kbGUgYSB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVUb3VjaChjYWxsYmFjaykge1xuICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gaWYgYF91cGRhdGVCb3VuZGluZ1JlY3RgIGhhcyBub3QgYmVlbiBiZWVuIGNhbGxlZCBvclxuICAgICAgLy8gaGFzIGJlZW4gY2FsbGVkIHdoZW4gJGVsIHdhcyBpbiBgZGlzcGxheTpub25lYCBzdGF0ZVxuICAgICAgaWYgKCF0aGlzLl9lbEJvdW5kaW5nUmVjdCB8fMKgXG4gICAgICAgICAgKHRoaXMuX2VsQm91bmRpbmdSZWN0LndpZHRoID09PSAwICYmIHRoaXMuX2VsQm91bmRpbmdSZWN0LmhlaWdodCA9PT0gMCkpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRpbmdSZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gdGhpcy5fZWxCb3VuZGluZ1JlY3Q7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b3VjaEV2ZW50ID0gdG91Y2hlc1tpXTtcbiAgICAgICAgY29uc3QgdG91Y2hJZCA9IHRvdWNoRXZlbnQuaWRlbnRpZmllcjtcblxuICAgICAgICBpZiAodGhpcy5fbm9ybWFsaXplQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICBjb25zdCByZWxYID0gdG91Y2hFdmVudC5jbGllbnRYIC0gYm91bmRpbmdSZWN0LmxlZnQ7XG4gICAgICAgICAgY29uc3QgcmVsWSA9IHRvdWNoRXZlbnQuY2xpZW50WSAtIGJvdW5kaW5nUmVjdC50b3A7XG4gICAgICAgICAgY29uc3Qgbm9ybVggPSByZWxYIC8gYm91bmRpbmdSZWN0LndpZHRoO1xuICAgICAgICAgIGNvbnN0IG5vcm1ZID0gcmVsWSAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgY2FsbGJhY2sodG91Y2hJZCwgbm9ybVgsIG5vcm1ZLCB0b3VjaEV2ZW50LCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayh0b3VjaElkLCB0b3VjaEV2ZW50LmNsaWVudFggLCB0b3VjaEV2ZW50LmNsaWVudFksIHRvdWNoRXZlbnQsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGUgdGhlIHRvdWNoIGV2ZW50IGFuZCBub3JtYWxpemVkIHZhbHVlcyB0byB0aGUgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIC0gVHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdWNoSWQgLSBJZCBvZiB0aGUgdG91Y2ggZXZlbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0geC1wb3NpdGlvbiAobWF5YmUgbm9ybWFsaXplZCB0byB0aGUgZWxlbWVudHMgd2lkdGggZGVwZW5kaW5nIG9uIG5vcm1hbGl6ZUNvb3JkaW5hdGVzIG9wdGlvbilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSB5LXBvc2l0aW9uIChtYXliZSBub3JtYWxpemVkIHRvIHRoZSBlbGVtZW50cyBoZWlnaHQgZGVwZW5kaW5nIG9uIG5vcm1hbGl6ZUNvb3JkaW5hdGVzIG9wdGlvbilcbiAgICogIGFjY29yZGluZyB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG91Y2hFdmVudCAtIE9yaWdpbmFsIHRvdWNoIGV2ZW50IChgZS5jaGFuZ2VkVG91Y2hlc1tuXWApLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIE9yaWdpbmFsIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb3BhZ2F0ZShldmVudE5hbWUsIHRvdWNoSWQsIHgsIHksIHRvdWNoRXZlbnQsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgIGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKHRvdWNoSWQsIHgsIHksIHRvdWNoRXZlbnQsIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciB0b3VjaCBldmVudHNcbiAgICpcbiAgICogQGNhbGxiYWNrIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5Ub3VjaFN1cmZhY2V+RXZlbnRMaXN0ZW5lclxuICAgKiBAcGFyYW0ge051bWJlcn0gdG91Y2hJZCAtIElkIG9mIHRoZSB0b3VjaC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSB4LXBvc2l0aW9uIChtYXliZSBub3JtYWxpemVkIHRvIHRoZSBlbGVtZW50cyB3aWR0aCBkZXBlbmRpbmcgb24gbm9ybWFsaXplQ29vcmRpbmF0ZXMgb3B0aW9uKVxuICAgKiBAcGFyYW0ge051bWJlcn0geSAtIHktcG9zaXRpb24gKG1heWJlIG5vcm1hbGl6ZWQgdG8gdGhlIGVsZW1lbnRzIGhlaWdodCBkZXBlbmRpbmcgb24gbm9ybWFsaXplQ29vcmRpbmF0ZXMgb3B0aW9uKVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaEV2ZW50IC0gVGhlIG9yaWdpbmFsIFRvdWNoIGV2ZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgKi9cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lci4gX19ub3RlOiBgdG91Y2hjYW5jZWxgIGlzIG1lcmdlIHdpdGggYHRvdWNoZW5kYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiAoYHRvdWNoc3RhcnRgLFxuICAgKiAgYHRvdWNoZW5kYCBvciBgdG91Y2htb3ZlYClcbiAgICogQHBhcmFtIHttb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVG91Y2hTdXJmYWNlfkV2ZW50TGlzdGVuZXJ9IGNhbGxiYWNrXG4gICAqL1xuICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXSlcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG5cbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBsaXN0ZW5lci4gX19ub3RlOiBgdG91Y2hjYW5jZWxgIGlzIG1lcmdlIHdpdGggYHRvdWNoZW5kYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiAoYHRvdWNoc3RhcnRgLFxuICAgKiAgYHRvdWNoZW5kYCBvciBgdG91Y2htb3ZlYClcbiAgICogQHBhcmFtIHttb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVG91Y2hTdXJmYWNlfkV2ZW50TGlzdGVuZXJ9IGNhbGxiYWNrXG4gICAqL1xuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb3VjaFN1cmZhY2U7XG4iLCJpbXBvcnQgdG1wbCBmcm9tICdsb2Rhc2gudGVtcGxhdGUnO1xuaW1wb3J0IHZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnO1xuaW1wb3J0IERlbGVnYXRlIGZyb20gJ2RvbS1kZWxlZ2F0ZSc7XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcXVpcmVkIHRvIGNyZWF0ZSBhIHNvdW5kd29ya3MgY29tcGF0aWJsZSB2aWV3LlxuICpcbiAqIFRvIGNvbXBseSB3aXRoIHRoZSBzb3VuZHdvcmsncyBpbnRlcm5hbCB2aWV3IHN5c3RlbSAoY2YuIHZpZXdNYW5hZ2VyKSBhbnlcbiAqIHZpZXcgc2hvdWxkIGltcGxlbWVudCBhbiBpbnRlcmZhY2UgY29tcG9zZWQgb2YgMiBtZXRob2RzOiBgcmVuZGVyYCBhbmQgYHJlbW92ZWBcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKiBAaW50ZXJmYWNlIEFic3RyYWN0Vmlld1xuICogQGFic3RyYWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIG1pbmltYWwgaW1wbGVtZW50YXRpb24gb2YgYSBzb3VuZHdvcmtzIGNvbXBsaWFudCB2aWV3XG4gKiBjbGFzcyBNeVZpZXcge1xuICogICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gKiAgICAgdGhpcy5tc2cgPSBtc2c7XG4gKiAgICAgdGhpcy4kZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqICAgfVxuICpcbiAqICAgcmVuZGVyKCkge1xuICogICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGA8aDE+JHt0aGlzLm1zZ308L2gxPmA7XG4gKiAgICAgcmV0dXJuIHRoaXMuJGVsO1xuICogICB9XG4gKlxuICogICByZW1vdmUoKSB7XG4gKiAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gKiAgIH1cbiAqIH1cbiAqL1xuLyoqXG4gKiBNZXRob2QgY2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgaW5zZXJ0ZWQgaW50byB0aGUgRE9NIGJ5IHRoZSBzZXJ2aWNlIG1hbmFnZXIuXG4gKlxuICogQG5hbWUgc2hvd1xuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFZpZXdcbiAqIEBmdW5jdGlvblxuICogQGFic3RyYWN0XG4gKiBAaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fSAtIGltbXV0YWJsZSBET00gZWxlbWVudCBjb250YWluaW5nIHRoZSB2aWV3LlxuICovXG4vKipcbiAqIE1ldGhvZCBjYWxsZWQgd2hlbiB0aGUgdmlldyBoYXMgdG8gYmUgdXBkYXRlZC4gVGhlIHJldHVybmVkIERPTSBlbGVtZW50XG4gKiBzaG91bGQgY29udGFpbiB0aGUgd2hvbGUgdmlldyBjb250ZW50IGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWQgZHVyaW5nIHRoZVxuICogd2hvbGUgbGlmZWN5Y2xlIG9mIHRoZSB2aWV3LlxuICpcbiAqIEBuYW1lIHJlbmRlclxuICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BYnN0cmFjdFZpZXdcbiAqIEBmdW5jdGlvblxuICogQGFic3RyYWN0XG4gKiBAaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fSAtIGltbXV0YWJsZSBET00gZWxlbWVudCBjb250YWluaW5nIHRoZSB2aWV3LlxuICovXG4vKipcbiAqIE1ldGhvZCBjYWxsZWQgd2hlbiB0aGUgdmlldyBpcyByZW1vdmVkIGluIHRoZSBET00gYnkgdGhlIGB2aWV3TWFuYWdlcmAuXG4gKlxuICogQG5hbWUgcmVtb3ZlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LkFic3RyYWN0Vmlld1xuICogQGZ1bmN0aW9uXG4gKiBAYWJzdHJhY3RcbiAqIEBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igdmlld3MuXG4gKlxuICogXzxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9fV0FSTklOR19fPC9zcGFuPiBWaWV3cyBzaG91bGQgYmUgY3JlYXRlZCB1c2luZ1xuICoge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5BY3Rpdml0eSNjcmVhdGVWaWV3fSBtZXRob2QuX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZSAtIFRlbXBsYXRlIG9mIHRoZSB2aWV3LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnQgLSBPYmplY3QgY29udGFpbmluZyB0aGUgdmFyaWFibGVzIHVzZWQgdG8gcG9wdWxhdGVcbiAqICB0aGUgdGVtcGxhdGUuIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNjb250ZW50fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudHMgLSBMaXN0ZW5lcnMgdG8gaW5zdGFsbCBpbiB0aGUgdmlld1xuICogIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNldmVudHN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIG9mIHRoZSB2aWV3LlxuICogIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNvcHRpb25zfS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50XG4gKi9cbmNsYXNzIFZpZXcge1xuICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgbW9kZWwgPSB7fSwgZXZlbnRzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCwgdG8gYmUgZXhlY3V0ZWQgd2l0aCB0aGVcbiAgICAgKiBgY29udGVudGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBuYW1lIHRtcGxcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RtcGwgPSBudWxsO1xuXG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gICAgLyoqXG4gICAgICogRGF0YSB1c2VkIHRvIHBvcHVsYXRlIHZhcmlhYmxlcyBkZWZpbmVkIGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG5hbWUgY29udGVudFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlld1xuICAgICAqL1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDsgLy8gbW9kZWxcblxuICAgIC8qKlxuICAgICAqIEV2ZW50cyB0byBhdHRhY2ggdG8gdGhlIHZpZXcuIFRoZSBrZXkgLyB2YWx1ZSBwYWlycyBtdXN0IGZvbGxvdyB0aGVcbiAgICAgKiBjb252ZW50aW9uOiBgJ2V2ZW50TmFtZSBbY3NzU2VsZWN0b3JdJzogY2FsbGJhY2tGdW5jdGlvbmBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG5hbWUgZXZlbnRzXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3XG4gICAgICovXG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIG9mIHRoZSBWaWV3LlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2VsPSdkaXYnXSAtIFR5cGUgb2YgRE9NIGVsZW1lbnQgb2YgdGhlIG1haW4gY29udGFpbmVyXG4gICAgICogIG9mIHRoZSB2aWV3LiBCYXNpY2FsbHkgdGhlIGFyZ3VtZW50IG9mIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50YC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2lkPW51bGxdIC0gSWQgb2YgdGhlIG1haW4gY29udGFpbmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gW2NsYXNzTmFtZT1udWxsXSAtIENsYXNzZXMgb2YgdGhlIG1haW4gY29udGFpbmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gW3ByaW9yaXR5PTBdIC0gUHJpb3JpdHkgb2YgdGhlIHZpZXcuIFRoaXMgdmFsdWVcbiAgICAgKiAgaXMgdXNlZCBieSB0aGUgYHZpZXdNYW5hZ2VyYCB0byBkZWZpbmUgd2hpY2ggdmlldyBzaG91bGQgYXBwZWFyIGZpcnN0LlxuICAgICAqIEBuYW1lIG9wdGlvbnNcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXdcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC52aWV3IyRlbH1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQudmlld01hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBlbDogJ2RpdicsXG4gICAgICBpZDogbnVsbCxcbiAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFZpZXdwb3J0IHdpZHRoLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSB2aWV3V2lkdGhcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LlZpZXdcbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQudmlld3BvcnR9XG4gICAgICovXG4gICAgdGhpcy52aWV3cG9ydFdpZHRoID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFZpZXdwb3J0IGhlaWdodC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgdmlld1dpZHRoXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LnZpZXdwb3J0fVxuICAgICAqL1xuICAgIHRoaXMudmlld3BvcnRIZWlnaHQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogT3JpZW50YXRpb24gb2YgdGhlIHZpZXcgKCdwb3J0cmFpdCd8J2xhbmRzY2FwZScpXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBuYW1lIG9yaWVudGF0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LnZpZXdwb3J0fVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSB2aWV3IGlzIHZpc2libGUgb3Igbm90LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQG5hbWUgaXNWaXNpYmxlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3XG4gICAgICovXG4gICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERPTSBlbGVtZW50IG9mIHRoZSBtYWluIGNvbnRhaW5lciBvZiB0aGUgdmlldy4gRGVmYXVsdHMgdG8gYDxkaXY+YC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBuYW1lICRlbFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlld1xuICAgICAqL1xuICAgIHRoaXMuJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMuZWwpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBldmVudCBkZWxlZ2F0aW9uXG4gICAgdGhpcy5fZGVsZWdhdGUgPSBuZXcgRGVsZWdhdGUodGhpcy4kZWwpO1xuICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmluc3RhbGxFdmVudHModGhpcy5ldmVudHMsIGZhbHNlKTtcbiAgfVxuXG4gIHNldCB0ZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl90bXBsID0gdG1wbCh0ZW1wbGF0ZSk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSAobWFrZSBzdXJlIHlvdSBkbyBub3QgdXNlIGVzNiBzeW50YXggaW4gU2FmYXJpIG1vYmlsZSk6ICcgKyB0ZW1wbGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kVG8oJGNvbnRhaW5lcikge1xuICAgICRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSByZS1yZW5kZXIgdGhlIHZpZXcgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBzZWxlY3Rvci4gSWYgdGhlXG4gICAqIHNlbGVjdG9yIGlzIGFzc29jaWF0ZWQgdG8gYSBgY29tcG9uZW50YCwgdGhlIGBjb21wb25lbnRgIGlzIHJlbmRlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBDc3Mgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnQgdG8gcmVuZGVyLiBUaGVcbiAgICogIGVsZW1lbnQgaXRzZWxmIGlzIG5vdCB1cGRhdGVkLCBvbmx5IGl0cyBjb250ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclBhcnRpYWwoc2VsZWN0b3IpIHtcbiAgICBjb25zdCAkY29udGFpbmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICBpZiAoJGNvbnRhaW5lciA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2VsZWN0b3IgJHtzZWxlY3Rvcn0gZG9lc24ndCBtYXRjaCBhbnkgZWxlbWVudGApO1xuXG4gICAgY29uc3QgaHRtbCA9IHRoaXMuX3RtcGwodGhpcy5tb2RlbCk7XG4gICAgY29uc3QgJHRtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgJHRtcC5pbm5lckhUTUwgPSBodG1sO1xuICAgICRjb250YWluZXIuaW5uZXJIVE1MID0gJHRtcC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKS5pbm5lckhUTUw7XG4gICAgdGhpcy5vblJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgd2hvbGUgdmlldyBhbmQgaXRzIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQWxsKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgLy8gc2V0IGlkIG9mIHRoZSBjb250YWluZXIgaWQgZ2l2ZW5cbiAgICBpZiAob3B0aW9ucy5pZClcbiAgICAgIHRoaXMuJGVsLmlkID0gb3B0aW9ucy5pZDtcbiAgICAvLyBzZXQgY2xhc3NlcyBvZiB0aGUgY29udGFpbmVyIGlmIGdpdmVuXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZTtcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IFtjbGFzc05hbWVdIDogY2xhc3NOYW1lO1xuICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcbiAgICB9XG5cbiAgICAvLyByZW5kZXIgdGVtcGxhdGUgYW5kIGluc2VydCBpdCBpbiB0aGUgbWFpbiBlbGVtZW50XG4gICAgY29uc3QgaHRtbCA9IHRoaXMuX3RtcGwodGhpcy5tb2RlbCk7XG4gICAgdGhpcy4kZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB0aGlzLm9uUmVuZGVyKCk7XG4gIH1cblxuICAvLyBMSUZFIENZQ0xFIE1FVEhPRFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHZpZXcgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB0ZW1wbGF0ZSBhbmQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcj1udWxsXSAtIElmIG5vdCBgbnVsbGAsIHJlbmRlcnMgb25seSB0aGUgcGFydCBvZlxuICAgKiAgdGhlIHZpZXcgaW5zaWRlIHRoZSBtYXRjaGVkIGVsZW1lbnQuIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBhIGNvbXBvbmVudFxuICAgKiAgKHN1Yi12aWV3KSwgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZC4gUmVuZGVyIHRoZSB3aG9sZSB2aWV3IG90aGVyd2lzZS5cbiAgICovXG4gIHJlbmRlcihzZWxlY3RvciA9IG51bGwpIHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpXG4gICAgICB0aGlzLl9yZW5kZXJQYXJ0aWFsKHNlbGVjdG9yKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9yZW5kZXJBbGwoKTtcblxuICAgIGlmICh0aGlzLmlzVmlzaWJsZSlcbiAgICAgIHRoaXMub25SZXNpemUodmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCwgdmlld3BvcnQub3JpZW50YXRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIHZpZXcuIEV4ZWN1dGVkIGJ5IHRoZSBgdmlld01hbmFnZXJgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLiRlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgLy8gbXVzdCByZXNpemUgYmVmb3JlIGNoaWxkIGNvbXBvbmVudFxuICAgIHRoaXMuX2RlbGVnYXRlRXZlbnRzKCk7XG4gICAgdmlld3BvcnQuYWRkUmVzaXplTGlzdGVuZXIodGhpcy5vblJlc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgdmlldyBhbmQgdW5pbnN0YWxsIGV2ZW50cy4gRXhlY3V0ZWQgYnkgdGhlIGB2aWV3TWFuYWdlcmAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMuJGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3VuZGVsZWdhdGVFdmVudHMoKTtcbiAgICB2aWV3cG9ydC5yZW1vdmVSZXNpemVMaXN0ZW5lcih0aGlzLm9uUmVzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHZpZXcgZnJvbSBpdCdzIGNvbnRhaW5lci4gRXhlY3V0ZWQgYnkgdGhlIGB2aWV3TWFuYWdlcmAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBleHRlbmQsIGV4ZWN1dGVkIHdoZW4gdGhlIERPTSBpcyBjcmVhdGVkLlxuICAgKi9cbiAgb25SZW5kZXIoKSB7fVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBleGVjdXRlZCBvbiBgcmVzaXplYCBldmVudHMuIEJ5IGRlZmF1bHQsIG1haW50YWlucyB0aGUgc2l6ZVxuICAgKiBvZiB0aGUgY29udGFpbmVyIHRvIGZpdCB0aGUgdmlld3BvcnQgc2l6ZS4gVGhlIG1ldGhvZCBpcyBhbHNvIGV4ZWN1dGVkIHdoZW5cbiAgICogdGhlIHZpZXcgaXMgaW5zZXJ0ZWQgaW4gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0V2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2aWV3cG9ydEhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAtIE9yaWVudGF0aW9uIG9mIHRoZSB2aWV3cG9ydC5cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOnNvdW5kd29ya3MvY2xpZW50LnZpZXdwb3J0fVxuICAgKi9cbiAgb25SZXNpemUodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIG9yaWVudGF0aW9uKSB7XG4gICAgdGhpcy52aWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aDtcbiAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQ7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuXG4gICAgdGhpcy4kZWwuc3R5bGUud2lkdGggPSBgJHt2aWV3cG9ydFdpZHRofXB4YDtcbiAgICB0aGlzLiRlbC5zdHlsZS5oZWlnaHQgPSBgJHt2aWV3cG9ydEhlaWdodH1weGA7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LnJlbW92ZSgncG9ydHJhaXQnLCAnbGFuZHNjYXBlJyk7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZChvcmllbnRhdGlvbik7XG4gIH1cblxuICAvLyBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBJbnN0YWxsIGV2ZW50cyBvbiB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q8U3RyaW5nLCBGdW5jdGlvbj59IGV2ZW50cyAtIEFuIG9iamVjdCBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW292ZXJyaWRlPWZhbHNlXSAtIERlZmluZXMgaWYgdGhlIG5ldyBldmVudHMgYWRkZWQgdG8gdGhlXG4gICAqICB0aGUgb2xkIG9uZSBvciBpZiB0aGV5IHJlcGxhY2UgdGhlbS5cbiAgICovXG4gIGluc3RhbGxFdmVudHMoZXZlbnRzLCBvdmVycmlkZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNWaXNpYmxlKVxuICAgICAgdGhpcy5fdW5kZWxlZ2F0ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5ldmVudHMgPSBvdmVycmlkZSA/IGV2ZW50cyA6IE9iamVjdC5hc3NpZ24odGhpcy5ldmVudHMsIGV2ZW50cyk7XG5cbiAgICBpZiAodGhpcy5pc1Zpc2libGUpXG4gICAgICB0aGlzLl9kZWxlZ2F0ZUV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIHZpZXcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVsZWdhdGVFdmVudHMoKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuZXZlbnRzKSB7XG4gICAgICBjb25zdCBbZXZlbnQsIC4uLnNlbGVjdG9yXSA9IGtleS5zcGxpdCgvICsvKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5ldmVudHNba2V5XTtcblxuICAgICAgdGhpcy5fZGVsZWdhdGUub24oZXZlbnQsIHNlbGVjdG9yLmxlbmd0aCA/IHNlbGVjdG9yLmpvaW4oJyAnKSA6wqBudWxsLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgdmlldy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91bmRlbGVnYXRlRXZlbnRzKCkge1xuICAgIHRoaXMuX2RlbGVnYXRlLm9mZigpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXc7XG4iLCIvKipcbiAqIFRyYWNrIHRoZSB2aWV3cG9ydCBzaXplIGFuZCBvcmllbnRhdGlvbi5cbiAqIEFsbCB2aWV3cyBhZGQgdGhlaXIge0BsaW5rIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC5WaWV3I29uUmVzaXplfSBtZXRob2QgYXNcbiAqIGxpc3RlbmVyIG9mIHRoaXMgaGVscGVyLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnRcbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuVmlldyNvblJlc2l6ZX1cbiAqL1xuY29uc3Qgdmlld3BvcnQgPSB7XG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB3aWR0aDogbnVsbCxcblxuICAvKipcbiAgICogSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogT3JpZW50YXRpb24gb2YgdGhlIHZpZXdwb3J0IChgJ3BvcnRyYWl0J3wnbGFuZHNjYXBlJ2ApLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgb3JpZW50YXRpb246IG51bGwsXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGV4ZWN1dGUgb24gZWFjaCBgcmVzaXplYCBldmVudC5cbiAgICpcbiAgICogQHR5cGUge1NldH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWxsYmFja3M6IG5ldyBTZXQoKSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgc2VydmljZSwgaXMgY2FsbGVkIGluIGBjbGllbnQuX2luaXRWaWV3c2AuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0KCkge1xuICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX29uUmVzaXplKCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLndpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8wqB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHzCoHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gdGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0ID8gJ2xhbmRzY2FwZScgOiAncG9ydHJhaXQnO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjYWxsYmFjayh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5vcmllbnRhdGlvbik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgb24gYSBgcmVzaXplYCBldmVudC5cbiAgICpcbiAgICogQGNhbGxiYWNrIG1vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC52aWV3cG9ydH5yZXNpemVDYWxsYmFja1xuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gLSBPcmllbnRhdGlvbiBvZiB0aGUgdmlld3BvcnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgYHJlc2l6ZWAgZXZlbnQuIFRoZSBjYWxsYmFjayBpcyBpbW1lZGlhdGVseVxuICAgKiBpbnZva2VkIHdpdGggdGhlIGN1cnJlbnQgYHdpZHRoYCwgYGhlaWdodGAgYW5kIGBvcmllbnRhdGlvbmAgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC52aWV3cG9ydH5yZXNpemVDYWxsYmFja30gY2FsbGJhY2sgLVxuICAgKiAgQ2FsbGJhY2sgdG8gYWRkIHRvIGxpc3RlbmVycy5cbiAgICovXG4gIGFkZFJlc2l6ZUxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgLy8gZXhlY3V0ZSBpbW1lZGlhdGx5IHdpdGggY3VycmVudCB2YWx1ZXNcbiAgICBjYWxsYmFjayh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5vcmllbnRhdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIGByZXNpemVgIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpzb3VuZHdvcmtzL2NsaWVudC52aWV3cG9ydH5yZXNpemVDYWxsYmFja30gY2FsbGJhY2sgLVxuICAgKiAgQ2FsbGJhY2sgdG8gcmVtb3ZlIGZyb20gbGlzdGVuZXJzLlxuICAgKi9cbiAgcmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHZpZXdwb3J0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAvLyBEaXNhYmxlZD9cbiAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC0/XFxkP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiLyoqXG4gKiBMaWdodHdlaWdodCBFdmVudEVtaXR0ZXIgbWltaWNpbmcgbm9kZSBFdmVudEVtaXR0ZXIncyBBUEkuXG4gKi9cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEV2ZW50c1xuICAgICAqIEBuYW1lIF9ldmVudHNcbiAgICAgKiBAdHlwZSB7TWFwPFN0cmluZywgU2V0Pn1cbiAgICAgKiBAaW5zdGFuY2VvZiBQcm9jZXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY2FsbGJhY2sgdG8gYSBuYW1lZCBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIE5hbWUgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAqL1xuICBhZGRMaXN0ZW5lcihjaGFubmVsLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmhhcyhjaGFubmVsKSlcbiAgICAgIHRoaXMuX2V2ZW50cy5zZXQoY2hhbm5lbCwgbmV3IFNldCgpKTtcblxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fZXZlbnRzLmdldChjaGFubmVsKTtcbiAgICBzdGFjay5hZGQoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gYSBuYW1lZCBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbCAtIE5hbWUgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZUxpc3RlbmVyKGNoYW5uZWwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLl9ldmVudHMuZ2V0KGNoYW5uZWwpO1xuXG4gICAgaWYgKHN0YWNrKVxuICAgICAgc3RhY2suZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWwgLSBOYW1lIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHsuLi5NaXhlZH0gYXJncyAtIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIGVtaXQoY2hhbm5lbCwgLi4uYXJncykge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fZXZlbnRzLmdldChjaGFubmVsKTtcblxuICAgIGlmIChzdGFjaylcbiAgICAgIHN0YWNrLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuIiwiLyoqXG4gKlxuICpcbiAqL1xuY2xhc3MgU2lnbmFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBzZXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3N0YXRlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlO1xuXG4gICAgICBmb3IgKGxldCBvYnNlcnZlciBvZiB0aGlzLl9vYnNlcnZlcnMpXG4gICAgICAgIG9ic2VydmVyKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLl9vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgfVxuXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lnbmFsO1xuIiwiaW1wb3J0IFNpZ25hbCBmcm9tICcuL1NpZ25hbCc7XG5cbi8qKlxuICogQ29tcG91bmQgc2lnbmFsIHRoYXQgaXMgYHRydWVgIHdoZW4gYWxsIHNpZ25hbHMgaXQgZGVwZW5kcyBvbiBhcmUgYHRydWVgLlxuICogRGVwZW5kZW5jaWVzIGFyZSBhZGRlZCB0aHJvdWdoIHRoZSBgYWRkYCBtZXRob2QuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTaWduYWxBbGwgZXh0ZW5kcyBTaWduYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY2llcy5zaXplO1xuICB9XG5cbiAgYWRkKHNpZ25hbCkge1xuICAgIHRoaXMuX2RlcGVuZGVuY2llcy5hZGQoc2lnbmFsKTtcblxuICAgIHNpZ25hbC5hZGRPYnNlcnZlcigoKSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSB0cnVlO1xuXG4gICAgICBmb3IgKGxldCBzaWduYWwgb2YgdGhpcy5fZGVwZW5kZW5jaWVzKVxuICAgICAgICB2YWx1ZSA9IHZhbHVlICYmIHNpZ25hbC5nZXQoKTtcblxuICAgICAgc3VwZXIuc2V0KHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldCh2YWx1ZSkgeyAvKiBub29wICovIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lnbmFsQWxsO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclRvRGVjaWJlbCh2YWwpIHtcbiAgcmV0dXJuIDguNjg1ODg5NjM4MDY1MDM1ICogTWF0aC5sb2codmFsKTsgLy8gMjAgKiBsb2cxMCh2YWwpXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjaWJlbFRvTGluZWFyKHZhbCkge1xuICByZXR1cm4gTWF0aC5leHAoMC4xMTUxMjkyNTQ2NDk3MDIyOSAqIHZhbCk7IC8vIHBvdygxMCwgdmFsIC8gMjApXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcG93ZXJUb0RlY2liZWwodmFsKSB7XG4gIHJldHVybiA0LjM0Mjk0NDgxOTAzMjUxNzUgKiBNYXRoLmxvZyh2YWwpOyAvLyAxMCAqIGxvZzEwKHZhbClcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNpYmVsVG9Qb3dlcih2YWwpIHtcbiAgcmV0dXJuIE1hdGguZXhwKDAuMjMwMjU4NTA5Mjk5NDA0NTggKiB2YWwpOyAvLyBwb3coMTAsIHZhbCAvIDEwKVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclRvQ2VudCh2YWwpIHtcbiAgcmV0dXJuIDE3MzEuMjM0MDQ5MDY2NzU2MTEgKiBNYXRoLmxvZyh2YWwpOyAvLyAxMjAwICogbG9nMih2YWwpXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2VudFRvTGluZWFyKHZhbCkge1xuICByZXR1cm4gTWF0aC5leHAoMC4wMDA1Nzc2MjI2NTA0NjY2MjExICogdmFsKTsgLy8gcG93KDIsIHZhbCAvIDEyMDApXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVyKG1pbkluLCBtYXhJbiwgbWluT3V0LCBtYXhPdXQpIHtcbiAgY29uc3QgYSA9IChtYXhPdXQgLSBtaW5PdXQpIC8gKG1heEluIC0gbWluSW4pO1xuICBjb25zdCBiID0gbWluT3V0IC0gYSAqIG1pbkluO1xuICByZXR1cm4geCA9PiBhICogeCArIGI7XG59O1xuIiwiaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmNvbnN0IGxvZyA9IGRlYnVnKCdzeW5jJyk7XG5cbi8vLy8vLyBoZWxwZXJzXG5cbi8qKlxuICogT3JkZXIgbWluIGFuZCBtYXggYXR0cmlidXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRoYXQgd2l0aCBtaW4gYW5kIG1heCBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB3aXRoIG1pbiBhbmQgbWFuIGF0dHJpYnV0ZXMsIHN3YXBwZWQgaWYgdGhhdC5taW4gPiB0aGF0Lm1heFxuICovXG5mdW5jdGlvbiBvcmRlck1pbk1heCh0aGF0KSB7XG4gIGlmKHR5cGVvZiB0aGF0ICE9PSAndW5kZWZpbmVkJ1xuICAgICAmJiB0eXBlb2YgdGhhdC5taW4gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGF0Lm1heCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgJiYgdGhhdC5taW4gPiB0aGF0Lm1heCkge1xuICAgIGNvbnN0IHRtcCA9IHRoYXQubWluO1xuICAgIHRoYXQubWluID0gdGhhdC5tYXg7XG4gICAgdGhhdC5tYXggPSB0bXA7XG4gIH1cbiAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogTWVhbiBvdmVyIGFuIGFycmF5LCBzZWxlY3Rpbmcgb25lIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48TnVtYmVyPj59IGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gW2RpbWVuc2lvbj0wXVxuICogQHJldHVybnMge051bWJlcn0gbWVhblxuICovXG5mdW5jdGlvbiBtZWFuKGFycmF5LCBkaW1lbnNpb24gPSAwKSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKHAsIHEpID0+IHAgKyBxW2RpbWVuc2lvbl0sIDApIC8gYXJyYXkubGVuZ3RoO1xufVxuXG5jbGFzcyBTeW5jQ2xpZW50IHtcbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fmdldFRpbWVGdW5jdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1vbm90b25pYywgZXZlciBpbmNyZWFzaW5nLCB0aW1lIGluIHNlY29uZC4gV2hlbiBwb3NzaWJsZVxuICAgKiAgdGhlIHNlcnZlciBjb2RlIHNob3VsZCBkZWZpbmUgaXRzIG93biBvcmlnaW4gKGkuZS4gYHRpbWU9MGApIGluIG9yZGVyIHRvXG4gICAqICBtYXhpbWl6ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY2xvY2sgZm9yIGEgbG9uZyBwZXJpb2Qgb2YgdGltZS4gV2hlblxuICAgKiAgYFN5bmNTZXJ2ZXJ+c3RhcnRgIGlzIGNhbGxlZCB0aGUgY2xvY2sgc2hvdWxkIGJlIHJ1bm5pbmdcbiAgICogIChjZi4gYGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZWAgdGhhdCBuZWVkcyB1c2VyIGludGVyYWN0aW9uIHRvIHN0YXJ0KVxuICAgKiovXG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fnNlbmRGdW5jdGlvblxuICAgKiBAc2VlIHtAbGlua2NvZGUgU3luY1NlcnZlcn5yZWNlaXZlRnVuY3Rpb259XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwaW5nSWQgdW5pcXVlIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaWVudFBpbmdUaW1lIHRpbWUtc3RhbXAgb2YgcGluZyBlbWlzc2lvblxuICAgKiovXG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fnJlY2VpdmVGdW5jdGlvblxuICAgKiBAc2VlIHtAbGlua2NvZGUgU3luY1NlcnZlcn5zZW5kRnVuY3Rpb259XG4gICAqIEBwYXJhbSB7U3luY0NsaWVudH5yZWNlaXZlQ2FsbGJhY2t9IHJlY2VpdmVDYWxsYmFjayBjYWxsZWQgb25cbiAgICogZWFjaCBtZXNzYWdlIG1hdGNoaW5nIG1lc3NhZ2VUeXBlLlxuICAgKiovXG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fnJlY2VpdmVDYWxsYmFja1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGluZ0lkIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjbGllbnRQaW5nVGltZSB0aW1lLXN0YW1wIG9mIHBpbmcgZW1pc3Npb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlcnZlclBpbmdUaW1lIHRpbWUtc3RhbXAgb2YgcGluZyByZWNlcHRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlcnZlclBvbmdUaW1lIHRpbWUtc3RhbXAgb2YgcG9uZyBlbWlzc2lvblxuICAgKiBAcGFyYW0ge051bWJlcn0gY2xpZW50UG9uZ1RpbWUgdGltZS1zdGFtcCBvZiBwb25nIHJlY2VwdGlvblxuICAgKiovXG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fnJlcG9ydEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlcG9ydC5zdGF0dXMgYG5ld2AsIGBzdGFydHVwYCxcbiAgICogYHRyYWluaW5nYCAob2Zmc2V0IGFkYXB0YXRpb24pLCBvciBgc3luY2AgKG9mZnNldCBhbmQgcmF0aW8gYWRhcHRhdGlvbikuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXBvcnQuc3RhdHVzRHVyYXRpb24gZHVyYXRpb24gc2luY2UgbGFzdCBzdGF0dXNcbiAgICogY2hhbmdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LnRpbWVPZmZzZXQgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gbG9jYWxcbiAgICogdGltZSBhbmQgc3luYyB0aW1lLCBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LmZyZXF1ZW5jeVJhdGlvIHRpbWUgcmF0aW8gYmV0d2VlbiBsb2NhbFxuICAgKiB0aW1lIGFuZCBzeW5jIHRpbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZXBvcnQuY29ubmVjdGlvbiBgb2ZmbGluZWAgb3IgYG9ubGluZWBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcG9ydC5jb25uZWN0aW9uRHVyYXRpb24gZHVyYXRpb24gc2luY2UgbGFzdCBjb25uZWN0aW9uXG4gICAqIGNoYW5nZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcG9ydC5jb25uZWN0aW9uVGltZU91dCBkdXJhdGlvbiwgaW4gc2Vjb25kcywgYmVmb3JlXG4gICAqIGEgdGltZS1vdXQgb2NjdXJzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LnRyYXZlbER1cmF0aW9uIGR1cmF0aW9uIG9mIGFcbiAgICogcGluZy1wb25nIHJvdW5kLXRyaXAsIGluIHNlY29uZHMsIG1lYW4gb3ZlciB0aGUgdGhlIGxhc3RcbiAgICogcGluZy1wb25nIHNlcmllcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcG9ydC50cmF2ZWxEdXJhdGlvbk1pbiBkdXJhdGlvbiBvZiBhXG4gICAqIHBpbmctcG9uZyByb3VuZC10cmlwLCBpbiBzZWNvbmRzLCBtaW5pbXVtIG92ZXIgdGhlIHRoZSBsYXN0XG4gICAqIHBpbmctcG9uZyBzZXJpZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXBvcnQudHJhdmVsRHVyYXRpb25NYXggZHVyYXRpb24gb2YgYVxuICAgKiBwaW5nLXBvbmcgcm91bmQtdHJpcCwgaW4gc2Vjb25kcywgbWF4aW11bSBvdmVyIHRoZSB0aGUgbGFzdFxuICAgKiBwaW5nLXBvbmcgc2VyaWVzLlxuICAgKiovXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yLiBTZWUge0BsaW5rY29kZSBTeW5jQ2xpZW50fnN0YXJ0fSBtZXRob2QgdG9cbiAgICogYWN0dWFsbHkgc3RhcnQgYSBzeW5jaHJvbmlzYXRpb24gcHJvY2Vzcy5cbiAgICpcbiAgICogQGNvbnN0cnVjdHMgU3luY0NsaWVudFxuICAgKiBAcGFyYW0ge1N5bmNDbGllbnR+Z2V0VGltZUZ1bmN0aW9ufSBnZXRUaW1lRnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGluZ1RpbWVPdXREZWxheV0gcmFuZ2Ugb2YgZHVyYXRpb24gKGluIHNlY29uZHMpIHRvXG4gICAqIGNvbnNpZGVyIGEgcGluZyB3YXMgbm90IHBvbmdlZCBiYWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nVGltZU91dERlbGF5Lm1pbj0xXSBtaW4gYW5kIG1heCBtdXN0IGJlIHNldCB0b2dldGhlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGluZ1RpbWVPdXREZWxheS5tYXg9MzBdIG1pbiBhbmQgbWF4IG11c3QgYmUgc2V0IHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nU2VyaWVzSXRlcmF0aW9ucz0xMF0gbnVtYmVyIG9mIHBpbmctcG9uZ3MgaW4gYVxuICAgKiBzZXJpZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBpbmdTZXJpZXNQZXJpb2Q9MC4yNTBdIGludGVydmFsIChpbiBzZWNvbmRzKSBiZXR3ZWVuIHBpbmdzXG4gICAqIGluIGEgc2VyaWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nU2VyaWVzRGVsYXldIHJhbmdlIG9mIGludGVydmFsIChpblxuICAgKiBzZWNvbmRzKSBiZXR3ZWVuIHBpbmctcG9uZyBzZXJpZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBpbmdTZXJpZXNEZWxheS5taW49MTBdIG1pbiBhbmQgbWF4IG11c3QgYmUgc2V0IHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nU2VyaWVzRGVsYXkubWF4PTIwXSBtaW4gYW5kIG1heCBtdXN0IGJlIHNldCB0b2dldGhlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9uZ1Rlcm1EYXRhVHJhaW5pbmdEdXJhdGlvbj0xMjBdIGR1cmF0aW9uIG9mXG4gICAqIHRyYWluaW5nLCBpbiBzZWNvbmRzLCBhcHByb3hpbWF0ZWx5LCBiZWZvcmUgdXNpbmcgdGhlIGVzdGltYXRlIG9mXG4gICAqIGNsb2NrIGZyZXF1ZW5jeVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9uZ1Rlcm1EYXRhRHVyYXRpb249OTAwXSBlc3RpbWF0ZSBzeW5jaHJvbmlzYXRpb24gb3ZlclxuICAgKiAgdGhpcyBkdXJhdGlvbiwgaW4gc2Vjb25kcywgYXBwcm94aW1hdGVseVxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2V0VGltZUZ1bmN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnBpbmdUaW1lb3V0RGVsYXkgPSBvcHRpb25zLnBpbmdUaW1lb3V0RGVsYXlcbiAgICAgIHx8IHsgbWluOiAxLCBtYXg6IDMwIH07XG4gICAgb3JkZXJNaW5NYXgodGhpcy5waW5nVGltZW91dERlbGF5KTtcblxuICAgIHRoaXMucGluZ1Nlcmllc0l0ZXJhdGlvbnMgPSBvcHRpb25zLnBpbmdTZXJpZXNJdGVyYXRpb25zIHx8IDEwO1xuICAgIHRoaXMucGluZ1Nlcmllc1BlcmlvZCA9IG9wdGlvbnMucGluZ1Nlcmllc1BlcmlvZCB8fCAwLjI1MDtcbiAgICB0aGlzLnBpbmdTZXJpZXNEZWxheSA9IG9wdGlvbnMucGluZ1Nlcmllc0RlbGF5XG4gICAgICB8fCB7IG1pbjogMTAsIG1heDogMjAgfTtcbiAgICBvcmRlck1pbk1heCh0aGlzLnBpbmdTZXJpZXNEZWxheSk7XG5cbiAgICB0aGlzLnBpbmdEZWxheSA9IDA7IC8vIGN1cnJlbnQgZGVsYXkgYmVmb3JlIG5leHQgcGluZ1xuICAgIHRoaXMucGluZ1RpbWVvdXRJZCA9IDA7IC8vIHRvIGNhbmNlbCB0aW1lb3V0IG9uIHN5bmNfcGluY1xuICAgIHRoaXMucGluZ0lkID0gMDsgLy8gYWJzb2x1dGUgSUQgdG8gbWFjaCBwb25nIGFnYWluc3RcblxuICAgIHRoaXMucGluZ1Nlcmllc0NvdW50ID0gMDsgLy8gZWxhcHNlZCBwaW5ncyBpbiBhIHNlcmllc1xuICAgIHRoaXMuc2VyaWVzRGF0YSA9IFtdOyAvLyBjaXJjdWxhciBidWZmZXJcbiAgICB0aGlzLnNlcmllc0RhdGFOZXh0SW5kZXggPSAwOyAvLyBuZXh0IGluZGV4IHRvIHdyaXRlIGluIGNpcmN1bGFyIGJ1ZmZlclxuICAgIHRoaXMuc2VyaWVzRGF0YUxlbmd0aCA9IHRoaXMucGluZ1Nlcmllc0l0ZXJhdGlvbnM7IC8vIHNpemUgb2YgY2lyY3VsYXIgYnVmZmVyXG5cbiAgICB0aGlzLmxvbmdUZXJtRGF0YVRyYWluaW5nRHVyYXRpb25cbiAgICAgID0gb3B0aW9ucy5sb25nVGVybURhdGFUcmFpbmluZ0R1cmF0aW9uIHx8IDEyMDtcblxuICAgIC8vIHVzZSBhIGZpeGVkLXNpemUgY2lyY3VsYXIgYnVmZmVyLCBldmVuIGlmIGl0IGRvZXMgbm90IG1hdGNoXG4gICAgLy8gZXhhY3RseSB0aGUgcmVxdWlyZWQgZHVyYXRpb25cbiAgICB0aGlzLmxvbmdUZXJtRGF0YUR1cmF0aW9uID0gb3B0aW9ucy5sb25nVGVybURhdGFEdXJhdGlvbiB8fCA5MDA7XG4gICAgdGhpcy5sb25nVGVybURhdGFMZW5ndGggPSBNYXRoLm1heChcbiAgICAgIDIsXG4gICAgICB0aGlzLmxvbmdUZXJtRGF0YUR1cmF0aW9uIC9cbiAgICAgICAgKDAuNSAqICh0aGlzLnBpbmdTZXJpZXNEZWxheS5taW4gKyB0aGlzLnBpbmdTZXJpZXNEZWxheS5tYXgpICkgKTtcblxuICAgIHRoaXMubG9uZ1Rlcm1EYXRhID0gW107IC8vIGNpcmN1bGFyIGJ1ZmZlclxuICAgIHRoaXMubG9uZ1Rlcm1EYXRhTmV4dEluZGV4ID0gMDsgLy8gbmV4dCBpbmRleCB0byB3cml0ZSBpbiBjaXJjdWxhciBidWZmZXJcblxuICAgIHRoaXMudGltZU9mZnNldCA9IDA7IC8vIG1lYW4gb2YgKHNlcnZlclRpbWUgLSBjbGllbnRUaW1lKSBpbiB0aGUgbGFzdCBzZXJpZXNcbiAgICB0aGlzLnRyYXZlbER1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyYXZlbER1cmF0aW9uTWluID0gMDtcbiAgICB0aGlzLnRyYXZlbER1cmF0aW9uTWF4ID0gMDtcblxuICAgIC8vIFQodCkgPSBUMCArIFIgKiAodCAtIHQwKVxuICAgIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSA9IDA7IC8vIFQwXG4gICAgdGhpcy5jbGllbnRUaW1lUmVmZXJlbmNlID0gMDsgLy8gdDBcbiAgICB0aGlzLmZyZXF1ZW5jeVJhdGlvID0gMTsgLy8gUlxuXG4gICAgdGhpcy5waW5nVGltZW91dERlbGF5LmN1cnJlbnQgPSB0aGlzLnBpbmdUaW1lb3V0RGVsYXkubWluO1xuXG4gICAgdGhpcy5nZXRUaW1lRnVuY3Rpb24gPSBnZXRUaW1lRnVuY3Rpb247XG5cbiAgICB0aGlzLnN0YXR1cyA9ICduZXcnO1xuICAgIHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUgPSAwO1xuXG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzID0gJ29mZmxpbmUnO1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NoYW5nZWRUaW1lID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc3RhdHVzLCBhbmQgc2V0IHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUsIHRvIGxhdGVyXG4gICAqIHVzZSBzZWUge0BsaW5rY29kZSBTeW5jQ2xpZW50fmdldFN0YXR1c0R1cmF0aW9ufVxuICAgKiBhbmQge0BsaW5rY29kZSBTeW5jQ2xpZW50fnJlcG9ydFN0YXR1c30uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBTeW5jQ2xpZW50fnNldFN0YXR1c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoaXNcbiAgICovXG4gIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICBpZihzdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUgPSB0aGlzLmdldExvY2FsVGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGltZSBzaW5jZSBsYXN0IHN0YXR1cyBjaGFuZ2UuIFNlZSB7QGxpbmtjb2RlIFN5bmNDbGllbnR+c2V0U3RhdHVzfVxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5nZXRTdGF0dXNEdXJhdGlvblxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aW1lLCBpbiBzZWNvbmRzLCBzaW5jZSBsYXN0IHN0YXR1cyBjaGFuZ2UuXG4gICAqL1xuICBnZXRTdGF0dXNEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5nZXRMb2NhbFRpbWUoKSAtIHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb25uZWN0aW9uU3RhdHVzLCBhbmQgc2V0IHRoaXMuY29ubmVjdGlvblN0YXR1c0NoYW5nZWRUaW1lLFxuICAgKiB0byBsYXRlciB1c2Ugc2VlIHtAbGlua2NvZGUgU3luY0NsaWVudH5nZXRDb25uZWN0aW9uU3RhdHVzRHVyYXRpb259XG4gICAqIGFuZCB7QGxpbmtjb2RlIFN5bmNDbGllbnR+cmVwb3J0U3RhdHVzfS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIFN5bmNDbGllbnR+c2V0Q29ubmVjdGlvblN0YXR1c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ubmVjdGlvblN0YXR1c1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGlzXG4gICAqL1xuICBzZXRDb25uZWN0aW9uU3RhdHVzKGNvbm5lY3Rpb25TdGF0dXMpIHtcbiAgICBpZihjb25uZWN0aW9uU3RhdHVzICE9PSB0aGlzLmNvbm5lY3Rpb25TdGF0dXMpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1cyA9IGNvbm5lY3Rpb25TdGF0dXM7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkVGltZSA9IHRoaXMuZ2V0TG9jYWxUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aW1lIHNpbmNlIGxhc3QgY29ubmVjdGlvblN0YXR1cyBjaGFuZ2UuXG4gICAqIFNlZSB7QGxpbmtjb2RlIFN5bmNDbGllbnR+c2V0Q29ubmVjdGlvblN0YXR1c31cbiAgICpcbiAgICogQGZ1bmN0aW9uIFN5bmNDbGllbnR+Z2V0Q29ubmVjdGlvblN0YXR1c0R1cmF0aW9uXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRpbWUsIGluIHNlY29uZHMsIHNpbmNlIGxhc3QgY29ubmVjdGlvblN0YXR1c1xuICAgKiBjaGFuZ2UuXG4gICAqL1xuICBnZXRDb25uZWN0aW9uU3RhdHVzRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuZ2V0TG9jYWxUaW1lKCkgLSB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkVGltZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwb3J0IHRoZSBzdGF0dXMgb2YgdGhlIHN5bmNocm9uaXNhdGlvbiBwcm9jZXNzLCBpZlxuICAgKiByZXBvcnRGdW5jdGlvbiBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5yZXBvcnRTdGF0dXNcbiAgICogQHBhcmFtIHtTeW5jQ2xpZW50fnJlcG9ydEZ1bmN0aW9ufSByZXBvcnRGdW5jdGlvblxuICAgKi9cbiAgcmVwb3J0U3RhdHVzKHJlcG9ydEZ1bmN0aW9uKSB7XG4gICAgaWYodHlwZW9mIHJlcG9ydEZ1bmN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVwb3J0RnVuY3Rpb24oe1xuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICBzdGF0dXNEdXJhdGlvbjogdGhpcy5nZXRTdGF0dXNEdXJhdGlvbigpLFxuICAgICAgICB0aW1lT2Zmc2V0OiB0aGlzLnRpbWVPZmZzZXQsXG4gICAgICAgIGZyZXF1ZW5jeVJhdGlvOiB0aGlzLmZyZXF1ZW5jeVJhdGlvLFxuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLmNvbm5lY3Rpb25TdGF0dXMsXG4gICAgICAgIGNvbm5lY3Rpb25EdXJhdGlvbjogdGhpcy5nZXRDb25uZWN0aW9uU3RhdHVzRHVyYXRpb24oKSxcbiAgICAgICAgY29ubmVjdGlvblRpbWVPdXQ6IHRoaXMucGluZ1RpbWVvdXREZWxheS5jdXJyZW50LFxuICAgICAgICB0cmF2ZWxEdXJhdGlvbjogdGhpcy50cmF2ZWxEdXJhdGlvbixcbiAgICAgICAgdHJhdmVsRHVyYXRpb25NaW46IHRoaXMudHJhdmVsRHVyYXRpb25NaW4sXG4gICAgICAgIHRyYXZlbER1cmF0aW9uTWF4OiB0aGlzLnRyYXZlbER1cmF0aW9uTWF4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0byBzZW5kIHBpbmcgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBTeW5jQ2xpZW50fl9fc3luY0xvb3BcbiAgICogQHBhcmFtIHtTeW5jQ2xpZW50fnNlbmRGdW5jdGlvbn0gc2VuZEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3luY0NsaWVudH5yZXBvcnRGdW5jdGlvbn0gcmVwb3J0RnVuY3Rpb25cbiAgICovXG4gIF9fc3luY0xvb3Aoc2VuZEZ1bmN0aW9uLCByZXBvcnRGdW5jdGlvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgKyt0aGlzLnBpbmdJZDtcbiAgICBzZW5kRnVuY3Rpb24odGhpcy5waW5nSWQsIHRoaXMuZ2V0TG9jYWxUaW1lKCkpO1xuXG4gICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGluY3JlYXNlIHRpbWVvdXQgZHVyYXRpb24gb24gdGltZW91dCwgdG8gYXZvaWQgb3ZlcmZsb3dcbiAgICAgIHRoaXMucGluZ1RpbWVvdXREZWxheS5jdXJyZW50ID0gTWF0aC5taW4odGhpcy5waW5nVGltZW91dERlbGF5LmN1cnJlbnQgKiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RGVsYXkubWF4KTtcbiAgICAgIGxvZygnc3luYzpwaW5nIHRpbWVvdXQgPiAlcycsIHRoaXMucGluZ1RpbWVvdXREZWxheS5jdXJyZW50KTtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cygnb2ZmbGluZScpO1xuICAgICAgdGhpcy5yZXBvcnRTdGF0dXMocmVwb3J0RnVuY3Rpb24pO1xuICAgICAgLy8gcmV0cnkgKHllcywgYWx3YXlzIGluY3JlbWVudCBwaW5nSWQpXG4gICAgICB0aGlzLl9fc3luY0xvb3Aoc2VuZEZ1bmN0aW9uLCByZXBvcnRGdW5jdGlvbik7XG4gICAgfSwgTWF0aC5jZWlsKDEwMDAgKiB0aGlzLnBpbmdUaW1lb3V0RGVsYXkuY3VycmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgc3luY2hyb25pc2F0aW9uIHByb2Nlc3MgYnkgcmVnaXN0ZXJpbmcgdGhlIHJlY2VpdmVcbiAgICogZnVuY3Rpb24gcGFzc2VkIGFzIHNlY29uZCBwYXJhbWV0ZXIuIFRoZW4sIHNlbmQgcmVndWxhciBtZXNzYWdlc1xuICAgKiB0byB0aGUgc2VydmVyLCB1c2luZyB0aGUgc2VuZCBmdW5jdGlvbiBwYXNzZWQgYXMgZmlyc3QgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5zdGFydFxuICAgKiBAcGFyYW0ge1N5bmNDbGllbnR+c2VuZEZ1bmN0aW9ufSBzZW5kRnVuY3Rpb25cbiAgICogQHBhcmFtIHtTeW5jQ2xpZW50fnJlY2VpdmVGdW5jdGlvbn0gcmVjZWl2ZUZ1bmN0aW9uIHRvIHJlZ2lzdGVyXG4gICAqIEBwYXJhbSB7U3luY0NsaWVudH5yZXBvcnRGdW5jdGlvbn0gcmVwb3J0RnVuY3Rpb24gaWYgZGVmaW5lZCxcbiAgICogaXMgY2FsbGVkIHRvIHJlcG9ydCB0aGUgc3RhdHVzLCBvbiBlYWNoIHN0YXR1cyBjaGFuZ2VcbiAgICovXG4gIHN0YXJ0KHNlbmRGdW5jdGlvbiwgcmVjZWl2ZUZ1bmN0aW9uLCByZXBvcnRGdW5jdGlvbikge1xuICAgIHRoaXMuc2V0U3RhdHVzKCdzdGFydHVwJyk7XG4gICAgdGhpcy5zZXRDb25uZWN0aW9uU3RhdHVzKCdvZmZsaW5lJyk7XG5cbiAgICB0aGlzLnNlcmllc0RhdGEgPSBbXTtcbiAgICB0aGlzLnNlcmllc0RhdGFOZXh0SW5kZXggPSAwO1xuXG4gICAgdGhpcy5sb25nVGVybURhdGEgPSBbXTtcbiAgICB0aGlzLmxvbmdUZXJtRGF0YU5leHRJbmRleCA9IDA7XG5cbiAgICByZWNlaXZlRnVuY3Rpb24oKHBpbmdJZCwgY2xpZW50UGluZ1RpbWUsIHNlcnZlclBpbmdUaW1lLCBzZXJ2ZXJQb25nVGltZSkgPT4ge1xuICAgICAgLy8gYWNjZXB0IG9ubHkgdGhlIHBvbmcgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgbGFzdCBwaW5nXG4gICAgICBpZiAocGluZ0lkID09PSB0aGlzLnBpbmdJZCkge1xuICAgICAgICArK3RoaXMucGluZ1Nlcmllc0NvdW50O1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0dXMoJ29ubGluZScpO1xuICAgICAgICAvLyByZWR1Y2UgdGltZW91dCBkdXJhdGlvbiBvbiBwb25nLCBmb3IgYmV0dGVyIHJlYWN0aXZpdHlcbiAgICAgICAgdGhpcy5waW5nVGltZW91dERlbGF5LmN1cnJlbnQgPSBNYXRoLm1heCh0aGlzLnBpbmdUaW1lb3V0RGVsYXkuY3VycmVudCAqIDAuNzUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waW5nVGltZW91dERlbGF5Lm1pbik7XG5cbiAgICAgICAgLy8gdGltZS1kaWZmZXJlbmNlcyBhcmUgdmFsaWQgb24gYSBzaW5nbGUtc2lkZSBvbmx5IChjbGllbnQgb3Igc2VydmVyKVxuICAgICAgICBjb25zdCBjbGllbnRQb25nVGltZSA9IHRoaXMuZ2V0TG9jYWxUaW1lKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudFRpbWUgPSAwLjUgKiAoY2xpZW50UG9uZ1RpbWUgKyBjbGllbnRQaW5nVGltZSk7XG4gICAgICAgIGNvbnN0IHNlcnZlclRpbWUgPSAwLjUgKiAoc2VydmVyUG9uZ1RpbWUgKyBzZXJ2ZXJQaW5nVGltZSk7XG4gICAgICAgIGNvbnN0IHRyYXZlbER1cmF0aW9uID0gTWF0aC5tYXgoMCwgKGNsaWVudFBvbmdUaW1lIC0gY2xpZW50UGluZ1RpbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAoc2VydmVyUG9uZ1RpbWUgLSBzZXJ2ZXJQaW5nVGltZSkpO1xuICAgICAgICBjb25zdCBvZmZzZXRUaW1lID0gc2VydmVyVGltZSAtIGNsaWVudFRpbWU7XG5cbiAgICAgICAgLy8gb3JkZXIgaXMgaW1wb3J0YW50IGZvciBzb3J0aW5nLCBsYXRlci5cbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhW3RoaXMuc2VyaWVzRGF0YU5leHRJbmRleF1cbiAgICAgICAgICA9IFt0cmF2ZWxEdXJhdGlvbiwgb2Zmc2V0VGltZSwgY2xpZW50VGltZSwgc2VydmVyVGltZV07XG4gICAgICAgIHRoaXMuc2VyaWVzRGF0YU5leHRJbmRleCA9ICgrK3RoaXMuc2VyaWVzRGF0YU5leHRJbmRleCkgJSB0aGlzLnNlcmllc0RhdGFMZW5ndGg7XG5cbiAgICAgICAgLy8gbG9nKCdwaW5nICVzLCB0cmF2ZWwgPSAlcywgb2Zmc2V0ID0gJXMsIGNsaWVudCA9ICVzLCBzZXJ2ZXIgPSAlcycsXG4gICAgICAgIC8vICAgICAgIHBpbmdJZCwgdHJhdmVsRHVyYXRpb24sIG9mZnNldFRpbWUsIGNsaWVudFRpbWUsIHNlcnZlclRpbWUpO1xuXG4gICAgICAgIC8vIGVuZCBvZiBhIHNlcmllc1xuICAgICAgICBpZiAodGhpcy5waW5nU2VyaWVzQ291bnQgPj0gdGhpcy5waW5nU2VyaWVzSXRlcmF0aW9uc1xuICAgICAgICAgICAgJiYgdGhpcy5zZXJpZXNEYXRhLmxlbmd0aCA+PSB0aGlzLnNlcmllc0RhdGFMZW5ndGgpIHtcbiAgICAgICAgICAvLyBwbGFuIHRoZSBiZWdpbmluZyBvZiB0aGUgbmV4dCBzZXJpZXNcbiAgICAgICAgICB0aGlzLnBpbmdEZWxheSA9IHRoaXMucGluZ1Nlcmllc0RlbGF5Lm1pblxuICAgICAgICAgICAgKyBNYXRoLnJhbmRvbSgpICogKHRoaXMucGluZ1Nlcmllc0RlbGF5Lm1heCAtIHRoaXMucGluZ1Nlcmllc0RlbGF5Lm1pbik7XG4gICAgICAgICAgdGhpcy5waW5nU2VyaWVzQ291bnQgPSAwO1xuXG4gICAgICAgICAgLy8gc29ydCBieSB0cmF2ZWwgdGltZSBmaXJzdCwgdGhlbiBvZmZzZXQgdGltZS5cbiAgICAgICAgICBjb25zdCBzb3J0ZWQgPSB0aGlzLnNlcmllc0RhdGEuc2xpY2UoMCkuc29ydCgpO1xuXG4gICAgICAgICAgY29uc3Qgc2VyaWVzVHJhdmVsRHVyYXRpb24gPSBzb3J0ZWRbMF1bMF07XG5cbiAgICAgICAgICAvLyBXaGVuIHRoZSBjbG9jayB0aWNrIGlzIGxvbmcgZW5vdWdoLFxuICAgICAgICAgIC8vIHNvbWUgdHJhdmVsIHRpbWVzIChkaW1lbnNpb24gMCkgbWlnaHQgYmUgaWRlbnRpY2FsLlxuICAgICAgICAgIC8vIFRoZW4sIHVzZSB0aGUgb2Zmc2V0IG1lZGlhbiAoZGltZW5zaW9uIDEgaXMgdGhlIHNlY29uZCBzb3J0IGtleSlcbiAgICAgICAgICBsZXQgcyA9IDA7XG4gICAgICAgICAgd2hpbGUocyA8IHNvcnRlZC5sZW5ndGggJiYgc29ydGVkW3NdWzBdIDw9IHNlcmllc1RyYXZlbER1cmF0aW9uICogMS4wMSkge1xuICAgICAgICAgICAgKytzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gTWF0aC5tYXgoMCwgcyAtIDEpO1xuICAgICAgICAgIGNvbnN0IG1lZGlhbiA9IE1hdGguZmxvb3IocyAvIDIpO1xuXG4gICAgICAgICAgY29uc3Qgc2VyaWVzQ2xpZW50VGltZSA9IHNvcnRlZFttZWRpYW5dWzJdO1xuICAgICAgICAgIGNvbnN0IHNlcmllc1NlcnZlclRpbWUgPSBzb3J0ZWRbbWVkaWFuXVszXTtcbiAgICAgICAgICBjb25zdCBzZXJpZXNDbGllbnRTcXVhcmVkVGltZSA9IHNlcmllc0NsaWVudFRpbWUgKiBzZXJpZXNDbGllbnRUaW1lO1xuICAgICAgICAgIGNvbnN0IHNlcmllc0NsaWVudFNlcnZlclRpbWUgPSBzZXJpZXNDbGllbnRUaW1lICogc2VyaWVzU2VydmVyVGltZTtcblxuICAgICAgICAgIHRoaXMubG9uZ1Rlcm1EYXRhW3RoaXMubG9uZ1Rlcm1EYXRhTmV4dEluZGV4XVxuICAgICAgICAgICAgPSBbc2VyaWVzVHJhdmVsRHVyYXRpb24sIHNlcmllc0NsaWVudFRpbWUsIHNlcmllc1NlcnZlclRpbWUsXG4gICAgICAgICAgICAgICBzZXJpZXNDbGllbnRTcXVhcmVkVGltZSwgc2VyaWVzQ2xpZW50U2VydmVyVGltZV07XG4gICAgICAgICAgdGhpcy5sb25nVGVybURhdGFOZXh0SW5kZXggPSAoKyt0aGlzLmxvbmdUZXJtRGF0YU5leHRJbmRleCkgJSB0aGlzLmxvbmdUZXJtRGF0YUxlbmd0aDtcblxuICAgICAgICAgIC8vIG1lYW4gb2YgdGhlIHRpbWUgb2Zmc2V0IG92ZXIgMyBzYW1wbGVzIGFyb3VuZCBtZWRpYW5cbiAgICAgICAgICAvLyAoaXQgbWlnaHQgdXNlIGEgbG9uZ2VyIHRyYXZlbCBkdXJhdGlvbilcbiAgICAgICAgICBjb25zdCBhcm91bmRNZWRpYW4gPSBzb3J0ZWQuc2xpY2UoTWF0aC5tYXgoMCwgbWVkaWFuIC0gMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHNvcnRlZC5sZW5ndGgsIG1lZGlhbiArIDEpICk7XG4gICAgICAgICAgdGhpcy50aW1lT2Zmc2V0ID0gbWVhbihhcm91bmRNZWRpYW4sIDMpIC0gbWVhbihhcm91bmRNZWRpYW4sIDIpO1xuXG4gICAgICAgICAgaWYodGhpcy5zdGF0dXMgPT09ICdzdGFydHVwJ1xuICAgICAgICAgICAgIHx8ICh0aGlzLnN0YXR1cyA9PT0gJ3RyYWluaW5nJ1xuICAgICAgICAgICAgICAgICAmJiB0aGlzLmdldFN0YXR1c0R1cmF0aW9uKCkgPCB0aGlzLmxvbmdUZXJtRGF0YVRyYWluaW5nRHVyYXRpb24pICkge1xuICAgICAgICAgICAgLy8gc2V0IG9ubHkgdGhlIHBoYXNlIG9mZnNldCwgbm90IHRoZSBmcmVxdWVuY3lcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSA9IHRoaXMudGltZU9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50VGltZVJlZmVyZW5jZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVJhdGlvID0gMTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKCd0cmFpbmluZycpO1xuICAgICAgICAgICAgbG9nKCdUID0gJXMgKyAlcyAqICglcyAtICVzKSA9ICVzJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSwgdGhpcy5mcmVxdWVuY3lSYXRpbyxcbiAgICAgICAgICAgICAgICAgIHNlcmllc0NsaWVudFRpbWUsIHRoaXMuY2xpZW50VGltZVJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0U3luY1RpbWUoc2VyaWVzQ2xpZW50VGltZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCh0aGlzLnN0YXR1cyA9PT0gJ3RyYWluaW5nJ1xuICAgICAgICAgICAgICAmJiB0aGlzLmdldFN0YXR1c0R1cmF0aW9uKCkgPj0gdGhpcy5sb25nVGVybURhdGFUcmFpbmluZ0R1cmF0aW9uKVxuICAgICAgICAgICAgIHx8IHRoaXMuc3RhdHVzID09PSAnc3luYycpIHtcbiAgICAgICAgICAgIC8vIGxpbmVhciByZWdyZXNzaW9uLCBSID0gY292YXJpYW5jZSh0LFQpIC8gdmFyaWFuY2UodClcbiAgICAgICAgICAgIGNvbnN0IHJlZ0NsaWVudFRpbWUgPSBtZWFuKHRoaXMubG9uZ1Rlcm1EYXRhLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ1NlcnZlclRpbWUgPSBtZWFuKHRoaXMubG9uZ1Rlcm1EYXRhLCAyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0NsaWVudFNxdWFyZWRUaW1lID0gbWVhbih0aGlzLmxvbmdUZXJtRGF0YSwgMyk7XG4gICAgICAgICAgICBjb25zdCByZWdDbGllbnRTZXJ2ZXJUaW1lID0gbWVhbih0aGlzLmxvbmdUZXJtRGF0YSwgNCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvdmFyaWFuY2UgPSByZWdDbGllbnRTZXJ2ZXJUaW1lIC0gcmVnQ2xpZW50VGltZSAqIHJlZ1NlcnZlclRpbWU7XG4gICAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IHJlZ0NsaWVudFNxdWFyZWRUaW1lIC0gcmVnQ2xpZW50VGltZSAqIHJlZ0NsaWVudFRpbWU7XG4gICAgICAgICAgICBpZih2YXJpYW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGZyZXEgYW5kIHNoaWZ0XG4gICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5UmF0aW8gPSBjb3ZhcmlhbmNlIC8gdmFyaWFuY2U7XG4gICAgICAgICAgICAgIHRoaXMuY2xpZW50VGltZVJlZmVyZW5jZSA9IHJlZ0NsaWVudFRpbWU7XG4gICAgICAgICAgICAgIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSA9IHJlZ1NlcnZlclRpbWU7XG5cbiAgICAgICAgICAgICAgLy8gMC4wNSUgaXMgYSBsb3QgKDUwMCBQUE0sIGxpa2UgYW4gb2xkIG1lY2hhbmljYWwgY2xvY2spXG4gICAgICAgICAgICAgIGlmKHRoaXMuZnJlcXVlbmN5UmF0aW8gPiAwLjk5OTUgJiYgdGhpcy5mcmVxdWVuY3lSYXRpbyA8IDEuMDAwNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKCdzeW5jJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKCdjbG9jayBmcmVxdWVuY3kgcmF0aW8gb3V0IG9mIHN5bmM6ICVzLCB0cmFpbmluZyBhZ2FpbicsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lSYXRpbyk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdGhlIHRyYWluaW5nIGFnYWluIGZyb20gdGhlIGxhc3Qgc2VyaWVzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUaW1lUmVmZXJlbmNlID0gdGhpcy50aW1lT2Zmc2V0OyAvLyBvZmZzZXQgb25seVxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50VGltZVJlZmVyZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lSYXRpbyA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoJ3RyYWluaW5nJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvbmdUZXJtRGF0YVswXVxuICAgICAgICAgICAgICAgICAgPSBbc2VyaWVzVHJhdmVsRHVyYXRpb24sIHNlcmllc0NsaWVudFRpbWUsIHNlcmllc1NlcnZlclRpbWUsXG4gICAgICAgICAgICAgICAgICAgICBzZXJpZXNDbGllbnRTcXVhcmVkVGltZSwgc2VyaWVzQ2xpZW50U2VydmVyVGltZV07XG4gICAgICAgICAgICAgICAgdGhpcy5sb25nVGVybURhdGEubGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvbmdUZXJtRGF0YU5leHRJbmRleCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9nKCdUID0gJXMgKyAlcyAqICglcyAtICVzKSA9ICVzJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSwgdGhpcy5mcmVxdWVuY3lSYXRpbyxcbiAgICAgICAgICAgICAgICAgIHNlcmllc0NsaWVudFRpbWUsIHRoaXMuY2xpZW50VGltZVJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0U3luY1RpbWUoc2VyaWVzQ2xpZW50VGltZSkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRyYXZlbER1cmF0aW9uID0gbWVhbihzb3J0ZWQsIDApO1xuICAgICAgICAgIHRoaXMudHJhdmVsRHVyYXRpb25NaW4gPSBzb3J0ZWRbMF1bMF07XG4gICAgICAgICAgdGhpcy50cmF2ZWxEdXJhdGlvbk1heCA9IHNvcnRlZFtzb3J0ZWQubGVuZ3RoIC0gMV1bMF07XG5cbiAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhyZXBvcnRGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2UgYXJlIGluIGEgc2VyaWVzLCB1c2UgdGhlIHBpbmdJbnRlcnZhbCB2YWx1ZVxuICAgICAgICAgIHRoaXMucGluZ0RlbGF5ID0gdGhpcy5waW5nU2VyaWVzUGVyaW9kO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9fc3luY0xvb3Aoc2VuZEZ1bmN0aW9uLCByZXBvcnRGdW5jdGlvbik7XG4gICAgICAgIH0sIE1hdGguY2VpbCgxMDAwICogdGhpcy5waW5nRGVsYXkpKTtcbiAgICAgIH0gIC8vIHBpbmcgYW5kIHBvbmcgSUQgbWF0Y2hcbiAgICB9KTsgLy8gcmVjZWl2ZSBmdW5jdGlvblxuXG4gICAgdGhpcy5fX3N5bmNMb29wKHNlbmRGdW5jdGlvbiwgcmVwb3J0RnVuY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsb2NhbCB0aW1lLCBvciBjb252ZXJ0IGEgc3luY2hyb25pc2VkIHRpbWUgdG8gYSBsb2NhbCB0aW1lLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5nZXRMb2NhbFRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN5bmNUaW1lIHVuZGVmaW5lZCB0byBnZXQgbG9jYWwgdGltZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBsb2NhbCB0aW1lLCBpbiBzZWNvbmRzXG4gICAqL1xuICBnZXRMb2NhbFRpbWUoc3luY1RpbWUpIHtcbiAgICBpZiAodHlwZW9mIHN5bmNUaW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gY29udmVyc2lvbjogdChUKSA9IHQwICsgKFQgLSBUMCkgLyBSXG4gICAgICByZXR1cm4gdGhpcy5jbGllbnRUaW1lUmVmZXJlbmNlXG4gICAgICAgICsgKHN5bmNUaW1lIC0gdGhpcy5zZXJ2ZXJUaW1lUmVmZXJlbmNlKSAvIHRoaXMuZnJlcXVlbmN5UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWQgbG9jYWwgY2xvY2tcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbWVGdW5jdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3luY2hyb25pc2VkIHRpbWUsIG9yIGNvbnZlcnQgYSBsb2NhbCB0aW1lIHRvIGEgc3luY2hyb25pc2VkIHRpbWUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBTeW5jQ2xpZW50fmdldFN5bmNUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhbFRpbWUgdW5kZWZpbmVkIHRvIGdldCBzeW5jaHJvbmlzZWQgdGltZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBzeW5jaHJvbmlzZWQgdGltZSwgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldFN5bmNUaW1lKGxvY2FsVGltZSA9IHRoaXMuZ2V0TG9jYWxUaW1lKCkpIHtcbiAgICAvLyBhbHdheXMgY29udmVydDogVCh0KSA9IFQwICsgUiAqICh0IC0gdDApXG4gICAgcmV0dXJuIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZVxuICAgICAgKyB0aGlzLmZyZXF1ZW5jeVJhdGlvICogKGxvY2FsVGltZSAtIHRoaXMuY2xpZW50VGltZVJlZmVyZW5jZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3luY0NsaWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG4iLCJjb25zdCBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG5cbi8qKlxuICogRXhwb3NlIGEgdW5pcXVlIGF1ZGlvIGNvbnRleHQgc2luZ2xldG9uIGFzIHRoZSBkZWZhdWx0IGF1ZGlvXG4gKiBjb250ZXh0IHVzZWQgYnkgdGhlIGNvbXBvbmVudHMgb2YgdGhlIFdhdmVzIEF1ZGlvIGxpYnJhcnkgYW5kXG4gKiBhcHBsaWNhdGlvbnMgdXNpbmcgdGhlIGxpYnJhcnkuXG4gKlxuICogQHR5cGUgQXVkaW9Db250ZXh0XG4gKiBAbmFtZSBhdWRpb0NvbnRleHRcbiAqIEBjb25zdGFudFxuICogQGdsb2JhbFxuICogQGluc3RhbmNlXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IGF1ZGlvQ29udGV4dCA9IGF1ZGlvLmF1ZGlvQ29udGV4dDtcbiAqL1xubGV0IGF1ZGlvQ29udGV4dCA9IG51bGw7XG5cbmlmIChBdWRpb0NvbnRleHQpIHtcbiAgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuXG4gIGlmICgvKGlQaG9uZXxpUGFkKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgPCA0NDEwMCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgNDQxMDApO1xuICAgIGNvbnN0IGR1bW15ID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgIGR1bW15LmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICBkdW1teS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgZHVtbXkuc3RhcnQoMCk7XG4gICAgZHVtbXkuZGlzY29ubmVjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGF1ZGlvQ29udGV4dDtcbiIsImltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4vdGltZS1lbmdpbmUnO1xuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi9hdWRpby1jb250ZXh0JztcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgYXVkaW8gcmVsYXRlZCB0aW1lIGVuZ2luZSBjb21wb25lbnRzLiBJdCBpc1xuICogdXNlZCB0byBoYW5kbGUgYXVkaW8gcmVsYXRlZCBldmVudHMgc3VjaCBhcyB0aGUgcGxheWJhY2sgb2YgYSBtZWRpYSBzdHJlYW0uXG4gKiBJdCBleHRlbmRzIHRoZSBUaW1lRW5naW5lIGNsYXNzIGJ5IHRoZSBzdGFuZGFyZCB3ZWIgYXVkaW8gbm9kZSBtZXRob2RzXG4gKiBjb25uZWN0IGFuZCBkaXNjb25uZWN0LlxuICpcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvYXVkaW8tdGltZS1lbmdpbmUuaHRtbH1cbiAqXG4gKiBAZXh0ZW5kcyBUaW1lRW5naW5lXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqXG4gKiBjbGFzcyBNeUVuZ2luZSBleHRlbmRzIGF1ZGlvLkF1ZGlvVGltZUVuZ2luZSB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKCk7XG4gKiAgICAgLy8gLi4uXG4gKiAgIH1cbiAqIH1cbiAqL1xuY2xhc3MgQXVkaW9UaW1lRW5naW5lIGV4dGVuZHMgVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKGF1ZGlvQ29udGV4dCA9IGRlZmF1bHRBdWRpb0NvbnRleHQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQXVkaW8gY29udGV4dCB1c2VkIGJ5IHRoZSBUaW1lRW5naW5lLCBkZWZhdWx0IHRvIHRoZSBnbG9iYWwgYXVkaW9Db250ZXh0XG4gICAgICpcbiAgICAgKiBAbmFtZSBhdWRpb0NvbnRleHRcbiAgICAgKiBAdHlwZSBBdWRpb0NvbnRleHRcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXG4gICAgICogQHNlZSBhdWRpb0NvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIE91dHB1dCBhdWRpbyBub2RlLiBCeSBkZWZhdWx0IHRoZSBjb25uZWN0IG1ldGhvZCBjb25uZWN0cyBhIGdpdmVuIG5vZGVcbiAgICAgKiB0byB0aGlzIG91dHB1dCBub2RlLlxuICAgICAqXG4gICAgICogQG5hbWUgb3V0cHV0Tm9kZVxuICAgICAqIEB0eXBlIEF1ZGlvTm9kZVxuICAgICAqIEBtZW1iZXJvZiBBdWRpb1RpbWVFbmdpbmVcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdGhpcy5vdXRwdXROb2RlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIGFuIGF1ZGlvIG5vZGUgKGUuZy4gYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKVxuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZX0gdGFyZ2V0IC0gVGFyZ2V0IGF1ZGlvIG5vZGVcbiAgICovXG4gIGNvbm5lY3QodGFyZ2V0KSB7XG4gICAgdGhpcy5vdXRwdXROb2RlLmNvbm5lY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IGZyb20gYW4gYXVkaW8gbm9kZSAoZS5nLiBhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pLiBJZiB1bmRlZmluZWRcbiAgICogZGlzY29ubmVjdCBmcm9tIGFsbCB0YXJnZXQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9Ob2RlfSB0YXJnZXQgLSBUYXJnZXQgYXVkaW8gbm9kZS5cbiAgICovXG4gIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIHRoaXMub3V0cHV0Tm9kZS5kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVGltZUVuZ2luZTtcbiIsIi8vIHdvcmtzIGJ5IHJlZmVyZW5jZVxuZnVuY3Rpb24gc3dhcChhcnIsIGkxLCBpMikge1xuICBjb25zdCB0bXAgPSBhcnJbaTFdO1xuICBhcnJbaTFdID0gYXJyW2kyXTtcbiAgYXJyW2kyXSA9IHRtcDtcbn1cblxuLy8gaHR0cHM6Ly9qc3BlcmYuY29tL2pzLWZvci1sb29wLXZzLWFycmF5LWluZGV4b2YvMzQ2XG5mdW5jdGlvbiBpbmRleE9mKGFyciwgZWwpIHtcbiAgY29uc3QgbCA9IGFyci5sZW5ndGg7XG4gIC8vIGlnbm9yZSBmaXJzdCBlbGVtZW50IGFzIGl0IGNhbid0IGJlIGEgZW50cnlcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldID09PSBlbCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIERlZmluZSBpZiBgdGltZTFgIHNob3VsZCBiZSBsb3dlciBpbiB0aGUgdG9wb2dyYXBoeSB0aGFuIGB0aW1lMmAuXG4gKiBJcyBkeW5hbWljYWxseSBhZmZlY3RlZCB0byB0aGUgcHJpb3JpdHkgcXVldWUgYWNjb3JkaW5nIHRvIGhhbmRsZSBgbWluYCBhbmQgYG1heGAgaGVhcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUxXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IF9pc0xvd2VyTWF4SGVhcCA9IGZ1bmN0aW9uKHRpbWUxLCB0aW1lMikge1xuICByZXR1cm4gdGltZTEgPCB0aW1lMjtcbn07XG5cbmNvbnN0IF9pc0xvd2VyTWluSGVhcCA9IGZ1bmN0aW9uKHRpbWUxLCB0aW1lMikge1xuICByZXR1cm4gdGltZTEgPiB0aW1lMjtcbn07XG5cbi8qKlxuICogRGVmaW5lIGlmIGB0aW1lMWAgc2hvdWxkIGJlIGhpZ2hlciBpbiB0aGUgdG9wb2dyYXBoeSB0aGFuIGB0aW1lMmAuXG4gKiBJcyBkeW5hbWljYWxseSBhZmZlY3RlZCB0byB0aGUgcHJpb3JpdHkgcXVldWUgYWNjb3JkaW5nIHRvIGhhbmRsZSBgbWluYCBhbmQgYG1heGAgaGVhcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUxXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IF9pc0hpZ2hlck1heEhlYXAgPSBmdW5jdGlvbih0aW1lMSwgdGltZTIpIHtcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XG59O1xuXG5jb25zdCBfaXNIaWdoZXJNaW5IZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XG4gIHJldHVybiB0aW1lMSA8IHRpbWUyO1xufTtcblxuY29uc3QgUE9TSVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbi8qKlxuICogUHJpb3JpdHkgcXVldWUgaW1wbGVtZW50aW5nIGEgYmluYXJ5IGhlYXAuXG4gKiBBY3RzIGFzIGEgbWluIGhlYXAgYnkgZGVmYXVsdCwgY2FuIGJlIGR5bmFtaWNhbGx5IGNoYW5nZWQgdG8gYSBtYXggaGVhcFxuICogYnkgc2V0dGluZyBgcmV2ZXJzZWAgdG8gdHJ1ZS5cbiAqXG4gKiBfbm90ZV86IHRoZSBxdWV1ZSBjcmVhdGVzIGFuZCBtYWludGFpbnMgYSBuZXcgcHJvcGVydHkgKGkuZS4gYHF1ZXVlVGltZWApXG4gKiB0byBlYWNoIG9iamVjdCBhZGRlZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2hlYXBMZW5ndGg9MTAwXSAtIERlZmF1bHQgc2l6ZSBvZiB0aGUgYXJyYXkgdXNlZCB0byBjcmVhdGUgdGhlIGhlYXAuXG4gKi9cbmNsYXNzIFByaW9yaXR5UXVldWUge1xuICBjb25zdHJ1Y3RvcihoZWFwTGVuZ3RoID0gMTAwKSB7XG4gICAgLyoqXG4gICAgICogUG9pbnRlciB0byB0aGUgZmlyc3QgZW1wdHkgaW5kZXggb2YgdGhlIGhlYXAuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxuICAgICAqIEBuYW1lIF9jdXJyZW50TGVuZ3RoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50TGVuZ3RoID0gMTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHRoZSBzb3J0ZWQgaW5kZXhlcyBvZiB0aGUgZW50cmllcywgdGhlIGFjdHVhbCBoZWFwLiBJZ25vcmUgdGhlIGluZGV4IDAuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBtZW1iZXJvZiBQcmlvcml0eVF1ZXVlXG4gICAgICogQG5hbWUgX2hlYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hlYXAgPSBuZXcgQXJyYXkoaGVhcExlbmd0aCArIDEpO1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGUgcXVldWU6IGBtaW5gIGhlYXAgaWYgYGZhbHNlYCwgYG1heGAgaGVhcCBpZiBgdHJ1ZWBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxuICAgICAqIEBuYW1lIF9yZXZlcnNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXZlcnNlID0gbnVsbDtcblxuICAgIC8vIGluaXRpYWxpemUgY29tcGFyZSBmdW5jdGlvbnNcbiAgICB0aGlzLnJldmVyc2UgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaW1lIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBiaW5hcnkgaGVhcC5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldCB0aW1lKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50TGVuZ3RoID4gMSlcbiAgICAgIHJldHVybiB0aGlzLl9oZWFwWzFdLnF1ZXVlVGltZTtcblxuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJzdCBlbGVtZW50IGluIHRoZSBiaW5hcnkgaGVhcC5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhcFsxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBxdWV1ZSAobWF4IGhlYXAgaWYgdHJ1ZSwgbWluIGhlYXAgaWYgZmFsc2UpLFxuICAgKiByZWJ1aWxkIHRoZSBoZWFwIHdpdGggdGhlIGV4aXN0aW5nIGVudHJpZXMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2V0IHJldmVyc2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3JldmVyc2UpIHtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMuX3JldmVyc2UgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5faXNMb3dlciA9IF9pc0xvd2VyTWF4SGVhcDtcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNYXhIZWFwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNMb3dlciA9IF9pc0xvd2VyTWluSGVhcDtcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNaW5IZWFwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1aWxkSGVhcCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCByZXZlcnNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpeCB0aGUgaGVhcCBieSBtb3ZpbmcgYW4gZW50cnkgdG8gYSBuZXcgdXBwZXIgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbnRyeSB0byBtb3ZlLlxuICAgKi9cbiAgX2J1YmJsZVVwKHN0YXJ0SW5kZXgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLl9oZWFwW3N0YXJ0SW5kZXhdO1xuXG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICBsZXQgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gMik7XG4gICAgbGV0IHBhcmVudCA9IHRoaXMuX2hlYXBbcGFyZW50SW5kZXhdO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcihlbnRyeS5xdWV1ZVRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKSB7XG4gICAgICBzd2FwKHRoaXMuX2hlYXAsIGluZGV4LCBwYXJlbnRJbmRleCk7XG5cbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICBwYXJlbnRJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyAyKTtcbiAgICAgIHBhcmVudCA9IHRoaXMuX2hlYXBbcGFyZW50SW5kZXhdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIGhlYXAgYnkgbW92aW5nIGFuIGVudHJ5IHRvIGEgbmV3IGxvd2VyIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgZW50cnkgdG8gbW92ZS5cbiAgICovXG4gIF9idWJibGVEb3duKHN0YXJ0SW5kZXgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLl9oZWFwW3N0YXJ0SW5kZXhdO1xuXG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICBsZXQgYzFpbmRleCA9IGluZGV4ICogMjtcbiAgICBsZXQgYzJpbmRleCA9IGMxaW5kZXggKyAxO1xuICAgIGxldCBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xuICAgIGxldCBjaGlsZDIgPSB0aGlzLl9oZWFwW2MyaW5kZXhdO1xuXG4gICAgd2hpbGUgKChjaGlsZDEgJiYgdGhpcy5faXNMb3dlcihlbnRyeS5xdWV1ZVRpbWUsIGNoaWxkMS5xdWV1ZVRpbWUpKcKgfHxcbiAgICAgICAgICAgKGNoaWxkMiAmJiB0aGlzLl9pc0xvd2VyKGVudHJ5LnF1ZXVlVGltZSwgY2hpbGQyLnF1ZXVlVGltZSkpKVxuICAgIHtcbiAgICAgIC8vIHN3YXAgd2l0aCB0aGUgbWluaW11bSBjaGlsZFxuICAgICAgbGV0IHRhcmdldEluZGV4O1xuXG4gICAgICBpZiAoY2hpbGQyKVxuICAgICAgICB0YXJnZXRJbmRleCA9IHRoaXMuX2lzSGlnaGVyKGNoaWxkMS5xdWV1ZVRpbWUsIGNoaWxkMi5xdWV1ZVRpbWUpID8gYzFpbmRleCA6IGMyaW5kZXg7XG4gICAgICBlbHNlXG4gICAgICAgIHRhcmdldEluZGV4ID0gYzFpbmRleDtcblxuICAgICAgc3dhcCh0aGlzLl9oZWFwLCBpbmRleCwgdGFyZ2V0SW5kZXgpO1xuXG4gICAgICAvLyB1cGRhdGUgdG8gZmluZCBuZXh0IGNoaWxkcmVuXG4gICAgICBpbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgYzFpbmRleCA9IGluZGV4ICogMjtcbiAgICAgIGMyaW5kZXggPSBjMWluZGV4ICsgMTtcbiAgICAgIGNoaWxkMSA9IHRoaXMuX2hlYXBbYzFpbmRleF07XG4gICAgICBjaGlsZDIgPSB0aGlzLl9oZWFwW2MyaW5kZXhdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCB0aGUgaGVhcCAoZnJvbSBib3R0b20gdXApLlxuICAgKi9cbiAgYnVpbGRIZWFwKCkge1xuICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGludGVybmFsIG5vZGVcbiAgICAvLyBAdG9kbyAtIG1ha2Ugc3VyZSB0aGF0J3MgdGhlIHJpZ2h0IHdheSB0byBkby5cbiAgICBsZXQgbWF4SW5kZXggPSBNYXRoLmZsb29yKCh0aGlzLl9jdXJyZW50TGVuZ3RoIC0gMSkgLyAyKTtcblxuICAgIGZvciAobGV0IGkgPSBtYXhJbmRleDsgaSA+IDA7IGktLSlcbiAgICAgIHRoaXMuX2J1YmJsZURvd24oaSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGEgbmV3IG9iamVjdCBpbiB0aGUgYmluYXJ5IGhlYXAgYW5kIHNvcnQgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIGluc2VydC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBUaW1lIGF0IHdoaWNoIHRoZSBlbnRyeSBzaG91bGQgYmUgb3JkZXJlci5cbiAgICogQHJldHVybnMge051bWJlcn0gLSBUaW1lIG9mIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cbiAgICovXG4gIGluc2VydChlbnRyeSwgdGltZSkge1xuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGVudHJ5LnF1ZXVlVGltZSA9IHRpbWU7XG4gICAgICAvLyBhZGQgdGhlIG5ldyBlbnRyeSBhdCB0aGUgZW5kIG9mIHRoZSBoZWFwXG4gICAgICB0aGlzLl9oZWFwW3RoaXMuX2N1cnJlbnRMZW5ndGhdID0gZW50cnk7XG4gICAgICAvLyBidWJibGUgaXQgdXBcbiAgICAgIHRoaXMuX2J1YmJsZVVwKHRoaXMuX2N1cnJlbnRMZW5ndGgpO1xuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCArPSAxO1xuXG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgIH1cblxuICAgIGVudHJ5LnF1ZXVlVGltZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgYSBnaXZlbiBlbnRyeSB0byBhIG5ldyBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gbW92ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBUaW1lIGF0IHdoaWNoIHRoZSBlbnRyeSBzaG91bGQgYmUgb3JkZXJlci5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIFRpbWUgb2YgZmlyc3QgZW50cnkgaW4gdGhlIGhlYXAuXG4gICAqL1xuICBtb3ZlKGVudHJ5LCB0aW1lKSB7XG4gICAgaWYgKE1hdGguYWJzKHRpbWUpICE9PSBQT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgY29uc3QgaW5kZXggPSBpbmRleE9mKHRoaXMuX2hlYXAsIGVudHJ5KTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBlbnRyeS5xdWV1ZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBkZWZpbmUgaWYgdGhlIGVudHJ5IHNob3VsZCBiZSBidWJibGVkIHVwIG9yIGRvd25cbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5faGVhcFtNYXRoLmZsb29yKGluZGV4IC8gMildO1xuXG4gICAgICAgIGlmIChwYXJlbnQgJiYgdGhpcy5faXNIaWdoZXIodGltZSwgcGFyZW50LnF1ZXVlVGltZSkpXG4gICAgICAgICAgdGhpcy5fYnViYmxlVXAoaW5kZXgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5fYnViYmxlRG93bihpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRpbWU7XG4gICAgfVxuXG4gICAgZW50cnkucXVldWVUaW1lID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzLnJlbW92ZShlbnRyeSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGhlYXAgYW5kIGZpeCB0aGUgaGVhcC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGltZSBvZiBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cbiAgICovXG4gIHJlbW92ZShlbnRyeSkge1xuICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBlbnRyeVxuICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZih0aGlzLl9oZWFwLCBlbnRyeSk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLl9jdXJyZW50TGVuZ3RoIC0gMTtcblxuICAgICAgLy8gaWYgdGhlIGVudHJ5IGlzIHRoZSBsYXN0IG9uZVxuICAgICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gaGVhcFxuICAgICAgICB0aGlzLl9oZWFwW2xhc3RJbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGxlbmd0aFxuICAgICAgICB0aGlzLl9jdXJyZW50TGVuZ3RoID0gbGFzdEluZGV4O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzd2FwIHdpdGggdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgaGVhcFxuICAgICAgICBzd2FwKHRoaXMuX2hlYXAsIGluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSBoZWFwXG4gICAgICAgIHRoaXMuX2hlYXBbbGFzdEluZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9idWJibGVEb3duKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJ1YmJsZSB0aGUgKGV4IGxhc3QpIGVsZW1lbnQgdXAgb3IgZG93biBhY2NvcmRpbmcgdG8gaXRzIG5ldyBjb250ZXh0XG4gICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9oZWFwW2luZGV4XTtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9oZWFwW01hdGguZmxvb3IoaW5kZXggLyAyKV07XG5cbiAgICAgICAgICBpZiAocGFyZW50ICYmIHRoaXMuX2lzSGlnaGVyKGVudHJ5LnF1ZXVlVGltZSwgcGFyZW50LnF1ZXVlVGltZSkpXG4gICAgICAgICAgICB0aGlzLl9idWJibGVVcChpbmRleCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fYnViYmxlRG93bihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIGN1cnJlbnQgbGVuZ3RoXG4gICAgICB0aGlzLl9jdXJyZW50TGVuZ3RoID0gbGFzdEluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRpbWU7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHF1ZXVlLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY3VycmVudExlbmd0aCA9IDE7XG4gICAgdGhpcy5faGVhcCA9IG5ldyBBcnJheSh0aGlzLl9oZWFwLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBpZiB0aGUgcXVldWUgY29udGFpbnMgdGhlIGdpdmVuIGBlbnRyeWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhcyhlbnRyeSkge1xuICAgIHJldHVybiB0aGlzLl9oZWFwLmluZGV4T2YoZW50cnkpICE9PSAtMTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcmlvcml0eVF1ZXVlO1xuIiwiLyoqXG4gKiBTY2hlZHVsaW5nUXVldWUgYmFzZSBjbGFzc1xuICogaHR0cDovL3dhdmVzanMuZ2l0aHViLmlvL2F1ZGlvLyNhdWRpby1zY2hlZHVsaW5nLXF1ZXVlXG4gKlxuICogTm9yYmVydC5TY2huZWxsQGlyY2FtLmZyXG4gKiBDb3B5cmlnaHQgMjAxNCwgMjAxNSBJUkNBTSDigJPCoENlbnRyZSBQb21waWRvdVxuICovXG5cbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vcHJpb3JpdHktcXVldWUnO1xuaW1wb3J0IFRpbWVFbmdpbmUgZnJvbSAnLi90aW1lLWVuZ2luZSc7XG5cbi8qKlxuICogQGNsYXNzIFNjaGVkdWxpbmdRdWV1ZVxuICogQGV4dGVuZHMgVGltZUVuZ2luZVxuICovXG5jbGFzcyBTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBUaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX19xdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gICAgdGhpcy5fX2VuZ2luZXMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICAvLyBUaW1lRW5naW5lICdzY2hlZHVsZWQnIGludGVyZmFjZVxuICBhZHZhbmNlVGltZSh0aW1lKSB7XG4gICAgY29uc3QgZW5naW5lID0gdGhpcy5fX3F1ZXVlLmhlYWQ7XG4gICAgY29uc3QgbmV4dEVuZ2luZVRpbWUgPSBlbmdpbmUuYWR2YW5jZVRpbWUodGltZSk7XG5cbiAgICBpZiAoIW5leHRFbmdpbmVUaW1lKSB7XG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX19lbmdpbmVzLmRlbGV0ZShlbmdpbmUpO1xuICAgICAgdGhpcy5fX3F1ZXVlLnJlbW92ZShlbmdpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fcXVldWUubW92ZShlbmdpbmUsIG5leHRFbmdpbmVUaW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX3F1ZXVlLnRpbWU7XG4gIH1cblxuICAvLyBUaW1lRW5naW5lIG1hc3RlciBtZXRob2QgdG8gYmUgaW1wbGVtZW50ZWQgYnkgZGVyaXZlZCBjbGFzc1xuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBjYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lXG4gIGRlZmVyKGZ1biwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcbiAgICBpZiAoIShmdW4gaW5zdGFuY2VvZiBGdW5jdGlvbikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGRlZmVyZWQgYnkgc2NoZWR1bGVyXCIpO1xuXG4gICAgdGhpcy5hZGQoe1xuICAgICAgYWR2YW5jZVRpbWU6IGZ1bmN0aW9uKHRpbWUpIHsgZnVuKHRpbWUpOyB9LCAvLyBtYWtlIHN1ciB0aGF0IHRoZSBhZHZhbmNlVGltZSBtZXRob2QgZG9lcyBub3QgcmV0dXJtIGFueXRoaW5nXG4gICAgfSwgdGltZSk7XG4gIH1cblxuICAvLyBhZGQgYSB0aW1lIGVuZ2luZSB0byB0aGUgc2NoZWR1bGVyXG4gIGFkZChlbmdpbmUsIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKCFUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gc2NoZWR1bGVyXCIpO1xuXG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcblxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xuXG4gICAgLy8gYWRkIHRvIGVuZ2luZXMgYW5kIHF1ZXVlXG4gICAgdGhpcy5fX2VuZ2luZXMuYWRkKGVuZ2luZSk7XG4gICAgY29uc3QgbmV4dFRpbWUgPSB0aGlzLl9fcXVldWUuaW5zZXJ0KGVuZ2luZSwgdGltZSk7XG5cbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXG4gICAgdGhpcy5yZXNldFRpbWUobmV4dFRpbWUpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGEgdGltZSBlbmdpbmUgZnJvbSB0aGUgcXVldWVcbiAgcmVtb3ZlKGVuZ2luZSkge1xuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGlzIHNjaGVkdWxlclwiKTtcblxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xuXG4gICAgLy8gcmVtb3ZlIGZyb20gYXJyYXkgYW5kIHF1ZXVlXG4gICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XG4gICAgY29uc3QgbmV4dFRpbWUgPSB0aGlzLl9fcXVldWUucmVtb3ZlKGVuZ2luZSk7XG5cbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXG4gICAgdGhpcy5yZXNldFRpbWUobmV4dFRpbWUpO1xuICB9XG5cbiAgLy8gcmVzZXQgbmV4dCBlbmdpbmUgdGltZVxuICByZXNldEVuZ2luZVRpbWUoZW5naW5lLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGlzIHNjaGVkdWxlclwiKTtcblxuICAgIGxldCBuZXh0VGltZTtcblxuICAgIGlmICh0aGlzLl9fcXVldWUuaGFzKGVuZ2luZSkpXG4gICAgICBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5tb3ZlKGVuZ2luZSwgdGltZSk7XG4gICAgZWxzZVxuICAgICAgbmV4dFRpbWUgPSB0aGlzLl9fcXVldWUuaW5zZXJ0KGVuZ2luZSwgdGltZSk7XG5cbiAgICB0aGlzLnJlc2V0VGltZShuZXh0VGltZSk7XG4gIH1cblxuICAvLyBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZW5naW5lIGlzIHNjaGVkdWxlZFxuICBoYXMoZW5naW5lKSB7XG4gICAgcmV0dXJuIHRoaXMuX19lbmdpbmVzLmhhcyhlbmdpbmUpO1xuICB9XG5cbiAgLy8gY2xlYXIgcXVldWVcbiAgY2xlYXIoKSB7XG4gICAgZm9yKGxldCBlbmdpbmUgb2YgdGhpcy5fX2VuZ2luZXMpXG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcblxuICAgIHRoaXMuX19xdWV1ZS5jbGVhcigpO1xuICAgIHRoaXMuX19lbmdpbmVzLmNsZWFyKCk7XG4gICAgdGhpcy5yZXNldFRpbWUoSW5maW5pdHkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjaGVkdWxpbmdRdWV1ZVxuIiwiLyoqXG4gKiBCYXNlIGNsYXNzIGZvciB0aW1lIGVuZ2luZXNcbiAqXG4gKiBBIHRpbWUgZW5naW5lIGdlbmVyYXRlcyBtb3JlIG9yIGxlc3MgcmVndWxhciBldmVudHMgYW5kL29yIHBsYXlzIGJhY2sgYVxuICogbWVkaWEgc3RyZWFtLiBJdCBpbXBsZW1lbnRzIG9uZSBvciBtdWx0aXBsZSBpbnRlcmZhY2VzIHRvIGJlIGRyaXZlbiBieSBhXG4gKiBtYXN0ZXIgKGkuZS4gYSBTY2hlZHVsZXIsIGEgVHJhbnNwb3J0IG9yIGEgUGxheUNvbnRyb2wpIGluIHN5bmNocm9uaXphdGlvblxuICogd2l0aCBvdGhlciBlbmdpbmVzLiBUaGUgcHJvdmlkZWQgaW50ZXJmYWNlcyBhcmUgc2NoZWR1bGVkLCB0cmFuc3BvcnRlZCxcbiAqIGFuZCBwbGF5LWNvbnRyb2xsZWQuXG4gKlxuICpcbiAqICMjIyMgVGhlIGBzY2hlZHVsZWRgIGludGVyZmFjZVxuICpcbiAqIFRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY2hyb25pemluZyBhbiBlbmdpbmUgdG8gYSBtb25vdG9ub3VzIHRpbWVcbiAqIGFzIGl0IGlzIHByb3ZpZGVkIGJ5IHRoZSBTY2hlZHVsZXIgbWFzdGVyLlxuICpcbiAqICMjIyMjIyBgYWR2YW5jZVRpbWUodGltZSA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcbiAqXG4gKiBUaGUgYGFkdmFuY2VUaW1lYCBtZXRob2QgaGFzIHRvIGJlIGltcGxlbWVudGVkIGJ5IGFuIGBUaW1lRW5naW5lYCBhcyBwYXJ0IG9mIHRoZVxuICogc2NoZWR1bGVkIGludGVyZmFjZS4gVGhlIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1hc3RlciAoZS5nLiB0aGUgc2NoZWR1bGVyKS5cbiAqIEl0IGdlbmVyYXRlcyBhbiBldmVudCBhbmQgdG8gcmV0dXJucyB0aGUgdGltZSBvZiB0aGUgbmV4dCBldmVudCAoaS5lLiB0aGUgbmV4dFxuICogY2FsbCBvZiBhZHZhbmNlVGltZSkuIFRoZSByZXR1cm5lZCB0aW1lIGhhcyB0byBiZSBncmVhdGVyIHRoYW4gdGhlIHRpbWVcbiAqIHJlY2VpdmVkIGFzIGFyZ3VtZW50IG9mIHRoZSBtZXRob2QuIEluIGNhc2UgdGhhdCBhIFRpbWVFbmdpbmUgaGFzIHRvIGdlbmVyYXRlXG4gKiBtdWx0aXBsZSBldmVudHMgYXQgdGhlIHNhbWUgdGltZSwgdGhlIGVuZ2luZSBoYXMgdG8gaW1wbGVtZW50IGl0cyBvd24gbG9vcFxuICogd2hpbGUoZXZlbnQudGltZSA8PSB0aW1lKSBhbmQgcmV0dXJuIHRoZSB0aW1lIG9mIHRoZSBuZXh0IGV2ZW50IChpZiBhbnkpLlxuICpcbiAqICMjIyMjIyBgcmVzZXRUaW1lKHRpbWU9dW5kZWZpbmVkIDpOdW1iZXIpYFxuICpcbiAqIFRoZSBgcmVzZXRUaW1lYCBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIGBUaW1lRW5naW5lYCBiYXNlIGNsYXNzLiBBbiBlbmdpbmUgbWF5XG4gKiBjYWxsIHRoaXMgbWV0aG9kIHRvIHJlc2V0IGl0cyBuZXh0IGV2ZW50IHRpbWUgKGUuZy4gd2hlbiBhIHBhcmFtZXRlciBpc1xuICogY2hhbmdlZCB0aGF0IGluZmx1ZW5jZXMgdGhlIGVuZ2luZSdzIHRlbXBvcmFsIGJlaGF2aW9yKS4gV2hlbiBubyBhcmd1bWVudFxuICogaXMgZ2l2ZW4sIHRoZSB0aW1lIGlzIHJlc2V0IHRvIHRoZSBjdXJyZW50IG1hc3RlciB0aW1lLiBXaGVuIGNhbGxpbmcgdGhlXG4gKiBtZXRob2Qgd2l0aCBJbmZpbml0eSB0aGUgZW5naW5lIGlzIHN1c3BlbmRlZCB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbSB0aGVcbiAqIG1hc3Rlci5cbiAqXG4gKlxuICogIyMjIyBUaGUgYHRyYW5zcG9ydGVkYCBpbnRlcmZhY2VcbiAqXG4gKiBUaGUgdHJhbnNwb3J0ZWQgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY2hyb25pemluZyBhbiBlbmdpbmUgdG8gYSBwb3NpdGlvblxuICogKGkuZS4gbWVkaWEgcGxheWJhY2sgdGltZSkgdGhhdCBjYW4gcnVuIGZvcndhcmQgYW5kIGJhY2t3YXJkIGFuZCBqdW1wIGFzIGl0XG4gKiBpcyBwcm92aWRlZCBieSB0aGUgVHJhbnNwb3J0IG1hc3Rlci5cbiAqXG4gKiAjIyMjIyMgYHN5bmNQb3NpdGlvbih0aW1lIDpOdW1iZXIsIHBvc2l0aW9uIDpOdW1iZXIsIHNwZWVkIDpOdW1iZXIpIC0+IHtOdW1iZXJ9YFxuICpcbiAqIFRoZSBgc3luY1Bvc2l0b25gIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBgVGltZUVuZ2luZWAgYXMgcGFydCBvZiB0aGVcbiAqIHRyYW5zcG9ydGVkIGludGVyZmFjZS4gVGhlIG1ldGhvZCBzeW5jUG9zaXRvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIG1hc3RlclxuICogb2YgYSB0cmFuc3BvcnRlZCBlbmdpbmUgaGFzIHRvIChyZS0pc3luY2hyb25pemUgdGhlIGVuZ2luZSdzIHBvc2l0aW9uLiBUaGlzXG4gKiBpcyBmb3IgZXhhbXBsZSByZXF1aXJlZCB3aGVuIHRoZSBtYXN0ZXIgKHJlLSlzdGFydHMgcGxheWJhY2ssIGp1bXBzIHRvIGFuXG4gKiBhcmJpdHJhcnkgcG9zaXRpb24sIGFuZCB3aGVuIHJldmVyc2luZyBwbGF5YmFjayBkaXJlY3Rpb24uIFRoZSBtZXRob2QgcmV0dXJuc1xuICogdGhlIG5leHQgcG9zaXRpb24gb2YgdGhlIGVuZ2luZSBpbiB0aGUgZ2l2ZW4gcGxheWJhY2sgZGlyZWN0aW9uXG4gKiAoaS5lLiBgc3BlZWQgPCAwYCBvciBgc3BlZWQgPiAwYCkuXG4gKlxuICogIyMjIyMjIGBhZHZhbmNlUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcbiAqXG4gKiBUaGUgYGFkdmFuY2VQb3NpdGlvbmAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIGBUaW1lRW5naW5lYCBhcyBwYXJ0XG4gKiBvZiB0aGUgdHJhbnNwb3J0ZWQgaW50ZXJmYWNlLiBUaGUgbWFzdGVyIGNhbGxzIHRoZSBhZHZhbmNlUG9zaXRvbiBtZXRob2Qgd2hlblxuICogdGhlIGVuZ2luZSdzIGV2ZW50IHBvc2l0aW9uIGlzIHJlYWNoZWQuIFRoZSBtZXRob2QgZ2VuZXJhdGVzIGFuIGV2ZW50IGFuZFxuICogcmV0dXJucyB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgZ2l2ZW4gcGxheWJhY2sgZGlyZWN0aW9uIChpLmUuIHNwZWVkIDwgMCBvclxuICogc3BlZWQgPiAwKS4gVGhlIHJldHVybmVkIHBvc2l0aW9uIGhhcyB0byBiZSBncmVhdGVyIChpLmUuIHdoZW4gc3BlZWQgPiAwKVxuICogb3IgbGVzcyAoaS5lLiB3aGVuIHNwZWVkIDwgMCkgdGhhbiB0aGUgcG9zaXRpb24gcmVjZWl2ZWQgYXMgYXJndW1lbnQgb2YgdGhlXG4gKiBtZXRob2QuXG4gKlxuICogIyMjIyMjIGByZXNldFBvc2l0aW9uKHBvc2l0aW9uPXVuZGVmaW5lZCA6TnVtYmVyKWBcbiAqXG4gKiBUaGUgcmVzZXRQb3NpdGlvbiBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIFRpbWVFbmdpbmUgYmFzZSBjbGFzcy4gQW4gZW5naW5lXG4gKiBtYXkgY2FsbCB0aGlzIG1ldGhvZCB0byByZXNldCBpdHMgbmV4dCBldmVudCBwb3NpdGlvbi4gV2hlbiBubyBhcmd1bWVudFxuICogaXMgZ2l2ZW4sIHRoZSB0aW1lIGlzIHJlc2V0IHRvIHRoZSBjdXJyZW50IG1hc3RlciB0aW1lLiBXaGVuIGNhbGxpbmcgdGhlXG4gKiBtZXRob2Qgd2l0aCBJbmZpbml0eSB0aGUgZW5naW5lIGlzIHN1c3BlbmRlZCB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbVxuICogdGhlIG1hc3Rlci5cbiAqXG4gKlxuICogIyMjIyBUaGUgc3BlZWQtY29udHJvbGxlZCBpbnRlcmZhY2VcbiAqXG4gKiBUaGUgXCJzcGVlZC1jb250cm9sbGVkXCIgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY3Jvbml6aW5nIGFuIGVuZ2luZSB0aGF0IGlzXG4gKiBuZWl0aGVyIGRyaXZlbiB0aHJvdWdoIHRoZSBzY2hlZHVsZWQgbm9yIHRoZSB0cmFuc3BvcnRlZCBpbnRlcmZhY2UuIFRoZVxuICogaW50ZXJmYWNlIGFsbG93cyBpbiBwYXJ0aWN1bGFyIHRvIHN5bmNocm9uaXplIGVuZ2luZXMgdGhhdCBhc3N1cmUgdGhlaXIgb3duXG4gKiBzY2hlZHVsaW5nIChpLmUuIGF1ZGlvIHBsYXllciBvciBhbiBvc2NpbGxhdG9yKSB0byB0aGUgZXZlbnQtYmFzZWQgc2NoZWR1bGVkXG4gKiBhbmQgdHJhbnNwb3J0ZWQgZW5naW5lcy5cbiAqXG4gKiAjIyMjIyMgYHN5bmNTcGVlZCh0aW1lIDpOdW1iZXIsIHBvc2l0aW9uIDpOdW1iZXIsIHNwZWVkIDpOdW1iZXIsIHNlZWs9ZmFsc2UgOkJvb2xlYW4pYFxuICpcbiAqIFRoZSBzeW5jU3BlZWQgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIFRpbWVFbmdpbmUgYXMgcGFydCBvZiB0aGVcbiAqIHNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlLiBUaGUgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFzdGVyIHdoZW5ldmVyIHRoZVxuICogcGxheWJhY2sgc3BlZWQgY2hhbmdlcyBvciB0aGUgcG9zaXRpb24ganVtcHMgYXJiaXRhcmlseSAoaS5lLiBvbiBhIHNlZWspLlxuICpcbiAqXG4gKiA8aHIgLz5cbiAqXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgYSBgVGltZUVuZ2luZWAgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgIHRoYXQgY291bnRzIHVwXG4gKiBhdCBhIGdpdmVuIGZyZXF1ZW5jeTpcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvdGltZS1lbmdpbmUuaHRtbH1cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuICpcbiAqIGNsYXNzIE15RW5naW5lIGV4dGVuZHMgYXVkaW8uVGltZUVuZ2luZSB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKCk7XG4gKiAgICAgLy8gLi4uXG4gKiAgIH1cbiAqIH1cbiAqXG4gKi9cbmNsYXNzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZW5naW5lJ3MgbWFzdGVyLlxuICAgICAqXG4gICAgICogQHR5cGUge01peGVkfVxuICAgICAqIEBuYW1lIG1hc3RlclxuICAgICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXG4gICAgICovXG4gICAgdGhpcy5tYXN0ZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGVuZ2luZSdzIGN1cnJlbnQgKG1hc3RlcikgdGltZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgaWYgKHRoaXMubWFzdGVyKVxuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lO1xuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSBlbmdpbmUncyBjdXJyZW50IChtYXN0ZXIpIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgdmFyIG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbWFzdGVyLmN1cnJlbnRQb3NpdGlvbjtcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVkIGludGVyZmFjZVxuICAgKiAgIC0gYWR2YW5jZVRpbWUodGltZSksIGNhbGxlZCB0byBnZW5lcmF0ZSBuZXh0IGV2ZW50IGF0IGdpdmVuIHRpbWUsIHJldHVybnMgbmV4dCB0aW1lXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcbiAgICovXG4gIHN0YXRpYyBpbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkge1xuICAgIHJldHVybiAoZW5naW5lLmFkdmFuY2VUaW1lICYmIGVuZ2luZS5hZHZhbmNlVGltZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcbiAgfVxuXG4gIHJlc2V0VGltZSh0aW1lID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMubWFzdGVyKVxuICAgICAgdGhpcy5tYXN0ZXIucmVzZXRFbmdpbmVUaW1lKHRoaXMsIHRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zcG9ydGVkIGludGVyZmFjZVxuICAgKiAgIC0gc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCksIGNhbGxlZCB0byByZXBvc2l0aW9uIFRpbWVFbmdpbmUsIHJldHVybnMgbmV4dCBwb3NpdGlvblxuICAgKiAgIC0gYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCksIGNhbGxlZCB0byBnZW5lcmF0ZSBuZXh0IGV2ZW50IGF0IGdpdmVuIHRpbWUgYW5kIHBvc2l0aW9uLCByZXR1cm5zIG5leHQgcG9zaXRpb25cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxuICAgKi9cbiAgc3RhdGljIGltcGxlbWVudHNUcmFuc3BvcnRlZChlbmdpbmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZW5naW5lLnN5bmNQb3NpdGlvbiAmJiBlbmdpbmUuc3luY1Bvc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24gJiZcbiAgICAgIGVuZ2luZS5hZHZhbmNlUG9zaXRpb24gJiYgZW5naW5lLmFkdmFuY2VQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgKTtcbiAgfVxuXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24gPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5tYXN0ZXIpXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVlZC1jb250cm9sbGVkIGludGVyZmFjZVxuICAgKiAgIC0gc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgKSwgY2FsbGVkIHRvXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcbiAgICovXG4gIHN0YXRpYyBpbXBsZW1lbnRzU3BlZWRDb250cm9sbGVkKGVuZ2luZSkge1xuICAgIHJldHVybiAoZW5naW5lLnN5bmNTcGVlZCAmJiBlbmdpbmUuc3luY1NwZWVkIGluc3RhbmNlb2YgRnVuY3Rpb24pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVFbmdpbmU7XG4iLCJpbXBvcnQgQXVkaW9UaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xuXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xuICBpZiAob3B0ICE9PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIG9wdDtcblxuICByZXR1cm4gZGVmO1xufVxuXG5cbi8qKlxuICogR3JhbnVsYXIgc3ludGhlc2lzIFRpbWVFbmdpbmUgaW1wbGVtZW50aW5nIHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlLlxuICogVGhlIGdyYWluIHBvc2l0aW9uIChncmFpbiBvbnNldCBvciBjZW50ZXIgdGltZSBpbiB0aGUgYXVkaW8gYnVmZmVyKSBpc1xuICogb3B0aW9uYWxseSBkZXRlcm1pbmVkIGJ5IHRoZSBlbmdpbmUncyBjdXJyZW50UG9zaXRpb24gYXR0cmlidXRlLlxuICpcbiAqIEV4YW1wbGUgdGhhdCBzaG93cyBhIGBHcmFudWxhckVuZ2luZWAgKHdpdGggYSBmZXcgcGFyYW1ldGVyIGNvbnRyb2xzKSBkcml2ZW5cbiAqIGJ5IGEgYFNjaGVkdWxlcmAgYW5kIGEgYFBsYXlDb250cm9sYDpcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvZ3JhbnVsYXItZW5naW5lLmh0bWx9XG4gKlxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XG4gKiBjb25zdCBncmFudWxhckVuZ2luZSA9IG5ldyBhdWRpby5HcmFudWxhckVuZ2luZSgpO1xuICpcbiAqIHNjaGVkdWxlci5hZGQoZ3JhbnVsYXJFbmdpbmUpO1xuICpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucz17fSAtIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZEFicz0wLjAxXSAtIEFic29sdXRlIGdyYWluIHBlcmlvZCBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RSZWw9MF0gLSBHcmFpbiBwZXJpb2QgcmVsYXRpdmUgdG8gYWJzb2x1dGVcbiAqICBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZFZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwZXJpb2RcbiAqICB2YXJpYXRpb24gcmVsYXRpdmUgdG8gZ3JhaW4gcGVyaW9kXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gZ3JhaW4gcGVyaW9kXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb249MF0gLSBHcmFpbiBwb3NpdGlvbiAob25zZXQgdGltZSBpbiBhdWRpb1xuICogIGJ1ZmZlcikgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MC4wMDNdIC0gQW1vdXQgb2YgcmFuZG9tIGdyYWluIHBvc2l0aW9uXG4gKiAgdmFyaWF0aW9uIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uQWJzPTAuMV0gLSBBYnNvbHV0ZSBncmFpbiBkdXJhdGlvbiBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblJlbD0wXSAtIEdyYWluIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdyYWluXG4gKiAgcGVyaW9kIChvdmVybGFwKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja0Ficz0wXSAtIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja1JlbD0wLjVdIC0gQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hdHRhY2tTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiBhdHRhY2tcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlQWJzPTBdIC0gQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VSZWw9MC41XSAtIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBncmFpbiBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiByZWxlYXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZXhwUmFtcE9mZnNldD0wLjAwMDFdIC0gT2Zmc2V0IChzdGFydC9lbmQgdmFsdWUpXG4gKiAgZm9yIGV4cG9uZW50aWFsIGF0dGFjay9yZWxlYXNlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZz0wXSAtIEdyYWluIHJlc2FtcGxpbmcgaW4gY2VudFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmdWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBMaW5lYXIgZ2FpbiBmYWN0b3JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2VudGVyZWQ9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBncmFpbiBwb3NpdGlvbiByZWZlcnNcbiAqICB0byB0aGUgY2VudGVyIG9mIHRoZSBncmFpbiAob3IgdGhlIGJlZ2lubmluZylcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY3ljbGljPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgZ3JhaW5cbiAqICBwb3NpdGlvbiBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uPTBdIC0gUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZVxuICogIGF1ZGlvIGJ1ZmZlciB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxuICovXG5jbGFzcyBHcmFudWxhckVuZ2luZSBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcblxuICAgIC8qKlxuICAgICAqIEF1ZGlvIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHR5cGUge0F1ZGlvQnVmZmVyfVxuICAgICAqIEBuYW1lIGJ1ZmZlclxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlciA9IG9wdE9yRGVmKG9wdGlvbnMuYnVmZmVyLCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIGdyYWluIHBlcmlvZCBpbiBzZWNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcGVyaW9kQWJzXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kQWJzID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RBYnMsIDAuMDEpO1xuXG4gICAgLyoqXG4gICAgICogR3JhaW4gcGVyaW9kIHJlbGF0aXZlIHRvIGFic29sdXRlIGR1cmF0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIHBlcmlvZFJlbFxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBwZXJpb2RWYXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2RWYXIgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZFZhciwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGdyYWluIHBlcmlvZFxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBwZXJpb2RNaW5cbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kTWluID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RNaW4sIDAuMDAxKTtcblxuICAgIC8qKlxuICAgICAqIEdyYWluIHBvc2l0aW9uIChvbnNldCB0aW1lIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIHBvc2l0aW9uXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXG4gICAgICogQGRlZmF1bHQgMC4wMDNcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wb3NpdGlvblZhciwgMC4wMDMpO1xuXG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgZ3JhaW4gZHVyYXRpb24gaW4gc2VjXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGR1cmF0aW9uQWJzXG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbkFicyA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BYnMsIDAuMSk7IC8vIGFic29sdXRlIGdyYWluIGR1cmF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBHcmFpbiBkdXJhdGlvbiByZWxhdGl2ZSB0byBncmFpbiBwZXJpb2QgKG92ZXJsYXApXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGR1cmF0aW9uUmVsXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBhdHRhY2tBYnNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5hdHRhY2tBYnMgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja0FicywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2sgdGltZSByZWxhdGl2ZSB0byBncmFpbiBkdXJhdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBhdHRhY2tSZWxcbiAgICAgKiBAZGVmYXVsdCAwLjVcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmF0dGFja1JlbCA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrUmVsLCAwLjUpO1xuXG4gICAgLyoqXG4gICAgICogU2hhcGUgb2YgYXR0YWNrICgnbGluJyBmb3IgbGluZWFyIHJhbXAsICdleHAnIGZvciBleHBvbmVudGlhbCByYW1wKVxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAbmFtZSBhdHRhY2tTaGFwZVxuICAgICAqIEBkZWZhdWx0ICdsaW4nXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5hdHRhY2tTaGFwZSA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrU2hhcGUsICdsaW4nKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcmVsZWFzZUFic1xuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlbGVhc2VBYnMgPSBvcHRPckRlZihvcHRpb25zLnJlbGVhc2VBYnMsIDApO1xuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aW1lIHJlbGF0aXZlIHRvIGdyYWluIGR1cmF0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIHJlbGVhc2VSZWxcbiAgICAgKiBAZGVmYXVsdCAwLjVcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlbGVhc2VSZWwgPSBvcHRPckRlZihvcHRpb25zLnJlbGVhc2VSZWwsIDAuNSk7XG5cbiAgICAvKipcbiAgICAgKiBTaGFwZSBvZiByZWxlYXNlICgnbGluJyBmb3IgbGluZWFyIHJhbXAsICdleHAnIGZvciBleHBvbmVudGlhbCByYW1wKVxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAbmFtZSByZWxlYXNlU2hhcGVcbiAgICAgKiBAZGVmYXVsdCAnbGluJ1xuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucmVsZWFzZVNoYXBlID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlU2hhcGUsICdsaW4nKTtcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCAoc3RhcnQvZW5kIHZhbHVlKSBmb3IgZXhwb25lbnRpYWwgYXR0YWNrL3JlbGVhc2VcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgZXhwUmFtcE9mZnNldFxuICAgICAqIEBkZWZhdWx0IDAuMDAwMVxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZXhwUmFtcE9mZnNldCA9IG9wdE9yRGVmKG9wdGlvbnMuZXhwUmFtcE9mZnNldCwgMC4wMDAxKTtcblxuICAgIC8qKlxuICAgICAqIEdyYWluIHJlc2FtcGxpbmcgaW4gY2VudFxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSByZXNhbXBsaW5nXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucmVzYW1wbGluZyA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSByZXNhbXBsaW5nVmFyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucmVzYW1wbGluZ1ZhciA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZ1ZhciwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgZ2FpblxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmdhaW4gPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZ3JhaW4gcG9zaXRpb24gcmVmZXJzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGdyYWluIChvciB0aGUgYmVnaW5uaW5nKVxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQG5hbWUgY2VudGVyZWRcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJlZCA9IG9wdE9yRGVmKG9wdGlvbnMuY2VudGVyZWQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBncmFpbiBwb3NpdGlvbiBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBuYW1lIGN5Y2xpY1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGVcbiAgICAgKiBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSB3cmFwQXJvdW5kRXh0ZW5zaW9uXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XG5cbiAgICB0aGlzLm91dHB1dE5vZGUgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvbiAoZXhjbHVkaW5nIHdyYXBBcm91bmRFeHRlbnNpb24pXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBuYW1lIGJ1ZmZlckR1cmF0aW9uXG4gICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYnVmZmVyRHVyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcblxuICAgICAgaWYgKHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbilcbiAgICAgICAgYnVmZmVyRHVyYXRpb24gLT0gdGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uO1xuXG4gICAgICByZXR1cm4gYnVmZmVyRHVyYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCBwb3NpdGlvblxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBjdXJyZW50UG9zaXRpb25cbiAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgdmFyIG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbWFzdGVyLmN1cnJlbnRQb3NpdGlvbjtcblxuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICB9XG5cbiAgYWR2YW5jZVRpbWUodGltZSkge1xuICAgIHRpbWUgPSBNYXRoLm1heCh0aW1lLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgcmV0dXJuIHRpbWUgKyB0aGlzLnRyaWdnZXIodGltZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhIGdyYWluLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYXQgYW55IHRpbWUgKHdoZXRoZXIgdGhlXG4gICAqIGVuZ2luZSBpcyBzY2hlZHVsZWQgb3Igbm90KSB0byBnZW5lcmF0ZSBhIHNpbmdsZSBncmFpbiBhY2NvcmRpbmcgdG8gdGhlXG4gICAqIGN1cnJlbnQgZ3JhaW4gcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBncmFpbiBzeW50aGVzaXMgYXVkaW8gdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gcGVyaW9kIHRvIG5leHQgZ3JhaW5cbiAgICovXG4gIHRyaWdnZXIodGltZSkge1xuICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcbiAgICB2YXIgZ3JhaW5UaW1lID0gdGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIGdyYWluUGVyaW9kID0gdGhpcy5wZXJpb2RBYnM7XG4gICAgdmFyIGdyYWluUG9zaXRpb24gPSB0aGlzLmN1cnJlbnRQb3NpdGlvbjtcbiAgICB2YXIgZ3JhaW5EdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BYnM7XG5cbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHZhciByZXNhbXBsaW5nUmF0ZSA9IDEuMDtcblxuICAgICAgLy8gY2FsY3VsYXRlIHJlc2FtcGxpbmdcbiAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xuICAgICAgICB2YXIgcmFuZG9tUmVzYW1wbGluZyA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMCAqIHRoaXMucmVzYW1wbGluZ1ZhcjtcbiAgICAgICAgcmVzYW1wbGluZ1JhdGUgPSBNYXRoLnBvdygyLjAsICh0aGlzLnJlc2FtcGxpbmcgKyByYW5kb21SZXNhbXBsaW5nKSAvIDEyMDAuMCk7XG4gICAgICB9XG5cbiAgICAgIGdyYWluUGVyaW9kICs9IHRoaXMucGVyaW9kUmVsICogZ3JhaW5EdXJhdGlvbjtcbiAgICAgIGdyYWluRHVyYXRpb24gKz0gdGhpcy5kdXJhdGlvblJlbCAqIGdyYWluUGVyaW9kO1xuXG4gICAgICAvLyBncmFpbiBwZXJpb2QgcmFuZG9uIHZhcmlhdGlvblxuICAgICAgaWYgKHRoaXMucGVyaW9kVmFyID4gMC4wKVxuICAgICAgICBncmFpblBlcmlvZCArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBlcmlvZFZhciAqIGdyYWluUGVyaW9kO1xuXG4gICAgICAvLyBjZW50ZXIgZ3JhaW5cbiAgICAgIGlmICh0aGlzLmNlbnRlcmVkKVxuICAgICAgICBncmFpblBvc2l0aW9uIC09IDAuNSAqIGdyYWluRHVyYXRpb247XG5cbiAgICAgIC8vIHJhbmRvbWl6ZSBncmFpbiBwb3NpdGlvblxuICAgICAgaWYgKHRoaXMucG9zaXRpb25WYXIgPiAwKVxuICAgICAgICBncmFpblBvc2l0aW9uICs9ICgyLjAgKiBNYXRoLnJhbmRvbSgpIC0gMSkgKiB0aGlzLnBvc2l0aW9uVmFyO1xuXG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICAvLyB3cmFwIG9yIGNsaXAgZ3JhaW4gcG9zaXRpb24gYW5kIGR1cmF0aW9uIGludG8gYnVmZmVyIGR1cmF0aW9uXG4gICAgICBpZiAoZ3JhaW5Qb3NpdGlvbiA8IDAgfHwgZ3JhaW5Qb3NpdGlvbiA+PSBidWZmZXJEdXJhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5jeWNsaWMpIHtcbiAgICAgICAgICB2YXIgY3ljbGVzID0gZ3JhaW5Qb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xuICAgICAgICAgIGdyYWluUG9zaXRpb24gPSAoY3ljbGVzIC0gTWF0aC5mbG9vcihjeWNsZXMpKSAqIGJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICAgICAgaWYgKGdyYWluUG9zaXRpb24gKyBncmFpbkR1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24pXG4gICAgICAgICAgICBncmFpbkR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb24gLSBncmFpblBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChncmFpblBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgZ3JhaW5UaW1lIC09IGdyYWluUG9zaXRpb247XG4gICAgICAgICAgICBncmFpbkR1cmF0aW9uICs9IGdyYWluUG9zaXRpb247XG4gICAgICAgICAgICBncmFpblBvc2l0aW9uID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ3JhaW5Qb3NpdGlvbiArIGdyYWluRHVyYXRpb24gPiBidWZmZXJEdXJhdGlvbilcbiAgICAgICAgICAgIGdyYWluRHVyYXRpb24gPSBidWZmZXJEdXJhdGlvbiAtIGdyYWluUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBncmFpblxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgZ3JhaW5EdXJhdGlvbiA+PSAwLjAwMSkge1xuICAgICAgICAvLyBtYWtlIGdyYWluIGVudmVsb3BlXG4gICAgICAgIHZhciBlbnZlbG9wZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHZhciBhdHRhY2sgPSB0aGlzLmF0dGFja0FicyArIHRoaXMuYXR0YWNrUmVsICogZ3JhaW5EdXJhdGlvbjtcbiAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnJlbGVhc2VBYnMgKyB0aGlzLnJlbGVhc2VSZWwgKiBncmFpbkR1cmF0aW9uO1xuXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gZ3JhaW5EdXJhdGlvbikge1xuICAgICAgICAgIHZhciBmYWN0b3IgPSBncmFpbkR1cmF0aW9uIC8gKGF0dGFjayArIHJlbGVhc2UpO1xuICAgICAgICAgIGF0dGFjayAqPSBmYWN0b3I7XG4gICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IGdyYWluVGltZSArIGF0dGFjaztcbiAgICAgICAgdmFyIGdyYWluRW5kVGltZSA9IGdyYWluVGltZSArIGdyYWluRHVyYXRpb24gLyByZXNhbXBsaW5nUmF0ZTtcbiAgICAgICAgdmFyIHJlbGVhc2VTdGFydFRpbWUgPSBncmFpbkVuZFRpbWUgLSByZWxlYXNlO1xuXG4gICAgICAgIGVudmVsb3BlLmdhaW4udmFsdWUgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmF0dGFja1NoYXBlID09PSAnbGluJykge1xuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMC4wLCBncmFpblRpbWUpO1xuICAgICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5nYWluLCBhdHRhY2tFbmRUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZXhwUmFtcE9mZnNldCwgZ3JhaW5UaW1lKTtcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5nYWluLCBhdHRhY2tFbmRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWxlYXNlU3RhcnRUaW1lID4gYXR0YWNrRW5kVGltZSlcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgcmVsZWFzZVN0YXJ0VGltZSk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZVNoYXBlID09PSAnbGluJykge1xuICAgICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMC4wLCBncmFpbkVuZFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudmVsb3BlLmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmV4cFJhbXBPZmZzZXQsIGdyYWluRW5kVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnZlbG9wZS5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XG5cbiAgICAgICAgLy8gbWFrZSBzb3VyY2VcbiAgICAgICAgdmFyIHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblxuICAgICAgICBzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByZXNhbXBsaW5nUmF0ZTtcbiAgICAgICAgc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpO1xuXG4gICAgICAgIHNvdXJjZS5zdGFydChncmFpblRpbWUsIGdyYWluUG9zaXRpb24pO1xuICAgICAgICBzb3VyY2Uuc3RvcChncmFpbkVuZFRpbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnBlcmlvZE1pbiwgZ3JhaW5QZXJpb2QpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyYW51bGFyRW5naW5lO1xuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcblxuZnVuY3Rpb24gb3B0T3JEZWYob3B0LCBkZWYpIHtcbiAgaWYob3B0ICE9PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIG9wdDtcblxuICByZXR1cm4gZGVmO1xufVxuXG4vKipcbiAqIE1ldHJvbm9tZSBhdWRpbyBlbmdpbmUuIEl0IGV4dGVuZHMgVGltZSBFbmdpbmUgYXMgYSB0cmFuc3BvcnRlZCBpbnRlcmZhY2UuXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL21ldHJvbm9tZS5odG1sfVxuICpcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xuICogY29uc3QgbWV0cm9ub21lID0gbmV3IGF1ZGlvLk1ldHJvbm9tZSh7cGVyaW9kOiAwLjMzM30pO1xuICpcbiAqIHNjaGVkdWxlci5hZGQobWV0cm9ub21lKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kPTFdIC0gTWV0cm9ub21lIHBlcmlvZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsaWNrRnJlcT02MDBdIC0gTWV0cm9ub21lIGNsaWNrIGZyZXF1ZW5jeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsaWNrQXR0YWNrPTAuMDAyXSAtIE1ldHJvbm9tZSBjbGljayBhdHRhY2sgdGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsaWNrUmVsZWFzZT0wLjA5OF0gLSBNZXRyb25vbWUgY2xpY2sgcmVsZWFzZSB0aW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIEdhaW5cbiAqL1xuY2xhc3MgTWV0cm9ub21lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogTWV0cm9ub21lIHBlcmlvZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9fcGVyaW9kID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2QsIDEpO1xuXG4gICAgLyoqXG4gICAgICogTWV0cm9ub21lIGNsaWNrIGZyZXF1ZW5jeVxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXG4gICAgICogQG5hbWUgY2xpY2tGcmVxXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5jbGlja0ZyZXEgPSBvcHRPckRlZihvcHRpb25zLmNsaWNrRnJlcSwgNjAwKTtcblxuICAgIC8qKlxuICAgICAqIE1ldHJvbm9tZSBjbGljayBhdHRhY2sgdGltZVxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXG4gICAgICogQG5hbWUgY2xpY2tBdHRhY2tcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmNsaWNrQXR0YWNrID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0F0dGFjaywgMC4wMDIpO1xuXG4gICAgLyoqXG4gICAgICogTWV0cm9ub21lIGNsaWNrIHJlbGVhc2UgdGltZVxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXG4gICAgICogQG5hbWUgY2xpY2tSZWxlYXNlXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5jbGlja1JlbGVhc2UgPSBvcHRPckRlZihvcHRpb25zLmNsaWNrUmVsZWFzZSwgMC4wOTgpO1xuXG4gICAgdGhpcy5fX2xhc3RUaW1lID0gMDtcbiAgICB0aGlzLl9fcGhhc2UgPSAwO1xuXG4gICAgdGhpcy5fX2dhaW5Ob2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcblxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuX19nYWluTm9kZTtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzY2hlZHVsZWQgaW50ZXJmYWNlKVxuICBhZHZhbmNlVGltZSh0aW1lKSB7XG4gICAgdGhpcy50cmlnZ2VyKHRpbWUpO1xuICAgIHRoaXMuX19sYXN0VGltZSA9IHRpbWU7XG4gICAgcmV0dXJuIHRpbWUgKyB0aGlzLl9fcGVyaW9kO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcbiAgc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGlmICh0aGlzLl9fcGVyaW9kID4gMCkge1xuICAgICAgdmFyIG5leHRQb3NpdGlvbiA9IChNYXRoLmZsb29yKHBvc2l0aW9uIC8gdGhpcy5fX3BlcmlvZCkgKyB0aGlzLl9fcGhhc2UpICogdGhpcy5fX3BlcmlvZDtcblxuICAgICAgaWYgKHNwZWVkID4gMCAmJiBuZXh0UG9zaXRpb24gPCBwb3NpdGlvbilcbiAgICAgICAgbmV4dFBvc2l0aW9uICs9IHRoaXMuX19wZXJpb2Q7XG4gICAgICBlbHNlIGlmIChzcGVlZCA8IDAgJiYgbmV4dFBvc2l0aW9uID4gcG9zaXRpb24pXG4gICAgICAgIG5leHRQb3NpdGlvbiAtPSB0aGlzLl9fcGVyaW9kO1xuXG4gICAgICByZXR1cm4gbmV4dFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcblxuICAgIGlmIChzcGVlZCA8IDApXG4gICAgICByZXR1cm4gcG9zaXRpb24gLSB0aGlzLl9fcGVyaW9kO1xuXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5fX3BlcmlvZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIG1ldHJvbm9tZSBjbGlja1xuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBtZXRyb25vbWUgY2xpY2sgc3ludGhlc2lzIGF1ZGlvIHRpbWVcbiAgICovXG4gIHRyaWdnZXIodGltZSkge1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xuICAgIGNvbnN0IGNsaWNrQXR0YWNrID0gdGhpcy5jbGlja0F0dGFjaztcbiAgICBjb25zdCBjbGlja1JlbGVhc2UgPSB0aGlzLmNsaWNrUmVsZWFzZTtcblxuICAgIGNvbnN0IGVudiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgZW52LmdhaW4udmFsdWUgPSAwLjA7XG4gICAgZW52LmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGltZSk7XG4gICAgZW52LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMS4wLCB0aW1lICsgY2xpY2tBdHRhY2spO1xuICAgIGVudi5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUoMC4wMDAwMDAxLCB0aW1lICsgY2xpY2tBdHRhY2sgKyBjbGlja1JlbGVhc2UpO1xuICAgIGVudi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuICAgIGVudi5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XG5cbiAgICBjb25zdCBvc2MgPSBhdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgIG9zYy5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmNsaWNrRnJlcTtcbiAgICBvc2Muc3RhcnQodGltZSk7XG4gICAgb3NjLnN0b3AodGltZSArIGNsaWNrQXR0YWNrICsgY2xpY2tSZWxlYXNlKTtcbiAgICBvc2MuY29ubmVjdChlbnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIGxpbmVhciBnYWluIGZhY3RvclxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBnYWluXG4gICAqIEBtZW1iZXJvZiBNZXRyb25vbWVcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBzZXQgZ2Fpbih2YWx1ZSkge1xuICAgIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgZ2FpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogbWV0cm9ub21lIHBlcmlvZFxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBwZXJpb2RcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHNldCBwZXJpb2QocGVyaW9kKSB7XG4gICAgdGhpcy5fX3BlcmlvZCA9IHBlcmlvZDtcblxuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3Rlcikge1xuICAgICAgaWYgKG1hc3Rlci5yZXNldEVuZ2luZVRpbWUpXG4gICAgICAgIG1hc3Rlci5yZXNldEVuZ2luZVRpbWUodGhpcywgdGhpcy5fX2xhc3RUaW1lICsgcGVyaW9kKTtcbiAgICAgIGVsc2UgaWYgKG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKVxuICAgICAgICBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLl9fcGVyaW9kO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBwaGFzZSBwYXJhbWV0ZXIgKGF2YWlsYWJsZSBvbmx5IHdoZW4gJ3RyYW5zcG9ydGVkJyksIHNob3VsZCBiZVxuICAgKiBiZXR3ZWVuIFswLCAxW1xuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBwaGFzZVxuICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc2V0IHBoYXNlKHBoYXNlKSB7XG4gICAgdGhpcy5fX3BoYXNlID0gcGhhc2UgLSBNYXRoLmZsb29yKHBoYXNlKTtcblxuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24odGhpcyk7XG4gIH1cblxuICBnZXQgcGhhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19waGFzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXRyb25vbWU7XG4iLCJpbXBvcnQgQXVkaW9UaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xuXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xuICBpZihvcHQgIT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gb3B0O1xuXG4gIHJldHVybiBkZWY7XG59XG5cbi8qKlxuICogVXNlZCB3aXRoIGEgYnVmZmVyIHRvIHNlcnZlIGF1ZGlvIGZpbGVzLlxuICpcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvcGxheWVyLWVuZ2luZS5odG1sfVxuICpcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHBsYXllckVuZ2luZSA9IGF1ZGlvLlBsYXllckVuZ2luZSgpO1xuICogY29uc3QgcGxheUNvbnRyb2wgPSBuZXcgYXVkaW8uUGxheUNvbnRyb2wocGxheWVyRW5naW5lKTtcbiAqXG4gKiBwbGF5Q29udHJvbC5zdGFydCgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBEZWZhdWx0IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idWZmZXI9MV0gLSBBdWRpbyBidWZmZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYWRlVGltZT02MDBdIC0gRmFkZSB0aW1lIGZvciBjaGFpbmluZyBzZWdtZW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBMb29wIG1vZGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gR2FpblxuICovXG5jbGFzcyBQbGF5ZXJFbmdpbmUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zLmF1ZGlvQ29udGV4dCk7XG5cbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7IC8vIHNldCB3aGVuIGFkZGVkIHRvIHRyYW5zcG9ydGVyXG5cbiAgICAvKipcbiAgICAgKiBBdWRpbyBidWZmZXJcbiAgICAgKlxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cbiAgICAgKiBAbmFtZSBidWZmZXJcbiAgICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRoaXMuYnVmZmVyID0gb3B0T3JEZWYob3B0aW9ucy5idWZmZXIsIG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogRmFkZSB0aW1lIGZvciBjaGFpbmluZyBzZWdtZW50cyAoZS5nLiBpbiBzdGFydCwgc3RvcCwgYW5kIHNlZWspXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGZhZGVUaW1lXG4gICAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBkZWZhdWx0IDAuMDA1XG4gICAgICovXG4gICAgdGhpcy5mYWRlVGltZSA9IG9wdE9yRGVmKG9wdGlvbnMuZmFkZVRpbWUsIDAuMDA1KTtcblxuICAgIHRoaXMuX190aW1lID0gMDtcbiAgICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICAgIHRoaXMuX19zcGVlZCA9IDA7XG5cbiAgICB0aGlzLl9fYnVmZmVyU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9fZW52Tm9kZSA9IG51bGw7XG5cbiAgICB0aGlzLl9fZ2Fpbk5vZGUgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWUgPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xuXG4gICAgdGhpcy5fX2N5Y2xpYyA9IG9wdE9yRGVmKG9wdGlvbnMuY3ljbGljLCBmYWxzZSk7XG5cbiAgICB0aGlzLm91dHB1dE5vZGUgPSB0aGlzLl9fZ2Fpbk5vZGU7XG4gIH1cblxuICBfX3N0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcblxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb247XG5cbiAgICAgIGlmICh0aGlzLl9fY3ljbGljICYmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gYnVmZmVyRHVyYXRpb24pKSB7XG4gICAgICAgIHZhciBwaGFzZSA9IHBvc2l0aW9uIC8gYnVmZmVyRHVyYXRpb247XG4gICAgICAgIHBvc2l0aW9uID0gKHBoYXNlIC0gTWF0aC5mbG9vcihwaGFzZSkpICogYnVmZmVyRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwICYmIHBvc2l0aW9uIDwgYnVmZmVyRHVyYXRpb24gJiYgc3BlZWQgPiAwKSB7XG4gICAgICAgIHRoaXMuX19lbnZOb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcbiAgICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgxLCB0aW1lICsgdGhpcy5mYWRlVGltZSk7XG4gICAgICAgIHRoaXMuX19lbnZOb2RlLmNvbm5lY3QodGhpcy5fX2dhaW5Ob2RlKTtcblxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHNwZWVkO1xuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmxvb3AgPSB0aGlzLl9fY3ljbGljO1xuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmxvb3BTdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UubG9vcEVuZCA9IGJ1ZmZlckR1cmF0aW9uO1xuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnN0YXJ0KHRpbWUsIHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5jb25uZWN0KHRoaXMuX19lbnZOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2hhbHQodGltZSkge1xuICAgIGlmICh0aGlzLl9fYnVmZmVyU291cmNlKSB7XG4gICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcbiAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5fX2Vudk5vZGUuZ2Fpbi52YWx1ZSwgdGltZSk7XG4gICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRpbWUgKyB0aGlzLmZhZGVUaW1lKTtcbiAgICAgIHRoaXMuX19idWZmZXJTb3VyY2Uuc3RvcCh0aW1lICsgdGhpcy5mYWRlVGltZSk7XG5cbiAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5fX2Vudk5vZGUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZSlcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlayA9IGZhbHNlKSB7XG4gICAgdmFyIGxhc3RTcGVlZCA9IHRoaXMuX19zcGVlZDtcblxuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IHNlZWspIHtcbiAgICAgIGlmIChzZWVrIHx8IGxhc3RTcGVlZCAqIHNwZWVkIDwgMCkge1xuICAgICAgICB0aGlzLl9faGFsdCh0aW1lKTtcbiAgICAgICAgdGhpcy5fX3N0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCB8fCBzZWVrKSB7XG4gICAgICAgIHRoaXMuX19zdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9faGFsdCh0aW1lKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2J1ZmZlclNvdXJjZSkge1xuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZShzcGVlZCwgdGltZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19zcGVlZCA9IHNwZWVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGlzIGNvbnNpZGVyZWQgYXMgY3ljbGljXG4gICAqIEB0eXBlIHtCb29sfVxuICAgKiBAbmFtZSBjeWNsaWNcbiAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHNldCBjeWNsaWMoY3ljbGljKSB7XG4gICAgaWYgKGN5Y2xpYyAhPT0gdGhpcy5fX2N5Y2xpYykge1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5jdXJyZW50b3NpdGlvbjtcblxuICAgICAgdGhpcy5fX2hhbHQodGltZSk7XG4gICAgICB0aGlzLl9fY3ljbGljID0gY3ljbGljO1xuXG4gICAgICBpZiAodGhpcy5fX3NwZWVkICE9PSAwKVxuICAgICAgICB0aGlzLl9fc3RhcnQodGltZSwgcG9zaXRpb24sIHRoaXMuX19zcGVlZCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGN5Y2xpYygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2N5Y2xpYztcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgZ2FpblxuICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc2V0IGdhaW4odmFsdWUpIHtcbiAgICB2YXIgdGltZSA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgdGhpcy5fX2dhaW5Ob2RlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcbiAgICB0aGlzLl9fZ2Fpbk5vZGUuc2V0VmFsdWVBdFRpbWUodGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWUsIHRpbWUpO1xuICAgIHRoaXMuX19nYWluTm9kZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aW1lICsgdGhpcy5mYWRlVGltZSk7XG4gIH1cblxuICBnZXQgZ2FpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvblxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBidWZmZXJEdXJhdGlvblxuICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBidWZmZXJEdXJhdGlvbigpIHtcbiAgICBpZih0aGlzLmJ1ZmZlcilcbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcblxuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYXllckVuZ2luZTtcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XG5cbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gb3B0O1xuXG4gIHJldHVybiBkZWY7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XG4gIHZhciBzaXplID0gc29ydGVkQXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzaXplID4gMCkge1xuICAgIHZhciBmaXJzdFZhbCA9IHNvcnRlZEFycmF5WzBdO1xuICAgIHZhciBsYXN0VmFsID0gc29ydGVkQXJyYXlbc2l6ZSAtIDFdO1xuXG4gICAgaWYgKHZhbHVlIDwgZmlyc3RWYWwpXG4gICAgICBpbmRleCA9IC0xO1xuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXG4gICAgICBpbmRleCA9IHNpemUgLSAxO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKHNpemUgLSAxKSAqICh2YWx1ZSAtIGZpcnN0VmFsKSAvIChsYXN0VmFsIC0gZmlyc3RWYWwpKTtcblxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA+IHZhbHVlKVxuICAgICAgICBpbmRleC0tO1xuXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggKyAxXSA8PSB2YWx1ZSlcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRPck5leHRJbmRleChzb3J0ZWRBcnJheSwgdmFsdWUsIGluZGV4ID0gLTEpIHtcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XG5cbiAgaWYgKHNpemUgPiAwKSB7XG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XG4gICAgdmFyIGxhc3RWYWwgPSBzb3J0ZWRBcnJheVtzaXplIC0gMV07XG5cbiAgICBpZiAodmFsdWUgPD0gZmlyc3RWYWwpXG4gICAgICBpbmRleCA9IDA7XG4gICAgZWxzZSBpZiAodmFsdWUgPj0gbGFzdFZhbClcbiAgICAgIGluZGV4ID0gc2l6ZTtcbiAgICBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSlcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XG5cbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleF0gPCB2YWx1ZSlcbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4IC0gMV0gPj0gdmFsdWUpXG4gICAgICAgIGluZGV4LS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIFVzZWQgd2l0aCBhIGJ1ZmZlciB0byBzZXJ2ZSBhdWRpbyBmaWxlcyB2aWEgZ3JhbnVsYXIgc3ludGhlc2lzLlxuICpcbiAqIFRoZSBlbmdpbmUgaW1wbGVtZW50cyB0aGUgXCJzY2hlZHVsZWRcIiBhbmQgXCJ0cmFuc3BvcnRlZFwiIGludGVyZmFjZXMuXG4gKiBXaGVuIFwic2NoZWR1bGVkXCIsIHRoZSBlbmdpbmUgIGdlbmVyYXRlcyBzZWdtZW50cyBtb3JlIG9yIGxlc3PCoHBlcmlvZGljYWxseVxuICogKGNvbnRyb2xsZWQgYnkgdGhlIHBlcmlvZEFicywgcGVyaW9kUmVsLCBhbmQgcGVyaW9WYXIgYXR0cmlidXRlcykuXG4gKiBXaGVuIFwidHJhbnNwb3J0ZWRcIiwgdGhlIGVuZ2luZSBnZW5lcmF0ZXMgc2VnbWVudHMgYXQgdGhlIHBvc2l0aW9uIG9mIHRoZWlyIG9uc2V0IHRpbWUuXG4gKlxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYFNlZ21lbnRFbmdpbmVgIHdpdGggYSBmZXcgcGFyYW1ldGVyIGNvbnRyb2xzIHJ1bm5pbmcgaW4gYSBgU2NoZWR1bGVyYC5cbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvc2VnbWVudC1lbmdpbmUuaHRtbH1cbiAqXG4gKiBAZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKiBjb25zdCBzY2hlZHVsZXIgPSBhdWRpby5nZXRTY2hlZHVsZXIoKTtcbiAqIGNvbnN0IHNlZ21lbnRFbmdpbmUgPSBuZXcgYXVkaW8uU2VnbWVudEVuZ2luZSgpO1xuICpcbiAqIHNjaGVkdWxlci5hZGQoc2VnbWVudEVuZ2luZSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIERlZmF1bHQgb3B0aW9uc1xuICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gW29wdGlvbnMuYnVmZmVyPW51bGxdIC0gQXVkaW8gYnVmZmVyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTBdIC0gQWJzb2x1dGUgc2VnbWVudCBwZXJpb2QgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kUmVsPTFdIC0gU2VnbWVudCBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXItc2VnbWVudCBkaXN0YW5jZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZFZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBlcmlvZCB2YXJpYXRpb24gcmVsYXRpdmVcbiAqICB0byBzZWdtZW50IHBlcmlvZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZE1pbj0wLjAwMV0gLSBNaW5pbXVtIHNlZ21lbnQgcGVyaW9kXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25BcnJheT1bMC4wXV0gLSBBcnJheSBvZiBzZWdtZW50IHBvc2l0aW9ucyAob25zZXQgdGltZXNcbiAqICBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcG9zaXRpb24gdmFyaWF0aW9uIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uQXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBkdXJhdGlvbnMgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25BYnM9MF0gLSBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uUmVsPTFdIC0gU2VnbWVudCBkdXJhdGlvbiByZWxhdGl2ZSB0byBnaXZlbiBzZWdtZW50XG4gKiAgZHVyYXRpb24gb3IgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub2Zmc2V0QXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBvZmZzZXRzIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldEFicz0tMC4wMDVdIC0gQWJzb2x1dGUgc2VnbWVudCBvZmZzZXQgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0UmVsPTBdIC0gU2VnbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbGF5PTAuMDA1XSAtIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5XG4gKiAgdG8gcmVhbGl6ZSBzZWdtZW50IG9mZnNldHMpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXR0YWNrQWJzPTAuMDA1XSAtIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja1JlbD0wXSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlQWJzPTAuMDA1XSAtIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlUmVsPTBdIC0gUmVsZWFzZSB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nPTBdIC0gU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gTGluZWFyIGdhaW4gZmFjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWJvcnRUaW1lPTAuMDA1XSAtIGZhZGUtb3V0IHRpbWUgd2hlbiBhYm9ydGVkXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2VnbWVudEluZGV4PTBdIC0gSW5kZXggb2YgdGhlIHNlZ21lbnQgdG8gc3ludGhlc2l6ZSAoaS5lLiBvZlxuICogIHRoaXMucG9zaXRpb25BcnJheS9kdXJhdGlvbkFycmF5L29mZnNldEFycmF5KVxuICogQHBhcmFtIHtCb29sfSBbb3B0aW9ucy5jeWNsaWM9ZmFsc2VdIC0gV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBzZWdtZW50IGluZGljZXMgYXJlXG4gKiAgY29uc2lkZXJlZCBhcyBjeWNsaWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uPTBdIC0gUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXJcbiAqICB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxuICovXG5jbGFzcyBTZWdtZW50RW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogQXVkaW8gYnVmZmVyXG4gICAgICogQG5hbWUgYnVmZmVyXG4gICAgICogQHR5cGUge0F1ZGlvQnVmZmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuYnVmZmVyID0gb3B0T3JEZWYob3B0aW9ucy5idWZmZXIsIG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgc2VnbWVudCBwZXJpb2QgaW4gc2VjXG4gICAgICogQG5hbWUgcGVyaW9kQWJzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZEFicyA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kQWJzLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnQgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcbiAgICAgKiBAbmFtZSBwZXJpb2RSZWxcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kUmVsID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RSZWwsIDEpO1xuXG4gICAgLyoqXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcGVyaW9kIHZhcmlhdGlvbiByZWxhdGl2ZSB0byBzZWdtZW50IHBlcmlvZFxuICAgICAqIEBuYW1lIHBlcmlvZFZhclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2RWYXIgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZFZhciwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHNlZ21lbnQgcGVyaW9kXG4gICAgICogQG5hbWUgcGVyaW9kTWluXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXG4gICAgICogQG5hbWUgcG9zaXRpb25BcnJheVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgWzAuMF1cbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb25BcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25BcnJheSwgWzAuMF0pO1xuXG4gICAgLyoqXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcG9zaXRpb24gdmFyaWF0aW9uIGluIHNlY1xuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wb3NpdGlvblZhciwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBzZWdtZW50IGR1cmF0aW9ucyBpbiBzZWNcbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFycmF5XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBbMC4wXVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbkFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFycmF5LCBbMC4wXSk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xuICAgICAqIEBuYW1lIGR1cmF0aW9uQWJzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uQWJzID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFicywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdpdmVuIHNlZ21lbnQgZHVyYXRpb24gb3IgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxuICAgICAqIEBuYW1lIGR1cmF0aW9uUmVsXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uUmVsID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvblJlbCwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBzZWdtZW50IG9mZnNldHMgaW4gc2VjXG4gICAgICpcbiAgICAgKiBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxuICAgICAqIG9mZnNldCA8IDA6IHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uIGlzIHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uXG4gICAgICogYW5kIHRoZSBkdXJhdGlvbiBoYXMgdG8gYmUgY29ycmVjdGVkIGJ5IHRoZSBvZmZzZXRcbiAgICAgKlxuICAgICAqIEBuYW1lIG9mZnNldEFycmF5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0IFswLjBdXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldEFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRBcnJheSwgWzAuMF0pO1xuXG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgc2VnbWVudCBvZmZzZXQgaW4gc2VjXG4gICAgICogQG5hbWUgb2Zmc2V0QWJzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMC4wMDVcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0QWJzID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRBYnMsIC0wLjAwNSk7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IG9mZnNldCByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXG4gICAgICogQG5hbWUgb2Zmc2V0UmVsXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0UmVsLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5IHRvIHJlYWxpemUgc2VnbWVudCBvZmZzZXRzKVxuICAgICAqIEBuYW1lIGRlbGF5XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kZWxheSA9IG9wdE9yRGVmKG9wdGlvbnMuZGVsYXksIDAuMDA1KTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xuICAgICAqIEBuYW1lIGF0dGFja0Fic1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wMDVcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuYXR0YWNrQWJzID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tBYnMsIDAuMDA1KTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cbiAgICAgKiBAbmFtZSBhdHRhY2tSZWxcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuYXR0YWNrUmVsID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tSZWwsIDApO1xuXG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xuICAgICAqIEBuYW1lIHJlbGVhc2VBYnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMDA1XG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlbGVhc2VBYnMgPSBvcHRPckRlZihvcHRpb25zLnJlbGVhc2VBYnMsIDAuMDA1KTtcblxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXG4gICAgICogQG5hbWUgcmVsZWFzZVJlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5yZWxlYXNlUmVsID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlUmVsLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnQgcmVzYW1wbGluZyBpbiBjZW50XG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5yZXNhbXBsaW5nID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1ZhclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5yZXNhbXBsaW5nVmFyID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nVmFyLCAwKTtcblxuICAgIC8qKlxuICAgICAqIExpbmVhciBnYWluIGZhY3RvclxuICAgICAqIEBuYW1lIGdhaW5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZ2FpbiA9IG9wdE9yRGVmKG9wdGlvbnMuZ2FpbiwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiB0aGUgc2VnbWVudCB0byBzeW50aGVzaXplIChpLmUuIG9mIHRoaXMucG9zaXRpb25BcnJheS9kdXJhdGlvbkFycmF5L29mZnNldEFycmF5KVxuICAgICAqIEBuYW1lIHNlZ21lbnRJbmRleFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBvcHRPckRlZihvcHRpb25zLnNlZ21lbnRJbmRleCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIHNlZ21lbnQgaW5kaWNlcyBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcbiAgICAgKiBAbmFtZSBjeWNsaWNcbiAgICAgKiBAdHlwZSB7Qm9vbH1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xuICAgIHRoaXMuX19jeWNsaWNPZmZzZXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbGFzdCBzZWdtZW50IGlzIGFib3J0ZWQgd2hlbiB0cmlnZ2VyaW5nIHRoZSBuZXh0XG4gICAgICogQG5hbWUgbW9ub3Bob25pY1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMubW9ub3Bob25pYyA9IG9wdE9yRGVmKG9wdGlvbnMubW9ub3Bob25pYywgZmFsc2UpO1xuICAgIHRoaXMuX19jdXJyZW50U3JjID0gbnVsbDtcbiAgICB0aGlzLl9fY3VycmVudEVudiA9IG51bGw7XG4gICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IDA7XG4gICAgdGhpcy5fX2N1cnJlbnRFbmRUaW1lID0gMDtcblxuICAgIC8qKlxuICAgICAqIEZhZGUtb3V0IHRpbWUgKHdoZW4gYWJvcnRlZClcbiAgICAgKiBAbmFtZSBhYm9ydFRpbWVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMDA1XG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmFib3J0VGltZSA9IG9wdE9yRGVmKG9wdGlvbnMuYWJvcnRUaW1lLCAwLjAwNSk7XG5cbiAgICAvKipcbiAgICAgKiBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIGJ1ZmZlciB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxuICAgICAqIEBuYW1lIHdyYXBBcm91bmRFeHRlbnNpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XG5cbiAgICB0aGlzLm91dHB1dE5vZGUgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvbiAoZXhjbHVkaW5nIHdyYXBBcm91bmRFeHRlbnNpb24pXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBnZXQgYnVmZmVyRHVyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcblxuICAgICAgaWYgKHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbilcbiAgICAgICAgYnVmZmVyRHVyYXRpb24gLT0gdGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uO1xuXG4gICAgICByZXR1cm4gYnVmZmVyRHVyYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxuICBhZHZhbmNlVGltZSh0aW1lKSB7XG4gICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICByZXR1cm4gdGltZSArIHRoaXMudHJpZ2dlcih0aW1lKTtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcbiAgICB2YXIgY3ljbGljT2Zmc2V0ID0gMDtcbiAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgaWYgKHRoaXMuY3ljbGljKSB7XG4gICAgICB2YXIgY3ljbGVzID0gcG9zaXRpb24gLyBidWZmZXJEdXJhdGlvbjtcblxuICAgICAgY3ljbGljT2Zmc2V0ID0gTWF0aC5mbG9vcihjeWNsZXMpICogYnVmZmVyRHVyYXRpb247XG4gICAgICBwb3NpdGlvbiAtPSBjeWNsaWNPZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHNwZWVkID4gMCkge1xuICAgICAgaW5kZXggPSBnZXRDdXJyZW50T3JOZXh0SW5kZXgodGhpcy5wb3NpdGlvbkFycmF5LCBwb3NpdGlvbik7XG5cbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgY3ljbGljT2Zmc2V0ICs9IGJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwKSB7XG4gICAgICBpbmRleCA9IGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgodGhpcy5wb3NpdGlvbkFycmF5LCBwb3NpdGlvbik7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgY3ljbGljT2Zmc2V0IC09IGJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXG4gICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcblxuICAgIHJldHVybiBjeWNsaWNPZmZzZXQgKyB0aGlzLnBvc2l0aW9uQXJyYXlbaW5kZXhdO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xuICAgIHZhciBjeWNsaWNPZmZzZXQgPSB0aGlzLl9fY3ljbGljT2Zmc2V0O1xuXG4gICAgdGhpcy50cmlnZ2VyKHRpbWUpO1xuXG4gICAgaWYgKHNwZWVkID4gMCkge1xuICAgICAgaW5kZXgrKztcblxuICAgICAgaWYgKGluZGV4ID49IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBjeWNsaWNPZmZzZXQgKz0gdGhpcy5idWZmZXJEdXJhdGlvbjtcblxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXgtLTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxO1xuICAgICAgICBjeWNsaWNPZmZzZXQgLT0gdGhpcy5idWZmZXJEdXJhdGlvbjtcblxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gY3ljbGljT2Zmc2V0O1xuXG4gICAgcmV0dXJuIGN5Y2xpY09mZnNldCArIHRoaXMucG9zaXRpb25BcnJheVtpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhIHNlZ21lbnQuXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBhdCBhbnkgdGltZSAod2hldGhlciB0aGUgZW5naW5lIGlzIHNjaGVkdWxlZC90cmFuc3BvcnRlZCBvciBub3QpXG4gICAqIHRvIGdlbmVyYXRlIGEgc2luZ2xlIHNlZ21lbnQgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHNlZ21lbnQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgc2VnbWVudCBzeW50aGVzaXMgYXVkaW8gdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBlcmlvZCB0byBuZXh0IHNlZ21lbnRcbiAgICovXG4gIHRyaWdnZXIodGltZSkge1xuICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcbiAgICB2YXIgc2VnbWVudFRpbWUgPSAodGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUpICsgdGhpcy5kZWxheTtcbiAgICB2YXIgc2VnbWVudFBlcmlvZCA9IHRoaXMucGVyaW9kQWJzO1xuICAgIHZhciBzZWdtZW50SW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcblxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdmFyIHNlZ21lbnRQb3NpdGlvbiA9IDAuMDtcbiAgICAgIHZhciBzZWdtZW50RHVyYXRpb24gPSAwLjA7XG4gICAgICB2YXIgc2VnbWVudE9mZnNldCA9IDAuMDtcbiAgICAgIHZhciByZXNhbXBsaW5nUmF0ZSA9IDEuMDtcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XG5cbiAgICAgIGlmICh0aGlzLmN5Y2xpYylcbiAgICAgICAgc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICUgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgc2VnbWVudEluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VnbWVudEluZGV4LCB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMSkpO1xuXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbkFycmF5KVxuICAgICAgICBzZWdtZW50UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xuXG4gICAgICBpZiAodGhpcy5kdXJhdGlvbkFycmF5KVxuICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uQXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xuXG4gICAgICBpZiAodGhpcy5vZmZzZXRBcnJheSlcbiAgICAgICAgc2VnbWVudE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgcmVzYW1wbGluZ1xuICAgICAgaWYgKHRoaXMucmVzYW1wbGluZyAhPT0gMCB8fCB0aGlzLnJlc2FtcGxpbmdWYXIgPiAwKSB7XG4gICAgICAgIHZhciByYW5kb21SZXNhbXBsaW5nID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wICogdGhpcy5yZXNhbXBsaW5nVmFyO1xuICAgICAgICByZXNhbXBsaW5nUmF0ZSA9IE1hdGgucG93KDIuMCwgKHRoaXMucmVzYW1wbGluZyArIHJhbmRvbVJlc2FtcGxpbmcpIC8gMTIwMC4wKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsY3VsYXRlIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcbiAgICAgIGlmIChzZWdtZW50RHVyYXRpb24gPT09IDAgfHwgdGhpcy5wZXJpb2RSZWwgPiAwKSB7XG4gICAgICAgIHZhciBuZXh0U2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICsgMTtcbiAgICAgICAgdmFyIG5leHRQb3NpdGlvbiwgbmV4dE9mZnNldDtcblxuICAgICAgICBpZiAobmV4dFNlZ21lbnRJbmRleCA9PT0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0aGlzLmN5Y2xpYykge1xuICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5WzBdICsgYnVmZmVyRHVyYXRpb247XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gYnVmZmVyRHVyYXRpb247XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W25leHRTZWdtZW50SW5kZXhdO1xuICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W25leHRTZWdtZW50SW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGludGVyU2VnbWVudERpc3RhbmNlID0gbmV4dFBvc2l0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGNvcnJlY3QgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBieSBvZmZzZXRzXG4gICAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cbiAgICAgICAgaWYgKHNlZ21lbnRPZmZzZXQgPiAwKVxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlIC09IHNlZ21lbnRPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG5leHRPZmZzZXQgPiAwKVxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlICs9IG5leHRPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGludGVyU2VnbWVudERpc3RhbmNlIDwgMClcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSA9IDA7XG5cbiAgICAgICAgLy8gdXNlIGludGVyLXNlZ21lbnQgZGlzdGFuY2UgaW5zdGVhZCBvZiBzZWdtZW50IGR1cmF0aW9uXG4gICAgICAgIGlmIChzZWdtZW50RHVyYXRpb24gPT09IDApXG4gICAgICAgICAgc2VnbWVudER1cmF0aW9uID0gaW50ZXJTZWdtZW50RGlzdGFuY2U7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlciBtYXJrZXIgZGlzdGFuY2VcbiAgICAgICAgc2VnbWVudFBlcmlvZCArPSB0aGlzLnBlcmlvZFJlbCAqIGludGVyU2VnbWVudERpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgZHVyYXRpb25cbiAgICAgIHNlZ21lbnREdXJhdGlvbiAqPSB0aGlzLmR1cmF0aW9uUmVsO1xuICAgICAgc2VnbWVudER1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25BYnM7XG5cbiAgICAgIC8vIGFkZCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgc2VnbWVudCBvZmZzZXRcbiAgICAgIHNlZ21lbnRPZmZzZXQgKj0gdGhpcy5vZmZzZXRSZWw7XG4gICAgICBzZWdtZW50T2Zmc2V0ICs9IHRoaXMub2Zmc2V0QWJzO1xuXG4gICAgICAvLyBhcHBseSBzZWdtZW50IG9mZnNldFxuICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxuICAgICAgLy8gICBvZmZzZXQgPCAwOiB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvbiBpcyB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBhbmQgdGhlIGR1cmF0aW9uIGhhcyB0byBiZSBjb3JyZWN0ZWQgYnkgdGhlIG9mZnNldFxuICAgICAgaWYgKHNlZ21lbnRPZmZzZXQgPCAwKSB7XG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiAtPSBzZWdtZW50T2Zmc2V0O1xuICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gc2VnbWVudE9mZnNldDtcbiAgICAgICAgc2VnbWVudFRpbWUgKz0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50VGltZSAtPSAoc2VnbWVudE9mZnNldCAvIHJlc2FtcGxpbmdSYXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmFuZG9taXplIHNlZ21lbnQgcG9zaXRpb25cbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uVmFyID4gMClcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucG9zaXRpb25WYXI7XG5cbiAgICAgIC8vIHNob3J0ZW4gZHVyYXRpb24gb2Ygc2VnbWVudHMgb3ZlciB0aGUgZWRnZXMgb2YgdGhlIGJ1ZmZlclxuICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiA8IDApIHtcbiAgICAgICAgLy9zZWdtZW50VGltZSAtPSBncmFpblBvc2l0aW9uOyBobSwgbm90IHN1cmUgaWYgd2Ugd2FudCB0byBkbyB0aGlzXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiArPSBzZWdtZW50UG9zaXRpb247XG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gKyBzZWdtZW50RHVyYXRpb24gPiB0aGlzLmJ1ZmZlci5kdXJhdGlvbilcbiAgICAgICAgc2VnbWVudER1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb24gLSBzZWdtZW50UG9zaXRpb247XG5cbiAgICAgIHNlZ21lbnREdXJhdGlvbiAvPSByZXNhbXBsaW5nUmF0ZTtcblxuICAgICAgaWYgKHRoaXMubW9ub3Bob25pYylcbiAgICAgICAgdGhpcy5hYm9ydChzZWdtZW50VGltZSk7XG5cbiAgICAgIC8vIG1ha2Ugc2VnbWVudFxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgc2VnbWVudER1cmF0aW9uID4gMCkge1xuICAgICAgICAvLyBtYWtlIHNlZ21lbnQgZW52ZWxvcGVcbiAgICAgICAgdmFyIGVudmVsb3BlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgdmFyIGF0dGFjayA9IHRoaXMuYXR0YWNrQWJzICsgdGhpcy5hdHRhY2tSZWwgKiBzZWdtZW50RHVyYXRpb247XG4gICAgICAgIHZhciByZWxlYXNlID0gdGhpcy5yZWxlYXNlQWJzICsgdGhpcy5yZWxlYXNlUmVsICogc2VnbWVudER1cmF0aW9uO1xuXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gc2VnbWVudER1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIGZhY3RvciA9IHNlZ21lbnREdXJhdGlvbiAvIChhdHRhY2sgKyByZWxlYXNlKTtcbiAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xuICAgICAgICAgIHJlbGVhc2UgKj0gZmFjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dGFja0VuZFRpbWUgPSBzZWdtZW50VGltZSArIGF0dGFjaztcbiAgICAgICAgdmFyIHNlZ21lbnRFbmRUaW1lID0gc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb247XG4gICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gc2VnbWVudEVuZFRpbWUgLSByZWxlYXNlO1xuXG4gICAgICAgIGVudmVsb3BlLmdhaW4udmFsdWUgPSAwO1xuICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudFRpbWUpO1xuICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XG5cbiAgICAgICAgaWYgKHJlbGVhc2VTdGFydFRpbWUgPiBhdHRhY2tFbmRUaW1lKVxuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5nYWluLCByZWxlYXNlU3RhcnRUaW1lKTtcblxuICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudEVuZFRpbWUpO1xuICAgICAgICBlbnZlbG9wZS5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XG5cbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBlbnZlbG9wZTtcblxuICAgICAgICAvLyBtYWtlIHNvdXJjZVxuICAgICAgICB2YXIgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHJlc2FtcGxpbmdSYXRlO1xuICAgICAgICBzb3VyY2UuY29ubmVjdChlbnZlbG9wZSk7XG5cbiAgICAgICAgc291cmNlLnN0YXJ0KHNlZ21lbnRUaW1lLCBzZWdtZW50UG9zaXRpb24pO1xuICAgICAgICBzb3VyY2Uuc3RvcChzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbik7XG5cbiAgICAgICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gcmVsZWFzZVN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRHYWluID0gdGhpcy5nYWluO1xuICAgICAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSBzZWdtZW50RW5kVGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBncmFpbiBwZXJpb2QgcmFuZG9uIHZhcmlhdGlvblxuICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcbiAgICAgIHNlZ21lbnRQZXJpb2QgKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wZXJpb2RWYXIgKiBncmFpblBlcmlvZDtcblxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnBlcmlvZE1pbiwgc2VnbWVudFBlcmlvZCk7XG4gIH1cblxuICBhYm9ydCh0aW1lKSB7XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XG4gICAgY29uc3QgZW5kVGltZSA9IHRoaXMuX19jdXJyZW50RW5kVGltZTtcbiAgICBjb25zdCBhYm9ydFRpbWUgPSB0aW1lIHx8IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcblxuICAgIGlmIChhYm9ydFRpbWUgPCBlbmRUaW1lKSB7XG4gICAgICBjb25zdCBzZWdtZW50RW5kVGltZSA9IE1hdGgubWluKGFib3J0VGltZSArIHRoaXMuYWJvcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5fX2N1cnJlbnRFbnY7XG4gICAgICBsZXQgY3VycmVudEdhaW5WYWx1ZSA9IHRoaXMuX19jdXJyZW50R2FpbjtcblxuICAgICAgaWYgKGFib3J0VGltZSA+IHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2VTdGFydCA9IHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lO1xuICAgICAgICBjdXJyZW50R2FpblZhbHVlICo9IChhYm9ydFRpbWUgLSByZWxlYXNlU3RhcnQpIC8gKGVuZFRpbWUgLSByZWxlYXNlU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBlbnZlbG9wZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhYm9ydFRpbWUpO1xuICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShjdXJyZW50R2FpblZhbHVlLCBhYm9ydFRpbWUpO1xuICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBzZWdtZW50RW5kVGltZSk7XG5cbiAgICAgIHRoaXMuX19jdXJyZW50U3JjID0gbnVsbDtcbiAgICAgIHRoaXMuX19jdXJyZW50RW52ID0gbnVsbDtcbiAgICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gMDtcbiAgICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IDA7XG4gICAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSAwO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWdtZW50RW5naW5lO1xuIiwiLy8gY29yZVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBhdWRpb0NvbnRleHQgfSBmcm9tICcuL2NvcmUvYXVkaW8tY29udGV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRpbWVFbmdpbmUgfSBmcm9tICcuL2NvcmUvdGltZS1lbmdpbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdWRpb1RpbWVFbmdpbmUgfSBmcm9tICcuL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcmlvcml0eVF1ZXVlIH0gZnJvbSAnLi9jb3JlL3ByaW9yaXR5LXF1ZXVlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NoZWR1bGluZ1F1ZXVlIH0gZnJvbSAnLi9jb3JlL3NjaGVkdWxpbmctcXVldWUnO1xuXG4vLyBlbmdpbmVzXG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyYW51bGFyRW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL2dyYW51bGFyLWVuZ2luZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1ldHJvbm9tZSB9IGZyb20gJy4vZW5naW5lcy9tZXRyb25vbWUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQbGF5ZXJFbmdpbmUgfSBmcm9tICcuL2VuZ2luZXMvcGxheWVyLWVuZ2luZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlZ21lbnRFbmdpbmUgfSBmcm9tICcuL2VuZ2luZXMvc2VnbWVudC1lbmdpbmUnO1xuXG4vLyBtYXN0ZXJzXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYXlDb250cm9sIH0gZnJvbSAnLi9tYXN0ZXJzL3BsYXktY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRyYW5zcG9ydCB9IGZyb20gJy4vbWFzdGVycy90cmFuc3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTY2hlZHVsZXIgfSBmcm9tICcuL21hc3RlcnMvc2NoZWR1bGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2ltcGxlU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL3NpbXBsZS1zY2hlZHVsZXInO1xuXG4vLyBmYWN0b3JpZXNcbmV4cG9ydCB7IGdldFNjaGVkdWxlciB9IGZyb20gJy4vbWFzdGVycy9mYWN0b3JpZXMnO1xuZXhwb3J0IHsgZ2V0U2ltcGxlU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL2ZhY3Rvcmllcyc7XG4iLCIvLyBzY2hlZHVsZXJzIHNob3VsZCBiZSBzaW5nbGV0b25zXG5pbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICcuL3NjaGVkdWxlcic7XG5pbXBvcnQgU2ltcGxlU2NoZWR1bGVyIGZyb20gJy4vc2ltcGxlLXNjaGVkdWxlcic7XG5cbmNvbnN0IHNjaGVkdWxlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaW1wbGVTY2hlZHVsZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaW5zdGFuY2Ugb2YgYFNjaGVkdWxlcmBcbiAqXG4gKiBAZ2xvYmFsXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtTY2hlZHVsZXJ9XG4gKiBAc2VlIFNjaGVkdWxlclxuICovXG5leHBvcnQgY29uc3QgZ2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oYXVkaW9Db250ZXh0ID0gZGVmYXVsdEF1ZGlvQ29udGV4dCkge1xuICBsZXQgc2NoZWR1bGVyID0gc2NoZWR1bGVyTWFwLmdldChhdWRpb0NvbnRleHQpO1xuXG4gIGlmICghc2NoZWR1bGVyKSB7XG4gICAgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcih7IGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0IH0pO1xuICAgIHNjaGVkdWxlck1hcC5zZXQoYXVkaW9Db250ZXh0LCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgcmV0dXJuIHNjaGVkdWxlcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBgU2ltcGxlU2NoZWR1bGVyYFxuICpcbiAqIEBnbG9iYWxcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge1NpbXBsZVNjaGVkdWxlcn1cbiAqIEBzZWUgU2ltcGxlU2NoZWR1bGVyXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTaW1wbGVTY2hlZHVsZXIgPSBmdW5jdGlvbihhdWRpb0NvbnRleHQgPSBkZWZhdWx0QXVkaW9Db250ZXh0KSB7XG4gIGxldCBzaW1wbGVTY2hlZHVsZXIgPSBzaW1wbGVTY2hlZHVsZXJNYXAuZ2V0KGF1ZGlvQ29udGV4dCk7XG5cbiAgaWYgKCFzaW1wbGVTY2hlZHVsZXIpIHtcbiAgICBzaW1wbGVTY2hlZHVsZXIgPSBuZXcgU2ltcGxlU2NoZWR1bGVyKHsgYXVkaW9Db250ZXh0OiBhdWRpb0NvbnRleHQgfSk7XG4gICAgc2ltcGxlU2NoZWR1bGVyTWFwLnNldChhdWRpb0NvbnRleHQsIHNpbXBsZVNjaGVkdWxlcik7XG4gIH1cblxuICByZXR1cm4gc2ltcGxlU2NoZWR1bGVyO1xufTtcbiIsImltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XG5pbXBvcnQgU2NoZWR1bGluZ1F1ZXVlIGZyb20gJy4uL2NvcmUvc2NoZWR1bGluZy1xdWV1ZSc7XG5pbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL3RpbWUtZW5naW5lJztcbmltcG9ydCB7IGdldFNjaGVkdWxlciB9IGZyb20gJy4vZmFjdG9yaWVzJztcblxuY29uc3QgRVBTSUxPTiA9IDFlLTg7XG5cbmNsYXNzIExvb3BDb250cm9sIGV4dGVuZHMgVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKHBsYXlDb250cm9sKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIHRoaXMubG93ZXIgPSAtSW5maW5pdHk7XG4gICAgdGhpcy51cHBlciA9IEluZmluaXR5O1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHNjaGVkdWxlZCBpbnRlcmZhY2UpXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcbiAgICBjb25zdCBwbGF5Q29udHJvbCA9IHRoaXMuX19wbGF5Q29udHJvbDtcbiAgICBjb25zdCBzcGVlZCA9IHRoaXMuc3BlZWQ7XG4gICAgY29uc3QgbG93ZXIgPSB0aGlzLmxvd2VyO1xuICAgIGNvbnN0IHVwcGVyID0gdGhpcy51cHBlcjtcblxuICAgIGlmIChzcGVlZCA+IDApXG4gICAgICB0aW1lICs9IEVQU0lMT047XG4gICAgZWxzZVxuICAgICAgdGltZSAtPSBFUFNJTE9OO1xuXG4gICAgaWYgKHNwZWVkID4gMCkge1xuICAgICAgcGxheUNvbnRyb2wuc3luY1NwZWVkKHRpbWUsIGxvd2VyLCBzcGVlZCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbih1cHBlcikgLSBFUFNJTE9OO1xuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwKSB7XG4gICAgICBwbGF5Q29udHJvbC5zeW5jU3BlZWQodGltZSwgdXBwZXIsIHNwZWVkLCB0cnVlKTtcbiAgICAgIHJldHVybiBwbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKGxvd2VyKSArIEVQU0lMT047XG4gICAgfVxuXG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG5cbiAgcmVzY2hlZHVsZShzcGVlZCkge1xuICAgIGNvbnN0IHBsYXlDb250cm9sID0gdGhpcy5fX3BsYXlDb250cm9sO1xuICAgIGNvbnN0IGxvd2VyID0gTWF0aC5taW4ocGxheUNvbnRyb2wuX19sb29wU3RhcnQsIHBsYXlDb250cm9sLl9fbG9vcEVuZCk7XG4gICAgY29uc3QgdXBwZXIgPSBNYXRoLm1heChwbGF5Q29udHJvbC5fX2xvb3BTdGFydCwgcGxheUNvbnRyb2wuX19sb29wRW5kKTtcblxuICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICB0aGlzLmxvd2VyID0gbG93ZXI7XG4gICAgdGhpcy51cHBlciA9IHVwcGVyO1xuXG4gICAgaWYgKGxvd2VyID09PSB1cHBlcilcbiAgICAgIHNwZWVkID0gMDtcblxuICAgIGlmIChzcGVlZCA+IDApXG4gICAgICB0aGlzLnJlc2V0VGltZShwbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKHVwcGVyKSAtIEVQU0lMT04pO1xuICAgIGVsc2UgaWYgKHNwZWVkIDwgMClcbiAgICAgIHRoaXMucmVzZXRUaW1lKHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24obG93ZXIpICsgRVBTSUxPTik7XG4gICAgZWxzZVxuICAgICAgdGhpcy5yZXNldFRpbWUoSW5maW5pdHkpO1xuICB9XG5cbiAgYXBwbHlMb29wQm91bmRhcmllcyhwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBjb25zdCBsb3dlciA9IHRoaXMubG93ZXI7XG4gICAgY29uc3QgdXBwZXIgPSB0aGlzLnVwcGVyO1xuXG4gICAgaWYgKHNwZWVkID4gMCAmJiBwb3NpdGlvbiA+PSB1cHBlcilcbiAgICAgIHJldHVybiBsb3dlciArIChwb3NpdGlvbiAtIGxvd2VyKSAlICh1cHBlciAtIGxvd2VyKTtcbiAgICBlbHNlIGlmIChzcGVlZCA8IDAgJiYgcG9zaXRpb24gPCBsb3dlcilcbiAgICAgIHJldHVybiB1cHBlciAtICh1cHBlciAtIHBvc2l0aW9uKSAlICh1cHBlciAtIGxvd2VyKTtcblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxufVxuXG4vLyBwbGF5IGNvbnRyb2xsZWQgYmFzZSBjbGFzc1xuY2xhc3MgUGxheUNvbnRyb2xsZWQge1xuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gcGxheUNvbnRyb2w7XG5cbiAgICBlbmdpbmUubWFzdGVyID0gdGhpcztcbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xuICB9XG5cbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKSB7XG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRQb3NpdGlvbjtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gbnVsbDtcblxuICAgIHRoaXMuX19lbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICB0aGlzLl9fZW5naW5lID0gbnVsbDtcbiAgfVxufVxuXG4vLyBwbGF5IGNvbnRyb2wgZm9yIGVuZ2luZXMgaW1wbGVtZW50aW5nIHRoZSAqc3BlZWQtY29udHJvbGxlZCogaW50ZXJmYWNlXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNwZWVkQ29udHJvbGxlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xuICAgIHN1cGVyKHBsYXlDb250cm9sLCBlbmdpbmUpO1xuICB9XG59XG5cbi8vIHBsYXkgY29udHJvbCBmb3IgZW5naW5lcyBpbXBsbWVudGluZyB0aGUgKnRyYW5zcG9ydGVkKiBpbnRlcmZhY2VcbmNsYXNzIFBsYXlDb250cm9sbGVkVHJhbnNwb3J0ZWQgZXh0ZW5kcyBQbGF5Q29udHJvbGxlZCB7XG4gIGNvbnN0cnVjdG9yKHBsYXlDb250cm9sLCBlbmdpbmUpIHtcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcblxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rID0gbmV3IFBsYXlDb250cm9sbGVkU2NoZWR1bGVySG9vayhwbGF5Q29udHJvbCwgZW5naW5lKTtcbiAgfVxuXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWssIGxhc3RTcGVlZCkge1xuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IChzZWVrICYmIHNwZWVkICE9PSAwKSkge1xuICAgICAgdmFyIG5leHRQb3NpdGlvbjtcblxuICAgICAgLy8gcmVzeW5jIHRyYW5zcG9ydGVkIGVuZ2luZXNcbiAgICAgIGlmIChzZWVrIHx8IHNwZWVkICogbGFzdFNwZWVkIDwgMCkge1xuICAgICAgICAvLyBzZWVrIG9yIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCkge1xuICAgICAgICAvLyBzdGFydFxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gMCkge1xuICAgICAgICAvLyBzdG9wXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IEluZmluaXR5O1xuXG4gICAgICAgIGlmICh0aGlzLl9fZW5naW5lLnN5bmNTcGVlZClcbiAgICAgICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKSB7XG4gICAgICAgIC8vIGNoYW5nZSBzcGVlZCB3aXRob3V0IHJldmVyc2luZyBkaXJlY3Rpb25cbiAgICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fX3NjaGVkdWxlckhvb2sucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0RW5naW5lUG9zaXRpb24oZW5naW5lLCBwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XG4gICAgICB2YXIgdGltZSA9IHBsYXlDb250cm9sLl9fc3luYygpO1xuXG4gICAgICBwb3NpdGlvbiA9IHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBsYXlDb250cm9sLl9fcG9zaXRpb24sIHBsYXlDb250cm9sLl9fc3BlZWQpO1xuICAgIH1cblxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vay5kZXN0cm95KCk7XG4gICAgdGhpcy5fX3NjaGVkdWxlckhvb2sgPSBudWxsO1xuXG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbi8vIHBsYXkgY29udHJvbCBmb3IgdGltZSBlbmdpbmVzIGltcGxlbWVudGluZyB0aGUgKnNjaGVkdWxlZCogaW50ZXJmYWNlXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xuICAgIHN1cGVyKHBsYXlDb250cm9sLCBlbmdpbmUpO1xuXG4gICAgLy8gc2NoZWR1bGluZyBxdWV1ZSBiZWNvbWVzIG1hc3RlciBvZiBlbmdpbmVcbiAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICB0aGlzLl9fc2NoZWR1bGluZ1F1ZXVlID0gbmV3IFBsYXlDb250cm9sbGVkU2NoZWR1bGluZ1F1ZXVlKHBsYXlDb250cm9sLCBlbmdpbmUpO1xuICB9XG5cbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKSB7XG4gICAgaWYgKGxhc3RTcGVlZCA9PT0gMCAmJiBzcGVlZCAhPT0gMCkgLy8gc3RhcnQgb3Igc2Vla1xuICAgICAgdGhpcy5fX2VuZ2luZS5yZXNldFRpbWUoKTtcbiAgICBlbHNlIGlmIChsYXN0U3BlZWQgIT09IDAgJiYgc3BlZWQgPT09IDApIC8vIHN0b3BcbiAgICAgIHRoaXMuX19lbmdpbmUucmVzZXRUaW1lKEluZmluaXR5KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX3NjaGVkdWxpbmdRdWV1ZS5kZXN0cm95KCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbi8vIHRyYW5zbGF0ZXMgdHJhbnNwb3J0ZWQgZW5naW5lIGFkdmFuY2VQb3NpdGlvbiBpbnRvIGdsb2JhbCBzY2hlZHVsZXIgdGltZXNcbmNsYXNzIFBsYXlDb250cm9sbGVkU2NoZWR1bGVySG9vayBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xuICAgIHRoaXMuX19lbmdpbmUgPSBlbmdpbmU7XG5cbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gSW5maW5pdHk7XG4gICAgcGxheUNvbnRyb2wuX19zY2hlZHVsZXIuYWRkKHRoaXMsIEluZmluaXR5KTtcbiAgfVxuXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcbiAgICB2YXIgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XG4gICAgdmFyIGVuZ2luZSA9IHRoaXMuX19lbmdpbmU7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fX25leHRQb3NpdGlvbjtcbiAgICB2YXIgbmV4dFBvc2l0aW9uID0gZW5naW5lLmFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgcGxheUNvbnRyb2wuX19zcGVlZCk7XG4gICAgdmFyIG5leHRUaW1lID0gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IG5leHRQb3NpdGlvbjtcbiAgICByZXR1cm4gbmV4dFRpbWU7XG4gIH1cblxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50VGltZTtcbiAgfVxuXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50UG9zaXRpb247XG4gIH1cblxuICByZXNldFBvc2l0aW9uKHBvc2l0aW9uID0gdGhpcy5fX25leHRQb3NpdGlvbikge1xuICAgIHZhciB0aW1lID0gdGhpcy5fX3BsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB0aGlzLnJlc2V0VGltZSh0aW1lKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX3BsYXlDb250cm9sLl9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBudWxsO1xuICAgIHRoaXMuX19lbmdpbmUgPSBudWxsO1xuICB9XG59XG5cbi8vIGludGVybmFsIHNjaGVkdWxpbmcgcXVldWUgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHBvc2l0aW9uIChhbmQgdGltZSkgb2YgdGhlIHBsYXkgY29udHJvbFxuY2xhc3MgUGxheUNvbnRyb2xsZWRTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBTY2hlZHVsaW5nUXVldWUge1xuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBwbGF5Q29udHJvbDtcbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xuXG4gICAgdGhpcy5hZGQoZW5naW5lLCBJbmZpbml0eSk7XG4gICAgcGxheUNvbnRyb2wuX19zY2hlZHVsZXIuYWRkKHRoaXMsIEluZmluaXR5KTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRQb3NpdGlvbjtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX3BsYXlDb250cm9sLl9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9fZW5naW5lKTtcblxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IG51bGw7XG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XG4gIH1cbn1cblxuXG4vKipcbiAqIEV4dGVuZHMgVGltZSBFbmdpbmUgdG8gcHJvdmlkZSBwbGF5YmFjayBjb250cm9sIG9mIGEgVGltZSBFbmdpbmUgaW5zdGFuY2UuXG4gKlxuICogW2V4YW1wbGVde0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9wbGF5LWNvbnRyb2wuaHRtbH1cbiAqXG4gKiBAZXh0ZW5kcyBUaW1lRW5naW5lXG4gKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIGVuZ2luZSB0byBjb250cm9sXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHBsYXllckVuZ2luZSA9IGF1ZGlvLlBsYXllckVuZ2luZSgpO1xuICogY29uc3QgcGxheUNvbnRyb2wgPSBuZXcgYXVkaW8uUGxheUNvbnRyb2wocGxheWVyRW5naW5lKTtcbiAqXG4gKiBwbGF5Q29udHJvbC5zdGFydCgpO1xuICovXG5jbGFzcyBQbGF5Q29udHJvbCBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihlbmdpbmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IGRlZmF1bHRBdWRpb0NvbnRleHQ7XG4gICAgdGhpcy5fX3NjaGVkdWxlciA9IGdldFNjaGVkdWxlcih0aGlzLmF1ZGlvQ29udGV4dCk7XG5cbiAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBudWxsO1xuXG4gICAgdGhpcy5fX2xvb3BDb250cm9sID0gbnVsbDtcbiAgICB0aGlzLl9fbG9vcFN0YXJ0ID0gMDtcbiAgICB0aGlzLl9fbG9vcEVuZCA9IDE7XG5cbiAgICAvLyBzeW5jaHJvbml6ZWQgdGllLCBwb3NpdGlvbiwgYW5kIHNwZWVkXG4gICAgdGhpcy5fX3RpbWUgPSAwO1xuICAgIHRoaXMuX19wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5fX3NwZWVkID0gMDtcblxuICAgIC8vIG5vbi16ZXJvIFwidXNlclwiIHNwZWVkXG4gICAgdGhpcy5fX3BsYXlpbmdTcGVlZCA9IDE7XG5cbiAgICBpZiAoZW5naW5lKVxuICAgICAgdGhpcy5fX3NldEVuZ2luZShlbmdpbmUpO1xuICB9XG5cbiAgX19zZXRFbmdpbmUoZW5naW5lKSB7XG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcblxuICAgIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSlcbiAgICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZCA9IG5ldyBQbGF5Q29udHJvbGxlZFNwZWVkQ29udHJvbGxlZCh0aGlzLCBlbmdpbmUpO1xuICAgIGVsc2UgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1RyYW5zcG9ydGVkKGVuZ2luZSkpXG4gICAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBuZXcgUGxheUNvbnRyb2xsZWRUcmFuc3BvcnRlZCh0aGlzLCBlbmdpbmUpO1xuICAgIGVsc2UgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1NjaGVkdWxlZChlbmdpbmUpKVxuICAgICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbmV3IFBsYXlDb250cm9sbGVkU2NoZWR1bGVkKHRoaXMsIGVuZ2luZSk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBhZGRlZCB0byBwbGF5IGNvbnRyb2xcIik7XG4gIH1cblxuICBfX3Jlc2V0RW5naW5lKCkge1xuICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZC5kZXN0cm95KCk7XG4gICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUvZXh0cmFwb2xhdGUgcGxheWluZyB0aW1lIGZvciBnaXZlbiBwb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gcG9zaXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfSBleHRyYXBvbGF0ZWQgdGltZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX19nZXRUaW1lQXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9fdGltZSArIChwb3NpdGlvbiAtIHRoaXMuX19wb3NpdGlvbikgLyB0aGlzLl9fc3BlZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlL2V4dHJhcG9sYXRlIHBsYXlpbmcgcG9zaXRpb24gZm9yIGdpdmVuIHRpbWVcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGV4dHJhcG9sYXRlZCBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX19nZXRQb3NpdGlvbkF0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xuICB9XG5cbiAgX19zeW5jKCkge1xuICAgIGNvbnN0IG5vdyA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IChub3cgLSB0aGlzLl9fdGltZSkgKiB0aGlzLl9fc3BlZWQ7XG4gICAgdGhpcy5fX3RpbWUgPSBub3c7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgdGltZS5cbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHBsYXktY29udHJvbCBpcyBhZGRlZCB0byBhIG1hc3Rlci5cbiAgICpcbiAgICogQG5hbWUgY3VycmVudFRpbWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgcG9zaXRpb24uXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSBwbGF5LWNvbnRyb2wgaXMgYWRkZWQgdG8gYSBtYXN0ZXIuXG4gICAqXG4gICAqIEBuYW1lIGN1cnJlbnRQb3NpdGlvblxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcbiAgICogQGluc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uICsgKHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWUgLSB0aGlzLl9fdGltZSkgKiB0aGlzLl9fc3BlZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgcGxheSBjb250cm9sIGlzIHJ1bm5pbiBnLlxuICAgKlxuICAgKiBAbmFtZSBydW5uaW5nXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcbiAgICogQGluc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJ1bm5pbmcoKSB7XG4gICAgcmV0dXJuICEodGhpcy5fX3NwZWVkID09PSAwKTtcbiAgfVxuXG4gIHNldChlbmdpbmUgPSBudWxsKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XG5cbiAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkICE9PSBudWxsICYmIHRoaXMuX19wbGF5Q29udHJvbGxlZC5fX2VuZ2luZSAhPT0gZW5naW5lKSB7XG5cbiAgICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgMCk7XG5cbiAgICAgIGlmICh0aGlzLl9fcGxheUNvbnRyb2xsZWQpXG4gICAgICAgIHRoaXMuX19yZXNldEVuZ2luZSgpO1xuXG5cbiAgICAgIGlmICh0aGlzLl9fcGxheUNvbnRyb2xsZWQgPT09IG51bGwgJiYgZW5naW5lICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX19zZXRFbmdpbmUoZW5naW5lKTtcblxuICAgICAgICBpZiAoc3BlZWQgIT09IDApXG4gICAgICAgICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBsYXkgY29udHJvbCBsb29wIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQG5hbWUgbG9vcFxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBzZXQgbG9vcChlbmFibGUpIHtcbiAgICBpZiAoZW5hYmxlICYmIHRoaXMuX19sb29wU3RhcnQgPiAtSW5maW5pdHkgJiYgdGhpcy5fX2xvb3BFbmQgPCBJbmZpbml0eSkge1xuICAgICAgaWYgKCF0aGlzLl9fbG9vcENvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5fX2xvb3BDb250cm9sID0gbmV3IExvb3BDb250cm9sKHRoaXMpO1xuICAgICAgICB0aGlzLl9fc2NoZWR1bGVyLmFkZCh0aGlzLl9fbG9vcENvbnRyb2wsIEluZmluaXR5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19zcGVlZCAhPT0gMCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY3VycmVudFBvc2l0aW9uO1xuICAgICAgICBjb25zdCBsb3dlciA9IE1hdGgubWluKHRoaXMuX19sb29wU3RhcnQsIHRoaXMuX19sb29wRW5kKTtcbiAgICAgICAgY29uc3QgdXBwZXIgPSBNYXRoLm1heCh0aGlzLl9fbG9vcFN0YXJ0LCB0aGlzLl9fbG9vcEVuZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zcGVlZCA+IDAgJiYgcG9zaXRpb24gPiB1cHBlcilcbiAgICAgICAgICB0aGlzLnNlZWsodXBwZXIpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLl9fc3BlZWQgPCAwICYmIHBvc2l0aW9uIDwgbG93ZXIpXG4gICAgICAgICAgdGhpcy5zZWVrKGxvd2VyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuX19sb29wQ29udHJvbC5yZXNjaGVkdWxlKHRoaXMuX19zcGVlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9fbG9vcENvbnRyb2wpIHtcbiAgICAgIHRoaXMuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMuX19sb29wQ29udHJvbCk7XG4gICAgICB0aGlzLl9fbG9vcENvbnRyb2wgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsb29wKCkge1xuICAgIHJldHVybiAoISF0aGlzLl9fbG9vcENvbnRyb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbG9vcCBzdGFydCBhbmQgZW5kIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb29wU3RhcnQgLSBsb29wIHN0YXJ0IHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbG9vcEVuZCAtIGxvb3AgZW5kIHZhbHVlLlxuICAgKi9cbiAgc2V0TG9vcEJvdW5kYXJpZXMobG9vcFN0YXJ0LCBsb29wRW5kKSB7XG4gICAgdGhpcy5fX2xvb3BTdGFydCA9IGxvb3BTdGFydDtcbiAgICB0aGlzLl9fbG9vcEVuZCA9IGxvb3BFbmQ7XG5cbiAgICB0aGlzLmxvb3AgPSB0aGlzLmxvb3A7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBsb29wIHN0YXJ0IHZhbHVlXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBuYW1lIGxvb3BTdGFydFxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBzZXQgbG9vcFN0YXJ0KGxvb3BTdGFydCkge1xuICAgIHRoaXMuc2V0TG9vcEJvdW5kYXJpZXMobG9vcFN0YXJ0LCB0aGlzLl9fbG9vcEVuZCk7XG4gIH1cblxuICBnZXQgbG9vcFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9fbG9vcFN0YXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbG9vcCBlbmQgdmFsdWVcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgbG9vcEVuZFxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBzZXQgbG9vcEVuZChsb29wRW5kKSB7XG4gICAgdGhpcy5zZXRMb29wQm91bmRhcmllcyh0aGlzLl9fbG9vcFN0YXJ0LCBsb29wRW5kKTtcbiAgfVxuXG4gIGdldCBsb29wRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9fbG9vcEVuZDtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZSlcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlayA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGFzdFNwZWVkID0gdGhpcy5fX3NwZWVkO1xuXG4gICAgaWYgKHNwZWVkICE9PSBsYXN0U3BlZWQgfHwgc2Vlaykge1xuICAgICAgaWYgKChzZWVrIHx8IGxhc3RTcGVlZCA9PT0gMCkgJiYgdGhpcy5fX2xvb3BDb250cm9sKVxuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX19sb29wQ29udHJvbC5hcHBseUxvb3BCb3VuZGFyaWVzKHBvc2l0aW9uLCBzcGVlZCk7XG5cbiAgICAgIHRoaXMuX190aW1lID0gdGltZTtcbiAgICAgIHRoaXMuX19wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XG5cbiAgICAgIGlmICh0aGlzLl9fcGxheUNvbnRyb2xsZWQpXG4gICAgICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZC5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrLCBsYXN0U3BlZWQpO1xuXG4gICAgICBpZiAodGhpcy5fX2xvb3BDb250cm9sKVxuICAgICAgICB0aGlzLl9fbG9vcENvbnRyb2wucmVzY2hlZHVsZShzcGVlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBwbGF5YmFja1xuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XG4gICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCB0aGlzLl9fcGxheWluZ1NwZWVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgcGxheWJhY2sgYW5kIHN0YXlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XG4gICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBwbGF5YmFjayBhbmQgc2Vla3MgdG8gaW5pdGlhbCAoMCkgcG9zaXRpb24uXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xuICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIDAsIDAsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHNwZWVkIGlmIHByb3ZpZGVkLCBzZXRzIHRoZSBwbGF5YmFjayBzcGVlZC4gVGhlIHNwZWVkIHZhbHVlIHNob3VsZFxuICAgKiBiZSBub24temVybyBiZXR3ZWVuIC0xNiBhbmQgLTEvMTYgb3IgYmV0d2VlbiAxLzE2IGFuZCAxNi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgc3BlZWRcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc2V0IHNwZWVkKHNwZWVkKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XG5cbiAgICBpZiAoc3BlZWQgPj0gMCkge1xuICAgICAgaWYgKHNwZWVkIDwgMC4wMSlcbiAgICAgICAgc3BlZWQgPSAwLjAxO1xuICAgICAgZWxzZSBpZiAoc3BlZWQgPiAxMDApXG4gICAgICAgIHNwZWVkID0gMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3BlZWQgPCAtMTAwKVxuICAgICAgICBzcGVlZCA9IC0xMDA7XG4gICAgICBlbHNlIGlmIChzcGVlZCA+IC0wLjAxKVxuICAgICAgICBzcGVlZCA9IC0wLjAxO1xuICAgIH1cblxuICAgIHRoaXMuX19wbGF5aW5nU3BlZWQgPSBzcGVlZDtcblxuICAgIGlmICghdGhpcy5tYXN0ZXIgJiYgdGhpcy5fX3NwZWVkICE9PSAwKVxuICAgICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCBzcGVlZCk7XG4gIH1cblxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wbGF5aW5nU3BlZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IChqdW1wIHRvKSBwbGF5aW5nIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGFyZ2V0IHBvc2l0aW9uXG4gICAqL1xuICBzZWVrKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHRoaXMuX19zcGVlZCwgdHJ1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheUNvbnRyb2w7XG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcbmltcG9ydCBTY2hlZHVsaW5nUXVldWUgZnJvbSAnLi4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcblxuY29uc3QgbG9nID0gZGVidWcoJ3dhdmVzanM6YXVkaW8nKTtcblxuLyoqXG4gKiBUaGUgYFNjaGVkdWxlcmAgY2xhc3MgaW1wbGVtZW50cyBhIG1hc3RlciBmb3IgYFRpbWVFbmdpbmVgIG9yIGBBdWRpb1RpbWVFbmdpbmVgXG4gKiBpbnN0YW5jZXMgdGhhdCBpbXBsZW1lbnQgdGhlICpzY2hlZHVsZWQqIGludGVyZmFjZSBzdWNoIGFzIHRoZSBgTWV0cm9ub21lYFxuICogYEdyYW51bGFyRW5naW5lYC5cbiAqXG4gKiBBIGBTY2hlZHVsZXJgIGNhbiBhbHNvIHNjaGVkdWxlIHNpbXBsZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBUaGUgY2xhc3MgaXMgYmFzZWQgb24gcmVjdXJzaXZlIGNhbGxzIHRvIGBzZXRUaW1lT3V0YCBhbmQgdXNlcyB0aGVcbiAqIGBhdWRpb0NvbnRleHQuY3VycmVudFRpbWVgIGFzIGxvZ2ljYWwgcGFzc2VkIHRvIHRoZSBgYWR2YW5jZVRpbWVgIG1ldGhvZHNcbiAqIG9mIHRoZSBzY2hlZHVsZWQgZW5naW5lcyBvciB0byB0aGUgc2NoZWR1bGVkIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEl0IGV4dGVuZHMgdGhlIGBTY2hlZHVsaW5nUXVldWVgIGNsYXNzIHRoYXQgaXRzZWxmIGluY2x1ZGVzIGEgYFByaW9yaXR5UXVldWVgXG4gKiB0byBhc3N1cmUgdGhlIG9yZGVyIG9mIHRoZSBzY2hlZHVsZWQgZW5naW5lcyAoc2VlIGBTaW1wbGVTY2hlZHVsZXJgIGZvciBhXG4gKiBzaW1wbGlmaWVkIHNjaGVkdWxlciBpbXBsZW1lbnRhdGlvbiB3aXRob3V0IGBQcmlvcml0eVF1ZXVlYCkuXG4gKlxuICogVG8gZ2V0IGEgdW5pcXVlIGluc3RhbmNlIG9mIGBTY2hlZHVsZXJgIGFzIHRoZSBnbG9iYWwgc2NoZWR1bGVyIG9mIGFuXG4gKiBhcHBsaWNhdGlvbiwgdGhlIGBnZXRTY2hlZHVsZXJgIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQuIFRoZVxuICogZnVuY3Rpb24gYWNjZXB0cyBhbiBhdWRpbyBjb250ZXh0IGFzIG9wdGlvbmFsIGFyZ3VtZW50IGFuZCB1c2VzIHRoZSBXYXZlc1xuICogZGVmYXVsdCBhdWRpbyBjb250ZXh0IChzZWUgYGF1ZGlvQ29udGV4dGApIGFzXG4gKiBkZWZhdWx0LiBUaGUgZmFjdG9yeSBjcmVhdGVzIGEgc2luZ2xlIHNjaGVkdWxlciBmb3IgZWFjaCBhdWRpbyBjb250ZXh0LlxuICpcbiAqIEV4YW1wbGUgdGhhdCBzaG93cyB0aHJlZSBNZXRyb25vbWUgZW5naW5lcyBydW5uaW5nIGluIGEgU2NoZWR1bGVyOlxuICoge0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9zY2hlZHVsZXIuaHRtbH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gZGVmYXVsdCBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kPTAuMDI1XSAtIHBlcmlvZCBvZiB0aGUgc2NoZWR1bGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvb2thaGVhZD0wLjFdIC0gbG9va2FoZWFkIG9mIHRoZSBzY2hlZHVsZXIuXG4gKlxuICogQHNlZSBUaW1lRW5naW5lXG4gKiBAc2VlIEF1ZGlvVGltZUVuZ2luZVxuICogQHNlZSBnZXRTY2hlZHVsZXJcbiAqIEBzZWUgU2ltcGxlU2NoZWR1bGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xuICpcbiAqIHNjaGVkdWxlci5hZGQobXlFbmdpbmUpO1xuICovXG5jbGFzcyBTY2hlZHVsZXIgZXh0ZW5kcyBTY2hlZHVsaW5nUXVldWUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCDCoGRlZmF1bHRBdWRpb0NvbnRleHQ7XG5cbiAgICB0aGlzLl9fY3VycmVudFRpbWUgPSBudWxsO1xuICAgIHRoaXMuX19uZXh0VGltZSA9IEluZmluaXR5O1xuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHNjaGVkdWxlciAoc2V0VGltZW91dCkgcGVyaW9kXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBwZXJpb2RcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2QgPSBvcHRpb25zLnBlcmlvZCB8fCDCoDAuMDI1O1xuXG4gICAgLyoqXG4gICAgICogc2NoZWR1bGVyIGxvb2thaGVhZCB0aW1lICg+IHBlcmlvZClcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGxvb2thaGVhZFxuICAgICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmxvb2thaGVhZCA9IG9wdGlvbnMubG9va2FoZWFkIHx8IMKgMC4xO1xuICB9XG5cbiAgLy8gc2V0VGltZW91dCBzY2hlZHVsaW5nIGxvb3BcbiAgX190aWNrKCkge1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIGxldCB0aW1lID0gdGhpcy5fX25leHRUaW1lO1xuXG4gICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRpbWUgPD0gY3VycmVudFRpbWUgKyB0aGlzLmxvb2thaGVhZCkge1xuICAgICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gdGltZTtcbiAgICAgIHRpbWUgPSB0aGlzLmFkdmFuY2VUaW1lKHRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuX19jdXJyZW50VGltZSA9IG51bGw7XG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XG4gIH1cblxuICByZXNldFRpbWUodGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcbiAgICBpZiAodGhpcy5tYXN0ZXIpIHtcbiAgICAgIHRoaXMubWFzdGVyLnJlc2V0KHRoaXMsIHRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fX3RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX190aW1lb3V0KTtcbiAgICAgICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX19uZXh0VGltZSA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgbG9nKCdTY2hlZHVsZXIgU3RhcnQnKTtcblxuICAgICAgICBjb25zdCB0aW1lT3V0RGVsYXkgPSBNYXRoLm1heCgodGltZSAtIHRoaXMubG9va2FoZWFkIC0gdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpLCB0aGlzLnBlcmlvZCk7XG5cbiAgICAgICAgdGhpcy5fX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9fdGljaygpO1xuICAgICAgICB9LCBNYXRoLmNlaWwodGltZU91dERlbGF5ICogMTAwMCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbmV4dFRpbWUgIT09IEluZmluaXR5KSB7XG4gICAgICAgIGxvZygnU2NoZWR1bGVyIFN0b3AnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fX25leHRUaW1lID0gdGltZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVyIGN1cnJlbnQgbG9naWNhbCB0aW1lLlxuICAgKlxuICAgKiBAbmFtZSBjdXJyZW50VGltZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLm1hc3RlcilcbiAgICAgIHJldHVybiB0aGlzLm1hc3Rlci5jdXJyZW50VGltZTtcblxuICAgIHJldHVybiB0aGlzLl9fY3VycmVudFRpbWUgfHwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLmxvb2thaGVhZDtcbiAgfVxuXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgY29uc3QgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XG5cbiAgICBpZiAobWFzdGVyICYmIG1hc3Rlci5jdXJyZW50UG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIGluaGVyaXRlZCBmcm9tIHNjaGVkdWxpbmcgcXVldWVcbiAgLyoqXG4gICAqIEFkZCBhIFRpbWVFbmdpbmUgb3IgYSBzaW1wbGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdGhlIHNjaGVkdWxlciBhdCBhblxuICAgKiBvcHRpb25hbGx5IGdpdmVuIHRpbWUuIFdoZXRoZXIgdGhlIGFkZCBtZXRob2QgaXMgY2FsbGVkIHdpdGggYSBUaW1lRW5naW5lXG4gICAqIG9yIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXQgcmV0dXJucyBhIFRpbWVFbmdpbmUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhcmd1bWVudFxuICAgKiBvZiB0aGUgbWV0aG9kcyByZW1vdmUgYW5kIHJlc2V0RW5naW5lVGltZS4gQSBUaW1lRW5naW5lIGFkZGVkIHRvIGEgc2NoZWR1bGVyXG4gICAqIGhhcyB0byBpbXBsZW1lbnQgdGhlIHNjaGVkdWxlZCBpbnRlcmZhY2UuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBhZGRlZCB0byBhXG4gICAqIHNjaGVkdWxlciB3aWxsIGJlIGNhbGxlZCBhdCB0aGUgZ2l2ZW4gdGltZSBhbmQgd2l0aCB0aGUgZ2l2ZW4gdGltZSBhc1xuICAgKiBhcmd1bWVudC4gVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBuZXcgc2NoZWR1bGluZyB0aW1lIChpLmUuIHRoZSBuZXh0XG4gICAqIHRpbWUgd2hlbiBpdCB3aWxsIGJlIGNhbGxlZCkgb3IgaXQgY2FuIHJldHVybiBJbmZpbml0eSB0byBzdXNwZW5kIHNjaGVkdWxpbmdcbiAgICogd2l0aG91dCByZW1vdmluZyB0aGUgZnVuY3Rpb24gZnJvbSB0aGUgc2NoZWR1bGVyLiBBIGZ1bmN0aW9uIHRoYXQgZG9lc1xuICAgKiBub3QgcmV0dXJuIGEgdmFsdWUgKG9yIHJldHVybnMgbnVsbCBvciAwKSBpcyByZW1vdmVkIGZyb20gdGhlIHNjaGVkdWxlclxuICAgKiBhbmQgY2Fubm90IGJlIHVzZWQgYXMgYXJndW1lbnQgb2YgdGhlIG1ldGhvZHMgcmVtb3ZlIGFuZCByZXNldEVuZ2luZVRpbWVcbiAgICogYW55bW9yZS5cbiAgICpcbiAgICogQG5hbWUgYWRkXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV8RnVuY3Rpb259IGVuZ2luZSAtIEVuZ2luZSB0byBhZGQgdG8gdGhlIHNjaGVkdWxlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXG4gICAqL1xuICAvKipcbiAgICogUmVtb3ZlIGEgVGltZUVuZ2luZSBmcm9tIHRoZSBzY2hlZHVsZXIgdGhhdCBoYXMgYmVlbiBhZGRlZCB0byB0aGVcbiAgICogc2NoZWR1bGVyIHVzaW5nIHRoZSBhZGQgbWV0aG9kLlxuICAgKlxuICAgKiBAbmFtZSBhZGRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIHJlbW92ZSBmcm9tIHRoZSBzY2hlZHVsZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxuICAgKi9cbiAgLyoqXG4gICAqIFJlc2NoZWR1bGUgYSBzY2hlZHVsZWQgdGltZSBlbmdpbmUgYXQgYSBnaXZlbiB0aW1lLlxuICAgKlxuICAgKiBAbmFtZSByZXNldEVuZ2luZVRpbWVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIHJlc2NoZWR1bGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBTY2hlZHVsZSB0aW1lXG4gICAqL1xuICAvKipcbiAgICogUmVtb3ZlIGFsbCBzY2hlZHVsZWQgY2FsbGJhY2tzIGFuZCBlbmdpbmVzIGZyb20gdGhlIHNjaGVkdWxlci5cbiAgICpcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjaGVkdWxlcjtcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xuaW1wb3J0IFRpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS90aW1lLWVuZ2luZSc7XG5cbmNvbnN0IGxvZyA9IGRlYnVnKCd3YXZlc2pzOmF1ZGlvJyk7XG5cbi8qKlxuICpcbiAqXG4gKlxuICogVGhlIFNpbXBsZVNjaGVkdWxlciBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxpZmllZCBtYXN0ZXIgZm9yIHRpbWUgZW5naW5lc1xuICogKHNlZSBUaW1lRW5naW5lIG9yIEF1ZGlvVGltZUVuZ2luZSkgdGhhdCBpbXBsZW1lbnQgdGhlIHNjaGVkdWxlZCBpbnRlcmZhY2VcbiAqIHN1Y2ggYXMgdGhlIE1ldHJvbm9tZSBhbmQgdGhlIEdyYW51bGFyRW5naW5lLiBUaGUgQVBJIGFuZCBmdW50aW9uYWxpdGllcyBvZlxuICogdGhlIFNpbXBsZVNjaGVkdWxlciBjbGFzcyBhcmUgaWRlbnRpY2FsIHRvIHRoZSBTY2hlZHVsZXIgY2xhc3MuIEJ1dCwgb3RoZXJcbiAqIHRoYW4gdGhlIFNjaGVkdWxlciwgdGhlIFNpbXBsZVNjaGVkdWxlciBjbGFzcyBkb2VzIG5vdCBndWFyYW50ZWUgdGhlIG9yZGVyXG4gKiBvZiBldmVudHMgKGkuZS4gY2FsbHMgdG8gdGhlIGFkdmFuY2VUaW1lIG1ldGhvZCBvZiBzY2hlZHVsZWQgdGltZSBlbmdpbmVzXG4gKiBhbmQgdG8gc2NoZWR1bGVkIGNhbGxiYWNrIGZ1bmN0aW9ucykgd2l0aGluIGEgc2NoZWR1bGluZyBwZXJpb2QgKHNlZSBwZXJpb2RcbiAqIGF0dHJpYnV0ZSkuXG4gKlxuICogVG8gZ2V0IGEgdW5pcXVlIGluc3RhbmNlIG9mIFNpbXBsZVNjaGVkdWxlciBhcyB0aGUgZ2xvYmFsIHNjaGVkdWxlciBvZiBhblxuICogYXBwbGljYXRpb24sIHRoZSBnZXRTaW1wbGVTY2hlZHVsZXIgZmFjdG9yeSBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZC4gVGhlXG4gKiBmdW5jdGlvbiBhY2NlcHRzIGFuIGF1ZGlvIGNvbnRleHQgYXMgb3B0aW9uYWwgYXJndW1lbnQgYW5kIHVzZXMgdGhlIFdhdmVzXG4gKiBkZWZhdWx0IGF1ZGlvIGNvbnRleHQgKHNlZSBBdWRpbyBDb250ZXh0KSBhcyBkZWZhdWx0LiBUaGUgZmFjdG9yeSBjcmVhdGVzXG4gKiBhIHNpbmdsZSAoc2ltcGxlKSBzY2hlZHVsZXIgZm9yIGVhY2ggYXVkaW8gY29udGV4dC5cbiAqXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgdGhyZWUgTWV0cm9ub21lIGVuZ2luZXMgcnVubmluZyBpbiBhIFNpbXBsZVNjaGVkdWxlcjpcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvc2ltcGxlLXNjaGVkdWxlci5odG1sfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBkZWZhdWx0IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2Q9MC4wMjVdIC0gcGVyaW9kIG9mIHRoZSBzY2hlZHVsZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9va2FoZWFkPTAuMV0gLSBsb29rYWhlYWQgb2YgdGhlIHNjaGVkdWxlci5cbiAqXG4gKiBAc2VlIFRpbWVFbmdpbmVcbiAqIEBzZWUgQXVkaW9UaW1lRW5naW5lXG4gKiBAc2VlIGdldFNpbXBsZVNjaGVkdWxlclxuICogQHNlZSBTY2hlZHVsZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2ltcGxlU2NoZWR1bGVyKCk7XG4gKlxuICogc2NoZWR1bGVyLmFkZChteUVuZ2luZSk7XG4gKi9cbmNsYXNzIFNpbXBsZVNjaGVkdWxlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gb3B0aW9ucy5hdWRpb0NvbnRleHQgfHwgwqBkZWZhdWx0QXVkaW9Db250ZXh0O1xuXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBuZXcgU2V0KCk7XG5cbiAgICB0aGlzLl9fc2NoZWRFbmdpbmVzID0gW107XG4gICAgdGhpcy5fX3NjaGVkVGltZXMgPSBbXTtcblxuICAgIHRoaXMuX19jdXJyZW50VGltZSA9IG51bGw7XG4gICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogc2NoZWR1bGVyIChzZXRUaW1lb3V0KSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIHBlcmlvZFxuICAgICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZCA9IG9wdGlvbnMucGVyaW9kIHx8IDAuMDI1O1xuXG4gICAgLyoqXG4gICAgICogc2NoZWR1bGVyIGxvb2thaGVhZCB0aW1lICg+IHBlcmlvZClcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGxvb2thaGVhZFxuICAgICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmxvb2thaGVhZCA9IG9wdGlvbnMubG9va2FoZWFkIHx8IDAuMTtcbiAgfVxuXG4gIF9fc2NoZWR1bGVFbmdpbmUoZW5naW5lLCB0aW1lKSB7XG4gICAgdGhpcy5fX3NjaGVkRW5naW5lcy5wdXNoKGVuZ2luZSk7XG4gICAgdGhpcy5fX3NjaGVkVGltZXMucHVzaCh0aW1lKTtcbiAgfVxuXG4gIF9fcmVzY2hlZHVsZUVuZ2luZShlbmdpbmUsIHRpbWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9fc2NoZWRFbmdpbmVzLmluZGV4T2YoZW5naW5lKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpZiAodGltZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5fX3NjaGVkVGltZXNbaW5kZXhdID0gdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19zY2hlZEVuZ2luZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fX3NjaGVkVGltZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRpbWUgPCBJbmZpbml0eSkge1xuICAgICAgdGhpcy5fX3NjaGVkRW5naW5lcy5wdXNoKGVuZ2luZSk7XG4gICAgICB0aGlzLl9fc2NoZWRUaW1lcy5wdXNoKHRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIF9fdW5zY2hlZHVsZUVuZ2luZShlbmdpbmUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9fc2NoZWRFbmdpbmVzLmluZGV4T2YoZW5naW5lKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLl9fc2NoZWRFbmdpbmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLl9fc2NoZWRUaW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIF9fcmVzZXRUaWNrKCkge1xuICAgIGlmICh0aGlzLl9fc2NoZWRFbmdpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICghdGhpcy5fX3RpbWVvdXQpIHtcbiAgICAgICAgbG9nKCdTaW1wbGVTY2hlZHVsZXIgU3RhcnQnKTtcbiAgICAgICAgdGhpcy5fX3RpY2soKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX190aW1lb3V0KSB7XG4gICAgICBsb2coJ1NpbXBsZVNjaGVkdWxlciBTdG9wJyk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fX3RpbWVvdXQpO1xuICAgICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9fdGljaygpIHtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgdGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbmdpbmUgPSB0aGlzLl9fc2NoZWRFbmdpbmVzW2ldO1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLl9fc2NoZWRUaW1lc1tpXTtcblxuICAgICAgd2hpbGUgKHRpbWUgJiYgdGltZSA8PSBjdXJyZW50VGltZSArIHRoaXMubG9va2FoZWFkKSB7XG4gICAgICAgIHRpbWUgPSBNYXRoLm1heCh0aW1lLCBjdXJyZW50VGltZSk7XG4gICAgICAgIHRoaXMuX19jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgICAgIHRpbWUgPSBlbmdpbmUuYWR2YW5jZVRpbWUodGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lICYmIHRpbWUgPCBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLl9fc2NoZWRUaW1lc1tpKytdID0gdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX191bnNjaGVkdWxlRW5naW5lKGVuZ2luZSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGVuZ2luZSBmcm9tIHNjaGVkdWxlclxuICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9fZW5naW5lcy5kZWxldGUoZW5naW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX19jdXJyZW50VGltZSA9IG51bGw7XG4gICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX19zY2hlZEVuZ2luZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fX3RpY2soKTtcbiAgICAgIH0sIHRoaXMucGVyaW9kICogMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlciBjdXJyZW50IGxvZ2ljYWwgdGltZS5cbiAgICpcbiAgICogQG5hbWUgY3VycmVudFRpbWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnRUaW1lIHx8IHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5sb29rYWhlYWQ7XG4gIH1cblxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBjYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lXG4gIC8qKlxuICAgKiBEZWZlciB0aGUgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW4gLSBGdW5jdGlvbiB0byBkZWZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXG4gICAqL1xuICBkZWZlcihmdW4sIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKCEoZnVuIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBkZWZlcmVkIGJ5IHNjaGVkdWxlclwiKTtcblxuICAgIHRoaXMuYWRkKHtcbiAgICAgIGFkdmFuY2VUaW1lOiBmdW5jdGlvbih0aW1lKSB7IGZ1bih0aW1lKTsgfSwgLy8gbWFrZSBzdXIgdGhhdCB0aGUgYWR2YW5jZVRpbWUgbWV0aG9kIGRvZXMgbm90IHJldHVybSBhbnl0aGluZ1xuICAgIH0sIHRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIFRpbWVFbmdpbmUgZnVuY3Rpb24gdG8gdGhlIHNjaGVkdWxlciBhdCBhbiBvcHRpb25hbGx5IGdpdmVuIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIGFkZCB0byB0aGUgc2NoZWR1bGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcbiAgICovXG4gIGFkZChlbmdpbmUsIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKCFUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gc2NoZWR1bGVyXCIpO1xuXG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcblxuICAgIC8vIHNldCBtYXN0ZXIgYW5kIGFkZCB0byBhcnJheVxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xuICAgIHRoaXMuX19lbmdpbmVzLmFkZChlbmdpbmUpO1xuXG4gICAgLy8gc2NoZWR1bGUgZW5naW5lXG4gICAgdGhpcy5fX3NjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSk7XG4gICAgdGhpcy5fX3Jlc2V0VGljaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIFRpbWVFbmdpbmUgZnJvbSB0aGUgc2NoZWR1bGVyIHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlXG4gICAqIHNjaGVkdWxlciB1c2luZyB0aGUgYWRkIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gcmVtb3ZlIGZyb20gdGhlIHNjaGVkdWxlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXG4gICAqL1xuICByZW1vdmUoZW5naW5lKSB7XG4gICAgaWYgKCFlbmdpbmUubWFzdGVyIHx8IGVuZ2luZS5tYXN0ZXIgIT09IHRoaXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmdpbmUgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgc2NoZWR1bGVyXCIpO1xuXG4gICAgLy8gcmVzZXQgbWFzdGVyIGFuZCByZW1vdmUgZnJvbSBhcnJheVxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xuICAgIHRoaXMuX19lbmdpbmVzLmRlbGV0ZShlbmdpbmUpO1xuXG4gICAgLy8gdW5zY2hlZHVsZSBlbmdpbmVcbiAgICB0aGlzLl9fdW5zY2hlZHVsZUVuZ2luZShlbmdpbmUpO1xuICAgIHRoaXMuX19yZXNldFRpY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjaGVkdWxlIGEgc2NoZWR1bGVkIHRpbWUgZW5naW5lIGF0IGEgZ2l2ZW4gdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gcmVzY2hlZHVsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIFNjaGVkdWxlIHRpbWVcbiAgICovXG4gIHJlc2V0RW5naW5lVGltZShlbmdpbmUsIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgdGhpcy5fX3Jlc2NoZWR1bGVFbmdpbmUoZW5naW5lLCB0aW1lKTtcbiAgICB0aGlzLl9fcmVzZXRUaWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIGVuZ2luZSBpcyBzY2hlZHVsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIGNoZWNrXG4gICAqL1xuICBoYXMoZW5naW5lKSB7XG4gICAgcmV0dXJuIHRoaXMuX19lbmdpbmVzLmhhcyhlbmdpbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZW5naW5lcyBmcm9tIHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5fX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fdGltZW91dCk7XG4gICAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX19zY2hlZFRpbWVzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2ltcGxlU2NoZWR1bGVyO1xuIiwiaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4uL2NvcmUvcHJpb3JpdHktcXVldWUnO1xuaW1wb3J0IFNjaGVkdWxpbmdRdWV1ZSBmcm9tICcuLi9jb3JlL3NjaGVkdWxpbmctcXVldWUnO1xuaW1wb3J0IFRpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS90aW1lLWVuZ2luZSc7XG5pbXBvcnQgeyBnZXRTY2hlZHVsZXIgfSBmcm9tICcuL2ZhY3Rvcmllcyc7XG5cblxuZnVuY3Rpb24gYWRkRHVwbGV0KGZpcnN0QXJyYXksIHNlY29uZEFycmF5LCBmaXJzdEVsZW1lbnQsIHNlY29uZEVsZW1lbnQpIHtcbiAgZmlyc3RBcnJheS5wdXNoKGZpcnN0RWxlbWVudCk7XG4gIHNlY29uZEFycmF5LnB1c2goc2Vjb25kRWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUR1cGxldChmaXJzdEFycmF5LCBzZWNvbmRBcnJheSwgZmlyc3RFbGVtZW50KSB7XG4gIGNvbnN0IGluZGV4ID0gZmlyc3RBcnJheS5pbmRleE9mKGZpcnN0RWxlbWVudCk7XG5cbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICBjb25zdCBzZWNvbmRFbGVtZW50ID0gc2Vjb25kQXJyYXlbaW5kZXhdO1xuXG4gICAgZmlyc3RBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHNlY29uZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICByZXR1cm4gc2Vjb25kRWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUaGUgVHJhbnNwb3J0ZWQgY2FsbCBpcyB0aGUgYmFzZSBjbGFzcyBvZiB0aGUgYWRhcHRlcnMgYmV0d2VlblxuLy8gZGlmZmVyZW50IHR5cGVzIG9mIGVuZ2luZXMgKGkuZS4gdHJhbnNwb3J0ZWQsIHNjaGVkdWxlZCwgcGxheS1jb250cm9sbGVkKVxuLy8gVGhlIGFkYXB0ZXJzIGFyZSBhdCB0aGUgc2FtZSB0aW1lIG1hc3RlcnMgZm9yIHRoZSBlbmdpbmVzIGFkZGVkIHRvIHRoZSB0cmFuc3BvcnRcbi8vIGFuZCB0cmFuc3BvcnRlZCBUaW1lRW5naW5lcyBpbnNlcnRlZCBpbnRvIHRoZSB0cmFuc3BvcnQncyBwb3NpdGlvbi1iYXNlZCBwcml0b3JpdHkgcXVldWUuXG5jbGFzcyBUcmFuc3BvcnRlZCBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnQsIGR1cmF0aW9uLCBvZmZzZXQsIHN0cmV0Y2ggPSAxKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1hc3RlciA9IHRyYW5zcG9ydDtcblxuICAgIHRoaXMuX19lbmdpbmUgPSBlbmdpbmU7XG4gICAgZW5naW5lLm1hc3RlciA9IHRoaXM7XG5cbiAgICB0aGlzLl9fc3RhcnRQb3NpdGlvbiA9IHN0YXJ0O1xuICAgIHRoaXMuX19lbmRQb3NpdGlvbiA9ICFpc0Zpbml0ZShkdXJhdGlvbikgPyBJbmZpbml0eSA6IHN0YXJ0ICsgZHVyYXRpb247XG4gICAgdGhpcy5fX29mZnNldFBvc2l0aW9uID0gc3RhcnQgKyBvZmZzZXQ7XG4gICAgdGhpcy5fX3N0cmV0Y2hQb3NpdGlvbiA9IHN0cmV0Y2g7XG4gICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xuICB9XG5cbiAgc2V0Qm91bmRhcmllcyhzdGFydCwgZHVyYXRpb24sIG9mZnNldCA9IDAsIHN0cmV0Y2ggPSAxKSB7XG4gICAgdGhpcy5fX3N0YXJ0UG9zaXRpb24gPSBzdGFydDtcbiAgICB0aGlzLl9fZW5kUG9zaXRpb24gPSBzdGFydCArIGR1cmF0aW9uO1xuICAgIHRoaXMuX19vZmZzZXRQb3NpdGlvbiA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgIHRoaXMuX19zdHJldGNoUG9zaXRpb24gPSBzdHJldGNoO1xuICAgIHRoaXMucmVzZXRQb3NpdGlvbigpO1xuICB9XG5cbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7fVxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7fVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFRpbWU7XG4gIH1cblxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hc3Rlci5jdXJyZW50UG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb247XG4gIH1cblxuICByZXNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICBwb3NpdGlvbiArPSB0aGlzLl9fb2Zmc2V0UG9zaXRpb247XG5cbiAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgfVxuXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAoc3BlZWQgPiAwKSB7XG4gICAgICBpZiAocG9zaXRpb24gPCB0aGlzLl9fc3RhcnRQb3NpdGlvbikge1xuXG4gICAgICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKVxuICAgICAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXJ0UG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RhcnQodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcblxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5fX2VuZFBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKSAvLyBpZiBlbmdpbmUgaXMgcnVubmluZ1xuICAgICAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5fX2VuZFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IHRoaXMuX19zdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RhcnQodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcblxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKSAvLyBpZiBlbmdpbmUgaXMgcnVubmluZ1xuICAgICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uKTtcblxuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcbiAgfVxuXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAoIXRoaXMuX19pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RhcnQodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoc3BlZWQgPiAwKVxuICAgICAgICByZXR1cm4gdGhpcy5fX2VuZFBvc2l0aW9uO1xuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXJ0UG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gc3RvcCBlbmdpbmVcbiAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xuXG4gICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xuICB9XG5cbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGlmIChzcGVlZCA9PT0gMCkgLy8gc3RvcFxuICAgICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tYXN0ZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fX2VuZ2luZS5tYXN0ZXIgPSBudWxsO1xuICAgIHRoaXMuX19lbmdpbmUgPSBudWxsO1xuICB9XG59XG5cbi8vIFRyYW5zcG9ydGVkVHJhbnNwb3J0ZWRcbi8vIGhhcyB0byBzd2l0Y2ggb24gYW5kIG9mZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgd2hlbiB0aGUgdHJhbnNwb3J0IGhpdHMgdGhlIGVuZ2luZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25cbmNsYXNzIFRyYW5zcG9ydGVkVHJhbnNwb3J0ZWQgZXh0ZW5kcyBUcmFuc3BvcnRlZCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pIHtcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcbiAgfVxuXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAoc3BlZWQgPiAwICYmIHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uKVxuICAgICAgcG9zaXRpb24gPSBNYXRoLm1heChwb3NpdGlvbiwgdGhpcy5fX3N0YXJ0UG9zaXRpb24pO1xuICAgIGVsc2UgaWYgKHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA+PSB0aGlzLl9fc3RhcnRQb3NpdGlvbilcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5taW4ocG9zaXRpb24sIHRoaXMuX19lbmRQb3NpdGlvbik7XG5cbiAgICByZXR1cm4gdGhpcy5fX29mZnNldFBvc2l0aW9uICsgdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcbiAgfVxuXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBwb3NpdGlvbiA9IHRoaXMuX19vZmZzZXRQb3NpdGlvbiArIHRoaXMuX19lbmdpbmUuYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG5cbiAgICBpZiAoc3BlZWQgPiAwICYmIHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uIHx8IHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA+PSB0aGlzLl9fc3RhcnRQb3NpdGlvbilcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcblxuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xuICB9XG5cbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGlmICh0aGlzLl9fZW5naW5lLnN5bmNTcGVlZClcbiAgICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gIH1cblxuICByZXNldEVuZ2luZVBvc2l0aW9uKGVuZ2luZSwgcG9zaXRpb24gPSB1bmRlZmluZWQpIHtcbiAgICBpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgIHBvc2l0aW9uICs9IHRoaXMuX19vZmZzZXRQb3NpdGlvbjtcblxuICAgIHRoaXMucmVzZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gIH1cbn1cblxuLy8gVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWRcbi8vIGhhcyB0byBzdGFydCBhbmQgc3RvcCB0aGUgc3BlZWQtY29udHJvbGxlZCBlbmdpbmVzIHdoZW4gdGhlIHRyYW5zcG9ydCBoaXRzIHRoZSBlbmdpbmUncyBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXG5jbGFzcyBUcmFuc3BvcnRlZFNwZWVkQ29udHJvbGxlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbikge1xuICAgIHN1cGVyKHRyYW5zcG9ydCwgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xuICB9XG5cbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCB0cnVlKTtcbiAgfVxuXG4gIHN0b3AodGltZSwgcG9zaXRpb24pIHtcbiAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgMCk7XG4gIH1cblxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgaWYgKHRoaXMuX19pc1J1bm5pbmcpXG4gICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aGlzLm1hc3Rlci5jdXJyZW50VGltZSwgdGhpcy5tYXN0ZXIuY3VycmVudFBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCAwKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuLy8gVHJhbnNwb3J0ZWRTY2hlZHVsZWRcbi8vIGhhcyB0byBzd2l0Y2ggb24gYW5kIG9mZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgd2hlbiB0aGUgdHJhbnNwb3J0IGhpdHMgdGhlIGVuZ2luZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25cbmNsYXNzIFRyYW5zcG9ydGVkU2NoZWR1bGVkIGV4dGVuZHMgVHJhbnNwb3J0ZWQge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XG5cbiAgICAvLyBzY2hlZHVsaW5nIHF1ZXVlIGJlY29tZXMgbWFzdGVyIG9mIGVuZ2luZVxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xuICAgIHRyYW5zcG9ydC5fX3NjaGVkdWxpbmdRdWV1ZS5hZGQoZW5naW5lLCBJbmZpbml0eSk7XG4gIH1cblxuICBzdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICB0aGlzLm1hc3Rlci5fX3NjaGVkdWxpbmdRdWV1ZS5yZXNldEVuZ2luZVRpbWUodGhpcy5fX2VuZ2luZSwgdGltZSk7XG4gIH1cblxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5tYXN0ZXIuX19zY2hlZHVsaW5nUXVldWUucmVzZXRFbmdpbmVUaW1lKHRoaXMuX19lbmdpbmUsIEluZmluaXR5KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tYXN0ZXIuX19zY2hlZHVsaW5nUXVldWUucmVtb3ZlKHRoaXMuX19lbmdpbmUpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vLyB0cmFuc2xhdGVzIGFkdmFuY2VQb3NpdGlvbiBvZiAqdHJhbnNwb3J0ZWQqIGVuZ2luZXMgaW50byBnbG9iYWwgc2NoZWR1bGVyIHRpbWVzXG5jbGFzcyBUcmFuc3BvcnRTY2hlZHVsZXJIb29rIGV4dGVuZHMgVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IEluZmluaXR5O1xuICAgIHRoaXMuX19uZXh0VGltZSA9IEluZmluaXR5O1xuICAgIHRyYW5zcG9ydC5fX3NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHNjaGVkdWxlZCBpbnRlcmZhY2UpXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl9fdHJhbnNwb3J0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fX25leHRQb3NpdGlvbjtcbiAgICBjb25zdCBzcGVlZCA9IHRyYW5zcG9ydC5fX3NwZWVkO1xuICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRyYW5zcG9ydC5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICBjb25zdCBuZXh0VGltZSA9IHRyYW5zcG9ydC5fX2dldFRpbWVBdFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XG5cbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gbmV4dFBvc2l0aW9uO1xuICAgIHRoaXMuX19uZXh0VGltZSA9IG5leHRUaW1lO1xuXG4gICAgcmV0dXJuIG5leHRUaW1lO1xuICB9XG5cbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb24pIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl9fdHJhbnNwb3J0O1xuICAgIGNvbnN0IHRpbWUgPSB0cmFuc3BvcnQuX19nZXRUaW1lQXRQb3NpdGlvbihwb3NpdGlvbik7XG5cbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5fX25leHRUaW1lID0gdGltZTtcblxuICAgIHRoaXMucmVzZXRUaW1lKHRpbWUpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9fdHJhbnNwb3J0Ll9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxufVxuXG4vLyBpbnRlcm5hbCBzY2hlZHVsaW5nIHF1ZXVlIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiAoYW5kIHRpbWUpIG9mIHRoZSBwbGF5IGNvbnRyb2xcbmNsYXNzIFRyYW5zcG9ydFNjaGVkdWxpbmdRdWV1ZSBleHRlbmRzIFNjaGVkdWxpbmdRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRyYW5zcG9ydC5fX3NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9fdHJhbnNwb3J0LmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50UG9zaXRpb247XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX190cmFuc3BvcnQuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMuX190cmFuc3BvcnQgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXMgc3luY2hyb25pemVkIHNjaGVkdWxpbmcgb2YgVGltZSBFbmdpbmUgaW5zdGFuY2VzLlxuICpcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvdHJhbnNwb3J0Lmh0bWx9XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHRyYW5zcG9ydCA9IGF1ZGlvLlRyYW5zcG9ydCgpO1xuICogY29uc3QgcGxheUNvbnRyb2wgPSBuZXcgYXVkaW8uUGxheUNvbnRyb2wodHJhbnNwb3J0KTtcbiAqIGNvbnN0IG15RW5naW5lID0gbmV3IE15RW5naW5lKCk7XG4gKiBjb25zdCB5b3VyRW5naW5lID0gbmV3IHlvdXJFbmdpbmUoKTtcbiAqXG4gKiB0cmFuc3BvcnQuYWRkKG15RW5naW5lKTtcbiAqIHRyYW5zcG9ydC5hZGQoeW91ckVuZ2luZSk7XG4gKlxuICogcGxheUNvbnRyb2wuc3RhcnQoKTtcbiAqL1xuY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IGRlZmF1bHRBdWRpb0NvbnRleHQ7XG5cbiAgICB0aGlzLl9fZW5naW5lcyA9IFtdO1xuICAgIHRoaXMuX190cmFuc3BvcnRlZCA9IFtdO1xuXG4gICAgdGhpcy5fX3NjaGVkdWxlciA9IGdldFNjaGVkdWxlcih0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgdGhpcy5fX3NjaGVkdWxlckhvb2sgPSBuZXcgVHJhbnNwb3J0U2NoZWR1bGVySG9vayh0aGlzKTtcbiAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gICAgdGhpcy5fX3NjaGVkdWxpbmdRdWV1ZSA9IG5ldyBUcmFuc3BvcnRTY2hlZHVsaW5nUXVldWUodGhpcyk7XG5cbiAgICAvLyBzeW5jcm9uaXplZCB0aW1lLCBwb3NpdGlvbiwgYW5kIHNwZWVkXG4gICAgdGhpcy5fX3RpbWUgPSAwO1xuICAgIHRoaXMuX19wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5fX3NwZWVkID0gMDtcbiAgfVxuXG4gIF9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fX3RpbWUgKyAocG9zaXRpb24gLSB0aGlzLl9fcG9zaXRpb24pIC8gdGhpcy5fX3NwZWVkO1xuICB9XG5cbiAgX19nZXRQb3NpdGlvbkF0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xuICB9XG5cbiAgX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBjb25zdCBudW1UcmFuc3BvcnRlZEVuZ2luZXMgPSB0aGlzLl9fdHJhbnNwb3J0ZWQubGVuZ3RoO1xuICAgIGxldCBuZXh0UG9zaXRpb24gPSBJbmZpbml0eSAqIHNwZWVkO1xuXG4gICAgaWYgKG51bVRyYW5zcG9ydGVkRW5naW5lcyA+IDApIHtcbiAgICAgIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmNsZWFyKCk7XG4gICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5yZXZlcnNlID0gKHNwZWVkIDwgMCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJhbnNwb3J0ZWRFbmdpbmVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5fX3RyYW5zcG9ydGVkW2ldO1xuICAgICAgICBjb25zdCBuZXh0RW5naW5lUG9zaXRpb24gPSBlbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICAgIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmluc2VydChlbmdpbmUsIG5leHRFbmdpbmVQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLnRpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRQb3NpdGlvbjtcbiAgfVxuXG4gIF9fc3luY1RyYW5zcG9ydGVkU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgZm9yIChsZXQgdHJhbnNwb3J0ZWQgb2YgdGhpcy5fX3RyYW5zcG9ydGVkKVxuICAgICAgdHJhbnNwb3J0ZWQuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgbWFzdGVyIHRpbWUuIFRoaXMgZ2V0dGVyIHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0aGUgdHJhbnNwb3J0XG4gICAqIGlzIGFkZGVkIHRvIGEgbWFzdGVyIChpLmUuIHRyYW5zcG9ydCBvciBwbGF5LWNvbnRyb2wpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBjdXJyZW50VGltZVxuICAgKiBAbWVtYmVyb2YgVHJhbnNwb3J0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgcG9zaXRpb24uIFRoaXMgZ2V0dGVyIHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0aGUgdHJhbnNwb3J0XG4gICAqIGlzIGFkZGVkIHRvIGEgbWFzdGVyIChpLmUuIHRyYW5zcG9ydCBvciBwbGF5LWNvbnRyb2wpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBjdXJyZW50UG9zaXRpb25cbiAgICogQG1lbWJlcm9mIFRyYW5zcG9ydFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbWFzdGVyLmN1cnJlbnRQb3NpdGlvbjtcblxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBuZXh0IHRyYW5zcG9ydCBwb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV4dCAtIHRyYW5zcG9ydCBwb3NpdGlvblxuICAgKi9cbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSB0cmFuc3BvcnRlZCB0aW1lIGVuZ2luZSBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3BlZWRcbiAgICovXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XG5cbiAgICByZXR1cm4gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZFxuICAgKi9cbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmhlYWQ7XG4gICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gZW5naW5lLmFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgIHJldHVybiB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5tb3ZlKGVuZ2luZSwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdHJhbnNwb3J0ZWQgdGltZSBlbmdpbmUgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NlZWs9ZmFsc2VdXG4gICAqL1xuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrID0gZmFsc2UpIHtcbiAgICBjb25zdCBsYXN0U3BlZWQgPSB0aGlzLl9fc3BlZWQ7XG5cbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XG5cbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCAoc2VlayAmJiBzcGVlZCAhPT0gMCkpIHtcbiAgICAgIGxldCBuZXh0UG9zaXRpb247XG5cbiAgICAgIC8vIHJlc3luYyB0cmFuc3BvcnRlZCBlbmdpbmVzXG4gICAgICBpZiAoc2VlayB8fCBzcGVlZCAqIGxhc3RTcGVlZCA8IDApIHtcbiAgICAgICAgLy8gc2VlayBvciByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fc3luY1RyYW5zcG9ydGVkUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNwZWVkID09PSAwKSB7XG4gICAgICAgIC8vIHN0YXJ0XG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gMCkge1xuICAgICAgICAvLyBzdG9wXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLl9fc3luY1RyYW5zcG9ydGVkU3BlZWQodGltZSwgcG9zaXRpb24sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hhbmdlIHNwZWVkIHdpdGhvdXQgcmV2ZXJzaW5nIGRpcmVjdGlvblxuICAgICAgICB0aGlzLl9fc3luY1RyYW5zcG9ydGVkU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRpbWUgZW5naW5lIHRvIHRoZSB0cmFuc3BvcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmdpbmUgLSBlbmdpbmUgdG8gYmUgYWRkZWQgdG8gdGhlIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBzdGFydCBwb3NpdGlvblxuICAgKi9cbiAgYWRkKGVuZ2luZSwgc3RhcnRQb3NpdGlvbiA9IDAsIGVuZFBvc2l0aW9uID0gSW5maW5pdHksIG9mZnNldFBvc2l0aW9uID0gMCkge1xuICAgIGxldCB0cmFuc3BvcnRlZCA9IG51bGw7XG5cbiAgICBpZiAob2Zmc2V0UG9zaXRpb24gPT09IC1JbmZpbml0eSlcbiAgICAgIG9mZnNldFBvc2l0aW9uID0gMDtcblxuICAgIGlmIChlbmdpbmUubWFzdGVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XG5cbiAgICBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzVHJhbnNwb3J0ZWQoZW5naW5lKSlcbiAgICAgIHRyYW5zcG9ydGVkID0gbmV3IFRyYW5zcG9ydGVkVHJhbnNwb3J0ZWQodGhpcywgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xuICAgIGVsc2UgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1NwZWVkQ29udHJvbGxlZChlbmdpbmUpKVxuICAgICAgdHJhbnNwb3J0ZWQgPSBuZXcgVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWQodGhpcywgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xuICAgIGVsc2UgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1NjaGVkdWxlZChlbmdpbmUpKVxuICAgICAgdHJhbnNwb3J0ZWQgPSBuZXcgVHJhbnNwb3J0ZWRTY2hlZHVsZWQodGhpcywgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gYSB0cmFuc3BvcnRcIik7XG5cbiAgICBpZiAodHJhbnNwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHNwZWVkID0gdGhpcy5fX3NwZWVkO1xuXG4gICAgICBhZGREdXBsZXQodGhpcy5fX2VuZ2luZXMsIHRoaXMuX190cmFuc3BvcnRlZCwgZW5naW5lLCB0cmFuc3BvcnRlZCk7XG5cbiAgICAgIGlmIChzcGVlZCAhPT0gMCkge1xuICAgICAgICAvLyBzeW5jIGFuZCBzdGFydFxuICAgICAgICBjb25zdCBuZXh0RW5naW5lUG9zaXRpb24gPSB0cmFuc3BvcnRlZC5zeW5jUG9zaXRpb24odGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50UG9zaXRpb24sIHNwZWVkKTtcbiAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUuaW5zZXJ0KHRyYW5zcG9ydGVkLCBuZXh0RW5naW5lUG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmFuc3BvcnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0aW1lIGVuZ2luZSBmcm9tIHRoZSB0cmFuc3BvcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbmdpbmVPclRyYW5zcG9ydGVkIC0gZW5naW5lIG9yIHRyYW5zcG9ydGVkIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgdHJhbnNwb3J0XG4gICAqL1xuICByZW1vdmUoZW5naW5lT3JUcmFuc3BvcnRlZCkge1xuICAgIGxldCBlbmdpbmUgPSBlbmdpbmVPclRyYW5zcG9ydGVkO1xuICAgIGxldCB0cmFuc3BvcnRlZCA9IHJlbW92ZUR1cGxldCh0aGlzLl9fZW5naW5lcywgdGhpcy5fX3RyYW5zcG9ydGVkLCBlbmdpbmVPclRyYW5zcG9ydGVkKTtcblxuICAgIGlmICghdHJhbnNwb3J0ZWQpIHtcbiAgICAgIGVuZ2luZSA9IHJlbW92ZUR1cGxldCh0aGlzLl9fdHJhbnNwb3J0ZWQsIHRoaXMuX19lbmdpbmVzLCBlbmdpbmVPclRyYW5zcG9ydGVkKTtcbiAgICAgIHRyYW5zcG9ydGVkID0gZW5naW5lT3JUcmFuc3BvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoZW5naW5lICYmIHRyYW5zcG9ydGVkKSB7XG4gICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5yZW1vdmUodHJhbnNwb3J0ZWQpO1xuXG4gICAgICB0cmFuc3BvcnRlZC5kZXN0cm95KCk7XG5cbiAgICAgIGlmICh0aGlzLl9fc3BlZWQgIT09IDApXG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgdHJhbnNwb3J0XCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gZW5naW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IHRyYW5zcG9ydGVkIC0gRW5naW5lIHRvIHJlc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIE5ldyBwb3NpdGlvblxuICAgKi9cbiAgcmVzZXRFbmdpbmVQb3NpdGlvbih0cmFuc3BvcnRlZCwgcG9zaXRpb24gPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzcGVlZCA9IHRoaXMuX19zcGVlZDtcblxuICAgIGlmIChzcGVlZCAhPT0gMCkge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpXG4gICAgICAgIHBvc2l0aW9uID0gdHJhbnNwb3J0ZWQuc3luY1Bvc2l0aW9uKHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudFBvc2l0aW9uLCBzcGVlZCk7XG5cbiAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLm1vdmUodHJhbnNwb3J0ZWQsIHBvc2l0aW9uKTtcbiAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRpbWUgZW5naW5lcyBmcm9tIHRoZSB0cmFuc3BvcnQuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnN5bmNTcGVlZCh0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmN1cnJlbnRQb3NpdGlvbiwgMCk7XG5cbiAgICBmb3IgKGxldCB0cmFuc3BvcnRlZCBvZiB0aGlzLl9fdHJhbnNwb3J0ZWQpXG4gICAgICB0cmFuc3BvcnRlZC5kZXN0cm95KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNwb3J0O1xuIiwiaW1wb3J0IExvYWRlciBmcm9tICcuL2xvYWRlcic7XG5cblxuLyoqXG4gKiBHZXRzIGNhbGxlZCBpZiBhIHBhcmFtZXRlciBpcyBtaXNzaW5nIGFuZCB0aGUgZXhwcmVzc2lvblxuICogc3BlY2lmeWluZyB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBldmFsdWF0ZWQuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZk1pc3NpbmcoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwYXJhbWV0ZXInKTtcbn1cblxubGV0IGF1ZGlvQ29udGV4dDtcblxud2luZG93LkF1ZGlvQ29udGV4dCA9ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuXG50cnkge1xuICBhdWRpb0NvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xufSBjYXRjaCAoZSkge31cblxuXG4vKipcbiAqIEF1ZGlvQnVmZmVyTG9hZGVyXG4gKiBQcm9taXNlIGJhc2VkIGltcGxlbWVudGF0aW9uIG9mIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIgZm9yIEdFVCBtZXRob2QgYW5kIGRlY29kZSBhdWRpbyBkYXRhIGZvciBhcnJheWJ1ZmZlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9CdWZmZXJMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICAvKipcbiAgICogU2V0IHRoZSByZXNwb25zZVR5cGUgdG8gJ2FycmF5YnVmZmVyJyBhbmQgaW5pdGlhbGl6ZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Jlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCJdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInKSB7XG4gICAgc3VwZXIocmVzcG9uc2VUeXBlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBcIndyYXBBcm91bmRFeHRlbnNpb25cIjogMFxuICAgIH07XG4gICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdG8gc2V0IHRoZSBhdWRpbyBjb250ZXh0IHRoYXQgc2hvdWxkIGJlIHVzZWQgaW4gb3JkZXIgdG8gZGVjb2RlXG4gICAqIHRoZSBmaWxlIGFuZCBjcmVhdGUgdGhlIEF1ZGlvQnVmZmVyLlxuICAgKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gYXVkaW9Db250ZXh0XG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0KSB7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciBwcm9taXNlIGF1ZGlvIGZpbGUgbG9hZGluZyBhbmQgZGVjb2RpbmcuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGZpbGVVUkxzIC0gVGhlIFVSTChzKSBvZiB0aGUgYXVkaW8gZmlsZXMgdG8gbG9hZC4gQWNjZXB0cyBhIFVSTCBwb2ludGluZyB0byB0aGUgZmlsZSBsb2NhdGlvbiBvciBhbiBhcnJheSBvZiBVUkxzLlxuICAgKiBAcGFyYW0ge3t3cmFwQXJvdW5kRXh0ZW5zaW9uOiBudW1iZXJ9fSBbb3B0aW9uc10gLSBPYmplY3Qgd2l0aCBhIHdyYXBBcm91bmRFeHRlbnNpb24ga2V5IHdoaWNoIHNldCB0aGUgbGVuZ3RoLCBpbiBzZWNvbmRzIHRvIGJlIGNvcGllZCBmcm9tIHRoZSBiZWdpbmluZyBhdCB0aGUgZW5kIG9mIHRoZSByZXR1cm5lZCBBdWRpb0J1ZmZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWQoZmlsZVVSTHMgPSB0aHJvd0lmTWlzc2luZygpLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24gfHwgMDtcbiAgICByZXR1cm4gc3VwZXIubG9hZChmaWxlVVJMcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIHNpbmdsZSBhdWRpbyBmaWxlLCBkZWNvZGUgaXQgaW4gYW4gQXVkaW9CdWZmZXIsIHJldHVybiBhIFByb21pc2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVVUkwgLSBUaGUgVVJMIG9mIHRoZSBhdWRpbyBmaWxlIGxvY2F0aW9uIHRvIGxvYWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZE9uZShmaWxlVVJMKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxvYWRPbmUoZmlsZVVSTClcbiAgICAgIC50aGVuKFxuICAgICAgICB0aGlzLmRlY29kZUF1ZGlvRGF0YS5iaW5kKHRoaXMpLFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBhdWRpbyBmaWxlcyBhdCBvbmNlIGluIGEgc2luZ2xlIGFycmF5LCBkZWNvZGUgdGhlbSBpbiBhbiBhcnJheSBvZiBBdWRpb0J1ZmZlcnMsIGFuZCByZXR1cm4gYSBQcm9taXNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWxlVVJMcyAtIFRoZSBVUkxzIGFycmF5IG9mIHRoZSBhdWRpbyBmaWxlcyB0byBsb2FkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWRBbGwoZmlsZVVSTHMpIHtcbiAgICByZXR1cm4gc3VwZXIubG9hZEFsbChmaWxlVVJMcylcbiAgICAgIC50aGVuKFxuICAgICAgICAoYXJyYXlidWZmZXJzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFycmF5YnVmZmVycy5tYXAoKGFycmF5YnVmZmVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVBdWRpb0RhdGEuYmluZCh0aGlzKShhcnJheWJ1ZmZlcik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gVE9ETzogYmV0dGVyIGVycm9yIGhhbmRsZXJcbiAgICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIEF1ZGlvIERhdGEsIHJldHVybiBhIFByb21pc2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHthcnJheWJ1ZmZlcn0gLSBUaGUgYXJyYXlidWZmZXIgb2YgdGhlIGxvYWRlZCBhdWRpbyBmaWxlIHRvIGJlIGRlY29kZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyKSB7XG4gICAgaWYgKGFycmF5YnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShcbiAgICAgICAgICBhcnJheWJ1ZmZlciwgLy8gcmV0dXJuZWQgYXVkaW8gZGF0YSBhcnJheVxuICAgICAgICAgIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiA9PT0gMCkgcmVzb2x2ZShidWZmZXIpO1xuICAgICAgICAgICAgZWxzZSByZXNvbHZlKHRoaXMuX193cmFwQXJvdW5kKGJ1ZmZlcikpO1xuICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkRlY29kZUF1ZGlvRGF0YSBlcnJvclwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUoYXJyYXlidWZmZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBBcm91bmQsIGNvcHkgdGhlIGJlZ2luaW5nIGlucHV0IGJ1ZmZlciB0byB0aGUgZW5kIG9mIGFuIG91dHB1dCBidWZmZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHthcnJheWJ1ZmZlcn0gaW5CdWZmZXIge2FycmF5YnVmZmVyfSAtIFRoZSBpbnB1dCBidWZmZXJcbiAgICogQHJldHVybnMge2FycmF5YnVmZmVyfSAtIFRoZSBwcm9jZXNzZWQgYnVmZmVyICh3aXRoIGZyYW1lIGNvcGllZCBmcm9tIHRoZSBiZWdpbmluZyB0byB0aGUgZW5kKVxuICAgKi9cbiAgX193cmFwQXJvdW5kKGluQnVmZmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGluQnVmZmVyLmxlbmd0aCArIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uICogaW5CdWZmZXIuc2FtcGxlUmF0ZTtcblxuICAgIHZhciBvdXRCdWZmZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoaW5CdWZmZXIubnVtYmVyT2ZDaGFubmVscywgbGVuZ3RoLCBpbkJ1ZmZlci5zYW1wbGVSYXRlKTtcbiAgICB2YXIgYXJyYXlDaERhdGEsIGFycmF5T3V0Q2hEYXRhO1xuXG4gICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBpbkJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBjaGFubmVsKyspIHtcbiAgICAgIGFycmF5Q2hEYXRhID0gaW5CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG4gICAgICBhcnJheU91dENoRGF0YSA9IG91dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcblxuICAgICAgYXJyYXlPdXRDaERhdGEuZm9yRWFjaChmdW5jdGlvbihzYW1wbGUsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IGluQnVmZmVyLmxlbmd0aCkgYXJyYXlPdXRDaERhdGFbaW5kZXhdID0gYXJyYXlDaERhdGFbaW5kZXhdO1xuICAgICAgICBlbHNlIGFycmF5T3V0Q2hEYXRhW2luZGV4XSA9IGFycmF5Q2hEYXRhW2luZGV4IC0gaW5CdWZmZXIubGVuZ3RoXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRCdWZmZXI7XG4gIH1cbn1cbiIsIi8qKlxuICogQGZpbGUgTG9hZGVyczogQXVkaW9CdWZmZXIgbG9hZGVyIGFuZCB1dGlsaXRpZXNcbiAqIEBhdXRob3IgU2FtdWVsIEdvbGRzem1pZHRcbiAqIEB2ZXJzaW9uIDAuMS4xXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdWRpb0J1ZmZlckxvYWRlciB9IGZyb20gJy4vYXVkaW8tYnVmZmVyLWxvYWRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN1cGVyTG9hZGVyIH0gZnJvbSAnLi9zdXBlci1sb2FkZXInO1xuIiwiLyoqXG4gKiBHZXRzIGNhbGxlZCBpZiBhIHBhcmFtZXRlciBpcyBtaXNzaW5nIGFuZCB0aGUgZXhwcmVzc2lvblxuICogc3BlY2lmeWluZyB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBldmFsdWF0ZWQuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZk1pc3NpbmcoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwYXJhbWV0ZXInKTtcbn1cblxuXG4vKipcbiAqIFByb21pc2UgYmFzZWQgaW1wbGVtZW50YXRpb24gb2YgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMiBmb3IgR0VUIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzcG9uc2VUeXBlPVwiXCJdIC0gcmVzcG9uc2VUeXBlJ3MgdmFsdWUsIFwidGV4dFwiIChlcXVhbCB0byBcIlwiKSwgXCJhcnJheWJ1ZmZlclwiLCBcImJsb2JcIiwgXCJkb2N1bWVudFwiIG9yIFwianNvblwiXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZVR5cGUgPSB1bmRlZmluZWQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgIC8vIHJlbmFtZSB0byBgb25Qcm9ncmVzc2AgP1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnByb2dyZXNzQ2IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciBhIHByb21pc2UgYmFzZWQgZmlsZSBsb2FkaW5nLlxuICAgKiBJbnRlcm5hbGx5IHN3aXRjaCBiZXR3ZWVuIGxvYWRPbmUgYW5kIGxvYWRBbGwuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHsoc3RyaW5nfHN0cmluZ1tdKX0gZmlsZVVSTHMgLSBUaGUgVVJMKHMpIG9mIHRoZSBmaWxlcyB0byBsb2FkLiBBY2NlcHRzIGEgVVJMIHBvaW50aW5nIHRvIHRoZSBmaWxlIGxvY2F0aW9uIG9yIGFuIGFycmF5IG9mIFVSTHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZChmaWxlVVJMcyA9IHRocm93SWZNaXNzaW5nKCkpIHtcbiAgICBpZiAoZmlsZVVSTHMgPT09IHVuZGVmaW5lZCkgdGhyb3cgKG5ldyBFcnJvcignbG9hZCBuZWVkcyBhdCBsZWFzdCBhIHVybCB0byBsb2FkJykpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGVVUkxzKSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZEFsbChmaWxlVVJMcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRPbmUoZmlsZVVSTHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgc2luZ2xlIGZpbGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVVUkwgLSBUaGUgVVJMIG9mIHRoZSBmaWxlIHRvIGxvYWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZE9uZShmaWxlVVJMKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZUxvYWRpbmdSZXF1ZXN0KGZpbGVVUkwpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIGZpbGVzIGF0IG9uY2UgaW4gYSBzaW5nbGUgYXJyYXkgYW5kIHJldHVybiBhIFByb21pc2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmlsZVVSTHMgLSBUaGUgVVJMcyBhcnJheSBvZiB0aGUgZmlsZXMgdG8gbG9hZC5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBsb2FkQWxsKGZpbGVVUkxzKSB7XG4gICAgdmFyIHVybHNDb3VudCA9IGZpbGVVUkxzLmxlbmd0aCxcbiAgICAgIHByb21pc2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHNDb3VudDsgKytpKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZmlsZUxvYWRpbmdSZXF1ZXN0KGZpbGVVUkxzW2ldLCBpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgZmlsZSBhc3luY2hyb25vdXNseSwgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIGZpbGUgdG8gbG9hZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2luZGV4XSAtIFRoZSBpbmRleCBvZiB0aGUgZmlsZSBpbiB0aGUgYXJyYXkgb2YgZmlsZXMgdG8gbG9hZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGZpbGVMb2FkaW5nUmVxdWVzdCh1cmwsIGluZGV4KSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShcbiAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN1ZmZpeCA9ICcuanNvbic7XG4gICAgICAgICAgaWYgKHVybC5pbmRleE9mKHN1ZmZpeCwgdGhpcy5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFRlc3QgcmVxdWVzdC5zdGF0dXMgdmFsdWUsIGFzIDQwNCB3aWxsIGFsc28gZ2V0IHRoZXJlXG4gICAgICAgICAgLy8gVGVzdCByZXF1ZXN0LnN0YXR1cyA9PT0gMCBmb3IgY29yZG92YSBpbnRlcm5hbCBhamF4IGNhbGxzXG4gICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDMwNCB8fMKgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEhhY2sgZm9yIGlPUyA3LCB0byByZW1vdmUgYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbicgJiYgdHlwZW9mKHJlcXVlc3QucmVzcG9uc2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChldnQpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5wcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXZ0LmxvYWRlZCAvIGV2dC50b3RhbCxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2dC5sb2FkZWQgLyBldnQudG90YWwsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFuYWdlIG5ldHdvcmsgZXJyb3JzXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOZXR3b3JrIEVycm9yJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZ2V0IHRoZSBwcm9ncmVzcyBvZiBmaWxlIGxvYWRpbmcgcHJvY2Vzcy5cbiAgICogVGhpcyBpcyBvbmx5IGZvciB0aGUgZmlsZSBsb2FkaW5nIHByb2dyZXNzIGFzIGRlY29kZUF1ZGlvRGF0YSBkb2Vzbid0XG4gICAqIGV4cG9zZSBhIGRlY29kZSBwcm9ncmVzcyB2YWx1ZS5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IHByb2dyZXNzQ2FsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3NDYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGdldCB0aGUgcHJvZ3Jlc3Mgb2YgZmlsZSBsb2FkaW5nIHByb2Nlc3MuXG4gICAqIFRoaXMgaXMgb25seSBmb3IgdGhlIGZpbGUgbG9hZGluZyBwcm9ncmVzcyBhcyBkZWNvZGVBdWRpb0RhdGEgZG9lc24ndFxuICAgKiBleHBvc2UgYSBkZWNvZGUgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBoYW5kbGVzIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHNldCBwcm9ncmVzc0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcm9ncmVzc0NiID0gY2FsbGJhY2s7XG4gIH1cbn1cbiIsImltcG9ydCBBdWRpb0J1ZmZlckxvYWRlciBmcm9tICcuL2F1ZGlvLWJ1ZmZlci1sb2FkZXInO1xuXG5cbi8qKlxuICogU3VwZXJMb2FkZXJcbiAqIEhlbHBlciB0byBsb2FkIG11bHRpcGxlIHR5cGUgb2YgZmlsZXMsIGFuZCBnZXQgdGhlbSBpbiB0aGVpciB1c2VmdWwgdHlwZSwganNvbiBmb3IganNvbiBmaWxlcywgQXVkaW9CdWZmZXIgZm9yIGF1ZGlvIGZpbGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdXBlckxvYWRlciBleHRlbmRzIEF1ZGlvQnVmZmVyTG9hZGVyIHtcbiAgLyoqXG4gICAqIFVzZSBjb21wb3NpdGlvbiB0byBzZXR1cCBhcHByb3ByaWF0ZSBmaWxlIGxvYWRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG51bGwpO1xuICAgIC8vIGJ5cGFzcyBBdWRpb0J1ZmZlckxvYWRlciBjb25zdHJ1Y3Rvci4gVGhpcyBpcyBiYWQgYnV0IGl0IHdvcmtzLlxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuIl19
